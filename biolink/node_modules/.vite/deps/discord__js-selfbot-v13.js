import {
  require_browser,
  require_buffer,
  require_cjs,
  require_dist2 as require_dist,
  require_dist4 as require_dist2,
  require_es6,
  require_events,
  require_get,
  require_node_child_process,
  require_node_process,
  require_node_timers,
  require_path,
  require_process,
  require_promises,
  require_string_decoder,
  require_uniqWith,
  require_util
} from "./chunk-4KJ65UQ4.js";
import {
  require_stream
} from "./chunk-VEZN4GAJ.js";
import {
  require_node_assert,
  require_node_async_hooks,
  require_node_buffer,
  require_node_console,
  require_node_crypto,
  require_node_diagnostics_channel,
  require_node_events,
  require_node_fs,
  require_node_http,
  require_node_http2,
  require_node_net,
  require_node_path,
  require_node_perf_hooks,
  require_node_querystring,
  require_node_stream,
  require_node_tls,
  require_node_url,
  require_node_util,
  require_node_worker_threads,
  require_node_zlib,
  require_types
} from "./chunk-XQBGVLKA.js";
import {
  __commonJS,
  __esm,
  __export,
  __privateAdd,
  __privateGet,
  __privateIn,
  __privateMethod,
  __privateSet,
  __publicField,
  __require,
  __toCommonJS
} from "./chunk-N5SXXOWC.js";

// ../../../node_modules/punycode/punycode.es6.js
var punycode_es6_exports = {};
__export(punycode_es6_exports, {
  decode: () => decode,
  default: () => punycode_es6_default,
  encode: () => encode,
  toASCII: () => toASCII,
  toUnicode: () => toUnicode,
  ucs2decode: () => ucs2decode,
  ucs2encode: () => ucs2encode
});
function error(type) {
  throw new RangeError(errors[type]);
}
function map(array, callback) {
  const result = [];
  let length = array.length;
  while (length--) {
    result[length] = callback(array[length]);
  }
  return result;
}
function mapDomain(domain, callback) {
  const parts = domain.split("@");
  let result = "";
  if (parts.length > 1) {
    result = parts[0] + "@";
    domain = parts[1];
  }
  domain = domain.replace(regexSeparators, ".");
  const labels = domain.split(".");
  const encoded = map(labels, callback).join(".");
  return result + encoded;
}
function ucs2decode(string) {
  const output = [];
  let counter = 0;
  const length = string.length;
  while (counter < length) {
    const value = string.charCodeAt(counter++);
    if (value >= 55296 && value <= 56319 && counter < length) {
      const extra = string.charCodeAt(counter++);
      if ((extra & 64512) == 56320) {
        output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
      } else {
        output.push(value);
        counter--;
      }
    } else {
      output.push(value);
    }
  }
  return output;
}
var maxInt, base, tMin, tMax, skew, damp, initialBias, initialN, delimiter, regexPunycode, regexNonASCII, regexSeparators, errors, baseMinusTMin, floor, stringFromCharCode, ucs2encode, basicToDigit, digitToBasic, adapt, decode, encode, toUnicode, toASCII, punycode, punycode_es6_default;
var init_punycode_es6 = __esm({
  "../../../node_modules/punycode/punycode.es6.js"() {
    "use strict";
    maxInt = 2147483647;
    base = 36;
    tMin = 1;
    tMax = 26;
    skew = 38;
    damp = 700;
    initialBias = 72;
    initialN = 128;
    delimiter = "-";
    regexPunycode = /^xn--/;
    regexNonASCII = /[^\0-\x7F]/;
    regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
    errors = {
      "overflow": "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    };
    baseMinusTMin = base - tMin;
    floor = Math.floor;
    stringFromCharCode = String.fromCharCode;
    ucs2encode = (codePoints) => String.fromCodePoint(...codePoints);
    basicToDigit = function(codePoint) {
      if (codePoint >= 48 && codePoint < 58) {
        return 26 + (codePoint - 48);
      }
      if (codePoint >= 65 && codePoint < 91) {
        return codePoint - 65;
      }
      if (codePoint >= 97 && codePoint < 123) {
        return codePoint - 97;
      }
      return base;
    };
    digitToBasic = function(digit, flag) {
      return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
    };
    adapt = function(delta, numPoints, firstTime) {
      let k = 0;
      delta = firstTime ? floor(delta / damp) : delta >> 1;
      delta += floor(delta / numPoints);
      for (; delta > baseMinusTMin * tMax >> 1; k += base) {
        delta = floor(delta / baseMinusTMin);
      }
      return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
    };
    decode = function(input) {
      const output = [];
      const inputLength = input.length;
      let i = 0;
      let n = initialN;
      let bias = initialBias;
      let basic = input.lastIndexOf(delimiter);
      if (basic < 0) {
        basic = 0;
      }
      for (let j = 0; j < basic; ++j) {
        if (input.charCodeAt(j) >= 128) {
          error("not-basic");
        }
        output.push(input.charCodeAt(j));
      }
      for (let index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
        const oldi = i;
        for (let w = 1, k = base; ; k += base) {
          if (index >= inputLength) {
            error("invalid-input");
          }
          const digit = basicToDigit(input.charCodeAt(index++));
          if (digit >= base) {
            error("invalid-input");
          }
          if (digit > floor((maxInt - i) / w)) {
            error("overflow");
          }
          i += digit * w;
          const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
          if (digit < t) {
            break;
          }
          const baseMinusT = base - t;
          if (w > floor(maxInt / baseMinusT)) {
            error("overflow");
          }
          w *= baseMinusT;
        }
        const out = output.length + 1;
        bias = adapt(i - oldi, out, oldi == 0);
        if (floor(i / out) > maxInt - n) {
          error("overflow");
        }
        n += floor(i / out);
        i %= out;
        output.splice(i++, 0, n);
      }
      return String.fromCodePoint(...output);
    };
    encode = function(input) {
      const output = [];
      input = ucs2decode(input);
      const inputLength = input.length;
      let n = initialN;
      let delta = 0;
      let bias = initialBias;
      for (const currentValue of input) {
        if (currentValue < 128) {
          output.push(stringFromCharCode(currentValue));
        }
      }
      const basicLength = output.length;
      let handledCPCount = basicLength;
      if (basicLength) {
        output.push(delimiter);
      }
      while (handledCPCount < inputLength) {
        let m = maxInt;
        for (const currentValue of input) {
          if (currentValue >= n && currentValue < m) {
            m = currentValue;
          }
        }
        const handledCPCountPlusOne = handledCPCount + 1;
        if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
          error("overflow");
        }
        delta += (m - n) * handledCPCountPlusOne;
        n = m;
        for (const currentValue of input) {
          if (currentValue < n && ++delta > maxInt) {
            error("overflow");
          }
          if (currentValue === n) {
            let q = delta;
            for (let k = base; ; k += base) {
              const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
              if (q < t) {
                break;
              }
              const qMinusT = q - t;
              const baseMinusT = base - t;
              output.push(
                stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
              );
              q = floor(qMinusT / baseMinusT);
            }
            output.push(stringFromCharCode(digitToBasic(q, 0)));
            bias = adapt(delta, handledCPCountPlusOne, handledCPCount === basicLength);
            delta = 0;
            ++handledCPCount;
          }
        }
        ++delta;
        ++n;
      }
      return output.join("");
    };
    toUnicode = function(input) {
      return mapDomain(input, function(string) {
        return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
      });
    };
    toASCII = function(input) {
      return mapDomain(input, function(string) {
        return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
      });
    };
    punycode = {
      /**
       * A string representing the current Punycode.js version number.
       * @memberOf punycode
       * @type String
       */
      "version": "2.3.1",
      /**
       * An object of methods to convert from JavaScript's internal character
       * representation (UCS-2) to Unicode code points, and back.
       * @see <https://mathiasbynens.be/notes/javascript-encoding>
       * @memberOf punycode
       * @type Object
       */
      "ucs2": {
        "decode": ucs2decode,
        "encode": ucs2encode
      },
      "decode": decode,
      "encode": encode,
      "toASCII": toASCII,
      "toUnicode": toUnicode
    };
    punycode_es6_default = punycode;
  }
});

// ../../../node_modules/requires-port/index.js
var require_requires_port = __commonJS({
  "../../../node_modules/requires-port/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function required(port, protocol) {
      protocol = protocol.split(":")[0];
      port = +port;
      if (!port) return false;
      switch (protocol) {
        case "http":
        case "ws":
          return port !== 80;
        case "https":
        case "wss":
          return port !== 443;
        case "ftp":
          return port !== 21;
        case "gopher":
          return port !== 70;
        case "file":
          return false;
      }
      return port !== 0;
    };
  }
});

// ../../../node_modules/querystringify/index.js
var require_querystringify = __commonJS({
  "../../../node_modules/querystringify/index.js"(exports2) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var undef;
    function decode2(input) {
      try {
        return decodeURIComponent(input.replace(/\+/g, " "));
      } catch (e) {
        return null;
      }
    }
    function encode2(input) {
      try {
        return encodeURIComponent(input);
      } catch (e) {
        return null;
      }
    }
    function querystring(query) {
      var parser = /([^=?#&]+)=?([^&]*)/g, result = {}, part;
      while (part = parser.exec(query)) {
        var key = decode2(part[1]), value = decode2(part[2]);
        if (key === null || value === null || key in result) continue;
        result[key] = value;
      }
      return result;
    }
    function querystringify(obj, prefix) {
      prefix = prefix || "";
      var pairs = [], value, key;
      if ("string" !== typeof prefix) prefix = "?";
      for (key in obj) {
        if (has.call(obj, key)) {
          value = obj[key];
          if (!value && (value === null || value === undef || isNaN(value))) {
            value = "";
          }
          key = encode2(key);
          value = encode2(value);
          if (key === null || value === null) continue;
          pairs.push(key + "=" + value);
        }
      }
      return pairs.length ? prefix + pairs.join("&") : "";
    }
    exports2.stringify = querystringify;
    exports2.parse = querystring;
  }
});

// ../../../node_modules/url-parse/index.js
var require_url_parse = __commonJS({
  "../../../node_modules/url-parse/index.js"(exports2, module2) {
    "use strict";
    var required = require_requires_port();
    var qs = require_querystringify();
    var controlOrWhitespace = /^[\x00-\x20\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]+/;
    var CRHTLF = /[\n\r\t]/g;
    var slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//;
    var port = /:\d+$/;
    var protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\\/]+)?([\S\s]*)/i;
    var windowsDriveLetter = /^[a-zA-Z]:/;
    function trimLeft(str) {
      return (str ? str : "").toString().replace(controlOrWhitespace, "");
    }
    var rules = [
      ["#", "hash"],
      // Extract from the back.
      ["?", "query"],
      // Extract from the back.
      function sanitize(address, url) {
        return isSpecial(url.protocol) ? address.replace(/\\/g, "/") : address;
      },
      ["/", "pathname"],
      // Extract from the back.
      ["@", "auth", 1],
      // Extract from the front.
      [NaN, "host", void 0, 1, 1],
      // Set left over value.
      [/:(\d*)$/, "port", void 0, 1],
      // RegExp the back.
      [NaN, "hostname", void 0, 1, 1]
      // Set left over.
    ];
    var ignore = { hash: 1, query: 1 };
    function lolcation(loc) {
      var globalVar;
      if (typeof window !== "undefined") globalVar = window;
      else if (typeof global !== "undefined") globalVar = global;
      else if (typeof self !== "undefined") globalVar = self;
      else globalVar = {};
      var location = globalVar.location || {};
      loc = loc || location;
      var finaldestination = {}, type = typeof loc, key;
      if ("blob:" === loc.protocol) {
        finaldestination = new Url(unescape(loc.pathname), {});
      } else if ("string" === type) {
        finaldestination = new Url(loc, {});
        for (key in ignore) delete finaldestination[key];
      } else if ("object" === type) {
        for (key in loc) {
          if (key in ignore) continue;
          finaldestination[key] = loc[key];
        }
        if (finaldestination.slashes === void 0) {
          finaldestination.slashes = slashes.test(loc.href);
        }
      }
      return finaldestination;
    }
    function isSpecial(scheme) {
      return scheme === "file:" || scheme === "ftp:" || scheme === "http:" || scheme === "https:" || scheme === "ws:" || scheme === "wss:";
    }
    function extractProtocol(address, location) {
      address = trimLeft(address);
      address = address.replace(CRHTLF, "");
      location = location || {};
      var match = protocolre.exec(address);
      var protocol = match[1] ? match[1].toLowerCase() : "";
      var forwardSlashes = !!match[2];
      var otherSlashes = !!match[3];
      var slashesCount = 0;
      var rest;
      if (forwardSlashes) {
        if (otherSlashes) {
          rest = match[2] + match[3] + match[4];
          slashesCount = match[2].length + match[3].length;
        } else {
          rest = match[2] + match[4];
          slashesCount = match[2].length;
        }
      } else {
        if (otherSlashes) {
          rest = match[3] + match[4];
          slashesCount = match[3].length;
        } else {
          rest = match[4];
        }
      }
      if (protocol === "file:") {
        if (slashesCount >= 2) {
          rest = rest.slice(2);
        }
      } else if (isSpecial(protocol)) {
        rest = match[4];
      } else if (protocol) {
        if (forwardSlashes) {
          rest = rest.slice(2);
        }
      } else if (slashesCount >= 2 && isSpecial(location.protocol)) {
        rest = match[4];
      }
      return {
        protocol,
        slashes: forwardSlashes || isSpecial(protocol),
        slashesCount,
        rest
      };
    }
    function resolve(relative, base2) {
      if (relative === "") return base2;
      var path = (base2 || "/").split("/").slice(0, -1).concat(relative.split("/")), i = path.length, last = path[i - 1], unshift = false, up = 0;
      while (i--) {
        if (path[i] === ".") {
          path.splice(i, 1);
        } else if (path[i] === "..") {
          path.splice(i, 1);
          up++;
        } else if (up) {
          if (i === 0) unshift = true;
          path.splice(i, 1);
          up--;
        }
      }
      if (unshift) path.unshift("");
      if (last === "." || last === "..") path.push("");
      return path.join("/");
    }
    function Url(address, location, parser) {
      address = trimLeft(address);
      address = address.replace(CRHTLF, "");
      if (!(this instanceof Url)) {
        return new Url(address, location, parser);
      }
      var relative, extracted, parse, instruction, index, key, instructions = rules.slice(), type = typeof location, url = this, i = 0;
      if ("object" !== type && "string" !== type) {
        parser = location;
        location = null;
      }
      if (parser && "function" !== typeof parser) parser = qs.parse;
      location = lolcation(location);
      extracted = extractProtocol(address || "", location);
      relative = !extracted.protocol && !extracted.slashes;
      url.slashes = extracted.slashes || relative && location.slashes;
      url.protocol = extracted.protocol || location.protocol || "";
      address = extracted.rest;
      if (extracted.protocol === "file:" && (extracted.slashesCount !== 2 || windowsDriveLetter.test(address)) || !extracted.slashes && (extracted.protocol || extracted.slashesCount < 2 || !isSpecial(url.protocol))) {
        instructions[3] = [/(.*)/, "pathname"];
      }
      for (; i < instructions.length; i++) {
        instruction = instructions[i];
        if (typeof instruction === "function") {
          address = instruction(address, url);
          continue;
        }
        parse = instruction[0];
        key = instruction[1];
        if (parse !== parse) {
          url[key] = address;
        } else if ("string" === typeof parse) {
          index = parse === "@" ? address.lastIndexOf(parse) : address.indexOf(parse);
          if (~index) {
            if ("number" === typeof instruction[2]) {
              url[key] = address.slice(0, index);
              address = address.slice(index + instruction[2]);
            } else {
              url[key] = address.slice(index);
              address = address.slice(0, index);
            }
          }
        } else if (index = parse.exec(address)) {
          url[key] = index[1];
          address = address.slice(0, index.index);
        }
        url[key] = url[key] || (relative && instruction[3] ? location[key] || "" : "");
        if (instruction[4]) url[key] = url[key].toLowerCase();
      }
      if (parser) url.query = parser(url.query);
      if (relative && location.slashes && url.pathname.charAt(0) !== "/" && (url.pathname !== "" || location.pathname !== "")) {
        url.pathname = resolve(url.pathname, location.pathname);
      }
      if (url.pathname.charAt(0) !== "/" && isSpecial(url.protocol)) {
        url.pathname = "/" + url.pathname;
      }
      if (!required(url.port, url.protocol)) {
        url.host = url.hostname;
        url.port = "";
      }
      url.username = url.password = "";
      if (url.auth) {
        index = url.auth.indexOf(":");
        if (~index) {
          url.username = url.auth.slice(0, index);
          url.username = encodeURIComponent(decodeURIComponent(url.username));
          url.password = url.auth.slice(index + 1);
          url.password = encodeURIComponent(decodeURIComponent(url.password));
        } else {
          url.username = encodeURIComponent(decodeURIComponent(url.auth));
        }
        url.auth = url.password ? url.username + ":" + url.password : url.username;
      }
      url.origin = url.protocol !== "file:" && isSpecial(url.protocol) && url.host ? url.protocol + "//" + url.host : "null";
      url.href = url.toString();
    }
    function set(part, value, fn) {
      var url = this;
      switch (part) {
        case "query":
          if ("string" === typeof value && value.length) {
            value = (fn || qs.parse)(value);
          }
          url[part] = value;
          break;
        case "port":
          url[part] = value;
          if (!required(value, url.protocol)) {
            url.host = url.hostname;
            url[part] = "";
          } else if (value) {
            url.host = url.hostname + ":" + value;
          }
          break;
        case "hostname":
          url[part] = value;
          if (url.port) value += ":" + url.port;
          url.host = value;
          break;
        case "host":
          url[part] = value;
          if (port.test(value)) {
            value = value.split(":");
            url.port = value.pop();
            url.hostname = value.join(":");
          } else {
            url.hostname = value;
            url.port = "";
          }
          break;
        case "protocol":
          url.protocol = value.toLowerCase();
          url.slashes = !fn;
          break;
        case "pathname":
        case "hash":
          if (value) {
            var char = part === "pathname" ? "/" : "#";
            url[part] = value.charAt(0) !== char ? char + value : value;
          } else {
            url[part] = value;
          }
          break;
        case "username":
        case "password":
          url[part] = encodeURIComponent(value);
          break;
        case "auth":
          var index = value.indexOf(":");
          if (~index) {
            url.username = value.slice(0, index);
            url.username = encodeURIComponent(decodeURIComponent(url.username));
            url.password = value.slice(index + 1);
            url.password = encodeURIComponent(decodeURIComponent(url.password));
          } else {
            url.username = encodeURIComponent(decodeURIComponent(value));
          }
      }
      for (var i = 0; i < rules.length; i++) {
        var ins = rules[i];
        if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();
      }
      url.auth = url.password ? url.username + ":" + url.password : url.username;
      url.origin = url.protocol !== "file:" && isSpecial(url.protocol) && url.host ? url.protocol + "//" + url.host : "null";
      url.href = url.toString();
      return url;
    }
    function toString(stringify) {
      if (!stringify || "function" !== typeof stringify) stringify = qs.stringify;
      var query, url = this, host = url.host, protocol = url.protocol;
      if (protocol && protocol.charAt(protocol.length - 1) !== ":") protocol += ":";
      var result = protocol + (url.protocol && url.slashes || isSpecial(url.protocol) ? "//" : "");
      if (url.username) {
        result += url.username;
        if (url.password) result += ":" + url.password;
        result += "@";
      } else if (url.password) {
        result += ":" + url.password;
        result += "@";
      } else if (url.protocol !== "file:" && isSpecial(url.protocol) && !host && url.pathname !== "/") {
        result += "@";
      }
      if (host[host.length - 1] === ":" || port.test(url.hostname) && !url.port) {
        host += ":";
      }
      result += host + url.pathname;
      query = "object" === typeof url.query ? stringify(url.query) : url.query;
      if (query) result += "?" !== query.charAt(0) ? "?" + query : query;
      if (url.hash) result += url.hash;
      return result;
    }
    Url.prototype = { set, toString };
    Url.extractProtocol = extractProtocol;
    Url.location = lolcation;
    Url.trimLeft = trimLeft;
    Url.qs = qs;
    module2.exports = Url;
  }
});

// ../../../node_modules/psl/dist/psl.cjs
var require_psl = __commonJS({
  "../../../node_modules/psl/dist/psl.cjs"(exports2) {
    "use strict";
    Object.defineProperties(exports2, { __esModule: { value: true }, [Symbol.toStringTag]: { value: "Module" } });
    function K(e) {
      return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
    }
    var O;
    var F;
    function Q() {
      if (F) return O;
      F = 1;
      const e = 2147483647, s = 36, c = 1, o = 26, t = 38, d = 700, z = 72, y = 128, g = "-", P = /^xn--/, V = /[^\0-\x7F]/, G = /[\x2E\u3002\uFF0E\uFF61]/g, W = { overflow: "Overflow: input needs wider integers to process", "not-basic": "Illegal input >= 0x80 (not a basic code point)", "invalid-input": "Invalid input" }, C = s - c, h = Math.floor, I = String.fromCharCode;
      function v(a) {
        throw new RangeError(W[a]);
      }
      function U(a, i) {
        const m = [];
        let n = a.length;
        for (; n--; ) m[n] = i(a[n]);
        return m;
      }
      function S(a, i) {
        const m = a.split("@");
        let n = "";
        m.length > 1 && (n = m[0] + "@", a = m[1]), a = a.replace(G, ".");
        const r = a.split("."), p = U(r, i).join(".");
        return n + p;
      }
      function L(a) {
        const i = [];
        let m = 0;
        const n = a.length;
        for (; m < n; ) {
          const r = a.charCodeAt(m++);
          if (r >= 55296 && r <= 56319 && m < n) {
            const p = a.charCodeAt(m++);
            (p & 64512) == 56320 ? i.push(((r & 1023) << 10) + (p & 1023) + 65536) : (i.push(r), m--);
          } else i.push(r);
        }
        return i;
      }
      const $ = (a) => String.fromCodePoint(...a), J = function(a) {
        return a >= 48 && a < 58 ? 26 + (a - 48) : a >= 65 && a < 91 ? a - 65 : a >= 97 && a < 123 ? a - 97 : s;
      }, D = function(a, i) {
        return a + 22 + 75 * (a < 26) - ((i != 0) << 5);
      }, T = function(a, i, m) {
        let n = 0;
        for (a = m ? h(a / d) : a >> 1, a += h(a / i); a > C * o >> 1; n += s) a = h(a / C);
        return h(n + (C + 1) * a / (a + t));
      }, E = function(a) {
        const i = [], m = a.length;
        let n = 0, r = y, p = z, j = a.lastIndexOf(g);
        j < 0 && (j = 0);
        for (let u = 0; u < j; ++u) a.charCodeAt(u) >= 128 && v("not-basic"), i.push(a.charCodeAt(u));
        for (let u = j > 0 ? j + 1 : 0; u < m; ) {
          const k = n;
          for (let l = 1, b = s; ; b += s) {
            u >= m && v("invalid-input");
            const w = J(a.charCodeAt(u++));
            w >= s && v("invalid-input"), w > h((e - n) / l) && v("overflow"), n += w * l;
            const x = b <= p ? c : b >= p + o ? o : b - p;
            if (w < x) break;
            const q = s - x;
            l > h(e / q) && v("overflow"), l *= q;
          }
          const f = i.length + 1;
          p = T(n - k, f, k == 0), h(n / f) > e - r && v("overflow"), r += h(n / f), n %= f, i.splice(n++, 0, r);
        }
        return String.fromCodePoint(...i);
      }, B = function(a) {
        const i = [];
        a = L(a);
        const m = a.length;
        let n = y, r = 0, p = z;
        for (const k of a) k < 128 && i.push(I(k));
        const j = i.length;
        let u = j;
        for (j && i.push(g); u < m; ) {
          let k = e;
          for (const l of a) l >= n && l < k && (k = l);
          const f = u + 1;
          k - n > h((e - r) / f) && v("overflow"), r += (k - n) * f, n = k;
          for (const l of a) if (l < n && ++r > e && v("overflow"), l === n) {
            let b = r;
            for (let w = s; ; w += s) {
              const x = w <= p ? c : w >= p + o ? o : w - p;
              if (b < x) break;
              const q = b - x, M = s - x;
              i.push(I(D(x + q % M, 0))), b = h(q / M);
            }
            i.push(I(D(b, 0))), p = T(r, f, u === j), r = 0, ++u;
          }
          ++r, ++n;
        }
        return i.join("");
      };
      return O = { version: "2.3.1", ucs2: { decode: L, encode: $ }, decode: E, encode: B, toASCII: function(a) {
        return S(a, function(i) {
          return V.test(i) ? "xn--" + B(i) : i;
        });
      }, toUnicode: function(a) {
        return S(a, function(i) {
          return P.test(i) ? E(i.slice(4).toLowerCase()) : i;
        });
      } }, O;
    }
    var X = Q();
    var A = K(X);
    var Y = ["ac", "com.ac", "edu.ac", "gov.ac", "mil.ac", "net.ac", "org.ac", "ad", "ae", "ac.ae", "co.ae", "gov.ae", "mil.ae", "net.ae", "org.ae", "sch.ae", "aero", "airline.aero", "airport.aero", "accident-investigation.aero", "accident-prevention.aero", "aerobatic.aero", "aeroclub.aero", "aerodrome.aero", "agents.aero", "air-surveillance.aero", "air-traffic-control.aero", "aircraft.aero", "airtraffic.aero", "ambulance.aero", "association.aero", "author.aero", "ballooning.aero", "broker.aero", "caa.aero", "cargo.aero", "catering.aero", "certification.aero", "championship.aero", "charter.aero", "civilaviation.aero", "club.aero", "conference.aero", "consultant.aero", "consulting.aero", "control.aero", "council.aero", "crew.aero", "design.aero", "dgca.aero", "educator.aero", "emergency.aero", "engine.aero", "engineer.aero", "entertainment.aero", "equipment.aero", "exchange.aero", "express.aero", "federation.aero", "flight.aero", "freight.aero", "fuel.aero", "gliding.aero", "government.aero", "groundhandling.aero", "group.aero", "hanggliding.aero", "homebuilt.aero", "insurance.aero", "journal.aero", "journalist.aero", "leasing.aero", "logistics.aero", "magazine.aero", "maintenance.aero", "marketplace.aero", "media.aero", "microlight.aero", "modelling.aero", "navigation.aero", "parachuting.aero", "paragliding.aero", "passenger-association.aero", "pilot.aero", "press.aero", "production.aero", "recreation.aero", "repbody.aero", "res.aero", "research.aero", "rotorcraft.aero", "safety.aero", "scientist.aero", "services.aero", "show.aero", "skydiving.aero", "software.aero", "student.aero", "taxi.aero", "trader.aero", "trading.aero", "trainer.aero", "union.aero", "workinggroup.aero", "works.aero", "af", "com.af", "edu.af", "gov.af", "net.af", "org.af", "ag", "co.ag", "com.ag", "net.ag", "nom.ag", "org.ag", "ai", "com.ai", "net.ai", "off.ai", "org.ai", "al", "com.al", "edu.al", "gov.al", "mil.al", "net.al", "org.al", "am", "co.am", "com.am", "commune.am", "net.am", "org.am", "ao", "co.ao", "ed.ao", "edu.ao", "gov.ao", "gv.ao", "it.ao", "og.ao", "org.ao", "pb.ao", "aq", "ar", "bet.ar", "com.ar", "coop.ar", "edu.ar", "gob.ar", "gov.ar", "int.ar", "mil.ar", "musica.ar", "mutual.ar", "net.ar", "org.ar", "senasa.ar", "tur.ar", "arpa", "e164.arpa", "home.arpa", "in-addr.arpa", "ip6.arpa", "iris.arpa", "uri.arpa", "urn.arpa", "as", "gov.as", "asia", "at", "ac.at", "sth.ac.at", "co.at", "gv.at", "or.at", "au", "asn.au", "com.au", "edu.au", "gov.au", "id.au", "net.au", "org.au", "conf.au", "oz.au", "act.au", "nsw.au", "nt.au", "qld.au", "sa.au", "tas.au", "vic.au", "wa.au", "act.edu.au", "catholic.edu.au", "nsw.edu.au", "nt.edu.au", "qld.edu.au", "sa.edu.au", "tas.edu.au", "vic.edu.au", "wa.edu.au", "qld.gov.au", "sa.gov.au", "tas.gov.au", "vic.gov.au", "wa.gov.au", "schools.nsw.edu.au", "aw", "com.aw", "ax", "az", "biz.az", "com.az", "edu.az", "gov.az", "info.az", "int.az", "mil.az", "name.az", "net.az", "org.az", "pp.az", "pro.az", "ba", "com.ba", "edu.ba", "gov.ba", "mil.ba", "net.ba", "org.ba", "bb", "biz.bb", "co.bb", "com.bb", "edu.bb", "gov.bb", "info.bb", "net.bb", "org.bb", "store.bb", "tv.bb", "*.bd", "be", "ac.be", "bf", "gov.bf", "bg", "0.bg", "1.bg", "2.bg", "3.bg", "4.bg", "5.bg", "6.bg", "7.bg", "8.bg", "9.bg", "a.bg", "b.bg", "c.bg", "d.bg", "e.bg", "f.bg", "g.bg", "h.bg", "i.bg", "j.bg", "k.bg", "l.bg", "m.bg", "n.bg", "o.bg", "p.bg", "q.bg", "r.bg", "s.bg", "t.bg", "u.bg", "v.bg", "w.bg", "x.bg", "y.bg", "z.bg", "bh", "com.bh", "edu.bh", "gov.bh", "net.bh", "org.bh", "bi", "co.bi", "com.bi", "edu.bi", "or.bi", "org.bi", "biz", "bj", "africa.bj", "agro.bj", "architectes.bj", "assur.bj", "avocats.bj", "co.bj", "com.bj", "eco.bj", "econo.bj", "edu.bj", "info.bj", "loisirs.bj", "money.bj", "net.bj", "org.bj", "ote.bj", "restaurant.bj", "resto.bj", "tourism.bj", "univ.bj", "bm", "com.bm", "edu.bm", "gov.bm", "net.bm", "org.bm", "bn", "com.bn", "edu.bn", "gov.bn", "net.bn", "org.bn", "bo", "com.bo", "edu.bo", "gob.bo", "int.bo", "mil.bo", "net.bo", "org.bo", "tv.bo", "web.bo", "academia.bo", "agro.bo", "arte.bo", "blog.bo", "bolivia.bo", "ciencia.bo", "cooperativa.bo", "democracia.bo", "deporte.bo", "ecologia.bo", "economia.bo", "empresa.bo", "indigena.bo", "industria.bo", "info.bo", "medicina.bo", "movimiento.bo", "musica.bo", "natural.bo", "nombre.bo", "noticias.bo", "patria.bo", "plurinacional.bo", "politica.bo", "profesional.bo", "pueblo.bo", "revista.bo", "salud.bo", "tecnologia.bo", "tksat.bo", "transporte.bo", "wiki.bo", "br", "9guacu.br", "abc.br", "adm.br", "adv.br", "agr.br", "aju.br", "am.br", "anani.br", "aparecida.br", "app.br", "arq.br", "art.br", "ato.br", "b.br", "barueri.br", "belem.br", "bet.br", "bhz.br", "bib.br", "bio.br", "blog.br", "bmd.br", "boavista.br", "bsb.br", "campinagrande.br", "campinas.br", "caxias.br", "cim.br", "cng.br", "cnt.br", "com.br", "contagem.br", "coop.br", "coz.br", "cri.br", "cuiaba.br", "curitiba.br", "def.br", "des.br", "det.br", "dev.br", "ecn.br", "eco.br", "edu.br", "emp.br", "enf.br", "eng.br", "esp.br", "etc.br", "eti.br", "far.br", "feira.br", "flog.br", "floripa.br", "fm.br", "fnd.br", "fortal.br", "fot.br", "foz.br", "fst.br", "g12.br", "geo.br", "ggf.br", "goiania.br", "gov.br", "ac.gov.br", "al.gov.br", "am.gov.br", "ap.gov.br", "ba.gov.br", "ce.gov.br", "df.gov.br", "es.gov.br", "go.gov.br", "ma.gov.br", "mg.gov.br", "ms.gov.br", "mt.gov.br", "pa.gov.br", "pb.gov.br", "pe.gov.br", "pi.gov.br", "pr.gov.br", "rj.gov.br", "rn.gov.br", "ro.gov.br", "rr.gov.br", "rs.gov.br", "sc.gov.br", "se.gov.br", "sp.gov.br", "to.gov.br", "gru.br", "imb.br", "ind.br", "inf.br", "jab.br", "jampa.br", "jdf.br", "joinville.br", "jor.br", "jus.br", "leg.br", "leilao.br", "lel.br", "log.br", "londrina.br", "macapa.br", "maceio.br", "manaus.br", "maringa.br", "mat.br", "med.br", "mil.br", "morena.br", "mp.br", "mus.br", "natal.br", "net.br", "niteroi.br", "*.nom.br", "not.br", "ntr.br", "odo.br", "ong.br", "org.br", "osasco.br", "palmas.br", "poa.br", "ppg.br", "pro.br", "psc.br", "psi.br", "pvh.br", "qsl.br", "radio.br", "rec.br", "recife.br", "rep.br", "ribeirao.br", "rio.br", "riobranco.br", "riopreto.br", "salvador.br", "sampa.br", "santamaria.br", "santoandre.br", "saobernardo.br", "saogonca.br", "seg.br", "sjc.br", "slg.br", "slz.br", "sorocaba.br", "srv.br", "taxi.br", "tc.br", "tec.br", "teo.br", "the.br", "tmp.br", "trd.br", "tur.br", "tv.br", "udi.br", "vet.br", "vix.br", "vlog.br", "wiki.br", "zlg.br", "bs", "com.bs", "edu.bs", "gov.bs", "net.bs", "org.bs", "bt", "com.bt", "edu.bt", "gov.bt", "net.bt", "org.bt", "bv", "bw", "co.bw", "org.bw", "by", "gov.by", "mil.by", "com.by", "of.by", "bz", "co.bz", "com.bz", "edu.bz", "gov.bz", "net.bz", "org.bz", "ca", "ab.ca", "bc.ca", "mb.ca", "nb.ca", "nf.ca", "nl.ca", "ns.ca", "nt.ca", "nu.ca", "on.ca", "pe.ca", "qc.ca", "sk.ca", "yk.ca", "gc.ca", "cat", "cc", "cd", "gov.cd", "cf", "cg", "ch", "ci", "ac.ci", "aéroport.ci", "asso.ci", "co.ci", "com.ci", "ed.ci", "edu.ci", "go.ci", "gouv.ci", "int.ci", "net.ci", "or.ci", "org.ci", "*.ck", "!www.ck", "cl", "co.cl", "gob.cl", "gov.cl", "mil.cl", "cm", "co.cm", "com.cm", "gov.cm", "net.cm", "cn", "ac.cn", "com.cn", "edu.cn", "gov.cn", "mil.cn", "net.cn", "org.cn", "公司.cn", "網絡.cn", "网络.cn", "ah.cn", "bj.cn", "cq.cn", "fj.cn", "gd.cn", "gs.cn", "gx.cn", "gz.cn", "ha.cn", "hb.cn", "he.cn", "hi.cn", "hk.cn", "hl.cn", "hn.cn", "jl.cn", "js.cn", "jx.cn", "ln.cn", "mo.cn", "nm.cn", "nx.cn", "qh.cn", "sc.cn", "sd.cn", "sh.cn", "sn.cn", "sx.cn", "tj.cn", "tw.cn", "xj.cn", "xz.cn", "yn.cn", "zj.cn", "co", "com.co", "edu.co", "gov.co", "mil.co", "net.co", "nom.co", "org.co", "com", "coop", "cr", "ac.cr", "co.cr", "ed.cr", "fi.cr", "go.cr", "or.cr", "sa.cr", "cu", "com.cu", "edu.cu", "gob.cu", "inf.cu", "nat.cu", "net.cu", "org.cu", "cv", "com.cv", "edu.cv", "id.cv", "int.cv", "net.cv", "nome.cv", "org.cv", "publ.cv", "cw", "com.cw", "edu.cw", "net.cw", "org.cw", "cx", "gov.cx", "cy", "ac.cy", "biz.cy", "com.cy", "ekloges.cy", "gov.cy", "ltd.cy", "mil.cy", "net.cy", "org.cy", "press.cy", "pro.cy", "tm.cy", "cz", "de", "dj", "dk", "dm", "co.dm", "com.dm", "edu.dm", "gov.dm", "net.dm", "org.dm", "do", "art.do", "com.do", "edu.do", "gob.do", "gov.do", "mil.do", "net.do", "org.do", "sld.do", "web.do", "dz", "art.dz", "asso.dz", "com.dz", "edu.dz", "gov.dz", "net.dz", "org.dz", "pol.dz", "soc.dz", "tm.dz", "ec", "com.ec", "edu.ec", "fin.ec", "gob.ec", "gov.ec", "info.ec", "k12.ec", "med.ec", "mil.ec", "net.ec", "org.ec", "pro.ec", "edu", "ee", "aip.ee", "com.ee", "edu.ee", "fie.ee", "gov.ee", "lib.ee", "med.ee", "org.ee", "pri.ee", "riik.ee", "eg", "ac.eg", "com.eg", "edu.eg", "eun.eg", "gov.eg", "info.eg", "me.eg", "mil.eg", "name.eg", "net.eg", "org.eg", "sci.eg", "sport.eg", "tv.eg", "*.er", "es", "com.es", "edu.es", "gob.es", "nom.es", "org.es", "et", "biz.et", "com.et", "edu.et", "gov.et", "info.et", "name.et", "net.et", "org.et", "eu", "fi", "aland.fi", "fj", "ac.fj", "biz.fj", "com.fj", "gov.fj", "info.fj", "mil.fj", "name.fj", "net.fj", "org.fj", "pro.fj", "*.fk", "fm", "com.fm", "edu.fm", "net.fm", "org.fm", "fo", "fr", "asso.fr", "com.fr", "gouv.fr", "nom.fr", "prd.fr", "tm.fr", "avoues.fr", "cci.fr", "greta.fr", "huissier-justice.fr", "ga", "gb", "gd", "edu.gd", "gov.gd", "ge", "com.ge", "edu.ge", "gov.ge", "net.ge", "org.ge", "pvt.ge", "school.ge", "gf", "gg", "co.gg", "net.gg", "org.gg", "gh", "com.gh", "edu.gh", "gov.gh", "mil.gh", "org.gh", "gi", "com.gi", "edu.gi", "gov.gi", "ltd.gi", "mod.gi", "org.gi", "gl", "co.gl", "com.gl", "edu.gl", "net.gl", "org.gl", "gm", "gn", "ac.gn", "com.gn", "edu.gn", "gov.gn", "net.gn", "org.gn", "gov", "gp", "asso.gp", "com.gp", "edu.gp", "mobi.gp", "net.gp", "org.gp", "gq", "gr", "com.gr", "edu.gr", "gov.gr", "net.gr", "org.gr", "gs", "gt", "com.gt", "edu.gt", "gob.gt", "ind.gt", "mil.gt", "net.gt", "org.gt", "gu", "com.gu", "edu.gu", "gov.gu", "guam.gu", "info.gu", "net.gu", "org.gu", "web.gu", "gw", "gy", "co.gy", "com.gy", "edu.gy", "gov.gy", "net.gy", "org.gy", "hk", "com.hk", "edu.hk", "gov.hk", "idv.hk", "net.hk", "org.hk", "个人.hk", "個人.hk", "公司.hk", "政府.hk", "敎育.hk", "教育.hk", "箇人.hk", "組織.hk", "組织.hk", "網絡.hk", "網络.hk", "组織.hk", "组织.hk", "网絡.hk", "网络.hk", "hm", "hn", "com.hn", "edu.hn", "gob.hn", "mil.hn", "net.hn", "org.hn", "hr", "com.hr", "from.hr", "iz.hr", "name.hr", "ht", "adult.ht", "art.ht", "asso.ht", "com.ht", "coop.ht", "edu.ht", "firm.ht", "gouv.ht", "info.ht", "med.ht", "net.ht", "org.ht", "perso.ht", "pol.ht", "pro.ht", "rel.ht", "shop.ht", "hu", "2000.hu", "agrar.hu", "bolt.hu", "casino.hu", "city.hu", "co.hu", "erotica.hu", "erotika.hu", "film.hu", "forum.hu", "games.hu", "hotel.hu", "info.hu", "ingatlan.hu", "jogasz.hu", "konyvelo.hu", "lakas.hu", "media.hu", "news.hu", "org.hu", "priv.hu", "reklam.hu", "sex.hu", "shop.hu", "sport.hu", "suli.hu", "szex.hu", "tm.hu", "tozsde.hu", "utazas.hu", "video.hu", "id", "ac.id", "biz.id", "co.id", "desa.id", "go.id", "mil.id", "my.id", "net.id", "or.id", "ponpes.id", "sch.id", "web.id", "ie", "gov.ie", "il", "ac.il", "co.il", "gov.il", "idf.il", "k12.il", "muni.il", "net.il", "org.il", "ישראל", "אקדמיה.ישראל", "ישוב.ישראל", "צהל.ישראל", "ממשל.ישראל", "im", "ac.im", "co.im", "ltd.co.im", "plc.co.im", "com.im", "net.im", "org.im", "tt.im", "tv.im", "in", "5g.in", "6g.in", "ac.in", "ai.in", "am.in", "bihar.in", "biz.in", "business.in", "ca.in", "cn.in", "co.in", "com.in", "coop.in", "cs.in", "delhi.in", "dr.in", "edu.in", "er.in", "firm.in", "gen.in", "gov.in", "gujarat.in", "ind.in", "info.in", "int.in", "internet.in", "io.in", "me.in", "mil.in", "net.in", "nic.in", "org.in", "pg.in", "post.in", "pro.in", "res.in", "travel.in", "tv.in", "uk.in", "up.in", "us.in", "info", "int", "eu.int", "io", "co.io", "com.io", "edu.io", "gov.io", "mil.io", "net.io", "nom.io", "org.io", "iq", "com.iq", "edu.iq", "gov.iq", "mil.iq", "net.iq", "org.iq", "ir", "ac.ir", "co.ir", "gov.ir", "id.ir", "net.ir", "org.ir", "sch.ir", "ایران.ir", "ايران.ir", "is", "it", "edu.it", "gov.it", "abr.it", "abruzzo.it", "aosta-valley.it", "aostavalley.it", "bas.it", "basilicata.it", "cal.it", "calabria.it", "cam.it", "campania.it", "emilia-romagna.it", "emiliaromagna.it", "emr.it", "friuli-v-giulia.it", "friuli-ve-giulia.it", "friuli-vegiulia.it", "friuli-venezia-giulia.it", "friuli-veneziagiulia.it", "friuli-vgiulia.it", "friuliv-giulia.it", "friulive-giulia.it", "friulivegiulia.it", "friulivenezia-giulia.it", "friuliveneziagiulia.it", "friulivgiulia.it", "fvg.it", "laz.it", "lazio.it", "lig.it", "liguria.it", "lom.it", "lombardia.it", "lombardy.it", "lucania.it", "mar.it", "marche.it", "mol.it", "molise.it", "piedmont.it", "piemonte.it", "pmn.it", "pug.it", "puglia.it", "sar.it", "sardegna.it", "sardinia.it", "sic.it", "sicilia.it", "sicily.it", "taa.it", "tos.it", "toscana.it", "trentin-sud-tirol.it", "trentin-süd-tirol.it", "trentin-sudtirol.it", "trentin-südtirol.it", "trentin-sued-tirol.it", "trentin-suedtirol.it", "trentino.it", "trentino-a-adige.it", "trentino-aadige.it", "trentino-alto-adige.it", "trentino-altoadige.it", "trentino-s-tirol.it", "trentino-stirol.it", "trentino-sud-tirol.it", "trentino-süd-tirol.it", "trentino-sudtirol.it", "trentino-südtirol.it", "trentino-sued-tirol.it", "trentino-suedtirol.it", "trentinoa-adige.it", "trentinoaadige.it", "trentinoalto-adige.it", "trentinoaltoadige.it", "trentinos-tirol.it", "trentinostirol.it", "trentinosud-tirol.it", "trentinosüd-tirol.it", "trentinosudtirol.it", "trentinosüdtirol.it", "trentinosued-tirol.it", "trentinosuedtirol.it", "trentinsud-tirol.it", "trentinsüd-tirol.it", "trentinsudtirol.it", "trentinsüdtirol.it", "trentinsued-tirol.it", "trentinsuedtirol.it", "tuscany.it", "umb.it", "umbria.it", "val-d-aosta.it", "val-daosta.it", "vald-aosta.it", "valdaosta.it", "valle-aosta.it", "valle-d-aosta.it", "valle-daosta.it", "valleaosta.it", "valled-aosta.it", "valledaosta.it", "vallee-aoste.it", "vallée-aoste.it", "vallee-d-aoste.it", "vallée-d-aoste.it", "valleeaoste.it", "valléeaoste.it", "valleedaoste.it", "valléedaoste.it", "vao.it", "vda.it", "ven.it", "veneto.it", "ag.it", "agrigento.it", "al.it", "alessandria.it", "alto-adige.it", "altoadige.it", "an.it", "ancona.it", "andria-barletta-trani.it", "andria-trani-barletta.it", "andriabarlettatrani.it", "andriatranibarletta.it", "ao.it", "aosta.it", "aoste.it", "ap.it", "aq.it", "aquila.it", "ar.it", "arezzo.it", "ascoli-piceno.it", "ascolipiceno.it", "asti.it", "at.it", "av.it", "avellino.it", "ba.it", "balsan.it", "balsan-sudtirol.it", "balsan-südtirol.it", "balsan-suedtirol.it", "bari.it", "barletta-trani-andria.it", "barlettatraniandria.it", "belluno.it", "benevento.it", "bergamo.it", "bg.it", "bi.it", "biella.it", "bl.it", "bn.it", "bo.it", "bologna.it", "bolzano.it", "bolzano-altoadige.it", "bozen.it", "bozen-sudtirol.it", "bozen-südtirol.it", "bozen-suedtirol.it", "br.it", "brescia.it", "brindisi.it", "bs.it", "bt.it", "bulsan.it", "bulsan-sudtirol.it", "bulsan-südtirol.it", "bulsan-suedtirol.it", "bz.it", "ca.it", "cagliari.it", "caltanissetta.it", "campidano-medio.it", "campidanomedio.it", "campobasso.it", "carbonia-iglesias.it", "carboniaiglesias.it", "carrara-massa.it", "carraramassa.it", "caserta.it", "catania.it", "catanzaro.it", "cb.it", "ce.it", "cesena-forli.it", "cesena-forlì.it", "cesenaforli.it", "cesenaforlì.it", "ch.it", "chieti.it", "ci.it", "cl.it", "cn.it", "co.it", "como.it", "cosenza.it", "cr.it", "cremona.it", "crotone.it", "cs.it", "ct.it", "cuneo.it", "cz.it", "dell-ogliastra.it", "dellogliastra.it", "en.it", "enna.it", "fc.it", "fe.it", "fermo.it", "ferrara.it", "fg.it", "fi.it", "firenze.it", "florence.it", "fm.it", "foggia.it", "forli-cesena.it", "forlì-cesena.it", "forlicesena.it", "forlìcesena.it", "fr.it", "frosinone.it", "ge.it", "genoa.it", "genova.it", "go.it", "gorizia.it", "gr.it", "grosseto.it", "iglesias-carbonia.it", "iglesiascarbonia.it", "im.it", "imperia.it", "is.it", "isernia.it", "kr.it", "la-spezia.it", "laquila.it", "laspezia.it", "latina.it", "lc.it", "le.it", "lecce.it", "lecco.it", "li.it", "livorno.it", "lo.it", "lodi.it", "lt.it", "lu.it", "lucca.it", "macerata.it", "mantova.it", "massa-carrara.it", "massacarrara.it", "matera.it", "mb.it", "mc.it", "me.it", "medio-campidano.it", "mediocampidano.it", "messina.it", "mi.it", "milan.it", "milano.it", "mn.it", "mo.it", "modena.it", "monza.it", "monza-brianza.it", "monza-e-della-brianza.it", "monzabrianza.it", "monzaebrianza.it", "monzaedellabrianza.it", "ms.it", "mt.it", "na.it", "naples.it", "napoli.it", "no.it", "novara.it", "nu.it", "nuoro.it", "og.it", "ogliastra.it", "olbia-tempio.it", "olbiatempio.it", "or.it", "oristano.it", "ot.it", "pa.it", "padova.it", "padua.it", "palermo.it", "parma.it", "pavia.it", "pc.it", "pd.it", "pe.it", "perugia.it", "pesaro-urbino.it", "pesarourbino.it", "pescara.it", "pg.it", "pi.it", "piacenza.it", "pisa.it", "pistoia.it", "pn.it", "po.it", "pordenone.it", "potenza.it", "pr.it", "prato.it", "pt.it", "pu.it", "pv.it", "pz.it", "ra.it", "ragusa.it", "ravenna.it", "rc.it", "re.it", "reggio-calabria.it", "reggio-emilia.it", "reggiocalabria.it", "reggioemilia.it", "rg.it", "ri.it", "rieti.it", "rimini.it", "rm.it", "rn.it", "ro.it", "roma.it", "rome.it", "rovigo.it", "sa.it", "salerno.it", "sassari.it", "savona.it", "si.it", "siena.it", "siracusa.it", "so.it", "sondrio.it", "sp.it", "sr.it", "ss.it", "südtirol.it", "suedtirol.it", "sv.it", "ta.it", "taranto.it", "te.it", "tempio-olbia.it", "tempioolbia.it", "teramo.it", "terni.it", "tn.it", "to.it", "torino.it", "tp.it", "tr.it", "trani-andria-barletta.it", "trani-barletta-andria.it", "traniandriabarletta.it", "tranibarlettaandria.it", "trapani.it", "trento.it", "treviso.it", "trieste.it", "ts.it", "turin.it", "tv.it", "ud.it", "udine.it", "urbino-pesaro.it", "urbinopesaro.it", "va.it", "varese.it", "vb.it", "vc.it", "ve.it", "venezia.it", "venice.it", "verbania.it", "vercelli.it", "verona.it", "vi.it", "vibo-valentia.it", "vibovalentia.it", "vicenza.it", "viterbo.it", "vr.it", "vs.it", "vt.it", "vv.it", "je", "co.je", "net.je", "org.je", "*.jm", "jo", "agri.jo", "ai.jo", "com.jo", "edu.jo", "eng.jo", "fm.jo", "gov.jo", "mil.jo", "net.jo", "org.jo", "per.jo", "phd.jo", "sch.jo", "tv.jo", "jobs", "jp", "ac.jp", "ad.jp", "co.jp", "ed.jp", "go.jp", "gr.jp", "lg.jp", "ne.jp", "or.jp", "aichi.jp", "akita.jp", "aomori.jp", "chiba.jp", "ehime.jp", "fukui.jp", "fukuoka.jp", "fukushima.jp", "gifu.jp", "gunma.jp", "hiroshima.jp", "hokkaido.jp", "hyogo.jp", "ibaraki.jp", "ishikawa.jp", "iwate.jp", "kagawa.jp", "kagoshima.jp", "kanagawa.jp", "kochi.jp", "kumamoto.jp", "kyoto.jp", "mie.jp", "miyagi.jp", "miyazaki.jp", "nagano.jp", "nagasaki.jp", "nara.jp", "niigata.jp", "oita.jp", "okayama.jp", "okinawa.jp", "osaka.jp", "saga.jp", "saitama.jp", "shiga.jp", "shimane.jp", "shizuoka.jp", "tochigi.jp", "tokushima.jp", "tokyo.jp", "tottori.jp", "toyama.jp", "wakayama.jp", "yamagata.jp", "yamaguchi.jp", "yamanashi.jp", "三重.jp", "京都.jp", "佐賀.jp", "兵庫.jp", "北海道.jp", "千葉.jp", "和歌山.jp", "埼玉.jp", "大分.jp", "大阪.jp", "奈良.jp", "宮城.jp", "宮崎.jp", "富山.jp", "山口.jp", "山形.jp", "山梨.jp", "岐阜.jp", "岡山.jp", "岩手.jp", "島根.jp", "広島.jp", "徳島.jp", "愛媛.jp", "愛知.jp", "新潟.jp", "東京.jp", "栃木.jp", "沖縄.jp", "滋賀.jp", "熊本.jp", "石川.jp", "神奈川.jp", "福井.jp", "福岡.jp", "福島.jp", "秋田.jp", "群馬.jp", "茨城.jp", "長崎.jp", "長野.jp", "青森.jp", "静岡.jp", "香川.jp", "高知.jp", "鳥取.jp", "鹿児島.jp", "*.kawasaki.jp", "!city.kawasaki.jp", "*.kitakyushu.jp", "!city.kitakyushu.jp", "*.kobe.jp", "!city.kobe.jp", "*.nagoya.jp", "!city.nagoya.jp", "*.sapporo.jp", "!city.sapporo.jp", "*.sendai.jp", "!city.sendai.jp", "*.yokohama.jp", "!city.yokohama.jp", "aisai.aichi.jp", "ama.aichi.jp", "anjo.aichi.jp", "asuke.aichi.jp", "chiryu.aichi.jp", "chita.aichi.jp", "fuso.aichi.jp", "gamagori.aichi.jp", "handa.aichi.jp", "hazu.aichi.jp", "hekinan.aichi.jp", "higashiura.aichi.jp", "ichinomiya.aichi.jp", "inazawa.aichi.jp", "inuyama.aichi.jp", "isshiki.aichi.jp", "iwakura.aichi.jp", "kanie.aichi.jp", "kariya.aichi.jp", "kasugai.aichi.jp", "kira.aichi.jp", "kiyosu.aichi.jp", "komaki.aichi.jp", "konan.aichi.jp", "kota.aichi.jp", "mihama.aichi.jp", "miyoshi.aichi.jp", "nishio.aichi.jp", "nisshin.aichi.jp", "obu.aichi.jp", "oguchi.aichi.jp", "oharu.aichi.jp", "okazaki.aichi.jp", "owariasahi.aichi.jp", "seto.aichi.jp", "shikatsu.aichi.jp", "shinshiro.aichi.jp", "shitara.aichi.jp", "tahara.aichi.jp", "takahama.aichi.jp", "tobishima.aichi.jp", "toei.aichi.jp", "togo.aichi.jp", "tokai.aichi.jp", "tokoname.aichi.jp", "toyoake.aichi.jp", "toyohashi.aichi.jp", "toyokawa.aichi.jp", "toyone.aichi.jp", "toyota.aichi.jp", "tsushima.aichi.jp", "yatomi.aichi.jp", "akita.akita.jp", "daisen.akita.jp", "fujisato.akita.jp", "gojome.akita.jp", "hachirogata.akita.jp", "happou.akita.jp", "higashinaruse.akita.jp", "honjo.akita.jp", "honjyo.akita.jp", "ikawa.akita.jp", "kamikoani.akita.jp", "kamioka.akita.jp", "katagami.akita.jp", "kazuno.akita.jp", "kitaakita.akita.jp", "kosaka.akita.jp", "kyowa.akita.jp", "misato.akita.jp", "mitane.akita.jp", "moriyoshi.akita.jp", "nikaho.akita.jp", "noshiro.akita.jp", "odate.akita.jp", "oga.akita.jp", "ogata.akita.jp", "semboku.akita.jp", "yokote.akita.jp", "yurihonjo.akita.jp", "aomori.aomori.jp", "gonohe.aomori.jp", "hachinohe.aomori.jp", "hashikami.aomori.jp", "hiranai.aomori.jp", "hirosaki.aomori.jp", "itayanagi.aomori.jp", "kuroishi.aomori.jp", "misawa.aomori.jp", "mutsu.aomori.jp", "nakadomari.aomori.jp", "noheji.aomori.jp", "oirase.aomori.jp", "owani.aomori.jp", "rokunohe.aomori.jp", "sannohe.aomori.jp", "shichinohe.aomori.jp", "shingo.aomori.jp", "takko.aomori.jp", "towada.aomori.jp", "tsugaru.aomori.jp", "tsuruta.aomori.jp", "abiko.chiba.jp", "asahi.chiba.jp", "chonan.chiba.jp", "chosei.chiba.jp", "choshi.chiba.jp", "chuo.chiba.jp", "funabashi.chiba.jp", "futtsu.chiba.jp", "hanamigawa.chiba.jp", "ichihara.chiba.jp", "ichikawa.chiba.jp", "ichinomiya.chiba.jp", "inzai.chiba.jp", "isumi.chiba.jp", "kamagaya.chiba.jp", "kamogawa.chiba.jp", "kashiwa.chiba.jp", "katori.chiba.jp", "katsuura.chiba.jp", "kimitsu.chiba.jp", "kisarazu.chiba.jp", "kozaki.chiba.jp", "kujukuri.chiba.jp", "kyonan.chiba.jp", "matsudo.chiba.jp", "midori.chiba.jp", "mihama.chiba.jp", "minamiboso.chiba.jp", "mobara.chiba.jp", "mutsuzawa.chiba.jp", "nagara.chiba.jp", "nagareyama.chiba.jp", "narashino.chiba.jp", "narita.chiba.jp", "noda.chiba.jp", "oamishirasato.chiba.jp", "omigawa.chiba.jp", "onjuku.chiba.jp", "otaki.chiba.jp", "sakae.chiba.jp", "sakura.chiba.jp", "shimofusa.chiba.jp", "shirako.chiba.jp", "shiroi.chiba.jp", "shisui.chiba.jp", "sodegaura.chiba.jp", "sosa.chiba.jp", "tako.chiba.jp", "tateyama.chiba.jp", "togane.chiba.jp", "tohnosho.chiba.jp", "tomisato.chiba.jp", "urayasu.chiba.jp", "yachimata.chiba.jp", "yachiyo.chiba.jp", "yokaichiba.chiba.jp", "yokoshibahikari.chiba.jp", "yotsukaido.chiba.jp", "ainan.ehime.jp", "honai.ehime.jp", "ikata.ehime.jp", "imabari.ehime.jp", "iyo.ehime.jp", "kamijima.ehime.jp", "kihoku.ehime.jp", "kumakogen.ehime.jp", "masaki.ehime.jp", "matsuno.ehime.jp", "matsuyama.ehime.jp", "namikata.ehime.jp", "niihama.ehime.jp", "ozu.ehime.jp", "saijo.ehime.jp", "seiyo.ehime.jp", "shikokuchuo.ehime.jp", "tobe.ehime.jp", "toon.ehime.jp", "uchiko.ehime.jp", "uwajima.ehime.jp", "yawatahama.ehime.jp", "echizen.fukui.jp", "eiheiji.fukui.jp", "fukui.fukui.jp", "ikeda.fukui.jp", "katsuyama.fukui.jp", "mihama.fukui.jp", "minamiechizen.fukui.jp", "obama.fukui.jp", "ohi.fukui.jp", "ono.fukui.jp", "sabae.fukui.jp", "sakai.fukui.jp", "takahama.fukui.jp", "tsuruga.fukui.jp", "wakasa.fukui.jp", "ashiya.fukuoka.jp", "buzen.fukuoka.jp", "chikugo.fukuoka.jp", "chikuho.fukuoka.jp", "chikujo.fukuoka.jp", "chikushino.fukuoka.jp", "chikuzen.fukuoka.jp", "chuo.fukuoka.jp", "dazaifu.fukuoka.jp", "fukuchi.fukuoka.jp", "hakata.fukuoka.jp", "higashi.fukuoka.jp", "hirokawa.fukuoka.jp", "hisayama.fukuoka.jp", "iizuka.fukuoka.jp", "inatsuki.fukuoka.jp", "kaho.fukuoka.jp", "kasuga.fukuoka.jp", "kasuya.fukuoka.jp", "kawara.fukuoka.jp", "keisen.fukuoka.jp", "koga.fukuoka.jp", "kurate.fukuoka.jp", "kurogi.fukuoka.jp", "kurume.fukuoka.jp", "minami.fukuoka.jp", "miyako.fukuoka.jp", "miyama.fukuoka.jp", "miyawaka.fukuoka.jp", "mizumaki.fukuoka.jp", "munakata.fukuoka.jp", "nakagawa.fukuoka.jp", "nakama.fukuoka.jp", "nishi.fukuoka.jp", "nogata.fukuoka.jp", "ogori.fukuoka.jp", "okagaki.fukuoka.jp", "okawa.fukuoka.jp", "oki.fukuoka.jp", "omuta.fukuoka.jp", "onga.fukuoka.jp", "onojo.fukuoka.jp", "oto.fukuoka.jp", "saigawa.fukuoka.jp", "sasaguri.fukuoka.jp", "shingu.fukuoka.jp", "shinyoshitomi.fukuoka.jp", "shonai.fukuoka.jp", "soeda.fukuoka.jp", "sue.fukuoka.jp", "tachiarai.fukuoka.jp", "tagawa.fukuoka.jp", "takata.fukuoka.jp", "toho.fukuoka.jp", "toyotsu.fukuoka.jp", "tsuiki.fukuoka.jp", "ukiha.fukuoka.jp", "umi.fukuoka.jp", "usui.fukuoka.jp", "yamada.fukuoka.jp", "yame.fukuoka.jp", "yanagawa.fukuoka.jp", "yukuhashi.fukuoka.jp", "aizubange.fukushima.jp", "aizumisato.fukushima.jp", "aizuwakamatsu.fukushima.jp", "asakawa.fukushima.jp", "bandai.fukushima.jp", "date.fukushima.jp", "fukushima.fukushima.jp", "furudono.fukushima.jp", "futaba.fukushima.jp", "hanawa.fukushima.jp", "higashi.fukushima.jp", "hirata.fukushima.jp", "hirono.fukushima.jp", "iitate.fukushima.jp", "inawashiro.fukushima.jp", "ishikawa.fukushima.jp", "iwaki.fukushima.jp", "izumizaki.fukushima.jp", "kagamiishi.fukushima.jp", "kaneyama.fukushima.jp", "kawamata.fukushima.jp", "kitakata.fukushima.jp", "kitashiobara.fukushima.jp", "koori.fukushima.jp", "koriyama.fukushima.jp", "kunimi.fukushima.jp", "miharu.fukushima.jp", "mishima.fukushima.jp", "namie.fukushima.jp", "nango.fukushima.jp", "nishiaizu.fukushima.jp", "nishigo.fukushima.jp", "okuma.fukushima.jp", "omotego.fukushima.jp", "ono.fukushima.jp", "otama.fukushima.jp", "samegawa.fukushima.jp", "shimogo.fukushima.jp", "shirakawa.fukushima.jp", "showa.fukushima.jp", "soma.fukushima.jp", "sukagawa.fukushima.jp", "taishin.fukushima.jp", "tamakawa.fukushima.jp", "tanagura.fukushima.jp", "tenei.fukushima.jp", "yabuki.fukushima.jp", "yamato.fukushima.jp", "yamatsuri.fukushima.jp", "yanaizu.fukushima.jp", "yugawa.fukushima.jp", "anpachi.gifu.jp", "ena.gifu.jp", "gifu.gifu.jp", "ginan.gifu.jp", "godo.gifu.jp", "gujo.gifu.jp", "hashima.gifu.jp", "hichiso.gifu.jp", "hida.gifu.jp", "higashishirakawa.gifu.jp", "ibigawa.gifu.jp", "ikeda.gifu.jp", "kakamigahara.gifu.jp", "kani.gifu.jp", "kasahara.gifu.jp", "kasamatsu.gifu.jp", "kawaue.gifu.jp", "kitagata.gifu.jp", "mino.gifu.jp", "minokamo.gifu.jp", "mitake.gifu.jp", "mizunami.gifu.jp", "motosu.gifu.jp", "nakatsugawa.gifu.jp", "ogaki.gifu.jp", "sakahogi.gifu.jp", "seki.gifu.jp", "sekigahara.gifu.jp", "shirakawa.gifu.jp", "tajimi.gifu.jp", "takayama.gifu.jp", "tarui.gifu.jp", "toki.gifu.jp", "tomika.gifu.jp", "wanouchi.gifu.jp", "yamagata.gifu.jp", "yaotsu.gifu.jp", "yoro.gifu.jp", "annaka.gunma.jp", "chiyoda.gunma.jp", "fujioka.gunma.jp", "higashiagatsuma.gunma.jp", "isesaki.gunma.jp", "itakura.gunma.jp", "kanna.gunma.jp", "kanra.gunma.jp", "katashina.gunma.jp", "kawaba.gunma.jp", "kiryu.gunma.jp", "kusatsu.gunma.jp", "maebashi.gunma.jp", "meiwa.gunma.jp", "midori.gunma.jp", "minakami.gunma.jp", "naganohara.gunma.jp", "nakanojo.gunma.jp", "nanmoku.gunma.jp", "numata.gunma.jp", "oizumi.gunma.jp", "ora.gunma.jp", "ota.gunma.jp", "shibukawa.gunma.jp", "shimonita.gunma.jp", "shinto.gunma.jp", "showa.gunma.jp", "takasaki.gunma.jp", "takayama.gunma.jp", "tamamura.gunma.jp", "tatebayashi.gunma.jp", "tomioka.gunma.jp", "tsukiyono.gunma.jp", "tsumagoi.gunma.jp", "ueno.gunma.jp", "yoshioka.gunma.jp", "asaminami.hiroshima.jp", "daiwa.hiroshima.jp", "etajima.hiroshima.jp", "fuchu.hiroshima.jp", "fukuyama.hiroshima.jp", "hatsukaichi.hiroshima.jp", "higashihiroshima.hiroshima.jp", "hongo.hiroshima.jp", "jinsekikogen.hiroshima.jp", "kaita.hiroshima.jp", "kui.hiroshima.jp", "kumano.hiroshima.jp", "kure.hiroshima.jp", "mihara.hiroshima.jp", "miyoshi.hiroshima.jp", "naka.hiroshima.jp", "onomichi.hiroshima.jp", "osakikamijima.hiroshima.jp", "otake.hiroshima.jp", "saka.hiroshima.jp", "sera.hiroshima.jp", "seranishi.hiroshima.jp", "shinichi.hiroshima.jp", "shobara.hiroshima.jp", "takehara.hiroshima.jp", "abashiri.hokkaido.jp", "abira.hokkaido.jp", "aibetsu.hokkaido.jp", "akabira.hokkaido.jp", "akkeshi.hokkaido.jp", "asahikawa.hokkaido.jp", "ashibetsu.hokkaido.jp", "ashoro.hokkaido.jp", "assabu.hokkaido.jp", "atsuma.hokkaido.jp", "bibai.hokkaido.jp", "biei.hokkaido.jp", "bifuka.hokkaido.jp", "bihoro.hokkaido.jp", "biratori.hokkaido.jp", "chippubetsu.hokkaido.jp", "chitose.hokkaido.jp", "date.hokkaido.jp", "ebetsu.hokkaido.jp", "embetsu.hokkaido.jp", "eniwa.hokkaido.jp", "erimo.hokkaido.jp", "esan.hokkaido.jp", "esashi.hokkaido.jp", "fukagawa.hokkaido.jp", "fukushima.hokkaido.jp", "furano.hokkaido.jp", "furubira.hokkaido.jp", "haboro.hokkaido.jp", "hakodate.hokkaido.jp", "hamatonbetsu.hokkaido.jp", "hidaka.hokkaido.jp", "higashikagura.hokkaido.jp", "higashikawa.hokkaido.jp", "hiroo.hokkaido.jp", "hokuryu.hokkaido.jp", "hokuto.hokkaido.jp", "honbetsu.hokkaido.jp", "horokanai.hokkaido.jp", "horonobe.hokkaido.jp", "ikeda.hokkaido.jp", "imakane.hokkaido.jp", "ishikari.hokkaido.jp", "iwamizawa.hokkaido.jp", "iwanai.hokkaido.jp", "kamifurano.hokkaido.jp", "kamikawa.hokkaido.jp", "kamishihoro.hokkaido.jp", "kamisunagawa.hokkaido.jp", "kamoenai.hokkaido.jp", "kayabe.hokkaido.jp", "kembuchi.hokkaido.jp", "kikonai.hokkaido.jp", "kimobetsu.hokkaido.jp", "kitahiroshima.hokkaido.jp", "kitami.hokkaido.jp", "kiyosato.hokkaido.jp", "koshimizu.hokkaido.jp", "kunneppu.hokkaido.jp", "kuriyama.hokkaido.jp", "kuromatsunai.hokkaido.jp", "kushiro.hokkaido.jp", "kutchan.hokkaido.jp", "kyowa.hokkaido.jp", "mashike.hokkaido.jp", "matsumae.hokkaido.jp", "mikasa.hokkaido.jp", "minamifurano.hokkaido.jp", "mombetsu.hokkaido.jp", "moseushi.hokkaido.jp", "mukawa.hokkaido.jp", "muroran.hokkaido.jp", "naie.hokkaido.jp", "nakagawa.hokkaido.jp", "nakasatsunai.hokkaido.jp", "nakatombetsu.hokkaido.jp", "nanae.hokkaido.jp", "nanporo.hokkaido.jp", "nayoro.hokkaido.jp", "nemuro.hokkaido.jp", "niikappu.hokkaido.jp", "niki.hokkaido.jp", "nishiokoppe.hokkaido.jp", "noboribetsu.hokkaido.jp", "numata.hokkaido.jp", "obihiro.hokkaido.jp", "obira.hokkaido.jp", "oketo.hokkaido.jp", "okoppe.hokkaido.jp", "otaru.hokkaido.jp", "otobe.hokkaido.jp", "otofuke.hokkaido.jp", "otoineppu.hokkaido.jp", "oumu.hokkaido.jp", "ozora.hokkaido.jp", "pippu.hokkaido.jp", "rankoshi.hokkaido.jp", "rebun.hokkaido.jp", "rikubetsu.hokkaido.jp", "rishiri.hokkaido.jp", "rishirifuji.hokkaido.jp", "saroma.hokkaido.jp", "sarufutsu.hokkaido.jp", "shakotan.hokkaido.jp", "shari.hokkaido.jp", "shibecha.hokkaido.jp", "shibetsu.hokkaido.jp", "shikabe.hokkaido.jp", "shikaoi.hokkaido.jp", "shimamaki.hokkaido.jp", "shimizu.hokkaido.jp", "shimokawa.hokkaido.jp", "shinshinotsu.hokkaido.jp", "shintoku.hokkaido.jp", "shiranuka.hokkaido.jp", "shiraoi.hokkaido.jp", "shiriuchi.hokkaido.jp", "sobetsu.hokkaido.jp", "sunagawa.hokkaido.jp", "taiki.hokkaido.jp", "takasu.hokkaido.jp", "takikawa.hokkaido.jp", "takinoue.hokkaido.jp", "teshikaga.hokkaido.jp", "tobetsu.hokkaido.jp", "tohma.hokkaido.jp", "tomakomai.hokkaido.jp", "tomari.hokkaido.jp", "toya.hokkaido.jp", "toyako.hokkaido.jp", "toyotomi.hokkaido.jp", "toyoura.hokkaido.jp", "tsubetsu.hokkaido.jp", "tsukigata.hokkaido.jp", "urakawa.hokkaido.jp", "urausu.hokkaido.jp", "uryu.hokkaido.jp", "utashinai.hokkaido.jp", "wakkanai.hokkaido.jp", "wassamu.hokkaido.jp", "yakumo.hokkaido.jp", "yoichi.hokkaido.jp", "aioi.hyogo.jp", "akashi.hyogo.jp", "ako.hyogo.jp", "amagasaki.hyogo.jp", "aogaki.hyogo.jp", "asago.hyogo.jp", "ashiya.hyogo.jp", "awaji.hyogo.jp", "fukusaki.hyogo.jp", "goshiki.hyogo.jp", "harima.hyogo.jp", "himeji.hyogo.jp", "ichikawa.hyogo.jp", "inagawa.hyogo.jp", "itami.hyogo.jp", "kakogawa.hyogo.jp", "kamigori.hyogo.jp", "kamikawa.hyogo.jp", "kasai.hyogo.jp", "kasuga.hyogo.jp", "kawanishi.hyogo.jp", "miki.hyogo.jp", "minamiawaji.hyogo.jp", "nishinomiya.hyogo.jp", "nishiwaki.hyogo.jp", "ono.hyogo.jp", "sanda.hyogo.jp", "sannan.hyogo.jp", "sasayama.hyogo.jp", "sayo.hyogo.jp", "shingu.hyogo.jp", "shinonsen.hyogo.jp", "shiso.hyogo.jp", "sumoto.hyogo.jp", "taishi.hyogo.jp", "taka.hyogo.jp", "takarazuka.hyogo.jp", "takasago.hyogo.jp", "takino.hyogo.jp", "tamba.hyogo.jp", "tatsuno.hyogo.jp", "toyooka.hyogo.jp", "yabu.hyogo.jp", "yashiro.hyogo.jp", "yoka.hyogo.jp", "yokawa.hyogo.jp", "ami.ibaraki.jp", "asahi.ibaraki.jp", "bando.ibaraki.jp", "chikusei.ibaraki.jp", "daigo.ibaraki.jp", "fujishiro.ibaraki.jp", "hitachi.ibaraki.jp", "hitachinaka.ibaraki.jp", "hitachiomiya.ibaraki.jp", "hitachiota.ibaraki.jp", "ibaraki.ibaraki.jp", "ina.ibaraki.jp", "inashiki.ibaraki.jp", "itako.ibaraki.jp", "iwama.ibaraki.jp", "joso.ibaraki.jp", "kamisu.ibaraki.jp", "kasama.ibaraki.jp", "kashima.ibaraki.jp", "kasumigaura.ibaraki.jp", "koga.ibaraki.jp", "miho.ibaraki.jp", "mito.ibaraki.jp", "moriya.ibaraki.jp", "naka.ibaraki.jp", "namegata.ibaraki.jp", "oarai.ibaraki.jp", "ogawa.ibaraki.jp", "omitama.ibaraki.jp", "ryugasaki.ibaraki.jp", "sakai.ibaraki.jp", "sakuragawa.ibaraki.jp", "shimodate.ibaraki.jp", "shimotsuma.ibaraki.jp", "shirosato.ibaraki.jp", "sowa.ibaraki.jp", "suifu.ibaraki.jp", "takahagi.ibaraki.jp", "tamatsukuri.ibaraki.jp", "tokai.ibaraki.jp", "tomobe.ibaraki.jp", "tone.ibaraki.jp", "toride.ibaraki.jp", "tsuchiura.ibaraki.jp", "tsukuba.ibaraki.jp", "uchihara.ibaraki.jp", "ushiku.ibaraki.jp", "yachiyo.ibaraki.jp", "yamagata.ibaraki.jp", "yawara.ibaraki.jp", "yuki.ibaraki.jp", "anamizu.ishikawa.jp", "hakui.ishikawa.jp", "hakusan.ishikawa.jp", "kaga.ishikawa.jp", "kahoku.ishikawa.jp", "kanazawa.ishikawa.jp", "kawakita.ishikawa.jp", "komatsu.ishikawa.jp", "nakanoto.ishikawa.jp", "nanao.ishikawa.jp", "nomi.ishikawa.jp", "nonoichi.ishikawa.jp", "noto.ishikawa.jp", "shika.ishikawa.jp", "suzu.ishikawa.jp", "tsubata.ishikawa.jp", "tsurugi.ishikawa.jp", "uchinada.ishikawa.jp", "wajima.ishikawa.jp", "fudai.iwate.jp", "fujisawa.iwate.jp", "hanamaki.iwate.jp", "hiraizumi.iwate.jp", "hirono.iwate.jp", "ichinohe.iwate.jp", "ichinoseki.iwate.jp", "iwaizumi.iwate.jp", "iwate.iwate.jp", "joboji.iwate.jp", "kamaishi.iwate.jp", "kanegasaki.iwate.jp", "karumai.iwate.jp", "kawai.iwate.jp", "kitakami.iwate.jp", "kuji.iwate.jp", "kunohe.iwate.jp", "kuzumaki.iwate.jp", "miyako.iwate.jp", "mizusawa.iwate.jp", "morioka.iwate.jp", "ninohe.iwate.jp", "noda.iwate.jp", "ofunato.iwate.jp", "oshu.iwate.jp", "otsuchi.iwate.jp", "rikuzentakata.iwate.jp", "shiwa.iwate.jp", "shizukuishi.iwate.jp", "sumita.iwate.jp", "tanohata.iwate.jp", "tono.iwate.jp", "yahaba.iwate.jp", "yamada.iwate.jp", "ayagawa.kagawa.jp", "higashikagawa.kagawa.jp", "kanonji.kagawa.jp", "kotohira.kagawa.jp", "manno.kagawa.jp", "marugame.kagawa.jp", "mitoyo.kagawa.jp", "naoshima.kagawa.jp", "sanuki.kagawa.jp", "tadotsu.kagawa.jp", "takamatsu.kagawa.jp", "tonosho.kagawa.jp", "uchinomi.kagawa.jp", "utazu.kagawa.jp", "zentsuji.kagawa.jp", "akune.kagoshima.jp", "amami.kagoshima.jp", "hioki.kagoshima.jp", "isa.kagoshima.jp", "isen.kagoshima.jp", "izumi.kagoshima.jp", "kagoshima.kagoshima.jp", "kanoya.kagoshima.jp", "kawanabe.kagoshima.jp", "kinko.kagoshima.jp", "kouyama.kagoshima.jp", "makurazaki.kagoshima.jp", "matsumoto.kagoshima.jp", "minamitane.kagoshima.jp", "nakatane.kagoshima.jp", "nishinoomote.kagoshima.jp", "satsumasendai.kagoshima.jp", "soo.kagoshima.jp", "tarumizu.kagoshima.jp", "yusui.kagoshima.jp", "aikawa.kanagawa.jp", "atsugi.kanagawa.jp", "ayase.kanagawa.jp", "chigasaki.kanagawa.jp", "ebina.kanagawa.jp", "fujisawa.kanagawa.jp", "hadano.kanagawa.jp", "hakone.kanagawa.jp", "hiratsuka.kanagawa.jp", "isehara.kanagawa.jp", "kaisei.kanagawa.jp", "kamakura.kanagawa.jp", "kiyokawa.kanagawa.jp", "matsuda.kanagawa.jp", "minamiashigara.kanagawa.jp", "miura.kanagawa.jp", "nakai.kanagawa.jp", "ninomiya.kanagawa.jp", "odawara.kanagawa.jp", "oi.kanagawa.jp", "oiso.kanagawa.jp", "sagamihara.kanagawa.jp", "samukawa.kanagawa.jp", "tsukui.kanagawa.jp", "yamakita.kanagawa.jp", "yamato.kanagawa.jp", "yokosuka.kanagawa.jp", "yugawara.kanagawa.jp", "zama.kanagawa.jp", "zushi.kanagawa.jp", "aki.kochi.jp", "geisei.kochi.jp", "hidaka.kochi.jp", "higashitsuno.kochi.jp", "ino.kochi.jp", "kagami.kochi.jp", "kami.kochi.jp", "kitagawa.kochi.jp", "kochi.kochi.jp", "mihara.kochi.jp", "motoyama.kochi.jp", "muroto.kochi.jp", "nahari.kochi.jp", "nakamura.kochi.jp", "nankoku.kochi.jp", "nishitosa.kochi.jp", "niyodogawa.kochi.jp", "ochi.kochi.jp", "okawa.kochi.jp", "otoyo.kochi.jp", "otsuki.kochi.jp", "sakawa.kochi.jp", "sukumo.kochi.jp", "susaki.kochi.jp", "tosa.kochi.jp", "tosashimizu.kochi.jp", "toyo.kochi.jp", "tsuno.kochi.jp", "umaji.kochi.jp", "yasuda.kochi.jp", "yusuhara.kochi.jp", "amakusa.kumamoto.jp", "arao.kumamoto.jp", "aso.kumamoto.jp", "choyo.kumamoto.jp", "gyokuto.kumamoto.jp", "kamiamakusa.kumamoto.jp", "kikuchi.kumamoto.jp", "kumamoto.kumamoto.jp", "mashiki.kumamoto.jp", "mifune.kumamoto.jp", "minamata.kumamoto.jp", "minamioguni.kumamoto.jp", "nagasu.kumamoto.jp", "nishihara.kumamoto.jp", "oguni.kumamoto.jp", "ozu.kumamoto.jp", "sumoto.kumamoto.jp", "takamori.kumamoto.jp", "uki.kumamoto.jp", "uto.kumamoto.jp", "yamaga.kumamoto.jp", "yamato.kumamoto.jp", "yatsushiro.kumamoto.jp", "ayabe.kyoto.jp", "fukuchiyama.kyoto.jp", "higashiyama.kyoto.jp", "ide.kyoto.jp", "ine.kyoto.jp", "joyo.kyoto.jp", "kameoka.kyoto.jp", "kamo.kyoto.jp", "kita.kyoto.jp", "kizu.kyoto.jp", "kumiyama.kyoto.jp", "kyotamba.kyoto.jp", "kyotanabe.kyoto.jp", "kyotango.kyoto.jp", "maizuru.kyoto.jp", "minami.kyoto.jp", "minamiyamashiro.kyoto.jp", "miyazu.kyoto.jp", "muko.kyoto.jp", "nagaokakyo.kyoto.jp", "nakagyo.kyoto.jp", "nantan.kyoto.jp", "oyamazaki.kyoto.jp", "sakyo.kyoto.jp", "seika.kyoto.jp", "tanabe.kyoto.jp", "uji.kyoto.jp", "ujitawara.kyoto.jp", "wazuka.kyoto.jp", "yamashina.kyoto.jp", "yawata.kyoto.jp", "asahi.mie.jp", "inabe.mie.jp", "ise.mie.jp", "kameyama.mie.jp", "kawagoe.mie.jp", "kiho.mie.jp", "kisosaki.mie.jp", "kiwa.mie.jp", "komono.mie.jp", "kumano.mie.jp", "kuwana.mie.jp", "matsusaka.mie.jp", "meiwa.mie.jp", "mihama.mie.jp", "minamiise.mie.jp", "misugi.mie.jp", "miyama.mie.jp", "nabari.mie.jp", "shima.mie.jp", "suzuka.mie.jp", "tado.mie.jp", "taiki.mie.jp", "taki.mie.jp", "tamaki.mie.jp", "toba.mie.jp", "tsu.mie.jp", "udono.mie.jp", "ureshino.mie.jp", "watarai.mie.jp", "yokkaichi.mie.jp", "furukawa.miyagi.jp", "higashimatsushima.miyagi.jp", "ishinomaki.miyagi.jp", "iwanuma.miyagi.jp", "kakuda.miyagi.jp", "kami.miyagi.jp", "kawasaki.miyagi.jp", "marumori.miyagi.jp", "matsushima.miyagi.jp", "minamisanriku.miyagi.jp", "misato.miyagi.jp", "murata.miyagi.jp", "natori.miyagi.jp", "ogawara.miyagi.jp", "ohira.miyagi.jp", "onagawa.miyagi.jp", "osaki.miyagi.jp", "rifu.miyagi.jp", "semine.miyagi.jp", "shibata.miyagi.jp", "shichikashuku.miyagi.jp", "shikama.miyagi.jp", "shiogama.miyagi.jp", "shiroishi.miyagi.jp", "tagajo.miyagi.jp", "taiwa.miyagi.jp", "tome.miyagi.jp", "tomiya.miyagi.jp", "wakuya.miyagi.jp", "watari.miyagi.jp", "yamamoto.miyagi.jp", "zao.miyagi.jp", "aya.miyazaki.jp", "ebino.miyazaki.jp", "gokase.miyazaki.jp", "hyuga.miyazaki.jp", "kadogawa.miyazaki.jp", "kawaminami.miyazaki.jp", "kijo.miyazaki.jp", "kitagawa.miyazaki.jp", "kitakata.miyazaki.jp", "kitaura.miyazaki.jp", "kobayashi.miyazaki.jp", "kunitomi.miyazaki.jp", "kushima.miyazaki.jp", "mimata.miyazaki.jp", "miyakonojo.miyazaki.jp", "miyazaki.miyazaki.jp", "morotsuka.miyazaki.jp", "nichinan.miyazaki.jp", "nishimera.miyazaki.jp", "nobeoka.miyazaki.jp", "saito.miyazaki.jp", "shiiba.miyazaki.jp", "shintomi.miyazaki.jp", "takaharu.miyazaki.jp", "takanabe.miyazaki.jp", "takazaki.miyazaki.jp", "tsuno.miyazaki.jp", "achi.nagano.jp", "agematsu.nagano.jp", "anan.nagano.jp", "aoki.nagano.jp", "asahi.nagano.jp", "azumino.nagano.jp", "chikuhoku.nagano.jp", "chikuma.nagano.jp", "chino.nagano.jp", "fujimi.nagano.jp", "hakuba.nagano.jp", "hara.nagano.jp", "hiraya.nagano.jp", "iida.nagano.jp", "iijima.nagano.jp", "iiyama.nagano.jp", "iizuna.nagano.jp", "ikeda.nagano.jp", "ikusaka.nagano.jp", "ina.nagano.jp", "karuizawa.nagano.jp", "kawakami.nagano.jp", "kiso.nagano.jp", "kisofukushima.nagano.jp", "kitaaiki.nagano.jp", "komagane.nagano.jp", "komoro.nagano.jp", "matsukawa.nagano.jp", "matsumoto.nagano.jp", "miasa.nagano.jp", "minamiaiki.nagano.jp", "minamimaki.nagano.jp", "minamiminowa.nagano.jp", "minowa.nagano.jp", "miyada.nagano.jp", "miyota.nagano.jp", "mochizuki.nagano.jp", "nagano.nagano.jp", "nagawa.nagano.jp", "nagiso.nagano.jp", "nakagawa.nagano.jp", "nakano.nagano.jp", "nozawaonsen.nagano.jp", "obuse.nagano.jp", "ogawa.nagano.jp", "okaya.nagano.jp", "omachi.nagano.jp", "omi.nagano.jp", "ookuwa.nagano.jp", "ooshika.nagano.jp", "otaki.nagano.jp", "otari.nagano.jp", "sakae.nagano.jp", "sakaki.nagano.jp", "saku.nagano.jp", "sakuho.nagano.jp", "shimosuwa.nagano.jp", "shinanomachi.nagano.jp", "shiojiri.nagano.jp", "suwa.nagano.jp", "suzaka.nagano.jp", "takagi.nagano.jp", "takamori.nagano.jp", "takayama.nagano.jp", "tateshina.nagano.jp", "tatsuno.nagano.jp", "togakushi.nagano.jp", "togura.nagano.jp", "tomi.nagano.jp", "ueda.nagano.jp", "wada.nagano.jp", "yamagata.nagano.jp", "yamanouchi.nagano.jp", "yasaka.nagano.jp", "yasuoka.nagano.jp", "chijiwa.nagasaki.jp", "futsu.nagasaki.jp", "goto.nagasaki.jp", "hasami.nagasaki.jp", "hirado.nagasaki.jp", "iki.nagasaki.jp", "isahaya.nagasaki.jp", "kawatana.nagasaki.jp", "kuchinotsu.nagasaki.jp", "matsuura.nagasaki.jp", "nagasaki.nagasaki.jp", "obama.nagasaki.jp", "omura.nagasaki.jp", "oseto.nagasaki.jp", "saikai.nagasaki.jp", "sasebo.nagasaki.jp", "seihi.nagasaki.jp", "shimabara.nagasaki.jp", "shinkamigoto.nagasaki.jp", "togitsu.nagasaki.jp", "tsushima.nagasaki.jp", "unzen.nagasaki.jp", "ando.nara.jp", "gose.nara.jp", "heguri.nara.jp", "higashiyoshino.nara.jp", "ikaruga.nara.jp", "ikoma.nara.jp", "kamikitayama.nara.jp", "kanmaki.nara.jp", "kashiba.nara.jp", "kashihara.nara.jp", "katsuragi.nara.jp", "kawai.nara.jp", "kawakami.nara.jp", "kawanishi.nara.jp", "koryo.nara.jp", "kurotaki.nara.jp", "mitsue.nara.jp", "miyake.nara.jp", "nara.nara.jp", "nosegawa.nara.jp", "oji.nara.jp", "ouda.nara.jp", "oyodo.nara.jp", "sakurai.nara.jp", "sango.nara.jp", "shimoichi.nara.jp", "shimokitayama.nara.jp", "shinjo.nara.jp", "soni.nara.jp", "takatori.nara.jp", "tawaramoto.nara.jp", "tenkawa.nara.jp", "tenri.nara.jp", "uda.nara.jp", "yamatokoriyama.nara.jp", "yamatotakada.nara.jp", "yamazoe.nara.jp", "yoshino.nara.jp", "aga.niigata.jp", "agano.niigata.jp", "gosen.niigata.jp", "itoigawa.niigata.jp", "izumozaki.niigata.jp", "joetsu.niigata.jp", "kamo.niigata.jp", "kariwa.niigata.jp", "kashiwazaki.niigata.jp", "minamiuonuma.niigata.jp", "mitsuke.niigata.jp", "muika.niigata.jp", "murakami.niigata.jp", "myoko.niigata.jp", "nagaoka.niigata.jp", "niigata.niigata.jp", "ojiya.niigata.jp", "omi.niigata.jp", "sado.niigata.jp", "sanjo.niigata.jp", "seiro.niigata.jp", "seirou.niigata.jp", "sekikawa.niigata.jp", "shibata.niigata.jp", "tagami.niigata.jp", "tainai.niigata.jp", "tochio.niigata.jp", "tokamachi.niigata.jp", "tsubame.niigata.jp", "tsunan.niigata.jp", "uonuma.niigata.jp", "yahiko.niigata.jp", "yoita.niigata.jp", "yuzawa.niigata.jp", "beppu.oita.jp", "bungoono.oita.jp", "bungotakada.oita.jp", "hasama.oita.jp", "hiji.oita.jp", "himeshima.oita.jp", "hita.oita.jp", "kamitsue.oita.jp", "kokonoe.oita.jp", "kuju.oita.jp", "kunisaki.oita.jp", "kusu.oita.jp", "oita.oita.jp", "saiki.oita.jp", "taketa.oita.jp", "tsukumi.oita.jp", "usa.oita.jp", "usuki.oita.jp", "yufu.oita.jp", "akaiwa.okayama.jp", "asakuchi.okayama.jp", "bizen.okayama.jp", "hayashima.okayama.jp", "ibara.okayama.jp", "kagamino.okayama.jp", "kasaoka.okayama.jp", "kibichuo.okayama.jp", "kumenan.okayama.jp", "kurashiki.okayama.jp", "maniwa.okayama.jp", "misaki.okayama.jp", "nagi.okayama.jp", "niimi.okayama.jp", "nishiawakura.okayama.jp", "okayama.okayama.jp", "satosho.okayama.jp", "setouchi.okayama.jp", "shinjo.okayama.jp", "shoo.okayama.jp", "soja.okayama.jp", "takahashi.okayama.jp", "tamano.okayama.jp", "tsuyama.okayama.jp", "wake.okayama.jp", "yakage.okayama.jp", "aguni.okinawa.jp", "ginowan.okinawa.jp", "ginoza.okinawa.jp", "gushikami.okinawa.jp", "haebaru.okinawa.jp", "higashi.okinawa.jp", "hirara.okinawa.jp", "iheya.okinawa.jp", "ishigaki.okinawa.jp", "ishikawa.okinawa.jp", "itoman.okinawa.jp", "izena.okinawa.jp", "kadena.okinawa.jp", "kin.okinawa.jp", "kitadaito.okinawa.jp", "kitanakagusuku.okinawa.jp", "kumejima.okinawa.jp", "kunigami.okinawa.jp", "minamidaito.okinawa.jp", "motobu.okinawa.jp", "nago.okinawa.jp", "naha.okinawa.jp", "nakagusuku.okinawa.jp", "nakijin.okinawa.jp", "nanjo.okinawa.jp", "nishihara.okinawa.jp", "ogimi.okinawa.jp", "okinawa.okinawa.jp", "onna.okinawa.jp", "shimoji.okinawa.jp", "taketomi.okinawa.jp", "tarama.okinawa.jp", "tokashiki.okinawa.jp", "tomigusuku.okinawa.jp", "tonaki.okinawa.jp", "urasoe.okinawa.jp", "uruma.okinawa.jp", "yaese.okinawa.jp", "yomitan.okinawa.jp", "yonabaru.okinawa.jp", "yonaguni.okinawa.jp", "zamami.okinawa.jp", "abeno.osaka.jp", "chihayaakasaka.osaka.jp", "chuo.osaka.jp", "daito.osaka.jp", "fujiidera.osaka.jp", "habikino.osaka.jp", "hannan.osaka.jp", "higashiosaka.osaka.jp", "higashisumiyoshi.osaka.jp", "higashiyodogawa.osaka.jp", "hirakata.osaka.jp", "ibaraki.osaka.jp", "ikeda.osaka.jp", "izumi.osaka.jp", "izumiotsu.osaka.jp", "izumisano.osaka.jp", "kadoma.osaka.jp", "kaizuka.osaka.jp", "kanan.osaka.jp", "kashiwara.osaka.jp", "katano.osaka.jp", "kawachinagano.osaka.jp", "kishiwada.osaka.jp", "kita.osaka.jp", "kumatori.osaka.jp", "matsubara.osaka.jp", "minato.osaka.jp", "minoh.osaka.jp", "misaki.osaka.jp", "moriguchi.osaka.jp", "neyagawa.osaka.jp", "nishi.osaka.jp", "nose.osaka.jp", "osakasayama.osaka.jp", "sakai.osaka.jp", "sayama.osaka.jp", "sennan.osaka.jp", "settsu.osaka.jp", "shijonawate.osaka.jp", "shimamoto.osaka.jp", "suita.osaka.jp", "tadaoka.osaka.jp", "taishi.osaka.jp", "tajiri.osaka.jp", "takaishi.osaka.jp", "takatsuki.osaka.jp", "tondabayashi.osaka.jp", "toyonaka.osaka.jp", "toyono.osaka.jp", "yao.osaka.jp", "ariake.saga.jp", "arita.saga.jp", "fukudomi.saga.jp", "genkai.saga.jp", "hamatama.saga.jp", "hizen.saga.jp", "imari.saga.jp", "kamimine.saga.jp", "kanzaki.saga.jp", "karatsu.saga.jp", "kashima.saga.jp", "kitagata.saga.jp", "kitahata.saga.jp", "kiyama.saga.jp", "kouhoku.saga.jp", "kyuragi.saga.jp", "nishiarita.saga.jp", "ogi.saga.jp", "omachi.saga.jp", "ouchi.saga.jp", "saga.saga.jp", "shiroishi.saga.jp", "taku.saga.jp", "tara.saga.jp", "tosu.saga.jp", "yoshinogari.saga.jp", "arakawa.saitama.jp", "asaka.saitama.jp", "chichibu.saitama.jp", "fujimi.saitama.jp", "fujimino.saitama.jp", "fukaya.saitama.jp", "hanno.saitama.jp", "hanyu.saitama.jp", "hasuda.saitama.jp", "hatogaya.saitama.jp", "hatoyama.saitama.jp", "hidaka.saitama.jp", "higashichichibu.saitama.jp", "higashimatsuyama.saitama.jp", "honjo.saitama.jp", "ina.saitama.jp", "iruma.saitama.jp", "iwatsuki.saitama.jp", "kamiizumi.saitama.jp", "kamikawa.saitama.jp", "kamisato.saitama.jp", "kasukabe.saitama.jp", "kawagoe.saitama.jp", "kawaguchi.saitama.jp", "kawajima.saitama.jp", "kazo.saitama.jp", "kitamoto.saitama.jp", "koshigaya.saitama.jp", "kounosu.saitama.jp", "kuki.saitama.jp", "kumagaya.saitama.jp", "matsubushi.saitama.jp", "minano.saitama.jp", "misato.saitama.jp", "miyashiro.saitama.jp", "miyoshi.saitama.jp", "moroyama.saitama.jp", "nagatoro.saitama.jp", "namegawa.saitama.jp", "niiza.saitama.jp", "ogano.saitama.jp", "ogawa.saitama.jp", "ogose.saitama.jp", "okegawa.saitama.jp", "omiya.saitama.jp", "otaki.saitama.jp", "ranzan.saitama.jp", "ryokami.saitama.jp", "saitama.saitama.jp", "sakado.saitama.jp", "satte.saitama.jp", "sayama.saitama.jp", "shiki.saitama.jp", "shiraoka.saitama.jp", "soka.saitama.jp", "sugito.saitama.jp", "toda.saitama.jp", "tokigawa.saitama.jp", "tokorozawa.saitama.jp", "tsurugashima.saitama.jp", "urawa.saitama.jp", "warabi.saitama.jp", "yashio.saitama.jp", "yokoze.saitama.jp", "yono.saitama.jp", "yorii.saitama.jp", "yoshida.saitama.jp", "yoshikawa.saitama.jp", "yoshimi.saitama.jp", "aisho.shiga.jp", "gamo.shiga.jp", "higashiomi.shiga.jp", "hikone.shiga.jp", "koka.shiga.jp", "konan.shiga.jp", "kosei.shiga.jp", "koto.shiga.jp", "kusatsu.shiga.jp", "maibara.shiga.jp", "moriyama.shiga.jp", "nagahama.shiga.jp", "nishiazai.shiga.jp", "notogawa.shiga.jp", "omihachiman.shiga.jp", "otsu.shiga.jp", "ritto.shiga.jp", "ryuoh.shiga.jp", "takashima.shiga.jp", "takatsuki.shiga.jp", "torahime.shiga.jp", "toyosato.shiga.jp", "yasu.shiga.jp", "akagi.shimane.jp", "ama.shimane.jp", "gotsu.shimane.jp", "hamada.shimane.jp", "higashiizumo.shimane.jp", "hikawa.shimane.jp", "hikimi.shimane.jp", "izumo.shimane.jp", "kakinoki.shimane.jp", "masuda.shimane.jp", "matsue.shimane.jp", "misato.shimane.jp", "nishinoshima.shimane.jp", "ohda.shimane.jp", "okinoshima.shimane.jp", "okuizumo.shimane.jp", "shimane.shimane.jp", "tamayu.shimane.jp", "tsuwano.shimane.jp", "unnan.shimane.jp", "yakumo.shimane.jp", "yasugi.shimane.jp", "yatsuka.shimane.jp", "arai.shizuoka.jp", "atami.shizuoka.jp", "fuji.shizuoka.jp", "fujieda.shizuoka.jp", "fujikawa.shizuoka.jp", "fujinomiya.shizuoka.jp", "fukuroi.shizuoka.jp", "gotemba.shizuoka.jp", "haibara.shizuoka.jp", "hamamatsu.shizuoka.jp", "higashiizu.shizuoka.jp", "ito.shizuoka.jp", "iwata.shizuoka.jp", "izu.shizuoka.jp", "izunokuni.shizuoka.jp", "kakegawa.shizuoka.jp", "kannami.shizuoka.jp", "kawanehon.shizuoka.jp", "kawazu.shizuoka.jp", "kikugawa.shizuoka.jp", "kosai.shizuoka.jp", "makinohara.shizuoka.jp", "matsuzaki.shizuoka.jp", "minamiizu.shizuoka.jp", "mishima.shizuoka.jp", "morimachi.shizuoka.jp", "nishiizu.shizuoka.jp", "numazu.shizuoka.jp", "omaezaki.shizuoka.jp", "shimada.shizuoka.jp", "shimizu.shizuoka.jp", "shimoda.shizuoka.jp", "shizuoka.shizuoka.jp", "susono.shizuoka.jp", "yaizu.shizuoka.jp", "yoshida.shizuoka.jp", "ashikaga.tochigi.jp", "bato.tochigi.jp", "haga.tochigi.jp", "ichikai.tochigi.jp", "iwafune.tochigi.jp", "kaminokawa.tochigi.jp", "kanuma.tochigi.jp", "karasuyama.tochigi.jp", "kuroiso.tochigi.jp", "mashiko.tochigi.jp", "mibu.tochigi.jp", "moka.tochigi.jp", "motegi.tochigi.jp", "nasu.tochigi.jp", "nasushiobara.tochigi.jp", "nikko.tochigi.jp", "nishikata.tochigi.jp", "nogi.tochigi.jp", "ohira.tochigi.jp", "ohtawara.tochigi.jp", "oyama.tochigi.jp", "sakura.tochigi.jp", "sano.tochigi.jp", "shimotsuke.tochigi.jp", "shioya.tochigi.jp", "takanezawa.tochigi.jp", "tochigi.tochigi.jp", "tsuga.tochigi.jp", "ujiie.tochigi.jp", "utsunomiya.tochigi.jp", "yaita.tochigi.jp", "aizumi.tokushima.jp", "anan.tokushima.jp", "ichiba.tokushima.jp", "itano.tokushima.jp", "kainan.tokushima.jp", "komatsushima.tokushima.jp", "matsushige.tokushima.jp", "mima.tokushima.jp", "minami.tokushima.jp", "miyoshi.tokushima.jp", "mugi.tokushima.jp", "nakagawa.tokushima.jp", "naruto.tokushima.jp", "sanagochi.tokushima.jp", "shishikui.tokushima.jp", "tokushima.tokushima.jp", "wajiki.tokushima.jp", "adachi.tokyo.jp", "akiruno.tokyo.jp", "akishima.tokyo.jp", "aogashima.tokyo.jp", "arakawa.tokyo.jp", "bunkyo.tokyo.jp", "chiyoda.tokyo.jp", "chofu.tokyo.jp", "chuo.tokyo.jp", "edogawa.tokyo.jp", "fuchu.tokyo.jp", "fussa.tokyo.jp", "hachijo.tokyo.jp", "hachioji.tokyo.jp", "hamura.tokyo.jp", "higashikurume.tokyo.jp", "higashimurayama.tokyo.jp", "higashiyamato.tokyo.jp", "hino.tokyo.jp", "hinode.tokyo.jp", "hinohara.tokyo.jp", "inagi.tokyo.jp", "itabashi.tokyo.jp", "katsushika.tokyo.jp", "kita.tokyo.jp", "kiyose.tokyo.jp", "kodaira.tokyo.jp", "koganei.tokyo.jp", "kokubunji.tokyo.jp", "komae.tokyo.jp", "koto.tokyo.jp", "kouzushima.tokyo.jp", "kunitachi.tokyo.jp", "machida.tokyo.jp", "meguro.tokyo.jp", "minato.tokyo.jp", "mitaka.tokyo.jp", "mizuho.tokyo.jp", "musashimurayama.tokyo.jp", "musashino.tokyo.jp", "nakano.tokyo.jp", "nerima.tokyo.jp", "ogasawara.tokyo.jp", "okutama.tokyo.jp", "ome.tokyo.jp", "oshima.tokyo.jp", "ota.tokyo.jp", "setagaya.tokyo.jp", "shibuya.tokyo.jp", "shinagawa.tokyo.jp", "shinjuku.tokyo.jp", "suginami.tokyo.jp", "sumida.tokyo.jp", "tachikawa.tokyo.jp", "taito.tokyo.jp", "tama.tokyo.jp", "toshima.tokyo.jp", "chizu.tottori.jp", "hino.tottori.jp", "kawahara.tottori.jp", "koge.tottori.jp", "kotoura.tottori.jp", "misasa.tottori.jp", "nanbu.tottori.jp", "nichinan.tottori.jp", "sakaiminato.tottori.jp", "tottori.tottori.jp", "wakasa.tottori.jp", "yazu.tottori.jp", "yonago.tottori.jp", "asahi.toyama.jp", "fuchu.toyama.jp", "fukumitsu.toyama.jp", "funahashi.toyama.jp", "himi.toyama.jp", "imizu.toyama.jp", "inami.toyama.jp", "johana.toyama.jp", "kamiichi.toyama.jp", "kurobe.toyama.jp", "nakaniikawa.toyama.jp", "namerikawa.toyama.jp", "nanto.toyama.jp", "nyuzen.toyama.jp", "oyabe.toyama.jp", "taira.toyama.jp", "takaoka.toyama.jp", "tateyama.toyama.jp", "toga.toyama.jp", "tonami.toyama.jp", "toyama.toyama.jp", "unazuki.toyama.jp", "uozu.toyama.jp", "yamada.toyama.jp", "arida.wakayama.jp", "aridagawa.wakayama.jp", "gobo.wakayama.jp", "hashimoto.wakayama.jp", "hidaka.wakayama.jp", "hirogawa.wakayama.jp", "inami.wakayama.jp", "iwade.wakayama.jp", "kainan.wakayama.jp", "kamitonda.wakayama.jp", "katsuragi.wakayama.jp", "kimino.wakayama.jp", "kinokawa.wakayama.jp", "kitayama.wakayama.jp", "koya.wakayama.jp", "koza.wakayama.jp", "kozagawa.wakayama.jp", "kudoyama.wakayama.jp", "kushimoto.wakayama.jp", "mihama.wakayama.jp", "misato.wakayama.jp", "nachikatsuura.wakayama.jp", "shingu.wakayama.jp", "shirahama.wakayama.jp", "taiji.wakayama.jp", "tanabe.wakayama.jp", "wakayama.wakayama.jp", "yuasa.wakayama.jp", "yura.wakayama.jp", "asahi.yamagata.jp", "funagata.yamagata.jp", "higashine.yamagata.jp", "iide.yamagata.jp", "kahoku.yamagata.jp", "kaminoyama.yamagata.jp", "kaneyama.yamagata.jp", "kawanishi.yamagata.jp", "mamurogawa.yamagata.jp", "mikawa.yamagata.jp", "murayama.yamagata.jp", "nagai.yamagata.jp", "nakayama.yamagata.jp", "nanyo.yamagata.jp", "nishikawa.yamagata.jp", "obanazawa.yamagata.jp", "oe.yamagata.jp", "oguni.yamagata.jp", "ohkura.yamagata.jp", "oishida.yamagata.jp", "sagae.yamagata.jp", "sakata.yamagata.jp", "sakegawa.yamagata.jp", "shinjo.yamagata.jp", "shirataka.yamagata.jp", "shonai.yamagata.jp", "takahata.yamagata.jp", "tendo.yamagata.jp", "tozawa.yamagata.jp", "tsuruoka.yamagata.jp", "yamagata.yamagata.jp", "yamanobe.yamagata.jp", "yonezawa.yamagata.jp", "yuza.yamagata.jp", "abu.yamaguchi.jp", "hagi.yamaguchi.jp", "hikari.yamaguchi.jp", "hofu.yamaguchi.jp", "iwakuni.yamaguchi.jp", "kudamatsu.yamaguchi.jp", "mitou.yamaguchi.jp", "nagato.yamaguchi.jp", "oshima.yamaguchi.jp", "shimonoseki.yamaguchi.jp", "shunan.yamaguchi.jp", "tabuse.yamaguchi.jp", "tokuyama.yamaguchi.jp", "toyota.yamaguchi.jp", "ube.yamaguchi.jp", "yuu.yamaguchi.jp", "chuo.yamanashi.jp", "doshi.yamanashi.jp", "fuefuki.yamanashi.jp", "fujikawa.yamanashi.jp", "fujikawaguchiko.yamanashi.jp", "fujiyoshida.yamanashi.jp", "hayakawa.yamanashi.jp", "hokuto.yamanashi.jp", "ichikawamisato.yamanashi.jp", "kai.yamanashi.jp", "kofu.yamanashi.jp", "koshu.yamanashi.jp", "kosuge.yamanashi.jp", "minami-alps.yamanashi.jp", "minobu.yamanashi.jp", "nakamichi.yamanashi.jp", "nanbu.yamanashi.jp", "narusawa.yamanashi.jp", "nirasaki.yamanashi.jp", "nishikatsura.yamanashi.jp", "oshino.yamanashi.jp", "otsuki.yamanashi.jp", "showa.yamanashi.jp", "tabayama.yamanashi.jp", "tsuru.yamanashi.jp", "uenohara.yamanashi.jp", "yamanakako.yamanashi.jp", "yamanashi.yamanashi.jp", "ke", "ac.ke", "co.ke", "go.ke", "info.ke", "me.ke", "mobi.ke", "ne.ke", "or.ke", "sc.ke", "kg", "com.kg", "edu.kg", "gov.kg", "mil.kg", "net.kg", "org.kg", "*.kh", "ki", "biz.ki", "com.ki", "edu.ki", "gov.ki", "info.ki", "net.ki", "org.ki", "km", "ass.km", "com.km", "edu.km", "gov.km", "mil.km", "nom.km", "org.km", "prd.km", "tm.km", "asso.km", "coop.km", "gouv.km", "medecin.km", "notaires.km", "pharmaciens.km", "presse.km", "veterinaire.km", "kn", "edu.kn", "gov.kn", "net.kn", "org.kn", "kp", "com.kp", "edu.kp", "gov.kp", "org.kp", "rep.kp", "tra.kp", "kr", "ac.kr", "co.kr", "es.kr", "go.kr", "hs.kr", "kg.kr", "mil.kr", "ms.kr", "ne.kr", "or.kr", "pe.kr", "re.kr", "sc.kr", "busan.kr", "chungbuk.kr", "chungnam.kr", "daegu.kr", "daejeon.kr", "gangwon.kr", "gwangju.kr", "gyeongbuk.kr", "gyeonggi.kr", "gyeongnam.kr", "incheon.kr", "jeju.kr", "jeonbuk.kr", "jeonnam.kr", "seoul.kr", "ulsan.kr", "kw", "com.kw", "edu.kw", "emb.kw", "gov.kw", "ind.kw", "net.kw", "org.kw", "ky", "com.ky", "edu.ky", "net.ky", "org.ky", "kz", "com.kz", "edu.kz", "gov.kz", "mil.kz", "net.kz", "org.kz", "la", "com.la", "edu.la", "gov.la", "info.la", "int.la", "net.la", "org.la", "per.la", "lb", "com.lb", "edu.lb", "gov.lb", "net.lb", "org.lb", "lc", "co.lc", "com.lc", "edu.lc", "gov.lc", "net.lc", "org.lc", "li", "lk", "ac.lk", "assn.lk", "com.lk", "edu.lk", "gov.lk", "grp.lk", "hotel.lk", "int.lk", "ltd.lk", "net.lk", "ngo.lk", "org.lk", "sch.lk", "soc.lk", "web.lk", "lr", "com.lr", "edu.lr", "gov.lr", "net.lr", "org.lr", "ls", "ac.ls", "biz.ls", "co.ls", "edu.ls", "gov.ls", "info.ls", "net.ls", "org.ls", "sc.ls", "lt", "gov.lt", "lu", "lv", "asn.lv", "com.lv", "conf.lv", "edu.lv", "gov.lv", "id.lv", "mil.lv", "net.lv", "org.lv", "ly", "com.ly", "edu.ly", "gov.ly", "id.ly", "med.ly", "net.ly", "org.ly", "plc.ly", "sch.ly", "ma", "ac.ma", "co.ma", "gov.ma", "net.ma", "org.ma", "press.ma", "mc", "asso.mc", "tm.mc", "md", "me", "ac.me", "co.me", "edu.me", "gov.me", "its.me", "net.me", "org.me", "priv.me", "mg", "co.mg", "com.mg", "edu.mg", "gov.mg", "mil.mg", "nom.mg", "org.mg", "prd.mg", "mh", "mil", "mk", "com.mk", "edu.mk", "gov.mk", "inf.mk", "name.mk", "net.mk", "org.mk", "ml", "com.ml", "edu.ml", "gouv.ml", "gov.ml", "net.ml", "org.ml", "presse.ml", "*.mm", "mn", "edu.mn", "gov.mn", "org.mn", "mo", "com.mo", "edu.mo", "gov.mo", "net.mo", "org.mo", "mobi", "mp", "mq", "mr", "gov.mr", "ms", "com.ms", "edu.ms", "gov.ms", "net.ms", "org.ms", "mt", "com.mt", "edu.mt", "net.mt", "org.mt", "mu", "ac.mu", "co.mu", "com.mu", "gov.mu", "net.mu", "or.mu", "org.mu", "museum", "mv", "aero.mv", "biz.mv", "com.mv", "coop.mv", "edu.mv", "gov.mv", "info.mv", "int.mv", "mil.mv", "museum.mv", "name.mv", "net.mv", "org.mv", "pro.mv", "mw", "ac.mw", "biz.mw", "co.mw", "com.mw", "coop.mw", "edu.mw", "gov.mw", "int.mw", "net.mw", "org.mw", "mx", "com.mx", "edu.mx", "gob.mx", "net.mx", "org.mx", "my", "biz.my", "com.my", "edu.my", "gov.my", "mil.my", "name.my", "net.my", "org.my", "mz", "ac.mz", "adv.mz", "co.mz", "edu.mz", "gov.mz", "mil.mz", "net.mz", "org.mz", "na", "alt.na", "co.na", "com.na", "gov.na", "net.na", "org.na", "name", "nc", "asso.nc", "nom.nc", "ne", "net", "nf", "arts.nf", "com.nf", "firm.nf", "info.nf", "net.nf", "other.nf", "per.nf", "rec.nf", "store.nf", "web.nf", "ng", "com.ng", "edu.ng", "gov.ng", "i.ng", "mil.ng", "mobi.ng", "name.ng", "net.ng", "org.ng", "sch.ng", "ni", "ac.ni", "biz.ni", "co.ni", "com.ni", "edu.ni", "gob.ni", "in.ni", "info.ni", "int.ni", "mil.ni", "net.ni", "nom.ni", "org.ni", "web.ni", "nl", "no", "fhs.no", "folkebibl.no", "fylkesbibl.no", "idrett.no", "museum.no", "priv.no", "vgs.no", "dep.no", "herad.no", "kommune.no", "mil.no", "stat.no", "aa.no", "ah.no", "bu.no", "fm.no", "hl.no", "hm.no", "jan-mayen.no", "mr.no", "nl.no", "nt.no", "of.no", "ol.no", "oslo.no", "rl.no", "sf.no", "st.no", "svalbard.no", "tm.no", "tr.no", "va.no", "vf.no", "gs.aa.no", "gs.ah.no", "gs.bu.no", "gs.fm.no", "gs.hl.no", "gs.hm.no", "gs.jan-mayen.no", "gs.mr.no", "gs.nl.no", "gs.nt.no", "gs.of.no", "gs.ol.no", "gs.oslo.no", "gs.rl.no", "gs.sf.no", "gs.st.no", "gs.svalbard.no", "gs.tm.no", "gs.tr.no", "gs.va.no", "gs.vf.no", "akrehamn.no", "åkrehamn.no", "algard.no", "ålgård.no", "arna.no", "bronnoysund.no", "brønnøysund.no", "brumunddal.no", "bryne.no", "drobak.no", "drøbak.no", "egersund.no", "fetsund.no", "floro.no", "florø.no", "fredrikstad.no", "hokksund.no", "honefoss.no", "hønefoss.no", "jessheim.no", "jorpeland.no", "jørpeland.no", "kirkenes.no", "kopervik.no", "krokstadelva.no", "langevag.no", "langevåg.no", "leirvik.no", "mjondalen.no", "mjøndalen.no", "mo-i-rana.no", "mosjoen.no", "mosjøen.no", "nesoddtangen.no", "orkanger.no", "osoyro.no", "osøyro.no", "raholt.no", "råholt.no", "sandnessjoen.no", "sandnessjøen.no", "skedsmokorset.no", "slattum.no", "spjelkavik.no", "stathelle.no", "stavern.no", "stjordalshalsen.no", "stjørdalshalsen.no", "tananger.no", "tranby.no", "vossevangen.no", "aarborte.no", "aejrie.no", "afjord.no", "åfjord.no", "agdenes.no", "nes.akershus.no", "aknoluokta.no", "ákŋoluokta.no", "al.no", "ål.no", "alaheadju.no", "álaheadju.no", "alesund.no", "ålesund.no", "alstahaug.no", "alta.no", "áltá.no", "alvdal.no", "amli.no", "åmli.no", "amot.no", "åmot.no", "andasuolo.no", "andebu.no", "andoy.no", "andøy.no", "ardal.no", "årdal.no", "aremark.no", "arendal.no", "ås.no", "aseral.no", "åseral.no", "asker.no", "askim.no", "askoy.no", "askøy.no", "askvoll.no", "asnes.no", "åsnes.no", "audnedaln.no", "aukra.no", "aure.no", "aurland.no", "aurskog-holand.no", "aurskog-høland.no", "austevoll.no", "austrheim.no", "averoy.no", "averøy.no", "badaddja.no", "bådåddjå.no", "bærum.no", "bahcavuotna.no", "báhcavuotna.no", "bahccavuotna.no", "báhccavuotna.no", "baidar.no", "báidár.no", "bajddar.no", "bájddar.no", "balat.no", "bálát.no", "balestrand.no", "ballangen.no", "balsfjord.no", "bamble.no", "bardu.no", "barum.no", "batsfjord.no", "båtsfjord.no", "bearalvahki.no", "bearalváhki.no", "beardu.no", "beiarn.no", "berg.no", "bergen.no", "berlevag.no", "berlevåg.no", "bievat.no", "bievát.no", "bindal.no", "birkenes.no", "bjarkoy.no", "bjarkøy.no", "bjerkreim.no", "bjugn.no", "bodo.no", "bodø.no", "bokn.no", "bomlo.no", "bømlo.no", "bremanger.no", "bronnoy.no", "brønnøy.no", "budejju.no", "nes.buskerud.no", "bygland.no", "bykle.no", "cahcesuolo.no", "čáhcesuolo.no", "davvenjarga.no", "davvenjárga.no", "davvesiida.no", "deatnu.no", "dielddanuorri.no", "divtasvuodna.no", "divttasvuotna.no", "donna.no", "dønna.no", "dovre.no", "drammen.no", "drangedal.no", "dyroy.no", "dyrøy.no", "eid.no", "eidfjord.no", "eidsberg.no", "eidskog.no", "eidsvoll.no", "eigersund.no", "elverum.no", "enebakk.no", "engerdal.no", "etne.no", "etnedal.no", "evenassi.no", "evenášši.no", "evenes.no", "evje-og-hornnes.no", "farsund.no", "fauske.no", "fedje.no", "fet.no", "finnoy.no", "finnøy.no", "fitjar.no", "fjaler.no", "fjell.no", "fla.no", "flå.no", "flakstad.no", "flatanger.no", "flekkefjord.no", "flesberg.no", "flora.no", "folldal.no", "forde.no", "førde.no", "forsand.no", "fosnes.no", "fræna.no", "frana.no", "frei.no", "frogn.no", "froland.no", "frosta.no", "froya.no", "frøya.no", "fuoisku.no", "fuossko.no", "fusa.no", "fyresdal.no", "gaivuotna.no", "gáivuotna.no", "galsa.no", "gálsá.no", "gamvik.no", "gangaviika.no", "gáŋgaviika.no", "gaular.no", "gausdal.no", "giehtavuoatna.no", "gildeskal.no", "gildeskål.no", "giske.no", "gjemnes.no", "gjerdrum.no", "gjerstad.no", "gjesdal.no", "gjovik.no", "gjøvik.no", "gloppen.no", "gol.no", "gran.no", "grane.no", "granvin.no", "gratangen.no", "grimstad.no", "grong.no", "grue.no", "gulen.no", "guovdageaidnu.no", "ha.no", "hå.no", "habmer.no", "hábmer.no", "hadsel.no", "hægebostad.no", "hagebostad.no", "halden.no", "halsa.no", "hamar.no", "hamaroy.no", "hammarfeasta.no", "hámmárfeasta.no", "hammerfest.no", "hapmir.no", "hápmir.no", "haram.no", "hareid.no", "harstad.no", "hasvik.no", "hattfjelldal.no", "haugesund.no", "os.hedmark.no", "valer.hedmark.no", "våler.hedmark.no", "hemne.no", "hemnes.no", "hemsedal.no", "hitra.no", "hjartdal.no", "hjelmeland.no", "hobol.no", "hobøl.no", "hof.no", "hol.no", "hole.no", "holmestrand.no", "holtalen.no", "holtålen.no", "os.hordaland.no", "hornindal.no", "horten.no", "hoyanger.no", "høyanger.no", "hoylandet.no", "høylandet.no", "hurdal.no", "hurum.no", "hvaler.no", "hyllestad.no", "ibestad.no", "inderoy.no", "inderøy.no", "iveland.no", "ivgu.no", "jevnaker.no", "jolster.no", "jølster.no", "jondal.no", "kafjord.no", "kåfjord.no", "karasjohka.no", "kárášjohka.no", "karasjok.no", "karlsoy.no", "karmoy.no", "karmøy.no", "kautokeino.no", "klabu.no", "klæbu.no", "klepp.no", "kongsberg.no", "kongsvinger.no", "kraanghke.no", "kråanghke.no", "kragero.no", "kragerø.no", "kristiansand.no", "kristiansund.no", "krodsherad.no", "krødsherad.no", "kvæfjord.no", "kvænangen.no", "kvafjord.no", "kvalsund.no", "kvam.no", "kvanangen.no", "kvinesdal.no", "kvinnherad.no", "kviteseid.no", "kvitsoy.no", "kvitsøy.no", "laakesvuemie.no", "lærdal.no", "lahppi.no", "láhppi.no", "lardal.no", "larvik.no", "lavagis.no", "lavangen.no", "leangaviika.no", "leaŋgaviika.no", "lebesby.no", "leikanger.no", "leirfjord.no", "leka.no", "leksvik.no", "lenvik.no", "lerdal.no", "lesja.no", "levanger.no", "lier.no", "lierne.no", "lillehammer.no", "lillesand.no", "lindas.no", "lindås.no", "lindesnes.no", "loabat.no", "loabát.no", "lodingen.no", "lødingen.no", "lom.no", "loppa.no", "lorenskog.no", "lørenskog.no", "loten.no", "løten.no", "lund.no", "lunner.no", "luroy.no", "lurøy.no", "luster.no", "lyngdal.no", "lyngen.no", "malatvuopmi.no", "málatvuopmi.no", "malselv.no", "målselv.no", "malvik.no", "mandal.no", "marker.no", "marnardal.no", "masfjorden.no", "masoy.no", "måsøy.no", "matta-varjjat.no", "mátta-várjjat.no", "meland.no", "meldal.no", "melhus.no", "meloy.no", "meløy.no", "meraker.no", "meråker.no", "midsund.no", "midtre-gauldal.no", "moareke.no", "moåreke.no", "modalen.no", "modum.no", "molde.no", "heroy.more-og-romsdal.no", "sande.more-og-romsdal.no", "herøy.møre-og-romsdal.no", "sande.møre-og-romsdal.no", "moskenes.no", "moss.no", "mosvik.no", "muosat.no", "muosát.no", "naamesjevuemie.no", "nååmesjevuemie.no", "nærøy.no", "namdalseid.no", "namsos.no", "namsskogan.no", "nannestad.no", "naroy.no", "narviika.no", "narvik.no", "naustdal.no", "navuotna.no", "návuotna.no", "nedre-eiker.no", "nesna.no", "nesodden.no", "nesseby.no", "nesset.no", "nissedal.no", "nittedal.no", "nord-aurdal.no", "nord-fron.no", "nord-odal.no", "norddal.no", "nordkapp.no", "bo.nordland.no", "bø.nordland.no", "heroy.nordland.no", "herøy.nordland.no", "nordre-land.no", "nordreisa.no", "nore-og-uvdal.no", "notodden.no", "notteroy.no", "nøtterøy.no", "odda.no", "oksnes.no", "øksnes.no", "omasvuotna.no", "oppdal.no", "oppegard.no", "oppegård.no", "orkdal.no", "orland.no", "ørland.no", "orskog.no", "ørskog.no", "orsta.no", "ørsta.no", "osen.no", "osteroy.no", "osterøy.no", "valer.ostfold.no", "våler.østfold.no", "ostre-toten.no", "østre-toten.no", "overhalla.no", "ovre-eiker.no", "øvre-eiker.no", "oyer.no", "øyer.no", "oygarden.no", "øygarden.no", "oystre-slidre.no", "øystre-slidre.no", "porsanger.no", "porsangu.no", "porsáŋgu.no", "porsgrunn.no", "rade.no", "råde.no", "radoy.no", "radøy.no", "rælingen.no", "rahkkeravju.no", "ráhkkerávju.no", "raisa.no", "ráisa.no", "rakkestad.no", "ralingen.no", "rana.no", "randaberg.no", "rauma.no", "rendalen.no", "rennebu.no", "rennesoy.no", "rennesøy.no", "rindal.no", "ringebu.no", "ringerike.no", "ringsaker.no", "risor.no", "risør.no", "rissa.no", "roan.no", "rodoy.no", "rødøy.no", "rollag.no", "romsa.no", "romskog.no", "rømskog.no", "roros.no", "røros.no", "rost.no", "røst.no", "royken.no", "røyken.no", "royrvik.no", "røyrvik.no", "ruovat.no", "rygge.no", "salangen.no", "salat.no", "sálat.no", "sálát.no", "saltdal.no", "samnanger.no", "sandefjord.no", "sandnes.no", "sandoy.no", "sandøy.no", "sarpsborg.no", "sauda.no", "sauherad.no", "sel.no", "selbu.no", "selje.no", "seljord.no", "siellak.no", "sigdal.no", "siljan.no", "sirdal.no", "skanit.no", "skánit.no", "skanland.no", "skånland.no", "skaun.no", "skedsmo.no", "ski.no", "skien.no", "skierva.no", "skiervá.no", "skiptvet.no", "skjak.no", "skjåk.no", "skjervoy.no", "skjervøy.no", "skodje.no", "smola.no", "smøla.no", "snaase.no", "snåase.no", "snasa.no", "snåsa.no", "snillfjord.no", "snoasa.no", "sogndal.no", "sogne.no", "søgne.no", "sokndal.no", "sola.no", "solund.no", "somna.no", "sømna.no", "sondre-land.no", "søndre-land.no", "songdalen.no", "sor-aurdal.no", "sør-aurdal.no", "sor-fron.no", "sør-fron.no", "sor-odal.no", "sør-odal.no", "sor-varanger.no", "sør-varanger.no", "sorfold.no", "sørfold.no", "sorreisa.no", "sørreisa.no", "sortland.no", "sorum.no", "sørum.no", "spydeberg.no", "stange.no", "stavanger.no", "steigen.no", "steinkjer.no", "stjordal.no", "stjørdal.no", "stokke.no", "stor-elvdal.no", "stord.no", "stordal.no", "storfjord.no", "strand.no", "stranda.no", "stryn.no", "sula.no", "suldal.no", "sund.no", "sunndal.no", "surnadal.no", "sveio.no", "svelvik.no", "sykkylven.no", "tana.no", "bo.telemark.no", "bø.telemark.no", "time.no", "tingvoll.no", "tinn.no", "tjeldsund.no", "tjome.no", "tjøme.no", "tokke.no", "tolga.no", "tonsberg.no", "tønsberg.no", "torsken.no", "træna.no", "trana.no", "tranoy.no", "tranøy.no", "troandin.no", "trogstad.no", "trøgstad.no", "tromsa.no", "tromso.no", "tromsø.no", "trondheim.no", "trysil.no", "tvedestrand.no", "tydal.no", "tynset.no", "tysfjord.no", "tysnes.no", "tysvær.no", "tysvar.no", "ullensaker.no", "ullensvang.no", "ulvik.no", "unjarga.no", "unjárga.no", "utsira.no", "vaapste.no", "vadso.no", "vadsø.no", "værøy.no", "vaga.no", "vågå.no", "vagan.no", "vågan.no", "vagsoy.no", "vågsøy.no", "vaksdal.no", "valle.no", "vang.no", "vanylven.no", "vardo.no", "vardø.no", "varggat.no", "várggát.no", "varoy.no", "vefsn.no", "vega.no", "vegarshei.no", "vegårshei.no", "vennesla.no", "verdal.no", "verran.no", "vestby.no", "sande.vestfold.no", "vestnes.no", "vestre-slidre.no", "vestre-toten.no", "vestvagoy.no", "vestvågøy.no", "vevelstad.no", "vik.no", "vikna.no", "vindafjord.no", "voagat.no", "volda.no", "voss.no", "*.np", "nr", "biz.nr", "com.nr", "edu.nr", "gov.nr", "info.nr", "net.nr", "org.nr", "nu", "nz", "ac.nz", "co.nz", "cri.nz", "geek.nz", "gen.nz", "govt.nz", "health.nz", "iwi.nz", "kiwi.nz", "maori.nz", "māori.nz", "mil.nz", "net.nz", "org.nz", "parliament.nz", "school.nz", "om", "co.om", "com.om", "edu.om", "gov.om", "med.om", "museum.om", "net.om", "org.om", "pro.om", "onion", "org", "pa", "abo.pa", "ac.pa", "com.pa", "edu.pa", "gob.pa", "ing.pa", "med.pa", "net.pa", "nom.pa", "org.pa", "sld.pa", "pe", "com.pe", "edu.pe", "gob.pe", "mil.pe", "net.pe", "nom.pe", "org.pe", "pf", "com.pf", "edu.pf", "org.pf", "*.pg", "ph", "com.ph", "edu.ph", "gov.ph", "i.ph", "mil.ph", "net.ph", "ngo.ph", "org.ph", "pk", "ac.pk", "biz.pk", "com.pk", "edu.pk", "fam.pk", "gkp.pk", "gob.pk", "gog.pk", "gok.pk", "gon.pk", "gop.pk", "gos.pk", "gov.pk", "net.pk", "org.pk", "web.pk", "pl", "com.pl", "net.pl", "org.pl", "agro.pl", "aid.pl", "atm.pl", "auto.pl", "biz.pl", "edu.pl", "gmina.pl", "gsm.pl", "info.pl", "mail.pl", "media.pl", "miasta.pl", "mil.pl", "nieruchomosci.pl", "nom.pl", "pc.pl", "powiat.pl", "priv.pl", "realestate.pl", "rel.pl", "sex.pl", "shop.pl", "sklep.pl", "sos.pl", "szkola.pl", "targi.pl", "tm.pl", "tourism.pl", "travel.pl", "turystyka.pl", "gov.pl", "ap.gov.pl", "griw.gov.pl", "ic.gov.pl", "is.gov.pl", "kmpsp.gov.pl", "konsulat.gov.pl", "kppsp.gov.pl", "kwp.gov.pl", "kwpsp.gov.pl", "mup.gov.pl", "mw.gov.pl", "oia.gov.pl", "oirm.gov.pl", "oke.gov.pl", "oow.gov.pl", "oschr.gov.pl", "oum.gov.pl", "pa.gov.pl", "pinb.gov.pl", "piw.gov.pl", "po.gov.pl", "pr.gov.pl", "psp.gov.pl", "psse.gov.pl", "pup.gov.pl", "rzgw.gov.pl", "sa.gov.pl", "sdn.gov.pl", "sko.gov.pl", "so.gov.pl", "sr.gov.pl", "starostwo.gov.pl", "ug.gov.pl", "ugim.gov.pl", "um.gov.pl", "umig.gov.pl", "upow.gov.pl", "uppo.gov.pl", "us.gov.pl", "uw.gov.pl", "uzs.gov.pl", "wif.gov.pl", "wiih.gov.pl", "winb.gov.pl", "wios.gov.pl", "witd.gov.pl", "wiw.gov.pl", "wkz.gov.pl", "wsa.gov.pl", "wskr.gov.pl", "wsse.gov.pl", "wuoz.gov.pl", "wzmiuw.gov.pl", "zp.gov.pl", "zpisdn.gov.pl", "augustow.pl", "babia-gora.pl", "bedzin.pl", "beskidy.pl", "bialowieza.pl", "bialystok.pl", "bielawa.pl", "bieszczady.pl", "boleslawiec.pl", "bydgoszcz.pl", "bytom.pl", "cieszyn.pl", "czeladz.pl", "czest.pl", "dlugoleka.pl", "elblag.pl", "elk.pl", "glogow.pl", "gniezno.pl", "gorlice.pl", "grajewo.pl", "ilawa.pl", "jaworzno.pl", "jelenia-gora.pl", "jgora.pl", "kalisz.pl", "karpacz.pl", "kartuzy.pl", "kaszuby.pl", "katowice.pl", "kazimierz-dolny.pl", "kepno.pl", "ketrzyn.pl", "klodzko.pl", "kobierzyce.pl", "kolobrzeg.pl", "konin.pl", "konskowola.pl", "kutno.pl", "lapy.pl", "lebork.pl", "legnica.pl", "lezajsk.pl", "limanowa.pl", "lomza.pl", "lowicz.pl", "lubin.pl", "lukow.pl", "malbork.pl", "malopolska.pl", "mazowsze.pl", "mazury.pl", "mielec.pl", "mielno.pl", "mragowo.pl", "naklo.pl", "nowaruda.pl", "nysa.pl", "olawa.pl", "olecko.pl", "olkusz.pl", "olsztyn.pl", "opoczno.pl", "opole.pl", "ostroda.pl", "ostroleka.pl", "ostrowiec.pl", "ostrowwlkp.pl", "pila.pl", "pisz.pl", "podhale.pl", "podlasie.pl", "polkowice.pl", "pomorskie.pl", "pomorze.pl", "prochowice.pl", "pruszkow.pl", "przeworsk.pl", "pulawy.pl", "radom.pl", "rawa-maz.pl", "rybnik.pl", "rzeszow.pl", "sanok.pl", "sejny.pl", "skoczow.pl", "slask.pl", "slupsk.pl", "sosnowiec.pl", "stalowa-wola.pl", "starachowice.pl", "stargard.pl", "suwalki.pl", "swidnica.pl", "swiebodzin.pl", "swinoujscie.pl", "szczecin.pl", "szczytno.pl", "tarnobrzeg.pl", "tgory.pl", "turek.pl", "tychy.pl", "ustka.pl", "walbrzych.pl", "warmia.pl", "warszawa.pl", "waw.pl", "wegrow.pl", "wielun.pl", "wlocl.pl", "wloclawek.pl", "wodzislaw.pl", "wolomin.pl", "wroclaw.pl", "zachpomor.pl", "zagan.pl", "zarow.pl", "zgora.pl", "zgorzelec.pl", "pm", "pn", "co.pn", "edu.pn", "gov.pn", "net.pn", "org.pn", "post", "pr", "biz.pr", "com.pr", "edu.pr", "gov.pr", "info.pr", "isla.pr", "name.pr", "net.pr", "org.pr", "pro.pr", "ac.pr", "est.pr", "prof.pr", "pro", "aaa.pro", "aca.pro", "acct.pro", "avocat.pro", "bar.pro", "cpa.pro", "eng.pro", "jur.pro", "law.pro", "med.pro", "recht.pro", "ps", "com.ps", "edu.ps", "gov.ps", "net.ps", "org.ps", "plo.ps", "sec.ps", "pt", "com.pt", "edu.pt", "gov.pt", "int.pt", "net.pt", "nome.pt", "org.pt", "publ.pt", "pw", "belau.pw", "co.pw", "ed.pw", "go.pw", "or.pw", "py", "com.py", "coop.py", "edu.py", "gov.py", "mil.py", "net.py", "org.py", "qa", "com.qa", "edu.qa", "gov.qa", "mil.qa", "name.qa", "net.qa", "org.qa", "sch.qa", "re", "asso.re", "com.re", "ro", "arts.ro", "com.ro", "firm.ro", "info.ro", "nom.ro", "nt.ro", "org.ro", "rec.ro", "store.ro", "tm.ro", "www.ro", "rs", "ac.rs", "co.rs", "edu.rs", "gov.rs", "in.rs", "org.rs", "ru", "rw", "ac.rw", "co.rw", "coop.rw", "gov.rw", "mil.rw", "net.rw", "org.rw", "sa", "com.sa", "edu.sa", "gov.sa", "med.sa", "net.sa", "org.sa", "pub.sa", "sch.sa", "sb", "com.sb", "edu.sb", "gov.sb", "net.sb", "org.sb", "sc", "com.sc", "edu.sc", "gov.sc", "net.sc", "org.sc", "sd", "com.sd", "edu.sd", "gov.sd", "info.sd", "med.sd", "net.sd", "org.sd", "tv.sd", "se", "a.se", "ac.se", "b.se", "bd.se", "brand.se", "c.se", "d.se", "e.se", "f.se", "fh.se", "fhsk.se", "fhv.se", "g.se", "h.se", "i.se", "k.se", "komforb.se", "kommunalforbund.se", "komvux.se", "l.se", "lanbib.se", "m.se", "n.se", "naturbruksgymn.se", "o.se", "org.se", "p.se", "parti.se", "pp.se", "press.se", "r.se", "s.se", "t.se", "tm.se", "u.se", "w.se", "x.se", "y.se", "z.se", "sg", "com.sg", "edu.sg", "gov.sg", "net.sg", "org.sg", "sh", "com.sh", "gov.sh", "mil.sh", "net.sh", "org.sh", "si", "sj", "sk", "sl", "com.sl", "edu.sl", "gov.sl", "net.sl", "org.sl", "sm", "sn", "art.sn", "com.sn", "edu.sn", "gouv.sn", "org.sn", "perso.sn", "univ.sn", "so", "com.so", "edu.so", "gov.so", "me.so", "net.so", "org.so", "sr", "ss", "biz.ss", "co.ss", "com.ss", "edu.ss", "gov.ss", "me.ss", "net.ss", "org.ss", "sch.ss", "st", "co.st", "com.st", "consulado.st", "edu.st", "embaixada.st", "mil.st", "net.st", "org.st", "principe.st", "saotome.st", "store.st", "su", "sv", "com.sv", "edu.sv", "gob.sv", "org.sv", "red.sv", "sx", "gov.sx", "sy", "com.sy", "edu.sy", "gov.sy", "mil.sy", "net.sy", "org.sy", "sz", "ac.sz", "co.sz", "org.sz", "tc", "td", "tel", "tf", "tg", "th", "ac.th", "co.th", "go.th", "in.th", "mi.th", "net.th", "or.th", "tj", "ac.tj", "biz.tj", "co.tj", "com.tj", "edu.tj", "go.tj", "gov.tj", "int.tj", "mil.tj", "name.tj", "net.tj", "nic.tj", "org.tj", "test.tj", "web.tj", "tk", "tl", "gov.tl", "tm", "co.tm", "com.tm", "edu.tm", "gov.tm", "mil.tm", "net.tm", "nom.tm", "org.tm", "tn", "com.tn", "ens.tn", "fin.tn", "gov.tn", "ind.tn", "info.tn", "intl.tn", "mincom.tn", "nat.tn", "net.tn", "org.tn", "perso.tn", "tourism.tn", "to", "com.to", "edu.to", "gov.to", "mil.to", "net.to", "org.to", "tr", "av.tr", "bbs.tr", "bel.tr", "biz.tr", "com.tr", "dr.tr", "edu.tr", "gen.tr", "gov.tr", "info.tr", "k12.tr", "kep.tr", "mil.tr", "name.tr", "net.tr", "org.tr", "pol.tr", "tel.tr", "tsk.tr", "tv.tr", "web.tr", "nc.tr", "gov.nc.tr", "tt", "biz.tt", "co.tt", "com.tt", "edu.tt", "gov.tt", "info.tt", "mil.tt", "name.tt", "net.tt", "org.tt", "pro.tt", "tv", "tw", "club.tw", "com.tw", "ebiz.tw", "edu.tw", "game.tw", "gov.tw", "idv.tw", "mil.tw", "net.tw", "org.tw", "tz", "ac.tz", "co.tz", "go.tz", "hotel.tz", "info.tz", "me.tz", "mil.tz", "mobi.tz", "ne.tz", "or.tz", "sc.tz", "tv.tz", "ua", "com.ua", "edu.ua", "gov.ua", "in.ua", "net.ua", "org.ua", "cherkassy.ua", "cherkasy.ua", "chernigov.ua", "chernihiv.ua", "chernivtsi.ua", "chernovtsy.ua", "ck.ua", "cn.ua", "cr.ua", "crimea.ua", "cv.ua", "dn.ua", "dnepropetrovsk.ua", "dnipropetrovsk.ua", "donetsk.ua", "dp.ua", "if.ua", "ivano-frankivsk.ua", "kh.ua", "kharkiv.ua", "kharkov.ua", "kherson.ua", "khmelnitskiy.ua", "khmelnytskyi.ua", "kiev.ua", "kirovograd.ua", "km.ua", "kr.ua", "kropyvnytskyi.ua", "krym.ua", "ks.ua", "kv.ua", "kyiv.ua", "lg.ua", "lt.ua", "lugansk.ua", "luhansk.ua", "lutsk.ua", "lv.ua", "lviv.ua", "mk.ua", "mykolaiv.ua", "nikolaev.ua", "od.ua", "odesa.ua", "odessa.ua", "pl.ua", "poltava.ua", "rivne.ua", "rovno.ua", "rv.ua", "sb.ua", "sebastopol.ua", "sevastopol.ua", "sm.ua", "sumy.ua", "te.ua", "ternopil.ua", "uz.ua", "uzhgorod.ua", "uzhhorod.ua", "vinnica.ua", "vinnytsia.ua", "vn.ua", "volyn.ua", "yalta.ua", "zakarpattia.ua", "zaporizhzhe.ua", "zaporizhzhia.ua", "zhitomir.ua", "zhytomyr.ua", "zp.ua", "zt.ua", "ug", "ac.ug", "co.ug", "com.ug", "go.ug", "ne.ug", "or.ug", "org.ug", "sc.ug", "uk", "ac.uk", "co.uk", "gov.uk", "ltd.uk", "me.uk", "net.uk", "nhs.uk", "org.uk", "plc.uk", "police.uk", "*.sch.uk", "us", "dni.us", "fed.us", "isa.us", "kids.us", "nsn.us", "ak.us", "al.us", "ar.us", "as.us", "az.us", "ca.us", "co.us", "ct.us", "dc.us", "de.us", "fl.us", "ga.us", "gu.us", "hi.us", "ia.us", "id.us", "il.us", "in.us", "ks.us", "ky.us", "la.us", "ma.us", "md.us", "me.us", "mi.us", "mn.us", "mo.us", "ms.us", "mt.us", "nc.us", "nd.us", "ne.us", "nh.us", "nj.us", "nm.us", "nv.us", "ny.us", "oh.us", "ok.us", "or.us", "pa.us", "pr.us", "ri.us", "sc.us", "sd.us", "tn.us", "tx.us", "ut.us", "va.us", "vi.us", "vt.us", "wa.us", "wi.us", "wv.us", "wy.us", "k12.ak.us", "k12.al.us", "k12.ar.us", "k12.as.us", "k12.az.us", "k12.ca.us", "k12.co.us", "k12.ct.us", "k12.dc.us", "k12.fl.us", "k12.ga.us", "k12.gu.us", "k12.ia.us", "k12.id.us", "k12.il.us", "k12.in.us", "k12.ks.us", "k12.ky.us", "k12.la.us", "k12.ma.us", "k12.md.us", "k12.me.us", "k12.mi.us", "k12.mn.us", "k12.mo.us", "k12.ms.us", "k12.mt.us", "k12.nc.us", "k12.ne.us", "k12.nh.us", "k12.nj.us", "k12.nm.us", "k12.nv.us", "k12.ny.us", "k12.oh.us", "k12.ok.us", "k12.or.us", "k12.pa.us", "k12.pr.us", "k12.sc.us", "k12.tn.us", "k12.tx.us", "k12.ut.us", "k12.va.us", "k12.vi.us", "k12.vt.us", "k12.wa.us", "k12.wi.us", "cc.ak.us", "lib.ak.us", "cc.al.us", "lib.al.us", "cc.ar.us", "lib.ar.us", "cc.as.us", "lib.as.us", "cc.az.us", "lib.az.us", "cc.ca.us", "lib.ca.us", "cc.co.us", "lib.co.us", "cc.ct.us", "lib.ct.us", "cc.dc.us", "lib.dc.us", "cc.de.us", "cc.fl.us", "cc.ga.us", "cc.gu.us", "cc.hi.us", "cc.ia.us", "cc.id.us", "cc.il.us", "cc.in.us", "cc.ks.us", "cc.ky.us", "cc.la.us", "cc.ma.us", "cc.md.us", "cc.me.us", "cc.mi.us", "cc.mn.us", "cc.mo.us", "cc.ms.us", "cc.mt.us", "cc.nc.us", "cc.nd.us", "cc.ne.us", "cc.nh.us", "cc.nj.us", "cc.nm.us", "cc.nv.us", "cc.ny.us", "cc.oh.us", "cc.ok.us", "cc.or.us", "cc.pa.us", "cc.pr.us", "cc.ri.us", "cc.sc.us", "cc.sd.us", "cc.tn.us", "cc.tx.us", "cc.ut.us", "cc.va.us", "cc.vi.us", "cc.vt.us", "cc.wa.us", "cc.wi.us", "cc.wv.us", "cc.wy.us", "k12.wy.us", "lib.fl.us", "lib.ga.us", "lib.gu.us", "lib.hi.us", "lib.ia.us", "lib.id.us", "lib.il.us", "lib.in.us", "lib.ks.us", "lib.ky.us", "lib.la.us", "lib.ma.us", "lib.md.us", "lib.me.us", "lib.mi.us", "lib.mn.us", "lib.mo.us", "lib.ms.us", "lib.mt.us", "lib.nc.us", "lib.nd.us", "lib.ne.us", "lib.nh.us", "lib.nj.us", "lib.nm.us", "lib.nv.us", "lib.ny.us", "lib.oh.us", "lib.ok.us", "lib.or.us", "lib.pa.us", "lib.pr.us", "lib.ri.us", "lib.sc.us", "lib.sd.us", "lib.tn.us", "lib.tx.us", "lib.ut.us", "lib.va.us", "lib.vi.us", "lib.vt.us", "lib.wa.us", "lib.wi.us", "lib.wy.us", "chtr.k12.ma.us", "paroch.k12.ma.us", "pvt.k12.ma.us", "ann-arbor.mi.us", "cog.mi.us", "dst.mi.us", "eaton.mi.us", "gen.mi.us", "mus.mi.us", "tec.mi.us", "washtenaw.mi.us", "uy", "com.uy", "edu.uy", "gub.uy", "mil.uy", "net.uy", "org.uy", "uz", "co.uz", "com.uz", "net.uz", "org.uz", "va", "vc", "com.vc", "edu.vc", "gov.vc", "mil.vc", "net.vc", "org.vc", "ve", "arts.ve", "bib.ve", "co.ve", "com.ve", "e12.ve", "edu.ve", "firm.ve", "gob.ve", "gov.ve", "info.ve", "int.ve", "mil.ve", "net.ve", "nom.ve", "org.ve", "rar.ve", "rec.ve", "store.ve", "tec.ve", "web.ve", "vg", "vi", "co.vi", "com.vi", "k12.vi", "net.vi", "org.vi", "vn", "ac.vn", "ai.vn", "biz.vn", "com.vn", "edu.vn", "gov.vn", "health.vn", "id.vn", "info.vn", "int.vn", "io.vn", "name.vn", "net.vn", "org.vn", "pro.vn", "angiang.vn", "bacgiang.vn", "backan.vn", "baclieu.vn", "bacninh.vn", "baria-vungtau.vn", "bentre.vn", "binhdinh.vn", "binhduong.vn", "binhphuoc.vn", "binhthuan.vn", "camau.vn", "cantho.vn", "caobang.vn", "daklak.vn", "daknong.vn", "danang.vn", "dienbien.vn", "dongnai.vn", "dongthap.vn", "gialai.vn", "hagiang.vn", "haiduong.vn", "haiphong.vn", "hanam.vn", "hanoi.vn", "hatinh.vn", "haugiang.vn", "hoabinh.vn", "hungyen.vn", "khanhhoa.vn", "kiengiang.vn", "kontum.vn", "laichau.vn", "lamdong.vn", "langson.vn", "laocai.vn", "longan.vn", "namdinh.vn", "nghean.vn", "ninhbinh.vn", "ninhthuan.vn", "phutho.vn", "phuyen.vn", "quangbinh.vn", "quangnam.vn", "quangngai.vn", "quangninh.vn", "quangtri.vn", "soctrang.vn", "sonla.vn", "tayninh.vn", "thaibinh.vn", "thainguyen.vn", "thanhhoa.vn", "thanhphohochiminh.vn", "thuathienhue.vn", "tiengiang.vn", "travinh.vn", "tuyenquang.vn", "vinhlong.vn", "vinhphuc.vn", "yenbai.vn", "vu", "com.vu", "edu.vu", "net.vu", "org.vu", "wf", "ws", "com.ws", "edu.ws", "gov.ws", "net.ws", "org.ws", "yt", "امارات", "հայ", "বাংলা", "бг", "البحرين", "бел", "中国", "中國", "الجزائر", "مصر", "ею", "ευ", "موريتانيا", "გე", "ελ", "香港", "個人.香港", "公司.香港", "政府.香港", "教育.香港", "組織.香港", "網絡.香港", "ಭಾರತ", "ଭାରତ", "ভাৰত", "भारतम्", "भारोत", "ڀارت", "ഭാരതം", "भारत", "بارت", "بھارت", "భారత్", "ભારત", "ਭਾਰਤ", "ভারত", "இந்தியா", "ایران", "ايران", "عراق", "الاردن", "한국", "қаз", "ລາວ", "ලංකා", "இலங்கை", "المغرب", "мкд", "мон", "澳門", "澳门", "مليسيا", "عمان", "پاکستان", "پاكستان", "فلسطين", "срб", "ак.срб", "обр.срб", "од.срб", "орг.срб", "пр.срб", "упр.срб", "рф", "قطر", "السعودية", "السعودیة", "السعودیۃ", "السعوديه", "سودان", "新加坡", "சிங்கப்பூர்", "سورية", "سوريا", "ไทย", "ทหาร.ไทย", "ธุรกิจ.ไทย", "เน็ต.ไทย", "รัฐบาล.ไทย", "ศึกษา.ไทย", "องค์กร.ไทย", "تونس", "台灣", "台湾", "臺灣", "укр", "اليمن", "xxx", "ye", "com.ye", "edu.ye", "gov.ye", "mil.ye", "net.ye", "org.ye", "ac.za", "agric.za", "alt.za", "co.za", "edu.za", "gov.za", "grondar.za", "law.za", "mil.za", "net.za", "ngo.za", "nic.za", "nis.za", "nom.za", "org.za", "school.za", "tm.za", "web.za", "zm", "ac.zm", "biz.zm", "co.zm", "com.zm", "edu.zm", "gov.zm", "info.zm", "mil.zm", "net.zm", "org.zm", "sch.zm", "zw", "ac.zw", "co.zw", "gov.zw", "mil.zw", "org.zw", "aaa", "aarp", "abb", "abbott", "abbvie", "abc", "able", "abogado", "abudhabi", "academy", "accenture", "accountant", "accountants", "aco", "actor", "ads", "adult", "aeg", "aetna", "afl", "africa", "agakhan", "agency", "aig", "airbus", "airforce", "airtel", "akdn", "alibaba", "alipay", "allfinanz", "allstate", "ally", "alsace", "alstom", "amazon", "americanexpress", "americanfamily", "amex", "amfam", "amica", "amsterdam", "analytics", "android", "anquan", "anz", "aol", "apartments", "app", "apple", "aquarelle", "arab", "aramco", "archi", "army", "art", "arte", "asda", "associates", "athleta", "attorney", "auction", "audi", "audible", "audio", "auspost", "author", "auto", "autos", "aws", "axa", "azure", "baby", "baidu", "banamex", "band", "bank", "bar", "barcelona", "barclaycard", "barclays", "barefoot", "bargains", "baseball", "basketball", "bauhaus", "bayern", "bbc", "bbt", "bbva", "bcg", "bcn", "beats", "beauty", "beer", "bentley", "berlin", "best", "bestbuy", "bet", "bharti", "bible", "bid", "bike", "bing", "bingo", "bio", "black", "blackfriday", "blockbuster", "blog", "bloomberg", "blue", "bms", "bmw", "bnpparibas", "boats", "boehringer", "bofa", "bom", "bond", "boo", "book", "booking", "bosch", "bostik", "boston", "bot", "boutique", "box", "bradesco", "bridgestone", "broadway", "broker", "brother", "brussels", "build", "builders", "business", "buy", "buzz", "bzh", "cab", "cafe", "cal", "call", "calvinklein", "cam", "camera", "camp", "canon", "capetown", "capital", "capitalone", "car", "caravan", "cards", "care", "career", "careers", "cars", "casa", "case", "cash", "casino", "catering", "catholic", "cba", "cbn", "cbre", "center", "ceo", "cern", "cfa", "cfd", "chanel", "channel", "charity", "chase", "chat", "cheap", "chintai", "christmas", "chrome", "church", "cipriani", "circle", "cisco", "citadel", "citi", "citic", "city", "claims", "cleaning", "click", "clinic", "clinique", "clothing", "cloud", "club", "clubmed", "coach", "codes", "coffee", "college", "cologne", "commbank", "community", "company", "compare", "computer", "comsec", "condos", "construction", "consulting", "contact", "contractors", "cooking", "cool", "corsica", "country", "coupon", "coupons", "courses", "cpa", "credit", "creditcard", "creditunion", "cricket", "crown", "crs", "cruise", "cruises", "cuisinella", "cymru", "cyou", "dad", "dance", "data", "date", "dating", "datsun", "day", "dclk", "dds", "deal", "dealer", "deals", "degree", "delivery", "dell", "deloitte", "delta", "democrat", "dental", "dentist", "desi", "design", "dev", "dhl", "diamonds", "diet", "digital", "direct", "directory", "discount", "discover", "dish", "diy", "dnp", "docs", "doctor", "dog", "domains", "dot", "download", "drive", "dtv", "dubai", "dunlop", "dupont", "durban", "dvag", "dvr", "earth", "eat", "eco", "edeka", "education", "email", "emerck", "energy", "engineer", "engineering", "enterprises", "epson", "equipment", "ericsson", "erni", "esq", "estate", "eurovision", "eus", "events", "exchange", "expert", "exposed", "express", "extraspace", "fage", "fail", "fairwinds", "faith", "family", "fan", "fans", "farm", "farmers", "fashion", "fast", "fedex", "feedback", "ferrari", "ferrero", "fidelity", "fido", "film", "final", "finance", "financial", "fire", "firestone", "firmdale", "fish", "fishing", "fit", "fitness", "flickr", "flights", "flir", "florist", "flowers", "fly", "foo", "food", "football", "ford", "forex", "forsale", "forum", "foundation", "fox", "free", "fresenius", "frl", "frogans", "frontier", "ftr", "fujitsu", "fun", "fund", "furniture", "futbol", "fyi", "gal", "gallery", "gallo", "gallup", "game", "games", "gap", "garden", "gay", "gbiz", "gdn", "gea", "gent", "genting", "george", "ggee", "gift", "gifts", "gives", "giving", "glass", "gle", "global", "globo", "gmail", "gmbh", "gmo", "gmx", "godaddy", "gold", "goldpoint", "golf", "goo", "goodyear", "goog", "google", "gop", "got", "grainger", "graphics", "gratis", "green", "gripe", "grocery", "group", "gucci", "guge", "guide", "guitars", "guru", "hair", "hamburg", "hangout", "haus", "hbo", "hdfc", "hdfcbank", "health", "healthcare", "help", "helsinki", "here", "hermes", "hiphop", "hisamitsu", "hitachi", "hiv", "hkt", "hockey", "holdings", "holiday", "homedepot", "homegoods", "homes", "homesense", "honda", "horse", "hospital", "host", "hosting", "hot", "hotels", "hotmail", "house", "how", "hsbc", "hughes", "hyatt", "hyundai", "ibm", "icbc", "ice", "icu", "ieee", "ifm", "ikano", "imamat", "imdb", "immo", "immobilien", "inc", "industries", "infiniti", "ing", "ink", "institute", "insurance", "insure", "international", "intuit", "investments", "ipiranga", "irish", "ismaili", "ist", "istanbul", "itau", "itv", "jaguar", "java", "jcb", "jeep", "jetzt", "jewelry", "jio", "jll", "jmp", "jnj", "joburg", "jot", "joy", "jpmorgan", "jprs", "juegos", "juniper", "kaufen", "kddi", "kerryhotels", "kerrylogistics", "kerryproperties", "kfh", "kia", "kids", "kim", "kindle", "kitchen", "kiwi", "koeln", "komatsu", "kosher", "kpmg", "kpn", "krd", "kred", "kuokgroup", "kyoto", "lacaixa", "lamborghini", "lamer", "lancaster", "land", "landrover", "lanxess", "lasalle", "lat", "latino", "latrobe", "law", "lawyer", "lds", "lease", "leclerc", "lefrak", "legal", "lego", "lexus", "lgbt", "lidl", "life", "lifeinsurance", "lifestyle", "lighting", "like", "lilly", "limited", "limo", "lincoln", "link", "lipsy", "live", "living", "llc", "llp", "loan", "loans", "locker", "locus", "lol", "london", "lotte", "lotto", "love", "lpl", "lplfinancial", "ltd", "ltda", "lundbeck", "luxe", "luxury", "madrid", "maif", "maison", "makeup", "man", "management", "mango", "map", "market", "marketing", "markets", "marriott", "marshalls", "mattel", "mba", "mckinsey", "med", "media", "meet", "melbourne", "meme", "memorial", "men", "menu", "merck", "merckmsd", "miami", "microsoft", "mini", "mint", "mit", "mitsubishi", "mlb", "mls", "mma", "mobile", "moda", "moe", "moi", "mom", "monash", "money", "monster", "mormon", "mortgage", "moscow", "moto", "motorcycles", "mov", "movie", "msd", "mtn", "mtr", "music", "nab", "nagoya", "navy", "nba", "nec", "netbank", "netflix", "network", "neustar", "new", "news", "next", "nextdirect", "nexus", "nfl", "ngo", "nhk", "nico", "nike", "nikon", "ninja", "nissan", "nissay", "nokia", "norton", "now", "nowruz", "nowtv", "nra", "nrw", "ntt", "nyc", "obi", "observer", "office", "okinawa", "olayan", "olayangroup", "ollo", "omega", "one", "ong", "onl", "online", "ooo", "open", "oracle", "orange", "organic", "origins", "osaka", "otsuka", "ott", "ovh", "page", "panasonic", "paris", "pars", "partners", "parts", "party", "pay", "pccw", "pet", "pfizer", "pharmacy", "phd", "philips", "phone", "photo", "photography", "photos", "physio", "pics", "pictet", "pictures", "pid", "pin", "ping", "pink", "pioneer", "pizza", "place", "play", "playstation", "plumbing", "plus", "pnc", "pohl", "poker", "politie", "porn", "pramerica", "praxi", "press", "prime", "prod", "productions", "prof", "progressive", "promo", "properties", "property", "protection", "pru", "prudential", "pub", "pwc", "qpon", "quebec", "quest", "racing", "radio", "read", "realestate", "realtor", "realty", "recipes", "red", "redstone", "redumbrella", "rehab", "reise", "reisen", "reit", "reliance", "ren", "rent", "rentals", "repair", "report", "republican", "rest", "restaurant", "review", "reviews", "rexroth", "rich", "richardli", "ricoh", "ril", "rio", "rip", "rocks", "rodeo", "rogers", "room", "rsvp", "rugby", "ruhr", "run", "rwe", "ryukyu", "saarland", "safe", "safety", "sakura", "sale", "salon", "samsclub", "samsung", "sandvik", "sandvikcoromant", "sanofi", "sap", "sarl", "sas", "save", "saxo", "sbi", "sbs", "scb", "schaeffler", "schmidt", "scholarships", "school", "schule", "schwarz", "science", "scot", "search", "seat", "secure", "security", "seek", "select", "sener", "services", "seven", "sew", "sex", "sexy", "sfr", "shangrila", "sharp", "shell", "shia", "shiksha", "shoes", "shop", "shopping", "shouji", "show", "silk", "sina", "singles", "site", "ski", "skin", "sky", "skype", "sling", "smart", "smile", "sncf", "soccer", "social", "softbank", "software", "sohu", "solar", "solutions", "song", "sony", "soy", "spa", "space", "sport", "spot", "srl", "stada", "staples", "star", "statebank", "statefarm", "stc", "stcgroup", "stockholm", "storage", "store", "stream", "studio", "study", "style", "sucks", "supplies", "supply", "support", "surf", "surgery", "suzuki", "swatch", "swiss", "sydney", "systems", "tab", "taipei", "talk", "taobao", "target", "tatamotors", "tatar", "tattoo", "tax", "taxi", "tci", "tdk", "team", "tech", "technology", "temasek", "tennis", "teva", "thd", "theater", "theatre", "tiaa", "tickets", "tienda", "tips", "tires", "tirol", "tjmaxx", "tjx", "tkmaxx", "tmall", "today", "tokyo", "tools", "top", "toray", "toshiba", "total", "tours", "town", "toyota", "toys", "trade", "trading", "training", "travel", "travelers", "travelersinsurance", "trust", "trv", "tube", "tui", "tunes", "tushu", "tvs", "ubank", "ubs", "unicom", "university", "uno", "uol", "ups", "vacations", "vana", "vanguard", "vegas", "ventures", "verisign", "versicherung", "vet", "viajes", "video", "vig", "viking", "villas", "vin", "vip", "virgin", "visa", "vision", "viva", "vivo", "vlaanderen", "vodka", "volvo", "vote", "voting", "voto", "voyage", "wales", "walmart", "walter", "wang", "wanggou", "watch", "watches", "weather", "weatherchannel", "webcam", "weber", "website", "wed", "wedding", "weibo", "weir", "whoswho", "wien", "wiki", "williamhill", "win", "windows", "wine", "winners", "wme", "wolterskluwer", "woodside", "work", "works", "world", "wow", "wtc", "wtf", "xbox", "xerox", "xihuan", "xin", "कॉम", "セール", "佛山", "慈善", "集团", "在线", "点看", "คอม", "八卦", "موقع", "公益", "公司", "香格里拉", "网站", "移动", "我爱你", "москва", "католик", "онлайн", "сайт", "联通", "קום", "时尚", "微博", "淡马锡", "ファッション", "орг", "नेट", "ストア", "アマゾン", "삼성", "商标", "商店", "商城", "дети", "ポイント", "新闻", "家電", "كوم", "中文网", "中信", "娱乐", "谷歌", "電訊盈科", "购物", "クラウド", "通販", "网店", "संगठन", "餐厅", "网络", "ком", "亚马逊", "食品", "飞利浦", "手机", "ارامكو", "العليان", "بازار", "ابوظبي", "كاثوليك", "همراه", "닷컴", "政府", "شبكة", "بيتك", "عرب", "机构", "组织机构", "健康", "招聘", "рус", "大拿", "みんな", "グーグル", "世界", "書籍", "网址", "닷넷", "コム", "天主教", "游戏", "vermögensberater", "vermögensberatung", "企业", "信息", "嘉里大酒店", "嘉里", "广东", "政务", "xyz", "yachts", "yahoo", "yamaxun", "yandex", "yodobashi", "yoga", "yokohama", "you", "youtube", "yun", "zappos", "zara", "zero", "zip", "zone", "zuerich", "co.krd", "edu.krd", "art.pl", "gliwice.pl", "krakow.pl", "poznan.pl", "wroc.pl", "zakopane.pl", "lib.de.us", "12chars.dev", "12chars.it", "12chars.pro", "cc.ua", "inf.ua", "ltd.ua", "611.to", "a2hosted.com", "cpserver.com", "aaa.vodka", "*.on-acorn.io", "activetrail.biz", "adaptable.app", "adobeaemcloud.com", "*.dev.adobeaemcloud.com", "aem.live", "hlx.live", "adobeaemcloud.net", "aem.page", "hlx.page", "hlx3.page", "adobeio-static.net", "adobeioruntime.net", "africa.com", "beep.pl", "airkitapps.com", "airkitapps-au.com", "airkitapps.eu", "aivencloud.com", "akadns.net", "akamai.net", "akamai-staging.net", "akamaiedge.net", "akamaiedge-staging.net", "akamaihd.net", "akamaihd-staging.net", "akamaiorigin.net", "akamaiorigin-staging.net", "akamaized.net", "akamaized-staging.net", "edgekey.net", "edgekey-staging.net", "edgesuite.net", "edgesuite-staging.net", "barsy.ca", "*.compute.estate", "*.alces.network", "kasserver.com", "altervista.org", "alwaysdata.net", "myamaze.net", "execute-api.cn-north-1.amazonaws.com.cn", "execute-api.cn-northwest-1.amazonaws.com.cn", "execute-api.af-south-1.amazonaws.com", "execute-api.ap-east-1.amazonaws.com", "execute-api.ap-northeast-1.amazonaws.com", "execute-api.ap-northeast-2.amazonaws.com", "execute-api.ap-northeast-3.amazonaws.com", "execute-api.ap-south-1.amazonaws.com", "execute-api.ap-south-2.amazonaws.com", "execute-api.ap-southeast-1.amazonaws.com", "execute-api.ap-southeast-2.amazonaws.com", "execute-api.ap-southeast-3.amazonaws.com", "execute-api.ap-southeast-4.amazonaws.com", "execute-api.ap-southeast-5.amazonaws.com", "execute-api.ca-central-1.amazonaws.com", "execute-api.ca-west-1.amazonaws.com", "execute-api.eu-central-1.amazonaws.com", "execute-api.eu-central-2.amazonaws.com", "execute-api.eu-north-1.amazonaws.com", "execute-api.eu-south-1.amazonaws.com", "execute-api.eu-south-2.amazonaws.com", "execute-api.eu-west-1.amazonaws.com", "execute-api.eu-west-2.amazonaws.com", "execute-api.eu-west-3.amazonaws.com", "execute-api.il-central-1.amazonaws.com", "execute-api.me-central-1.amazonaws.com", "execute-api.me-south-1.amazonaws.com", "execute-api.sa-east-1.amazonaws.com", "execute-api.us-east-1.amazonaws.com", "execute-api.us-east-2.amazonaws.com", "execute-api.us-gov-east-1.amazonaws.com", "execute-api.us-gov-west-1.amazonaws.com", "execute-api.us-west-1.amazonaws.com", "execute-api.us-west-2.amazonaws.com", "cloudfront.net", "auth.af-south-1.amazoncognito.com", "auth.ap-east-1.amazoncognito.com", "auth.ap-northeast-1.amazoncognito.com", "auth.ap-northeast-2.amazoncognito.com", "auth.ap-northeast-3.amazoncognito.com", "auth.ap-south-1.amazoncognito.com", "auth.ap-south-2.amazoncognito.com", "auth.ap-southeast-1.amazoncognito.com", "auth.ap-southeast-2.amazoncognito.com", "auth.ap-southeast-3.amazoncognito.com", "auth.ap-southeast-4.amazoncognito.com", "auth.ca-central-1.amazoncognito.com", "auth.ca-west-1.amazoncognito.com", "auth.eu-central-1.amazoncognito.com", "auth.eu-central-2.amazoncognito.com", "auth.eu-north-1.amazoncognito.com", "auth.eu-south-1.amazoncognito.com", "auth.eu-south-2.amazoncognito.com", "auth.eu-west-1.amazoncognito.com", "auth.eu-west-2.amazoncognito.com", "auth.eu-west-3.amazoncognito.com", "auth.il-central-1.amazoncognito.com", "auth.me-central-1.amazoncognito.com", "auth.me-south-1.amazoncognito.com", "auth.sa-east-1.amazoncognito.com", "auth.us-east-1.amazoncognito.com", "auth-fips.us-east-1.amazoncognito.com", "auth.us-east-2.amazoncognito.com", "auth-fips.us-east-2.amazoncognito.com", "auth-fips.us-gov-west-1.amazoncognito.com", "auth.us-west-1.amazoncognito.com", "auth-fips.us-west-1.amazoncognito.com", "auth.us-west-2.amazoncognito.com", "auth-fips.us-west-2.amazoncognito.com", "*.compute.amazonaws.com.cn", "*.compute.amazonaws.com", "*.compute-1.amazonaws.com", "us-east-1.amazonaws.com", "emrappui-prod.cn-north-1.amazonaws.com.cn", "emrnotebooks-prod.cn-north-1.amazonaws.com.cn", "emrstudio-prod.cn-north-1.amazonaws.com.cn", "emrappui-prod.cn-northwest-1.amazonaws.com.cn", "emrnotebooks-prod.cn-northwest-1.amazonaws.com.cn", "emrstudio-prod.cn-northwest-1.amazonaws.com.cn", "emrappui-prod.af-south-1.amazonaws.com", "emrnotebooks-prod.af-south-1.amazonaws.com", "emrstudio-prod.af-south-1.amazonaws.com", "emrappui-prod.ap-east-1.amazonaws.com", "emrnotebooks-prod.ap-east-1.amazonaws.com", "emrstudio-prod.ap-east-1.amazonaws.com", "emrappui-prod.ap-northeast-1.amazonaws.com", "emrnotebooks-prod.ap-northeast-1.amazonaws.com", "emrstudio-prod.ap-northeast-1.amazonaws.com", "emrappui-prod.ap-northeast-2.amazonaws.com", "emrnotebooks-prod.ap-northeast-2.amazonaws.com", "emrstudio-prod.ap-northeast-2.amazonaws.com", "emrappui-prod.ap-northeast-3.amazonaws.com", "emrnotebooks-prod.ap-northeast-3.amazonaws.com", "emrstudio-prod.ap-northeast-3.amazonaws.com", "emrappui-prod.ap-south-1.amazonaws.com", "emrnotebooks-prod.ap-south-1.amazonaws.com", "emrstudio-prod.ap-south-1.amazonaws.com", "emrappui-prod.ap-south-2.amazonaws.com", "emrnotebooks-prod.ap-south-2.amazonaws.com", "emrstudio-prod.ap-south-2.amazonaws.com", "emrappui-prod.ap-southeast-1.amazonaws.com", "emrnotebooks-prod.ap-southeast-1.amazonaws.com", "emrstudio-prod.ap-southeast-1.amazonaws.com", "emrappui-prod.ap-southeast-2.amazonaws.com", "emrnotebooks-prod.ap-southeast-2.amazonaws.com", "emrstudio-prod.ap-southeast-2.amazonaws.com", "emrappui-prod.ap-southeast-3.amazonaws.com", "emrnotebooks-prod.ap-southeast-3.amazonaws.com", "emrstudio-prod.ap-southeast-3.amazonaws.com", "emrappui-prod.ap-southeast-4.amazonaws.com", "emrnotebooks-prod.ap-southeast-4.amazonaws.com", "emrstudio-prod.ap-southeast-4.amazonaws.com", "emrappui-prod.ca-central-1.amazonaws.com", "emrnotebooks-prod.ca-central-1.amazonaws.com", "emrstudio-prod.ca-central-1.amazonaws.com", "emrappui-prod.ca-west-1.amazonaws.com", "emrnotebooks-prod.ca-west-1.amazonaws.com", "emrstudio-prod.ca-west-1.amazonaws.com", "emrappui-prod.eu-central-1.amazonaws.com", "emrnotebooks-prod.eu-central-1.amazonaws.com", "emrstudio-prod.eu-central-1.amazonaws.com", "emrappui-prod.eu-central-2.amazonaws.com", "emrnotebooks-prod.eu-central-2.amazonaws.com", "emrstudio-prod.eu-central-2.amazonaws.com", "emrappui-prod.eu-north-1.amazonaws.com", "emrnotebooks-prod.eu-north-1.amazonaws.com", "emrstudio-prod.eu-north-1.amazonaws.com", "emrappui-prod.eu-south-1.amazonaws.com", "emrnotebooks-prod.eu-south-1.amazonaws.com", "emrstudio-prod.eu-south-1.amazonaws.com", "emrappui-prod.eu-south-2.amazonaws.com", "emrnotebooks-prod.eu-south-2.amazonaws.com", "emrstudio-prod.eu-south-2.amazonaws.com", "emrappui-prod.eu-west-1.amazonaws.com", "emrnotebooks-prod.eu-west-1.amazonaws.com", "emrstudio-prod.eu-west-1.amazonaws.com", "emrappui-prod.eu-west-2.amazonaws.com", "emrnotebooks-prod.eu-west-2.amazonaws.com", "emrstudio-prod.eu-west-2.amazonaws.com", "emrappui-prod.eu-west-3.amazonaws.com", "emrnotebooks-prod.eu-west-3.amazonaws.com", "emrstudio-prod.eu-west-3.amazonaws.com", "emrappui-prod.il-central-1.amazonaws.com", "emrnotebooks-prod.il-central-1.amazonaws.com", "emrstudio-prod.il-central-1.amazonaws.com", "emrappui-prod.me-central-1.amazonaws.com", "emrnotebooks-prod.me-central-1.amazonaws.com", "emrstudio-prod.me-central-1.amazonaws.com", "emrappui-prod.me-south-1.amazonaws.com", "emrnotebooks-prod.me-south-1.amazonaws.com", "emrstudio-prod.me-south-1.amazonaws.com", "emrappui-prod.sa-east-1.amazonaws.com", "emrnotebooks-prod.sa-east-1.amazonaws.com", "emrstudio-prod.sa-east-1.amazonaws.com", "emrappui-prod.us-east-1.amazonaws.com", "emrnotebooks-prod.us-east-1.amazonaws.com", "emrstudio-prod.us-east-1.amazonaws.com", "emrappui-prod.us-east-2.amazonaws.com", "emrnotebooks-prod.us-east-2.amazonaws.com", "emrstudio-prod.us-east-2.amazonaws.com", "emrappui-prod.us-gov-east-1.amazonaws.com", "emrnotebooks-prod.us-gov-east-1.amazonaws.com", "emrstudio-prod.us-gov-east-1.amazonaws.com", "emrappui-prod.us-gov-west-1.amazonaws.com", "emrnotebooks-prod.us-gov-west-1.amazonaws.com", "emrstudio-prod.us-gov-west-1.amazonaws.com", "emrappui-prod.us-west-1.amazonaws.com", "emrnotebooks-prod.us-west-1.amazonaws.com", "emrstudio-prod.us-west-1.amazonaws.com", "emrappui-prod.us-west-2.amazonaws.com", "emrnotebooks-prod.us-west-2.amazonaws.com", "emrstudio-prod.us-west-2.amazonaws.com", "*.cn-north-1.airflow.amazonaws.com.cn", "*.cn-northwest-1.airflow.amazonaws.com.cn", "*.af-south-1.airflow.amazonaws.com", "*.ap-east-1.airflow.amazonaws.com", "*.ap-northeast-1.airflow.amazonaws.com", "*.ap-northeast-2.airflow.amazonaws.com", "*.ap-northeast-3.airflow.amazonaws.com", "*.ap-south-1.airflow.amazonaws.com", "*.ap-south-2.airflow.amazonaws.com", "*.ap-southeast-1.airflow.amazonaws.com", "*.ap-southeast-2.airflow.amazonaws.com", "*.ap-southeast-3.airflow.amazonaws.com", "*.ap-southeast-4.airflow.amazonaws.com", "*.ca-central-1.airflow.amazonaws.com", "*.ca-west-1.airflow.amazonaws.com", "*.eu-central-1.airflow.amazonaws.com", "*.eu-central-2.airflow.amazonaws.com", "*.eu-north-1.airflow.amazonaws.com", "*.eu-south-1.airflow.amazonaws.com", "*.eu-south-2.airflow.amazonaws.com", "*.eu-west-1.airflow.amazonaws.com", "*.eu-west-2.airflow.amazonaws.com", "*.eu-west-3.airflow.amazonaws.com", "*.il-central-1.airflow.amazonaws.com", "*.me-central-1.airflow.amazonaws.com", "*.me-south-1.airflow.amazonaws.com", "*.sa-east-1.airflow.amazonaws.com", "*.us-east-1.airflow.amazonaws.com", "*.us-east-2.airflow.amazonaws.com", "*.us-west-1.airflow.amazonaws.com", "*.us-west-2.airflow.amazonaws.com", "s3.dualstack.cn-north-1.amazonaws.com.cn", "s3-accesspoint.dualstack.cn-north-1.amazonaws.com.cn", "s3-website.dualstack.cn-north-1.amazonaws.com.cn", "s3.cn-north-1.amazonaws.com.cn", "s3-accesspoint.cn-north-1.amazonaws.com.cn", "s3-deprecated.cn-north-1.amazonaws.com.cn", "s3-object-lambda.cn-north-1.amazonaws.com.cn", "s3-website.cn-north-1.amazonaws.com.cn", "s3.dualstack.cn-northwest-1.amazonaws.com.cn", "s3-accesspoint.dualstack.cn-northwest-1.amazonaws.com.cn", "s3.cn-northwest-1.amazonaws.com.cn", "s3-accesspoint.cn-northwest-1.amazonaws.com.cn", "s3-object-lambda.cn-northwest-1.amazonaws.com.cn", "s3-website.cn-northwest-1.amazonaws.com.cn", "s3.dualstack.af-south-1.amazonaws.com", "s3-accesspoint.dualstack.af-south-1.amazonaws.com", "s3-website.dualstack.af-south-1.amazonaws.com", "s3.af-south-1.amazonaws.com", "s3-accesspoint.af-south-1.amazonaws.com", "s3-object-lambda.af-south-1.amazonaws.com", "s3-website.af-south-1.amazonaws.com", "s3.dualstack.ap-east-1.amazonaws.com", "s3-accesspoint.dualstack.ap-east-1.amazonaws.com", "s3.ap-east-1.amazonaws.com", "s3-accesspoint.ap-east-1.amazonaws.com", "s3-object-lambda.ap-east-1.amazonaws.com", "s3-website.ap-east-1.amazonaws.com", "s3.dualstack.ap-northeast-1.amazonaws.com", "s3-accesspoint.dualstack.ap-northeast-1.amazonaws.com", "s3-website.dualstack.ap-northeast-1.amazonaws.com", "s3.ap-northeast-1.amazonaws.com", "s3-accesspoint.ap-northeast-1.amazonaws.com", "s3-object-lambda.ap-northeast-1.amazonaws.com", "s3-website.ap-northeast-1.amazonaws.com", "s3.dualstack.ap-northeast-2.amazonaws.com", "s3-accesspoint.dualstack.ap-northeast-2.amazonaws.com", "s3-website.dualstack.ap-northeast-2.amazonaws.com", "s3.ap-northeast-2.amazonaws.com", "s3-accesspoint.ap-northeast-2.amazonaws.com", "s3-object-lambda.ap-northeast-2.amazonaws.com", "s3-website.ap-northeast-2.amazonaws.com", "s3.dualstack.ap-northeast-3.amazonaws.com", "s3-accesspoint.dualstack.ap-northeast-3.amazonaws.com", "s3-website.dualstack.ap-northeast-3.amazonaws.com", "s3.ap-northeast-3.amazonaws.com", "s3-accesspoint.ap-northeast-3.amazonaws.com", "s3-object-lambda.ap-northeast-3.amazonaws.com", "s3-website.ap-northeast-3.amazonaws.com", "s3.dualstack.ap-south-1.amazonaws.com", "s3-accesspoint.dualstack.ap-south-1.amazonaws.com", "s3-website.dualstack.ap-south-1.amazonaws.com", "s3.ap-south-1.amazonaws.com", "s3-accesspoint.ap-south-1.amazonaws.com", "s3-object-lambda.ap-south-1.amazonaws.com", "s3-website.ap-south-1.amazonaws.com", "s3.dualstack.ap-south-2.amazonaws.com", "s3-accesspoint.dualstack.ap-south-2.amazonaws.com", "s3-website.dualstack.ap-south-2.amazonaws.com", "s3.ap-south-2.amazonaws.com", "s3-accesspoint.ap-south-2.amazonaws.com", "s3-object-lambda.ap-south-2.amazonaws.com", "s3-website.ap-south-2.amazonaws.com", "s3.dualstack.ap-southeast-1.amazonaws.com", "s3-accesspoint.dualstack.ap-southeast-1.amazonaws.com", "s3-website.dualstack.ap-southeast-1.amazonaws.com", "s3.ap-southeast-1.amazonaws.com", "s3-accesspoint.ap-southeast-1.amazonaws.com", "s3-object-lambda.ap-southeast-1.amazonaws.com", "s3-website.ap-southeast-1.amazonaws.com", "s3.dualstack.ap-southeast-2.amazonaws.com", "s3-accesspoint.dualstack.ap-southeast-2.amazonaws.com", "s3-website.dualstack.ap-southeast-2.amazonaws.com", "s3.ap-southeast-2.amazonaws.com", "s3-accesspoint.ap-southeast-2.amazonaws.com", "s3-object-lambda.ap-southeast-2.amazonaws.com", "s3-website.ap-southeast-2.amazonaws.com", "s3.dualstack.ap-southeast-3.amazonaws.com", "s3-accesspoint.dualstack.ap-southeast-3.amazonaws.com", "s3-website.dualstack.ap-southeast-3.amazonaws.com", "s3.ap-southeast-3.amazonaws.com", "s3-accesspoint.ap-southeast-3.amazonaws.com", "s3-object-lambda.ap-southeast-3.amazonaws.com", "s3-website.ap-southeast-3.amazonaws.com", "s3.dualstack.ap-southeast-4.amazonaws.com", "s3-accesspoint.dualstack.ap-southeast-4.amazonaws.com", "s3-website.dualstack.ap-southeast-4.amazonaws.com", "s3.ap-southeast-4.amazonaws.com", "s3-accesspoint.ap-southeast-4.amazonaws.com", "s3-object-lambda.ap-southeast-4.amazonaws.com", "s3-website.ap-southeast-4.amazonaws.com", "s3.dualstack.ap-southeast-5.amazonaws.com", "s3-accesspoint.dualstack.ap-southeast-5.amazonaws.com", "s3-website.dualstack.ap-southeast-5.amazonaws.com", "s3.ap-southeast-5.amazonaws.com", "s3-accesspoint.ap-southeast-5.amazonaws.com", "s3-deprecated.ap-southeast-5.amazonaws.com", "s3-object-lambda.ap-southeast-5.amazonaws.com", "s3-website.ap-southeast-5.amazonaws.com", "s3.dualstack.ca-central-1.amazonaws.com", "s3-accesspoint.dualstack.ca-central-1.amazonaws.com", "s3-accesspoint-fips.dualstack.ca-central-1.amazonaws.com", "s3-fips.dualstack.ca-central-1.amazonaws.com", "s3-website.dualstack.ca-central-1.amazonaws.com", "s3.ca-central-1.amazonaws.com", "s3-accesspoint.ca-central-1.amazonaws.com", "s3-accesspoint-fips.ca-central-1.amazonaws.com", "s3-fips.ca-central-1.amazonaws.com", "s3-object-lambda.ca-central-1.amazonaws.com", "s3-website.ca-central-1.amazonaws.com", "s3.dualstack.ca-west-1.amazonaws.com", "s3-accesspoint.dualstack.ca-west-1.amazonaws.com", "s3-accesspoint-fips.dualstack.ca-west-1.amazonaws.com", "s3-fips.dualstack.ca-west-1.amazonaws.com", "s3-website.dualstack.ca-west-1.amazonaws.com", "s3.ca-west-1.amazonaws.com", "s3-accesspoint.ca-west-1.amazonaws.com", "s3-accesspoint-fips.ca-west-1.amazonaws.com", "s3-fips.ca-west-1.amazonaws.com", "s3-object-lambda.ca-west-1.amazonaws.com", "s3-website.ca-west-1.amazonaws.com", "s3.dualstack.eu-central-1.amazonaws.com", "s3-accesspoint.dualstack.eu-central-1.amazonaws.com", "s3-website.dualstack.eu-central-1.amazonaws.com", "s3.eu-central-1.amazonaws.com", "s3-accesspoint.eu-central-1.amazonaws.com", "s3-object-lambda.eu-central-1.amazonaws.com", "s3-website.eu-central-1.amazonaws.com", "s3.dualstack.eu-central-2.amazonaws.com", "s3-accesspoint.dualstack.eu-central-2.amazonaws.com", "s3-website.dualstack.eu-central-2.amazonaws.com", "s3.eu-central-2.amazonaws.com", "s3-accesspoint.eu-central-2.amazonaws.com", "s3-object-lambda.eu-central-2.amazonaws.com", "s3-website.eu-central-2.amazonaws.com", "s3.dualstack.eu-north-1.amazonaws.com", "s3-accesspoint.dualstack.eu-north-1.amazonaws.com", "s3.eu-north-1.amazonaws.com", "s3-accesspoint.eu-north-1.amazonaws.com", "s3-object-lambda.eu-north-1.amazonaws.com", "s3-website.eu-north-1.amazonaws.com", "s3.dualstack.eu-south-1.amazonaws.com", "s3-accesspoint.dualstack.eu-south-1.amazonaws.com", "s3-website.dualstack.eu-south-1.amazonaws.com", "s3.eu-south-1.amazonaws.com", "s3-accesspoint.eu-south-1.amazonaws.com", "s3-object-lambda.eu-south-1.amazonaws.com", "s3-website.eu-south-1.amazonaws.com", "s3.dualstack.eu-south-2.amazonaws.com", "s3-accesspoint.dualstack.eu-south-2.amazonaws.com", "s3-website.dualstack.eu-south-2.amazonaws.com", "s3.eu-south-2.amazonaws.com", "s3-accesspoint.eu-south-2.amazonaws.com", "s3-object-lambda.eu-south-2.amazonaws.com", "s3-website.eu-south-2.amazonaws.com", "s3.dualstack.eu-west-1.amazonaws.com", "s3-accesspoint.dualstack.eu-west-1.amazonaws.com", "s3-website.dualstack.eu-west-1.amazonaws.com", "s3.eu-west-1.amazonaws.com", "s3-accesspoint.eu-west-1.amazonaws.com", "s3-deprecated.eu-west-1.amazonaws.com", "s3-object-lambda.eu-west-1.amazonaws.com", "s3-website.eu-west-1.amazonaws.com", "s3.dualstack.eu-west-2.amazonaws.com", "s3-accesspoint.dualstack.eu-west-2.amazonaws.com", "s3.eu-west-2.amazonaws.com", "s3-accesspoint.eu-west-2.amazonaws.com", "s3-object-lambda.eu-west-2.amazonaws.com", "s3-website.eu-west-2.amazonaws.com", "s3.dualstack.eu-west-3.amazonaws.com", "s3-accesspoint.dualstack.eu-west-3.amazonaws.com", "s3-website.dualstack.eu-west-3.amazonaws.com", "s3.eu-west-3.amazonaws.com", "s3-accesspoint.eu-west-3.amazonaws.com", "s3-object-lambda.eu-west-3.amazonaws.com", "s3-website.eu-west-3.amazonaws.com", "s3.dualstack.il-central-1.amazonaws.com", "s3-accesspoint.dualstack.il-central-1.amazonaws.com", "s3-website.dualstack.il-central-1.amazonaws.com", "s3.il-central-1.amazonaws.com", "s3-accesspoint.il-central-1.amazonaws.com", "s3-object-lambda.il-central-1.amazonaws.com", "s3-website.il-central-1.amazonaws.com", "s3.dualstack.me-central-1.amazonaws.com", "s3-accesspoint.dualstack.me-central-1.amazonaws.com", "s3-website.dualstack.me-central-1.amazonaws.com", "s3.me-central-1.amazonaws.com", "s3-accesspoint.me-central-1.amazonaws.com", "s3-object-lambda.me-central-1.amazonaws.com", "s3-website.me-central-1.amazonaws.com", "s3.dualstack.me-south-1.amazonaws.com", "s3-accesspoint.dualstack.me-south-1.amazonaws.com", "s3.me-south-1.amazonaws.com", "s3-accesspoint.me-south-1.amazonaws.com", "s3-object-lambda.me-south-1.amazonaws.com", "s3-website.me-south-1.amazonaws.com", "s3.amazonaws.com", "s3-1.amazonaws.com", "s3-ap-east-1.amazonaws.com", "s3-ap-northeast-1.amazonaws.com", "s3-ap-northeast-2.amazonaws.com", "s3-ap-northeast-3.amazonaws.com", "s3-ap-south-1.amazonaws.com", "s3-ap-southeast-1.amazonaws.com", "s3-ap-southeast-2.amazonaws.com", "s3-ca-central-1.amazonaws.com", "s3-eu-central-1.amazonaws.com", "s3-eu-north-1.amazonaws.com", "s3-eu-west-1.amazonaws.com", "s3-eu-west-2.amazonaws.com", "s3-eu-west-3.amazonaws.com", "s3-external-1.amazonaws.com", "s3-fips-us-gov-east-1.amazonaws.com", "s3-fips-us-gov-west-1.amazonaws.com", "mrap.accesspoint.s3-global.amazonaws.com", "s3-me-south-1.amazonaws.com", "s3-sa-east-1.amazonaws.com", "s3-us-east-2.amazonaws.com", "s3-us-gov-east-1.amazonaws.com", "s3-us-gov-west-1.amazonaws.com", "s3-us-west-1.amazonaws.com", "s3-us-west-2.amazonaws.com", "s3-website-ap-northeast-1.amazonaws.com", "s3-website-ap-southeast-1.amazonaws.com", "s3-website-ap-southeast-2.amazonaws.com", "s3-website-eu-west-1.amazonaws.com", "s3-website-sa-east-1.amazonaws.com", "s3-website-us-east-1.amazonaws.com", "s3-website-us-gov-west-1.amazonaws.com", "s3-website-us-west-1.amazonaws.com", "s3-website-us-west-2.amazonaws.com", "s3.dualstack.sa-east-1.amazonaws.com", "s3-accesspoint.dualstack.sa-east-1.amazonaws.com", "s3-website.dualstack.sa-east-1.amazonaws.com", "s3.sa-east-1.amazonaws.com", "s3-accesspoint.sa-east-1.amazonaws.com", "s3-object-lambda.sa-east-1.amazonaws.com", "s3-website.sa-east-1.amazonaws.com", "s3.dualstack.us-east-1.amazonaws.com", "s3-accesspoint.dualstack.us-east-1.amazonaws.com", "s3-accesspoint-fips.dualstack.us-east-1.amazonaws.com", "s3-fips.dualstack.us-east-1.amazonaws.com", "s3-website.dualstack.us-east-1.amazonaws.com", "s3.us-east-1.amazonaws.com", "s3-accesspoint.us-east-1.amazonaws.com", "s3-accesspoint-fips.us-east-1.amazonaws.com", "s3-deprecated.us-east-1.amazonaws.com", "s3-fips.us-east-1.amazonaws.com", "s3-object-lambda.us-east-1.amazonaws.com", "s3-website.us-east-1.amazonaws.com", "s3.dualstack.us-east-2.amazonaws.com", "s3-accesspoint.dualstack.us-east-2.amazonaws.com", "s3-accesspoint-fips.dualstack.us-east-2.amazonaws.com", "s3-fips.dualstack.us-east-2.amazonaws.com", "s3-website.dualstack.us-east-2.amazonaws.com", "s3.us-east-2.amazonaws.com", "s3-accesspoint.us-east-2.amazonaws.com", "s3-accesspoint-fips.us-east-2.amazonaws.com", "s3-deprecated.us-east-2.amazonaws.com", "s3-fips.us-east-2.amazonaws.com", "s3-object-lambda.us-east-2.amazonaws.com", "s3-website.us-east-2.amazonaws.com", "s3.dualstack.us-gov-east-1.amazonaws.com", "s3-accesspoint.dualstack.us-gov-east-1.amazonaws.com", "s3-accesspoint-fips.dualstack.us-gov-east-1.amazonaws.com", "s3-fips.dualstack.us-gov-east-1.amazonaws.com", "s3.us-gov-east-1.amazonaws.com", "s3-accesspoint.us-gov-east-1.amazonaws.com", "s3-accesspoint-fips.us-gov-east-1.amazonaws.com", "s3-fips.us-gov-east-1.amazonaws.com", "s3-object-lambda.us-gov-east-1.amazonaws.com", "s3-website.us-gov-east-1.amazonaws.com", "s3.dualstack.us-gov-west-1.amazonaws.com", "s3-accesspoint.dualstack.us-gov-west-1.amazonaws.com", "s3-accesspoint-fips.dualstack.us-gov-west-1.amazonaws.com", "s3-fips.dualstack.us-gov-west-1.amazonaws.com", "s3.us-gov-west-1.amazonaws.com", "s3-accesspoint.us-gov-west-1.amazonaws.com", "s3-accesspoint-fips.us-gov-west-1.amazonaws.com", "s3-fips.us-gov-west-1.amazonaws.com", "s3-object-lambda.us-gov-west-1.amazonaws.com", "s3-website.us-gov-west-1.amazonaws.com", "s3.dualstack.us-west-1.amazonaws.com", "s3-accesspoint.dualstack.us-west-1.amazonaws.com", "s3-accesspoint-fips.dualstack.us-west-1.amazonaws.com", "s3-fips.dualstack.us-west-1.amazonaws.com", "s3-website.dualstack.us-west-1.amazonaws.com", "s3.us-west-1.amazonaws.com", "s3-accesspoint.us-west-1.amazonaws.com", "s3-accesspoint-fips.us-west-1.amazonaws.com", "s3-fips.us-west-1.amazonaws.com", "s3-object-lambda.us-west-1.amazonaws.com", "s3-website.us-west-1.amazonaws.com", "s3.dualstack.us-west-2.amazonaws.com", "s3-accesspoint.dualstack.us-west-2.amazonaws.com", "s3-accesspoint-fips.dualstack.us-west-2.amazonaws.com", "s3-fips.dualstack.us-west-2.amazonaws.com", "s3-website.dualstack.us-west-2.amazonaws.com", "s3.us-west-2.amazonaws.com", "s3-accesspoint.us-west-2.amazonaws.com", "s3-accesspoint-fips.us-west-2.amazonaws.com", "s3-deprecated.us-west-2.amazonaws.com", "s3-fips.us-west-2.amazonaws.com", "s3-object-lambda.us-west-2.amazonaws.com", "s3-website.us-west-2.amazonaws.com", "labeling.ap-northeast-1.sagemaker.aws", "labeling.ap-northeast-2.sagemaker.aws", "labeling.ap-south-1.sagemaker.aws", "labeling.ap-southeast-1.sagemaker.aws", "labeling.ap-southeast-2.sagemaker.aws", "labeling.ca-central-1.sagemaker.aws", "labeling.eu-central-1.sagemaker.aws", "labeling.eu-west-1.sagemaker.aws", "labeling.eu-west-2.sagemaker.aws", "labeling.us-east-1.sagemaker.aws", "labeling.us-east-2.sagemaker.aws", "labeling.us-west-2.sagemaker.aws", "notebook.af-south-1.sagemaker.aws", "notebook.ap-east-1.sagemaker.aws", "notebook.ap-northeast-1.sagemaker.aws", "notebook.ap-northeast-2.sagemaker.aws", "notebook.ap-northeast-3.sagemaker.aws", "notebook.ap-south-1.sagemaker.aws", "notebook.ap-south-2.sagemaker.aws", "notebook.ap-southeast-1.sagemaker.aws", "notebook.ap-southeast-2.sagemaker.aws", "notebook.ap-southeast-3.sagemaker.aws", "notebook.ap-southeast-4.sagemaker.aws", "notebook.ca-central-1.sagemaker.aws", "notebook-fips.ca-central-1.sagemaker.aws", "notebook.ca-west-1.sagemaker.aws", "notebook-fips.ca-west-1.sagemaker.aws", "notebook.eu-central-1.sagemaker.aws", "notebook.eu-central-2.sagemaker.aws", "notebook.eu-north-1.sagemaker.aws", "notebook.eu-south-1.sagemaker.aws", "notebook.eu-south-2.sagemaker.aws", "notebook.eu-west-1.sagemaker.aws", "notebook.eu-west-2.sagemaker.aws", "notebook.eu-west-3.sagemaker.aws", "notebook.il-central-1.sagemaker.aws", "notebook.me-central-1.sagemaker.aws", "notebook.me-south-1.sagemaker.aws", "notebook.sa-east-1.sagemaker.aws", "notebook.us-east-1.sagemaker.aws", "notebook-fips.us-east-1.sagemaker.aws", "notebook.us-east-2.sagemaker.aws", "notebook-fips.us-east-2.sagemaker.aws", "notebook.us-gov-east-1.sagemaker.aws", "notebook-fips.us-gov-east-1.sagemaker.aws", "notebook.us-gov-west-1.sagemaker.aws", "notebook-fips.us-gov-west-1.sagemaker.aws", "notebook.us-west-1.sagemaker.aws", "notebook-fips.us-west-1.sagemaker.aws", "notebook.us-west-2.sagemaker.aws", "notebook-fips.us-west-2.sagemaker.aws", "notebook.cn-north-1.sagemaker.com.cn", "notebook.cn-northwest-1.sagemaker.com.cn", "studio.af-south-1.sagemaker.aws", "studio.ap-east-1.sagemaker.aws", "studio.ap-northeast-1.sagemaker.aws", "studio.ap-northeast-2.sagemaker.aws", "studio.ap-northeast-3.sagemaker.aws", "studio.ap-south-1.sagemaker.aws", "studio.ap-southeast-1.sagemaker.aws", "studio.ap-southeast-2.sagemaker.aws", "studio.ap-southeast-3.sagemaker.aws", "studio.ca-central-1.sagemaker.aws", "studio.eu-central-1.sagemaker.aws", "studio.eu-north-1.sagemaker.aws", "studio.eu-south-1.sagemaker.aws", "studio.eu-south-2.sagemaker.aws", "studio.eu-west-1.sagemaker.aws", "studio.eu-west-2.sagemaker.aws", "studio.eu-west-3.sagemaker.aws", "studio.il-central-1.sagemaker.aws", "studio.me-central-1.sagemaker.aws", "studio.me-south-1.sagemaker.aws", "studio.sa-east-1.sagemaker.aws", "studio.us-east-1.sagemaker.aws", "studio.us-east-2.sagemaker.aws", "studio.us-gov-east-1.sagemaker.aws", "studio-fips.us-gov-east-1.sagemaker.aws", "studio.us-gov-west-1.sagemaker.aws", "studio-fips.us-gov-west-1.sagemaker.aws", "studio.us-west-1.sagemaker.aws", "studio.us-west-2.sagemaker.aws", "studio.cn-north-1.sagemaker.com.cn", "studio.cn-northwest-1.sagemaker.com.cn", "*.experiments.sagemaker.aws", "analytics-gateway.ap-northeast-1.amazonaws.com", "analytics-gateway.ap-northeast-2.amazonaws.com", "analytics-gateway.ap-south-1.amazonaws.com", "analytics-gateway.ap-southeast-1.amazonaws.com", "analytics-gateway.ap-southeast-2.amazonaws.com", "analytics-gateway.eu-central-1.amazonaws.com", "analytics-gateway.eu-west-1.amazonaws.com", "analytics-gateway.us-east-1.amazonaws.com", "analytics-gateway.us-east-2.amazonaws.com", "analytics-gateway.us-west-2.amazonaws.com", "amplifyapp.com", "*.awsapprunner.com", "webview-assets.aws-cloud9.af-south-1.amazonaws.com", "vfs.cloud9.af-south-1.amazonaws.com", "webview-assets.cloud9.af-south-1.amazonaws.com", "webview-assets.aws-cloud9.ap-east-1.amazonaws.com", "vfs.cloud9.ap-east-1.amazonaws.com", "webview-assets.cloud9.ap-east-1.amazonaws.com", "webview-assets.aws-cloud9.ap-northeast-1.amazonaws.com", "vfs.cloud9.ap-northeast-1.amazonaws.com", "webview-assets.cloud9.ap-northeast-1.amazonaws.com", "webview-assets.aws-cloud9.ap-northeast-2.amazonaws.com", "vfs.cloud9.ap-northeast-2.amazonaws.com", "webview-assets.cloud9.ap-northeast-2.amazonaws.com", "webview-assets.aws-cloud9.ap-northeast-3.amazonaws.com", "vfs.cloud9.ap-northeast-3.amazonaws.com", "webview-assets.cloud9.ap-northeast-3.amazonaws.com", "webview-assets.aws-cloud9.ap-south-1.amazonaws.com", "vfs.cloud9.ap-south-1.amazonaws.com", "webview-assets.cloud9.ap-south-1.amazonaws.com", "webview-assets.aws-cloud9.ap-southeast-1.amazonaws.com", "vfs.cloud9.ap-southeast-1.amazonaws.com", "webview-assets.cloud9.ap-southeast-1.amazonaws.com", "webview-assets.aws-cloud9.ap-southeast-2.amazonaws.com", "vfs.cloud9.ap-southeast-2.amazonaws.com", "webview-assets.cloud9.ap-southeast-2.amazonaws.com", "webview-assets.aws-cloud9.ca-central-1.amazonaws.com", "vfs.cloud9.ca-central-1.amazonaws.com", "webview-assets.cloud9.ca-central-1.amazonaws.com", "webview-assets.aws-cloud9.eu-central-1.amazonaws.com", "vfs.cloud9.eu-central-1.amazonaws.com", "webview-assets.cloud9.eu-central-1.amazonaws.com", "webview-assets.aws-cloud9.eu-north-1.amazonaws.com", "vfs.cloud9.eu-north-1.amazonaws.com", "webview-assets.cloud9.eu-north-1.amazonaws.com", "webview-assets.aws-cloud9.eu-south-1.amazonaws.com", "vfs.cloud9.eu-south-1.amazonaws.com", "webview-assets.cloud9.eu-south-1.amazonaws.com", "webview-assets.aws-cloud9.eu-west-1.amazonaws.com", "vfs.cloud9.eu-west-1.amazonaws.com", "webview-assets.cloud9.eu-west-1.amazonaws.com", "webview-assets.aws-cloud9.eu-west-2.amazonaws.com", "vfs.cloud9.eu-west-2.amazonaws.com", "webview-assets.cloud9.eu-west-2.amazonaws.com", "webview-assets.aws-cloud9.eu-west-3.amazonaws.com", "vfs.cloud9.eu-west-3.amazonaws.com", "webview-assets.cloud9.eu-west-3.amazonaws.com", "webview-assets.aws-cloud9.il-central-1.amazonaws.com", "vfs.cloud9.il-central-1.amazonaws.com", "webview-assets.aws-cloud9.me-south-1.amazonaws.com", "vfs.cloud9.me-south-1.amazonaws.com", "webview-assets.cloud9.me-south-1.amazonaws.com", "webview-assets.aws-cloud9.sa-east-1.amazonaws.com", "vfs.cloud9.sa-east-1.amazonaws.com", "webview-assets.cloud9.sa-east-1.amazonaws.com", "webview-assets.aws-cloud9.us-east-1.amazonaws.com", "vfs.cloud9.us-east-1.amazonaws.com", "webview-assets.cloud9.us-east-1.amazonaws.com", "webview-assets.aws-cloud9.us-east-2.amazonaws.com", "vfs.cloud9.us-east-2.amazonaws.com", "webview-assets.cloud9.us-east-2.amazonaws.com", "webview-assets.aws-cloud9.us-west-1.amazonaws.com", "vfs.cloud9.us-west-1.amazonaws.com", "webview-assets.cloud9.us-west-1.amazonaws.com", "webview-assets.aws-cloud9.us-west-2.amazonaws.com", "vfs.cloud9.us-west-2.amazonaws.com", "webview-assets.cloud9.us-west-2.amazonaws.com", "awsapps.com", "cn-north-1.eb.amazonaws.com.cn", "cn-northwest-1.eb.amazonaws.com.cn", "elasticbeanstalk.com", "af-south-1.elasticbeanstalk.com", "ap-east-1.elasticbeanstalk.com", "ap-northeast-1.elasticbeanstalk.com", "ap-northeast-2.elasticbeanstalk.com", "ap-northeast-3.elasticbeanstalk.com", "ap-south-1.elasticbeanstalk.com", "ap-southeast-1.elasticbeanstalk.com", "ap-southeast-2.elasticbeanstalk.com", "ap-southeast-3.elasticbeanstalk.com", "ca-central-1.elasticbeanstalk.com", "eu-central-1.elasticbeanstalk.com", "eu-north-1.elasticbeanstalk.com", "eu-south-1.elasticbeanstalk.com", "eu-west-1.elasticbeanstalk.com", "eu-west-2.elasticbeanstalk.com", "eu-west-3.elasticbeanstalk.com", "il-central-1.elasticbeanstalk.com", "me-south-1.elasticbeanstalk.com", "sa-east-1.elasticbeanstalk.com", "us-east-1.elasticbeanstalk.com", "us-east-2.elasticbeanstalk.com", "us-gov-east-1.elasticbeanstalk.com", "us-gov-west-1.elasticbeanstalk.com", "us-west-1.elasticbeanstalk.com", "us-west-2.elasticbeanstalk.com", "*.elb.amazonaws.com.cn", "*.elb.amazonaws.com", "awsglobalaccelerator.com", "*.private.repost.aws", "eero.online", "eero-stage.online", "apigee.io", "panel.dev", "siiites.com", "appspacehosted.com", "appspaceusercontent.com", "appudo.net", "on-aptible.com", "f5.si", "arvanedge.ir", "user.aseinet.ne.jp", "gv.vc", "d.gv.vc", "user.party.eus", "pimienta.org", "poivron.org", "potager.org", "sweetpepper.org", "myasustor.com", "cdn.prod.atlassian-dev.net", "translated.page", "myfritz.link", "myfritz.net", "onavstack.net", "*.awdev.ca", "*.advisor.ws", "ecommerce-shop.pl", "b-data.io", "balena-devices.com", "base.ec", "official.ec", "buyshop.jp", "fashionstore.jp", "handcrafted.jp", "kawaiishop.jp", "supersale.jp", "theshop.jp", "shopselect.net", "base.shop", "beagleboard.io", "*.beget.app", "pages.gay", "bnr.la", "bitbucket.io", "blackbaudcdn.net", "of.je", "bluebite.io", "boomla.net", "boutir.com", "boxfuse.io", "square7.ch", "bplaced.com", "bplaced.de", "square7.de", "bplaced.net", "square7.net", "*.s.brave.io", "shop.brendly.hr", "shop.brendly.rs", "browsersafetymark.io", "radio.am", "radio.fm", "uk0.bigv.io", "dh.bytemark.co.uk", "vm.bytemark.co.uk", "cafjs.com", "canva-apps.cn", "*.my.canvasite.cn", "canva-apps.com", "*.my.canva.site", "drr.ac", "uwu.ai", "carrd.co", "crd.co", "ju.mp", "api.gov.uk", "cdn77-storage.com", "rsc.contentproxy9.cz", "r.cdn77.net", "cdn77-ssl.net", "c.cdn77.org", "rsc.cdn77.org", "ssl.origin.cdn77-secure.org", "za.bz", "br.com", "cn.com", "de.com", "eu.com", "jpn.com", "mex.com", "ru.com", "sa.com", "uk.com", "us.com", "za.com", "com.de", "gb.net", "hu.net", "jp.net", "se.net", "uk.net", "ae.org", "com.se", "cx.ua", "discourse.group", "discourse.team", "clerk.app", "clerkstage.app", "*.lcl.dev", "*.lclstage.dev", "*.stg.dev", "*.stgstage.dev", "cleverapps.cc", "*.services.clever-cloud.com", "cleverapps.io", "cleverapps.tech", "clickrising.net", "cloudns.asia", "cloudns.be", "cloud-ip.biz", "cloudns.biz", "cloudns.cc", "cloudns.ch", "cloudns.cl", "cloudns.club", "dnsabr.com", "ip-ddns.com", "cloudns.cx", "cloudns.eu", "cloudns.in", "cloudns.info", "ddns-ip.net", "dns-cloud.net", "dns-dynamic.net", "cloudns.nz", "cloudns.org", "ip-dynamic.org", "cloudns.ph", "cloudns.pro", "cloudns.pw", "cloudns.us", "c66.me", "cloud66.ws", "cloud66.zone", "jdevcloud.com", "wpdevcloud.com", "cloudaccess.host", "freesite.host", "cloudaccess.net", "*.cloudera.site", "cf-ipfs.com", "cloudflare-ipfs.com", "trycloudflare.com", "pages.dev", "r2.dev", "workers.dev", "cloudflare.net", "cdn.cloudflare.net", "cdn.cloudflareanycast.net", "cdn.cloudflarecn.net", "cdn.cloudflareglobal.net", "cust.cloudscale.ch", "objects.lpg.cloudscale.ch", "objects.rma.cloudscale.ch", "wnext.app", "cnpy.gdn", "*.otap.co", "co.ca", "co.com", "codeberg.page", "csb.app", "preview.csb.app", "co.nl", "co.no", "webhosting.be", "hosting-cluster.nl", "ctfcloud.net", "convex.site", "ac.ru", "edu.ru", "gov.ru", "int.ru", "mil.ru", "test.ru", "dyn.cosidns.de", "dnsupdater.de", "dynamisches-dns.de", "internet-dns.de", "l-o-g-i-n.de", "dynamic-dns.info", "feste-ip.net", "knx-server.net", "static-access.net", "craft.me", "realm.cz", "on.crisp.email", "*.cryptonomic.net", "curv.dev", "cfolks.pl", "cyon.link", "cyon.site", "platform0.app", "fnwk.site", "folionetwork.site", "biz.dk", "co.dk", "firm.dk", "reg.dk", "store.dk", "dyndns.dappnode.io", "builtwithdark.com", "darklang.io", "demo.datadetect.com", "instance.datadetect.com", "edgestack.me", "dattolocal.com", "dattorelay.com", "dattoweb.com", "mydatto.com", "dattolocal.net", "mydatto.net", "ddnss.de", "dyn.ddnss.de", "dyndns.ddnss.de", "dyn-ip24.de", "dyndns1.de", "home-webserver.de", "dyn.home-webserver.de", "myhome-server.de", "ddnss.org", "debian.net", "definima.io", "definima.net", "deno.dev", "deno-staging.dev", "dedyn.io", "deta.app", "deta.dev", "dfirma.pl", "dkonto.pl", "you2.pl", "ondigitalocean.app", "*.digitaloceanspaces.com", "us.kg", "rss.my.id", "diher.solutions", "discordsays.com", "discordsez.com", "jozi.biz", "dnshome.de", "online.th", "shop.th", "drayddns.com", "shoparena.pl", "dreamhosters.com", "durumis.com", "mydrobo.com", "drud.io", "drud.us", "duckdns.org", "dy.fi", "tunk.org", "dyndns.biz", "for-better.biz", "for-more.biz", "for-some.biz", "for-the.biz", "selfip.biz", "webhop.biz", "ftpaccess.cc", "game-server.cc", "myphotos.cc", "scrapping.cc", "blogdns.com", "cechire.com", "dnsalias.com", "dnsdojo.com", "doesntexist.com", "dontexist.com", "doomdns.com", "dyn-o-saur.com", "dynalias.com", "dyndns-at-home.com", "dyndns-at-work.com", "dyndns-blog.com", "dyndns-free.com", "dyndns-home.com", "dyndns-ip.com", "dyndns-mail.com", "dyndns-office.com", "dyndns-pics.com", "dyndns-remote.com", "dyndns-server.com", "dyndns-web.com", "dyndns-wiki.com", "dyndns-work.com", "est-a-la-maison.com", "est-a-la-masion.com", "est-le-patron.com", "est-mon-blogueur.com", "from-ak.com", "from-al.com", "from-ar.com", "from-ca.com", "from-ct.com", "from-dc.com", "from-de.com", "from-fl.com", "from-ga.com", "from-hi.com", "from-ia.com", "from-id.com", "from-il.com", "from-in.com", "from-ks.com", "from-ky.com", "from-ma.com", "from-md.com", "from-mi.com", "from-mn.com", "from-mo.com", "from-ms.com", "from-mt.com", "from-nc.com", "from-nd.com", "from-ne.com", "from-nh.com", "from-nj.com", "from-nm.com", "from-nv.com", "from-oh.com", "from-ok.com", "from-or.com", "from-pa.com", "from-pr.com", "from-ri.com", "from-sc.com", "from-sd.com", "from-tn.com", "from-tx.com", "from-ut.com", "from-va.com", "from-vt.com", "from-wa.com", "from-wi.com", "from-wv.com", "from-wy.com", "getmyip.com", "gotdns.com", "hobby-site.com", "homelinux.com", "homeunix.com", "iamallama.com", "is-a-anarchist.com", "is-a-blogger.com", "is-a-bookkeeper.com", "is-a-bulls-fan.com", "is-a-caterer.com", "is-a-chef.com", "is-a-conservative.com", "is-a-cpa.com", "is-a-cubicle-slave.com", "is-a-democrat.com", "is-a-designer.com", "is-a-doctor.com", "is-a-financialadvisor.com", "is-a-geek.com", "is-a-green.com", "is-a-guru.com", "is-a-hard-worker.com", "is-a-hunter.com", "is-a-landscaper.com", "is-a-lawyer.com", "is-a-liberal.com", "is-a-libertarian.com", "is-a-llama.com", "is-a-musician.com", "is-a-nascarfan.com", "is-a-nurse.com", "is-a-painter.com", "is-a-personaltrainer.com", "is-a-photographer.com", "is-a-player.com", "is-a-republican.com", "is-a-rockstar.com", "is-a-socialist.com", "is-a-student.com", "is-a-teacher.com", "is-a-techie.com", "is-a-therapist.com", "is-an-accountant.com", "is-an-actor.com", "is-an-actress.com", "is-an-anarchist.com", "is-an-artist.com", "is-an-engineer.com", "is-an-entertainer.com", "is-certified.com", "is-gone.com", "is-into-anime.com", "is-into-cars.com", "is-into-cartoons.com", "is-into-games.com", "is-leet.com", "is-not-certified.com", "is-slick.com", "is-uberleet.com", "is-with-theband.com", "isa-geek.com", "isa-hockeynut.com", "issmarterthanyou.com", "likes-pie.com", "likescandy.com", "neat-url.com", "saves-the-whales.com", "selfip.com", "sells-for-less.com", "sells-for-u.com", "servebbs.com", "simple-url.com", "space-to-rent.com", "teaches-yoga.com", "writesthisblog.com", "ath.cx", "fuettertdasnetz.de", "isteingeek.de", "istmein.de", "lebtimnetz.de", "leitungsen.de", "traeumtgerade.de", "barrel-of-knowledge.info", "barrell-of-knowledge.info", "dyndns.info", "for-our.info", "groks-the.info", "groks-this.info", "here-for-more.info", "knowsitall.info", "selfip.info", "webhop.info", "forgot.her.name", "forgot.his.name", "at-band-camp.net", "blogdns.net", "broke-it.net", "buyshouses.net", "dnsalias.net", "dnsdojo.net", "does-it.net", "dontexist.net", "dynalias.net", "dynathome.net", "endofinternet.net", "from-az.net", "from-co.net", "from-la.net", "from-ny.net", "gets-it.net", "ham-radio-op.net", "homeftp.net", "homeip.net", "homelinux.net", "homeunix.net", "in-the-band.net", "is-a-chef.net", "is-a-geek.net", "isa-geek.net", "kicks-ass.net", "office-on-the.net", "podzone.net", "scrapper-site.net", "selfip.net", "sells-it.net", "servebbs.net", "serveftp.net", "thruhere.net", "webhop.net", "merseine.nu", "mine.nu", "shacknet.nu", "blogdns.org", "blogsite.org", "boldlygoingnowhere.org", "dnsalias.org", "dnsdojo.org", "doesntexist.org", "dontexist.org", "doomdns.org", "dvrdns.org", "dynalias.org", "dyndns.org", "go.dyndns.org", "home.dyndns.org", "endofinternet.org", "endoftheinternet.org", "from-me.org", "game-host.org", "gotdns.org", "hobby-site.org", "homedns.org", "homeftp.org", "homelinux.org", "homeunix.org", "is-a-bruinsfan.org", "is-a-candidate.org", "is-a-celticsfan.org", "is-a-chef.org", "is-a-geek.org", "is-a-knight.org", "is-a-linux-user.org", "is-a-patsfan.org", "is-a-soxfan.org", "is-found.org", "is-lost.org", "is-saved.org", "is-very-bad.org", "is-very-evil.org", "is-very-good.org", "is-very-nice.org", "is-very-sweet.org", "isa-geek.org", "kicks-ass.org", "misconfused.org", "podzone.org", "readmyblog.org", "selfip.org", "sellsyourhome.org", "servebbs.org", "serveftp.org", "servegame.org", "stuff-4-sale.org", "webhop.org", "better-than.tv", "dyndns.tv", "on-the-web.tv", "worse-than.tv", "is-by.us", "land-4-sale.us", "stuff-4-sale.us", "dyndns.ws", "mypets.ws", "ddnsfree.com", "ddnsgeek.com", "giize.com", "gleeze.com", "kozow.com", "loseyourip.com", "ooguy.com", "theworkpc.com", "casacam.net", "dynu.net", "accesscam.org", "camdvr.org", "freeddns.org", "mywire.org", "webredirect.org", "myddns.rocks", "dynv6.net", "e4.cz", "easypanel.app", "easypanel.host", "*.ewp.live", "twmail.cc", "twmail.net", "twmail.org", "mymailer.com.tw", "url.tw", "at.emf.camp", "rt.ht", "elementor.cloud", "elementor.cool", "en-root.fr", "mytuleap.com", "tuleap-partners.com", "encr.app", "encoreapi.com", "eu.encoway.cloud", "eu.org", "al.eu.org", "asso.eu.org", "at.eu.org", "au.eu.org", "be.eu.org", "bg.eu.org", "ca.eu.org", "cd.eu.org", "ch.eu.org", "cn.eu.org", "cy.eu.org", "cz.eu.org", "de.eu.org", "dk.eu.org", "edu.eu.org", "ee.eu.org", "es.eu.org", "fi.eu.org", "fr.eu.org", "gr.eu.org", "hr.eu.org", "hu.eu.org", "ie.eu.org", "il.eu.org", "in.eu.org", "int.eu.org", "is.eu.org", "it.eu.org", "jp.eu.org", "kr.eu.org", "lt.eu.org", "lu.eu.org", "lv.eu.org", "me.eu.org", "mk.eu.org", "mt.eu.org", "my.eu.org", "net.eu.org", "ng.eu.org", "nl.eu.org", "no.eu.org", "nz.eu.org", "pl.eu.org", "pt.eu.org", "ro.eu.org", "ru.eu.org", "se.eu.org", "si.eu.org", "sk.eu.org", "tr.eu.org", "uk.eu.org", "us.eu.org", "eurodir.ru", "eu-1.evennode.com", "eu-2.evennode.com", "eu-3.evennode.com", "eu-4.evennode.com", "us-1.evennode.com", "us-2.evennode.com", "us-3.evennode.com", "us-4.evennode.com", "relay.evervault.app", "relay.evervault.dev", "expo.app", "staging.expo.app", "onfabrica.com", "ru.net", "adygeya.ru", "bashkiria.ru", "bir.ru", "cbg.ru", "com.ru", "dagestan.ru", "grozny.ru", "kalmykia.ru", "kustanai.ru", "marine.ru", "mordovia.ru", "msk.ru", "mytis.ru", "nalchik.ru", "nov.ru", "pyatigorsk.ru", "spb.ru", "vladikavkaz.ru", "vladimir.ru", "abkhazia.su", "adygeya.su", "aktyubinsk.su", "arkhangelsk.su", "armenia.su", "ashgabad.su", "azerbaijan.su", "balashov.su", "bashkiria.su", "bryansk.su", "bukhara.su", "chimkent.su", "dagestan.su", "east-kazakhstan.su", "exnet.su", "georgia.su", "grozny.su", "ivanovo.su", "jambyl.su", "kalmykia.su", "kaluga.su", "karacol.su", "karaganda.su", "karelia.su", "khakassia.su", "krasnodar.su", "kurgan.su", "kustanai.su", "lenug.su", "mangyshlak.su", "mordovia.su", "msk.su", "murmansk.su", "nalchik.su", "navoi.su", "north-kazakhstan.su", "nov.su", "obninsk.su", "penza.su", "pokrovsk.su", "sochi.su", "spb.su", "tashkent.su", "termez.su", "togliatti.su", "troitsk.su", "tselinograd.su", "tula.su", "tuva.su", "vladikavkaz.su", "vladimir.su", "vologda.su", "channelsdvr.net", "u.channelsdvr.net", "edgecompute.app", "fastly-edge.com", "fastly-terrarium.com", "freetls.fastly.net", "map.fastly.net", "a.prod.fastly.net", "global.prod.fastly.net", "a.ssl.fastly.net", "b.ssl.fastly.net", "global.ssl.fastly.net", "fastlylb.net", "map.fastlylb.net", "*.user.fm", "fastvps-server.com", "fastvps.host", "myfast.host", "fastvps.site", "myfast.space", "conn.uk", "copro.uk", "hosp.uk", "fedorainfracloud.org", "fedorapeople.org", "cloud.fedoraproject.org", "app.os.fedoraproject.org", "app.os.stg.fedoraproject.org", "mydobiss.com", "fh-muenster.io", "filegear.me", "firebaseapp.com", "fldrv.com", "flutterflow.app", "fly.dev", "shw.io", "edgeapp.net", "forgeblocks.com", "id.forgerock.io", "framer.ai", "framer.app", "framercanvas.com", "framer.media", "framer.photos", "framer.website", "framer.wiki", "0e.vc", "freebox-os.com", "freeboxos.com", "fbx-os.fr", "fbxos.fr", "freebox-os.fr", "freeboxos.fr", "freedesktop.org", "freemyip.com", "*.frusky.de", "wien.funkfeuer.at", "daemon.asia", "dix.asia", "mydns.bz", "0am.jp", "0g0.jp", "0j0.jp", "0t0.jp", "mydns.jp", "pgw.jp", "wjg.jp", "keyword-on.net", "live-on.net", "server-on.net", "mydns.tw", "mydns.vc", "*.futurecms.at", "*.ex.futurecms.at", "*.in.futurecms.at", "futurehosting.at", "futuremailing.at", "*.ex.ortsinfo.at", "*.kunden.ortsinfo.at", "*.statics.cloud", "aliases121.com", "campaign.gov.uk", "service.gov.uk", "independent-commission.uk", "independent-inquest.uk", "independent-inquiry.uk", "independent-panel.uk", "independent-review.uk", "public-inquiry.uk", "royal-commission.uk", "gehirn.ne.jp", "usercontent.jp", "gentapps.com", "gentlentapis.com", "lab.ms", "cdn-edges.net", "localcert.net", "localhostcert.net", "gsj.bz", "githubusercontent.com", "githubpreview.dev", "github.io", "gitlab.io", "gitapp.si", "gitpage.si", "glitch.me", "nog.community", "co.ro", "shop.ro", "lolipop.io", "angry.jp", "babyblue.jp", "babymilk.jp", "backdrop.jp", "bambina.jp", "bitter.jp", "blush.jp", "boo.jp", "boy.jp", "boyfriend.jp", "but.jp", "candypop.jp", "capoo.jp", "catfood.jp", "cheap.jp", "chicappa.jp", "chillout.jp", "chips.jp", "chowder.jp", "chu.jp", "ciao.jp", "cocotte.jp", "coolblog.jp", "cranky.jp", "cutegirl.jp", "daa.jp", "deca.jp", "deci.jp", "digick.jp", "egoism.jp", "fakefur.jp", "fem.jp", "flier.jp", "floppy.jp", "fool.jp", "frenchkiss.jp", "girlfriend.jp", "girly.jp", "gloomy.jp", "gonna.jp", "greater.jp", "hacca.jp", "heavy.jp", "her.jp", "hiho.jp", "hippy.jp", "holy.jp", "hungry.jp", "icurus.jp", "itigo.jp", "jellybean.jp", "kikirara.jp", "kill.jp", "kilo.jp", "kuron.jp", "littlestar.jp", "lolipopmc.jp", "lolitapunk.jp", "lomo.jp", "lovepop.jp", "lovesick.jp", "main.jp", "mods.jp", "mond.jp", "mongolian.jp", "moo.jp", "namaste.jp", "nikita.jp", "nobushi.jp", "noor.jp", "oops.jp", "parallel.jp", "parasite.jp", "pecori.jp", "peewee.jp", "penne.jp", "pepper.jp", "perma.jp", "pigboat.jp", "pinoko.jp", "punyu.jp", "pupu.jp", "pussycat.jp", "pya.jp", "raindrop.jp", "readymade.jp", "sadist.jp", "schoolbus.jp", "secret.jp", "staba.jp", "stripper.jp", "sub.jp", "sunnyday.jp", "thick.jp", "tonkotsu.jp", "under.jp", "upper.jp", "velvet.jp", "verse.jp", "versus.jp", "vivian.jp", "watson.jp", "weblike.jp", "whitesnow.jp", "zombie.jp", "heteml.net", "graphic.design", "goip.de", "blogspot.ae", "blogspot.al", "blogspot.am", "*.hosted.app", "*.run.app", "web.app", "blogspot.com.ar", "blogspot.co.at", "blogspot.com.au", "blogspot.ba", "blogspot.be", "blogspot.bg", "blogspot.bj", "blogspot.com.br", "blogspot.com.by", "blogspot.ca", "blogspot.cf", "blogspot.ch", "blogspot.cl", "blogspot.com.co", "*.0emm.com", "appspot.com", "*.r.appspot.com", "blogspot.com", "codespot.com", "googleapis.com", "googlecode.com", "pagespeedmobilizer.com", "withgoogle.com", "withyoutube.com", "blogspot.cv", "blogspot.com.cy", "blogspot.cz", "blogspot.de", "*.gateway.dev", "blogspot.dk", "blogspot.com.ee", "blogspot.com.eg", "blogspot.com.es", "blogspot.fi", "blogspot.fr", "cloud.goog", "translate.goog", "*.usercontent.goog", "blogspot.gr", "blogspot.hk", "blogspot.hr", "blogspot.hu", "blogspot.co.id", "blogspot.ie", "blogspot.co.il", "blogspot.in", "blogspot.is", "blogspot.it", "blogspot.jp", "blogspot.co.ke", "blogspot.kr", "blogspot.li", "blogspot.lt", "blogspot.lu", "blogspot.md", "blogspot.mk", "blogspot.com.mt", "blogspot.mx", "blogspot.my", "cloudfunctions.net", "blogspot.com.ng", "blogspot.nl", "blogspot.no", "blogspot.co.nz", "blogspot.pe", "blogspot.pt", "blogspot.qa", "blogspot.re", "blogspot.ro", "blogspot.rs", "blogspot.ru", "blogspot.se", "blogspot.sg", "blogspot.si", "blogspot.sk", "blogspot.sn", "blogspot.td", "blogspot.com.tr", "blogspot.tw", "blogspot.ug", "blogspot.co.uk", "blogspot.com.uy", "blogspot.vn", "blogspot.co.za", "goupile.fr", "pymnt.uk", "cloudapps.digital", "london.cloudapps.digital", "gov.nl", "grafana-dev.net", "grayjayleagues.com", "günstigbestellen.de", "günstigliefern.de", "fin.ci", "free.hr", "caa.li", "ua.rs", "conf.se", "häkkinen.fi", "hrsn.dev", "hashbang.sh", "hasura.app", "hasura-app.io", "hatenablog.com", "hatenadiary.com", "hateblo.jp", "hatenablog.jp", "hatenadiary.jp", "hatenadiary.org", "pages.it.hs-heilbronn.de", "pages-research.it.hs-heilbronn.de", "heiyu.space", "helioho.st", "heliohost.us", "hepforge.org", "herokuapp.com", "herokussl.com", "heyflow.page", "heyflow.site", "ravendb.cloud", "ravendb.community", "development.run", "ravendb.run", "homesklep.pl", "*.kin.one", "*.id.pub", "*.kin.pub", "secaas.hk", "hoplix.shop", "orx.biz", "biz.gl", "biz.ng", "co.biz.ng", "dl.biz.ng", "go.biz.ng", "lg.biz.ng", "on.biz.ng", "col.ng", "firm.ng", "gen.ng", "ltd.ng", "ngo.ng", "plc.ng", "ie.ua", "hostyhosting.io", "hf.space", "static.hf.space", "hypernode.io", "iobb.net", "co.cz", "*.moonscale.io", "moonscale.net", "gr.com", "iki.fi", "ibxos.it", "iliadboxos.it", "smushcdn.com", "wphostedmail.com", "wpmucdn.com", "tempurl.host", "wpmudev.host", "dyn-berlin.de", "in-berlin.de", "in-brb.de", "in-butter.de", "in-dsl.de", "in-vpn.de", "in-dsl.net", "in-vpn.net", "in-dsl.org", "in-vpn.org", "biz.at", "info.at", "info.cx", "ac.leg.br", "al.leg.br", "am.leg.br", "ap.leg.br", "ba.leg.br", "ce.leg.br", "df.leg.br", "es.leg.br", "go.leg.br", "ma.leg.br", "mg.leg.br", "ms.leg.br", "mt.leg.br", "pa.leg.br", "pb.leg.br", "pe.leg.br", "pi.leg.br", "pr.leg.br", "rj.leg.br", "rn.leg.br", "ro.leg.br", "rr.leg.br", "rs.leg.br", "sc.leg.br", "se.leg.br", "sp.leg.br", "to.leg.br", "pixolino.com", "na4u.ru", "apps-1and1.com", "live-website.com", "apps-1and1.net", "websitebuilder.online", "app-ionos.space", "iopsys.se", "*.dweb.link", "ipifony.net", "ir.md", "is-a-good.dev", "is-a.dev", "iservschule.de", "mein-iserv.de", "schulplattform.de", "schulserver.de", "test-iserv.de", "iserv.dev", "mel.cloudlets.com.au", "cloud.interhostsolutions.be", "alp1.ae.flow.ch", "appengine.flow.ch", "es-1.axarnet.cloud", "diadem.cloud", "vip.jelastic.cloud", "jele.cloud", "it1.eur.aruba.jenv-aruba.cloud", "it1.jenv-aruba.cloud", "keliweb.cloud", "cs.keliweb.cloud", "oxa.cloud", "tn.oxa.cloud", "uk.oxa.cloud", "primetel.cloud", "uk.primetel.cloud", "ca.reclaim.cloud", "uk.reclaim.cloud", "us.reclaim.cloud", "ch.trendhosting.cloud", "de.trendhosting.cloud", "jele.club", "dopaas.com", "paas.hosted-by-previder.com", "rag-cloud.hosteur.com", "rag-cloud-ch.hosteur.com", "jcloud.ik-server.com", "jcloud-ver-jpc.ik-server.com", "demo.jelastic.com", "paas.massivegrid.com", "jed.wafaicloud.com", "ryd.wafaicloud.com", "j.scaleforce.com.cy", "jelastic.dogado.eu", "fi.cloudplatform.fi", "demo.datacenter.fi", "paas.datacenter.fi", "jele.host", "mircloud.host", "paas.beebyte.io", "sekd1.beebyteapp.io", "jele.io", "jc.neen.it", "jcloud.kz", "cloudjiffy.net", "fra1-de.cloudjiffy.net", "west1-us.cloudjiffy.net", "jls-sto1.elastx.net", "jls-sto2.elastx.net", "jls-sto3.elastx.net", "fr-1.paas.massivegrid.net", "lon-1.paas.massivegrid.net", "lon-2.paas.massivegrid.net", "ny-1.paas.massivegrid.net", "ny-2.paas.massivegrid.net", "sg-1.paas.massivegrid.net", "jelastic.saveincloud.net", "nordeste-idc.saveincloud.net", "j.scaleforce.net", "sdscloud.pl", "unicloud.pl", "mircloud.ru", "enscaled.sg", "jele.site", "jelastic.team", "orangecloud.tn", "j.layershift.co.uk", "phx.enscaled.us", "mircloud.us", "myjino.ru", "*.hosting.myjino.ru", "*.landing.myjino.ru", "*.spectrum.myjino.ru", "*.vps.myjino.ru", "jotelulu.cloud", "webadorsite.com", "jouwweb.site", "*.cns.joyent.com", "*.triton.zone", "js.org", "kaas.gg", "khplay.nl", "kapsi.fi", "ezproxy.kuleuven.be", "kuleuven.cloud", "keymachine.de", "kinghost.net", "uni5.net", "knightpoint.systems", "koobin.events", "webthings.io", "krellian.net", "oya.to", "git-repos.de", "lcube-server.de", "svn-repos.de", "leadpages.co", "lpages.co", "lpusercontent.com", "lelux.site", "libp2p.direct", "runcontainers.dev", "co.business", "co.education", "co.events", "co.financial", "co.network", "co.place", "co.technology", "linkyard-cloud.ch", "linkyard.cloud", "members.linode.com", "*.nodebalancer.linode.com", "*.linodeobjects.com", "ip.linodeusercontent.com", "we.bs", "filegear-sg.me", "ggff.net", "*.user.localcert.dev", "lodz.pl", "pabianice.pl", "plock.pl", "sieradz.pl", "skierniewice.pl", "zgierz.pl", "loginline.app", "loginline.dev", "loginline.io", "loginline.services", "loginline.site", "lohmus.me", "servers.run", "krasnik.pl", "leczna.pl", "lubartow.pl", "lublin.pl", "poniatowa.pl", "swidnik.pl", "glug.org.uk", "lug.org.uk", "lugs.org.uk", "barsy.bg", "barsy.club", "barsycenter.com", "barsyonline.com", "barsy.de", "barsy.dev", "barsy.eu", "barsy.gr", "barsy.in", "barsy.info", "barsy.io", "barsy.me", "barsy.menu", "barsyonline.menu", "barsy.mobi", "barsy.net", "barsy.online", "barsy.org", "barsy.pro", "barsy.pub", "barsy.ro", "barsy.rs", "barsy.shop", "barsyonline.shop", "barsy.site", "barsy.store", "barsy.support", "barsy.uk", "barsy.co.uk", "barsyonline.co.uk", "*.magentosite.cloud", "hb.cldmail.ru", "matlab.cloud", "modelscape.com", "mwcloudnonprod.com", "polyspace.com", "mayfirst.info", "mayfirst.org", "mazeplay.com", "mcdir.me", "mcdir.ru", "vps.mcdir.ru", "mcpre.ru", "mediatech.by", "mediatech.dev", "hra.health", "medusajs.app", "miniserver.com", "memset.net", "messerli.app", "atmeta.com", "apps.fbsbx.com", "*.cloud.metacentrum.cz", "custom.metacentrum.cz", "flt.cloud.muni.cz", "usr.cloud.muni.cz", "meteorapp.com", "eu.meteorapp.com", "co.pl", "*.azurecontainer.io", "azure-api.net", "azure-mobile.net", "azureedge.net", "azurefd.net", "azurestaticapps.net", "1.azurestaticapps.net", "2.azurestaticapps.net", "3.azurestaticapps.net", "4.azurestaticapps.net", "5.azurestaticapps.net", "6.azurestaticapps.net", "7.azurestaticapps.net", "centralus.azurestaticapps.net", "eastasia.azurestaticapps.net", "eastus2.azurestaticapps.net", "westeurope.azurestaticapps.net", "westus2.azurestaticapps.net", "azurewebsites.net", "cloudapp.net", "trafficmanager.net", "blob.core.windows.net", "servicebus.windows.net", "routingthecloud.com", "sn.mynetname.net", "routingthecloud.net", "routingthecloud.org", "csx.cc", "mydbserver.com", "webspaceconfig.de", "mittwald.info", "mittwaldserver.info", "typo3server.info", "project.space", "modx.dev", "bmoattachments.org", "net.ru", "org.ru", "pp.ru", "hostedpi.com", "caracal.mythic-beasts.com", "customer.mythic-beasts.com", "fentiger.mythic-beasts.com", "lynx.mythic-beasts.com", "ocelot.mythic-beasts.com", "oncilla.mythic-beasts.com", "onza.mythic-beasts.com", "sphinx.mythic-beasts.com", "vs.mythic-beasts.com", "x.mythic-beasts.com", "yali.mythic-beasts.com", "cust.retrosnub.co.uk", "ui.nabu.casa", "cloud.nospamproxy.com", "netfy.app", "netlify.app", "4u.com", "nfshost.com", "ipfs.nftstorage.link", "ngo.us", "ngrok.app", "ngrok-free.app", "ngrok.dev", "ngrok-free.dev", "ngrok.io", "ap.ngrok.io", "au.ngrok.io", "eu.ngrok.io", "in.ngrok.io", "jp.ngrok.io", "sa.ngrok.io", "us.ngrok.io", "ngrok.pizza", "ngrok.pro", "torun.pl", "nh-serv.co.uk", "nimsite.uk", "mmafan.biz", "myftp.biz", "no-ip.biz", "no-ip.ca", "fantasyleague.cc", "gotdns.ch", "3utilities.com", "blogsyte.com", "ciscofreak.com", "damnserver.com", "ddnsking.com", "ditchyourip.com", "dnsiskinky.com", "dynns.com", "geekgalaxy.com", "health-carereform.com", "homesecuritymac.com", "homesecuritypc.com", "myactivedirectory.com", "mysecuritycamera.com", "myvnc.com", "net-freaks.com", "onthewifi.com", "point2this.com", "quicksytes.com", "securitytactics.com", "servebeer.com", "servecounterstrike.com", "serveexchange.com", "serveftp.com", "servegame.com", "servehalflife.com", "servehttp.com", "servehumour.com", "serveirc.com", "servemp3.com", "servep2p.com", "servepics.com", "servequake.com", "servesarcasm.com", "stufftoread.com", "unusualperson.com", "workisboring.com", "dvrcam.info", "ilovecollege.info", "no-ip.info", "brasilia.me", "ddns.me", "dnsfor.me", "hopto.me", "loginto.me", "noip.me", "webhop.me", "bounceme.net", "ddns.net", "eating-organic.net", "mydissent.net", "myeffect.net", "mymediapc.net", "mypsx.net", "mysecuritycamera.net", "nhlfan.net", "no-ip.net", "pgafan.net", "privatizehealthinsurance.net", "redirectme.net", "serveblog.net", "serveminecraft.net", "sytes.net", "cable-modem.org", "collegefan.org", "couchpotatofries.org", "hopto.org", "mlbfan.org", "myftp.org", "mysecuritycamera.org", "nflfan.org", "no-ip.org", "read-books.org", "ufcfan.org", "zapto.org", "no-ip.co.uk", "golffan.us", "noip.us", "pointto.us", "stage.nodeart.io", "*.developer.app", "noop.app", "*.northflank.app", "*.build.run", "*.code.run", "*.database.run", "*.migration.run", "noticeable.news", "notion.site", "dnsking.ch", "mypi.co", "n4t.co", "001www.com", "myiphost.com", "forumz.info", "soundcast.me", "tcp4.me", "dnsup.net", "hicam.net", "now-dns.net", "ownip.net", "vpndns.net", "dynserv.org", "now-dns.org", "x443.pw", "now-dns.top", "ntdll.top", "freeddns.us", "nsupdate.info", "nerdpol.ovh", "nyc.mn", "prvcy.page", "obl.ong", "observablehq.cloud", "static.observableusercontent.com", "omg.lol", "cloudycluster.net", "omniwe.site", "123webseite.at", "123website.be", "simplesite.com.br", "123website.ch", "simplesite.com", "123webseite.de", "123hjemmeside.dk", "123miweb.es", "123kotisivu.fi", "123siteweb.fr", "simplesite.gr", "123homepage.it", "123website.lu", "123website.nl", "123hjemmeside.no", "service.one", "simplesite.pl", "123paginaweb.pt", "123minsida.se", "is-a-fullstack.dev", "is-cool.dev", "is-not-a.dev", "localplayer.dev", "is-local.org", "opensocial.site", "opencraft.hosting", "16-b.it", "32-b.it", "64-b.it", "orsites.com", "operaunite.com", "*.customer-oci.com", "*.oci.customer-oci.com", "*.ocp.customer-oci.com", "*.ocs.customer-oci.com", "*.oraclecloudapps.com", "*.oraclegovcloudapps.com", "*.oraclegovcloudapps.uk", "tech.orange", "can.re", "authgear-staging.com", "authgearapps.com", "skygearapp.com", "outsystemscloud.com", "*.hosting.ovh.net", "*.webpaas.ovh.net", "ownprovider.com", "own.pm", "*.owo.codes", "ox.rs", "oy.lc", "pgfog.com", "pagexl.com", "gotpantheon.com", "pantheonsite.io", "*.paywhirl.com", "*.xmit.co", "xmit.dev", "madethis.site", "srv.us", "gh.srv.us", "gl.srv.us", "lk3.ru", "mypep.link", "perspecta.cloud", "on-web.fr", "*.upsun.app", "upsunapp.com", "ent.platform.sh", "eu.platform.sh", "us.platform.sh", "*.platformsh.site", "*.tst.site", "platter-app.com", "platter-app.dev", "platterp.us", "pley.games", "onporter.run", "co.bn", "postman-echo.com", "pstmn.io", "mock.pstmn.io", "httpbin.org", "prequalifyme.today", "xen.prgmr.com", "priv.at", "protonet.io", "chirurgiens-dentistes-en-france.fr", "byen.site", "pubtls.org", "pythonanywhere.com", "eu.pythonanywhere.com", "qa2.com", "qcx.io", "*.sys.qcx.io", "myqnapcloud.cn", "alpha-myqnapcloud.com", "dev-myqnapcloud.com", "mycloudnas.com", "mynascloud.com", "myqnapcloud.com", "qoto.io", "qualifioapp.com", "ladesk.com", "qbuser.com", "*.quipelements.com", "vapor.cloud", "vaporcloud.io", "rackmaze.com", "rackmaze.net", "cloudsite.builders", "myradweb.net", "servername.us", "web.in", "in.net", "myrdbx.io", "site.rb-hosting.io", "*.on-rancher.cloud", "*.on-k3s.io", "*.on-rio.io", "ravpage.co.il", "readthedocs-hosted.com", "readthedocs.io", "rhcloud.com", "instances.spawn.cc", "onrender.com", "app.render.com", "replit.app", "id.replit.app", "firewalledreplit.co", "id.firewalledreplit.co", "repl.co", "id.repl.co", "replit.dev", "archer.replit.dev", "bones.replit.dev", "canary.replit.dev", "global.replit.dev", "hacker.replit.dev", "id.replit.dev", "janeway.replit.dev", "kim.replit.dev", "kira.replit.dev", "kirk.replit.dev", "odo.replit.dev", "paris.replit.dev", "picard.replit.dev", "pike.replit.dev", "prerelease.replit.dev", "reed.replit.dev", "riker.replit.dev", "sisko.replit.dev", "spock.replit.dev", "staging.replit.dev", "sulu.replit.dev", "tarpit.replit.dev", "teams.replit.dev", "tucker.replit.dev", "wesley.replit.dev", "worf.replit.dev", "repl.run", "resindevice.io", "devices.resinstaging.io", "hzc.io", "adimo.co.uk", "itcouldbewor.se", "aus.basketball", "nz.basketball", "git-pages.rit.edu", "rocky.page", "rub.de", "ruhr-uni-bochum.de", "io.noc.ruhr-uni-bochum.de", "биз.рус", "ком.рус", "крым.рус", "мир.рус", "мск.рус", "орг.рус", "самара.рус", "сочи.рус", "спб.рус", "я.рус", "ras.ru", "nyat.app", "180r.com", "dojin.com", "sakuratan.com", "sakuraweb.com", "x0.com", "2-d.jp", "bona.jp", "crap.jp", "daynight.jp", "eek.jp", "flop.jp", "halfmoon.jp", "jeez.jp", "matrix.jp", "mimoza.jp", "ivory.ne.jp", "mail-box.ne.jp", "mints.ne.jp", "mokuren.ne.jp", "opal.ne.jp", "sakura.ne.jp", "sumomo.ne.jp", "topaz.ne.jp", "netgamers.jp", "nyanta.jp", "o0o0.jp", "rdy.jp", "rgr.jp", "rulez.jp", "s3.isk01.sakurastorage.jp", "s3.isk02.sakurastorage.jp", "saloon.jp", "sblo.jp", "skr.jp", "tank.jp", "uh-oh.jp", "undo.jp", "rs.webaccel.jp", "user.webaccel.jp", "websozai.jp", "xii.jp", "squares.net", "jpn.org", "kirara.st", "x0.to", "from.tv", "sakura.tv", "*.builder.code.com", "*.dev-builder.code.com", "*.stg-builder.code.com", "*.001.test.code-builder-stg.platform.salesforce.com", "*.d.crm.dev", "*.w.crm.dev", "*.wa.crm.dev", "*.wb.crm.dev", "*.wc.crm.dev", "*.wd.crm.dev", "*.we.crm.dev", "*.wf.crm.dev", "sandcats.io", "logoip.com", "logoip.de", "fr-par-1.baremetal.scw.cloud", "fr-par-2.baremetal.scw.cloud", "nl-ams-1.baremetal.scw.cloud", "cockpit.fr-par.scw.cloud", "fnc.fr-par.scw.cloud", "functions.fnc.fr-par.scw.cloud", "k8s.fr-par.scw.cloud", "nodes.k8s.fr-par.scw.cloud", "s3.fr-par.scw.cloud", "s3-website.fr-par.scw.cloud", "whm.fr-par.scw.cloud", "priv.instances.scw.cloud", "pub.instances.scw.cloud", "k8s.scw.cloud", "cockpit.nl-ams.scw.cloud", "k8s.nl-ams.scw.cloud", "nodes.k8s.nl-ams.scw.cloud", "s3.nl-ams.scw.cloud", "s3-website.nl-ams.scw.cloud", "whm.nl-ams.scw.cloud", "cockpit.pl-waw.scw.cloud", "k8s.pl-waw.scw.cloud", "nodes.k8s.pl-waw.scw.cloud", "s3.pl-waw.scw.cloud", "s3-website.pl-waw.scw.cloud", "scalebook.scw.cloud", "smartlabeling.scw.cloud", "dedibox.fr", "schokokeks.net", "gov.scot", "service.gov.scot", "scrysec.com", "client.scrypted.io", "firewall-gateway.com", "firewall-gateway.de", "my-gateway.de", "my-router.de", "spdns.de", "spdns.eu", "firewall-gateway.net", "my-firewall.org", "myfirewall.org", "spdns.org", "seidat.net", "sellfy.store", "minisite.ms", "senseering.net", "servebolt.cloud", "biz.ua", "co.ua", "pp.ua", "as.sh.cn", "sheezy.games", "shiftedit.io", "myshopblocks.com", "myshopify.com", "shopitsite.com", "shopware.shop", "shopware.store", "mo-siemens.io", "1kapp.com", "appchizi.com", "applinzi.com", "sinaapp.com", "vipsinaapp.com", "siteleaf.net", "small-web.org", "aeroport.fr", "avocat.fr", "chambagri.fr", "chirurgiens-dentistes.fr", "experts-comptables.fr", "medecin.fr", "notaires.fr", "pharmacien.fr", "port.fr", "veterinaire.fr", "vp4.me", "*.snowflake.app", "*.privatelink.snowflake.app", "streamlit.app", "streamlitapp.com", "try-snowplow.com", "mafelo.net", "playstation-cloud.com", "srht.site", "apps.lair.io", "*.stolos.io", "spacekit.io", "ind.mom", "customer.speedpartner.de", "myspreadshop.at", "myspreadshop.com.au", "myspreadshop.be", "myspreadshop.ca", "myspreadshop.ch", "myspreadshop.com", "myspreadshop.de", "myspreadshop.dk", "myspreadshop.es", "myspreadshop.fi", "myspreadshop.fr", "myspreadshop.ie", "myspreadshop.it", "myspreadshop.net", "myspreadshop.nl", "myspreadshop.no", "myspreadshop.pl", "myspreadshop.se", "myspreadshop.co.uk", "w-corp-staticblitz.com", "w-credentialless-staticblitz.com", "w-staticblitz.com", "stackhero-network.com", "runs.onstackit.cloud", "stackit.gg", "stackit.rocks", "stackit.run", "stackit.zone", "musician.io", "novecore.site", "api.stdlib.com", "feedback.ac", "forms.ac", "assessments.cx", "calculators.cx", "funnels.cx", "paynow.cx", "quizzes.cx", "researched.cx", "tests.cx", "surveys.so", "storebase.store", "storipress.app", "storj.farm", "strapiapp.com", "media.strapiapp.com", "vps-host.net", "atl.jelastic.vps-host.net", "njs.jelastic.vps-host.net", "ric.jelastic.vps-host.net", "streak-link.com", "streaklinks.com", "streakusercontent.com", "soc.srcf.net", "user.srcf.net", "utwente.io", "temp-dns.com", "supabase.co", "supabase.in", "supabase.net", "syncloud.it", "dscloud.biz", "direct.quickconnect.cn", "dsmynas.com", "familyds.com", "diskstation.me", "dscloud.me", "i234.me", "myds.me", "synology.me", "dscloud.mobi", "dsmynas.net", "familyds.net", "dsmynas.org", "familyds.org", "direct.quickconnect.to", "vpnplus.to", "mytabit.com", "mytabit.co.il", "tabitorder.co.il", "taifun-dns.de", "ts.net", "*.c.ts.net", "gda.pl", "gdansk.pl", "gdynia.pl", "med.pl", "sopot.pl", "taveusercontent.com", "p.tawk.email", "p.tawkto.email", "site.tb-hosting.com", "edugit.io", "s3.teckids.org", "telebit.app", "telebit.io", "*.telebit.xyz", "*.firenet.ch", "*.svc.firenet.ch", "reservd.com", "thingdustdata.com", "cust.dev.thingdust.io", "reservd.dev.thingdust.io", "cust.disrec.thingdust.io", "reservd.disrec.thingdust.io", "cust.prod.thingdust.io", "cust.testing.thingdust.io", "reservd.testing.thingdust.io", "tickets.io", "arvo.network", "azimuth.network", "tlon.network", "torproject.net", "pages.torproject.net", "townnews-staging.com", "12hp.at", "2ix.at", "4lima.at", "lima-city.at", "12hp.ch", "2ix.ch", "4lima.ch", "lima-city.ch", "trafficplex.cloud", "de.cool", "12hp.de", "2ix.de", "4lima.de", "lima-city.de", "1337.pictures", "clan.rip", "lima-city.rocks", "webspace.rocks", "lima.zone", "*.transurl.be", "*.transurl.eu", "site.transip.me", "*.transurl.nl", "tuxfamily.org", "dd-dns.de", "dray-dns.de", "draydns.de", "dyn-vpn.de", "dynvpn.de", "mein-vigor.de", "my-vigor.de", "my-wan.de", "syno-ds.de", "synology-diskstation.de", "synology-ds.de", "diskstation.eu", "diskstation.org", "typedream.app", "pro.typeform.com", "*.uberspace.de", "uber.space", "hk.com", "inc.hk", "ltd.hk", "hk.org", "it.com", "unison-services.cloud", "virtual-user.de", "virtualuser.de", "name.pm", "sch.tf", "biz.wf", "sch.wf", "org.yt", "rs.ba", "bielsko.pl", "upli.io", "urown.cloud", "dnsupdate.info", "us.org", "v.ua", "express.val.run", "web.val.run", "vercel.app", "v0.build", "vercel.dev", "vusercontent.net", "now.sh", "2038.io", "router.management", "v-info.info", "voorloper.cloud", "*.vultrobjects.com", "wafflecell.com", "webflow.io", "webflowtest.io", "*.webhare.dev", "bookonline.app", "hotelwithflight.com", "reserve-online.com", "reserve-online.net", "cprapid.com", "pleskns.com", "wp2.host", "pdns.page", "plesk.page", "wpsquared.site", "*.wadl.top", "remotewd.com", "box.ca", "pages.wiardweb.com", "toolforge.org", "wmcloud.org", "wmflabs.org", "wdh.app", "panel.gg", "daemon.panel.gg", "wixsite.com", "wixstudio.com", "editorx.io", "wixstudio.io", "wix.run", "messwithdns.com", "woltlab-demo.com", "myforum.community", "community-pro.de", "diskussionsbereich.de", "community-pro.net", "meinforum.net", "affinitylottery.org.uk", "raffleentry.org.uk", "weeklylottery.org.uk", "wpenginepowered.com", "js.wpenginepowered.com", "half.host", "xnbay.com", "u2.xnbay.com", "u2-local.xnbay.com", "cistron.nl", "demon.nl", "xs4all.space", "yandexcloud.net", "storage.yandexcloud.net", "website.yandexcloud.net", "official.academy", "yolasite.com", "yombo.me", "ynh.fr", "nohost.me", "noho.st", "za.net", "za.org", "zap.cloud", "zeabur.app", "bss.design", "basicserver.io", "virtualserver.io", "enterprisecloud.nu"];
    var Z = Y.reduce((e, s) => {
      const c = s.replace(/^(\*\.|\!)/, ""), o = A.toASCII(c), t = s.charAt(0);
      if (e.has(o)) throw new Error(`Multiple rules found for ${s} (${o})`);
      return e.set(o, { rule: s, suffix: c, punySuffix: o, wildcard: t === "*", exception: t === "!" }), e;
    }, /* @__PURE__ */ new Map());
    var aa = (e) => {
      const c = A.toASCII(e).split(".");
      for (let o = 0; o < c.length; o++) {
        const t = c.slice(o).join("."), d = Z.get(t);
        if (d) return d;
      }
      return null;
    };
    var H = { DOMAIN_TOO_SHORT: "Domain name too short.", DOMAIN_TOO_LONG: "Domain name too long. It should be no more than 255 chars.", LABEL_STARTS_WITH_DASH: "Domain name label can not start with a dash.", LABEL_ENDS_WITH_DASH: "Domain name label can not end with a dash.", LABEL_TOO_LONG: "Domain name label should be at most 63 chars long.", LABEL_TOO_SHORT: "Domain name label should be at least 1 character long.", LABEL_INVALID_CHARS: "Domain name label can only contain alphanumeric characters or dashes." };
    var oa = (e) => {
      const s = A.toASCII(e);
      if (s.length < 1) return "DOMAIN_TOO_SHORT";
      if (s.length > 255) return "DOMAIN_TOO_LONG";
      const c = s.split(".");
      let o;
      for (let t = 0; t < c.length; ++t) {
        if (o = c[t], !o.length) return "LABEL_TOO_SHORT";
        if (o.length > 63) return "LABEL_TOO_LONG";
        if (o.charAt(0) === "-") return "LABEL_STARTS_WITH_DASH";
        if (o.charAt(o.length - 1) === "-") return "LABEL_ENDS_WITH_DASH";
        if (!/^[a-z0-9\-_]+$/.test(o)) return "LABEL_INVALID_CHARS";
      }
    };
    var _ = (e) => {
      if (typeof e != "string") throw new TypeError("Domain name must be a string.");
      let s = e.slice(0).toLowerCase();
      s.charAt(s.length - 1) === "." && (s = s.slice(0, s.length - 1));
      const c = oa(s);
      if (c) return { input: e, error: { message: H[c], code: c } };
      const o = { input: e, tld: null, sld: null, domain: null, subdomain: null, listed: false }, t = s.split(".");
      if (t[t.length - 1] === "local") return o;
      const d = () => (/xn--/.test(s) && (o.domain && (o.domain = A.toASCII(o.domain)), o.subdomain && (o.subdomain = A.toASCII(o.subdomain))), o), z = aa(s);
      if (!z) return t.length < 2 ? o : (o.tld = t.pop(), o.sld = t.pop(), o.domain = [o.sld, o.tld].join("."), t.length && (o.subdomain = t.pop()), d());
      o.listed = true;
      const y = z.suffix.split("."), g = t.slice(0, t.length - y.length);
      return z.exception && g.push(y.shift()), o.tld = y.join("."), !g.length || (z.wildcard && (y.unshift(g.pop()), o.tld = y.join(".")), !g.length) || (o.sld = g.pop(), o.domain = [o.sld, o.tld].join("."), g.length && (o.subdomain = g.join("."))), d();
    };
    var N = (e) => e && _(e).domain || null;
    var R = (e) => {
      const s = _(e);
      return !!(s.domain && s.listed);
    };
    var sa = { parse: _, get: N, isValid: R };
    exports2.default = sa;
    exports2.errorCodes = H;
    exports2.get = N;
    exports2.isValid = R;
    exports2.parse = _;
  }
});

// ../../../node_modules/tough-cookie/lib/pubsuffix-psl.js
var require_pubsuffix_psl = __commonJS({
  "../../../node_modules/tough-cookie/lib/pubsuffix-psl.js"(exports2) {
    "use strict";
    var psl = require_psl();
    var SPECIAL_USE_DOMAINS = [
      "local",
      "example",
      "invalid",
      "localhost",
      "test"
    ];
    var SPECIAL_TREATMENT_DOMAINS = ["localhost", "invalid"];
    function getPublicSuffix(domain, options = {}) {
      const domainParts = domain.split(".");
      const topLevelDomain = domainParts[domainParts.length - 1];
      const allowSpecialUseDomain = !!options.allowSpecialUseDomain;
      const ignoreError = !!options.ignoreError;
      if (allowSpecialUseDomain && SPECIAL_USE_DOMAINS.includes(topLevelDomain)) {
        if (domainParts.length > 1) {
          const secondLevelDomain = domainParts[domainParts.length - 2];
          return `${secondLevelDomain}.${topLevelDomain}`;
        } else if (SPECIAL_TREATMENT_DOMAINS.includes(topLevelDomain)) {
          return `${topLevelDomain}`;
        }
      }
      if (!ignoreError && SPECIAL_USE_DOMAINS.includes(topLevelDomain)) {
        throw new Error(
          `Cookie has domain set to the public suffix "${topLevelDomain}" which is a special use domain. To allow this, configure your CookieJar with {allowSpecialUseDomain:true, rejectPublicSuffixes: false}.`
        );
      }
      return psl.get(domain);
    }
    exports2.getPublicSuffix = getPublicSuffix;
  }
});

// ../../../node_modules/tough-cookie/lib/store.js
var require_store = __commonJS({
  "../../../node_modules/tough-cookie/lib/store.js"(exports2) {
    "use strict";
    var Store = class {
      constructor() {
        this.synchronous = false;
      }
      findCookie(domain, path, key, cb) {
        throw new Error("findCookie is not implemented");
      }
      findCookies(domain, path, allowSpecialUseDomain, cb) {
        throw new Error("findCookies is not implemented");
      }
      putCookie(cookie, cb) {
        throw new Error("putCookie is not implemented");
      }
      updateCookie(oldCookie, newCookie, cb) {
        throw new Error("updateCookie is not implemented");
      }
      removeCookie(domain, path, key, cb) {
        throw new Error("removeCookie is not implemented");
      }
      removeCookies(domain, path, cb) {
        throw new Error("removeCookies is not implemented");
      }
      removeAllCookies(cb) {
        throw new Error("removeAllCookies is not implemented");
      }
      getAllCookies(cb) {
        throw new Error(
          "getAllCookies is not implemented (therefore jar cannot be serialized)"
        );
      }
    };
    exports2.Store = Store;
  }
});

// ../../../node_modules/universalify/index.js
var require_universalify = __commonJS({
  "../../../node_modules/universalify/index.js"(exports2) {
    "use strict";
    exports2.fromCallback = function(fn) {
      return Object.defineProperty(function() {
        if (typeof arguments[arguments.length - 1] === "function") fn.apply(this, arguments);
        else {
          return new Promise((resolve, reject) => {
            arguments[arguments.length] = (err, res) => {
              if (err) return reject(err);
              resolve(res);
            };
            arguments.length++;
            fn.apply(this, arguments);
          });
        }
      }, "name", { value: fn.name });
    };
    exports2.fromPromise = function(fn) {
      return Object.defineProperty(function() {
        const cb = arguments[arguments.length - 1];
        if (typeof cb !== "function") return fn.apply(this, arguments);
        else {
          delete arguments[arguments.length - 1];
          arguments.length--;
          fn.apply(this, arguments).then((r) => cb(null, r), cb);
        }
      }, "name", { value: fn.name });
    };
  }
});

// ../../../node_modules/tough-cookie/lib/permuteDomain.js
var require_permuteDomain = __commonJS({
  "../../../node_modules/tough-cookie/lib/permuteDomain.js"(exports2) {
    "use strict";
    var pubsuffix = require_pubsuffix_psl();
    function permuteDomain(domain, allowSpecialUseDomain) {
      const pubSuf = pubsuffix.getPublicSuffix(domain, {
        allowSpecialUseDomain
      });
      if (!pubSuf) {
        return null;
      }
      if (pubSuf == domain) {
        return [domain];
      }
      if (domain.slice(-1) == ".") {
        domain = domain.slice(0, -1);
      }
      const prefix = domain.slice(0, -(pubSuf.length + 1));
      const parts = prefix.split(".").reverse();
      let cur = pubSuf;
      const permutations = [cur];
      while (parts.length) {
        cur = `${parts.shift()}.${cur}`;
        permutations.push(cur);
      }
      return permutations;
    }
    exports2.permuteDomain = permuteDomain;
  }
});

// ../../../node_modules/tough-cookie/lib/pathMatch.js
var require_pathMatch = __commonJS({
  "../../../node_modules/tough-cookie/lib/pathMatch.js"(exports2) {
    "use strict";
    function pathMatch(reqPath, cookiePath) {
      if (cookiePath === reqPath) {
        return true;
      }
      const idx = reqPath.indexOf(cookiePath);
      if (idx === 0) {
        if (cookiePath.substr(-1) === "/") {
          return true;
        }
        if (reqPath.substr(cookiePath.length, 1) === "/") {
          return true;
        }
      }
      return false;
    }
    exports2.pathMatch = pathMatch;
  }
});

// ../../../node_modules/tough-cookie/lib/utilHelper.js
var require_utilHelper = __commonJS({
  "../../../node_modules/tough-cookie/lib/utilHelper.js"(exports2) {
    function requireUtil() {
      try {
        return require_util();
      } catch (e) {
        return null;
      }
    }
    function lookupCustomInspectSymbol() {
      return Symbol.for("nodejs.util.inspect.custom");
    }
    function tryReadingCustomSymbolFromUtilInspect(options) {
      const _requireUtil = options.requireUtil || requireUtil;
      const util = _requireUtil();
      return util ? util.inspect.custom : null;
    }
    exports2.getUtilInspect = function getUtilInspect(fallback, options = {}) {
      const _requireUtil = options.requireUtil || requireUtil;
      const util = _requireUtil();
      return function inspect(value, showHidden, depth) {
        return util ? util.inspect(value, showHidden, depth) : fallback(value);
      };
    };
    exports2.getCustomInspectSymbol = function getCustomInspectSymbol(options = {}) {
      const _lookupCustomInspectSymbol = options.lookupCustomInspectSymbol || lookupCustomInspectSymbol;
      return _lookupCustomInspectSymbol() || tryReadingCustomSymbolFromUtilInspect(options);
    };
  }
});

// ../../../node_modules/tough-cookie/lib/memstore.js
var require_memstore = __commonJS({
  "../../../node_modules/tough-cookie/lib/memstore.js"(exports2) {
    "use strict";
    var { fromCallback } = require_universalify();
    var Store = require_store().Store;
    var permuteDomain = require_permuteDomain().permuteDomain;
    var pathMatch = require_pathMatch().pathMatch;
    var { getCustomInspectSymbol, getUtilInspect } = require_utilHelper();
    var MemoryCookieStore = class extends Store {
      constructor() {
        super();
        this.synchronous = true;
        this.idx = /* @__PURE__ */ Object.create(null);
        const customInspectSymbol = getCustomInspectSymbol();
        if (customInspectSymbol) {
          this[customInspectSymbol] = this.inspect;
        }
      }
      inspect() {
        const util = { inspect: getUtilInspect(inspectFallback) };
        return `{ idx: ${util.inspect(this.idx, false, 2)} }`;
      }
      findCookie(domain, path, key, cb) {
        if (!this.idx[domain]) {
          return cb(null, void 0);
        }
        if (!this.idx[domain][path]) {
          return cb(null, void 0);
        }
        return cb(null, this.idx[domain][path][key] || null);
      }
      findCookies(domain, path, allowSpecialUseDomain, cb) {
        const results = [];
        if (typeof allowSpecialUseDomain === "function") {
          cb = allowSpecialUseDomain;
          allowSpecialUseDomain = true;
        }
        if (!domain) {
          return cb(null, []);
        }
        let pathMatcher;
        if (!path) {
          pathMatcher = function matchAll(domainIndex) {
            for (const curPath in domainIndex) {
              const pathIndex = domainIndex[curPath];
              for (const key in pathIndex) {
                results.push(pathIndex[key]);
              }
            }
          };
        } else {
          pathMatcher = function matchRFC(domainIndex) {
            Object.keys(domainIndex).forEach((cookiePath) => {
              if (pathMatch(path, cookiePath)) {
                const pathIndex = domainIndex[cookiePath];
                for (const key in pathIndex) {
                  results.push(pathIndex[key]);
                }
              }
            });
          };
        }
        const domains = permuteDomain(domain, allowSpecialUseDomain) || [domain];
        const idx = this.idx;
        domains.forEach((curDomain) => {
          const domainIndex = idx[curDomain];
          if (!domainIndex) {
            return;
          }
          pathMatcher(domainIndex);
        });
        cb(null, results);
      }
      putCookie(cookie, cb) {
        if (!this.idx[cookie.domain]) {
          this.idx[cookie.domain] = /* @__PURE__ */ Object.create(null);
        }
        if (!this.idx[cookie.domain][cookie.path]) {
          this.idx[cookie.domain][cookie.path] = /* @__PURE__ */ Object.create(null);
        }
        this.idx[cookie.domain][cookie.path][cookie.key] = cookie;
        cb(null);
      }
      updateCookie(oldCookie, newCookie, cb) {
        this.putCookie(newCookie, cb);
      }
      removeCookie(domain, path, key, cb) {
        if (this.idx[domain] && this.idx[domain][path] && this.idx[domain][path][key]) {
          delete this.idx[domain][path][key];
        }
        cb(null);
      }
      removeCookies(domain, path, cb) {
        if (this.idx[domain]) {
          if (path) {
            delete this.idx[domain][path];
          } else {
            delete this.idx[domain];
          }
        }
        return cb(null);
      }
      removeAllCookies(cb) {
        this.idx = /* @__PURE__ */ Object.create(null);
        return cb(null);
      }
      getAllCookies(cb) {
        const cookies = [];
        const idx = this.idx;
        const domains = Object.keys(idx);
        domains.forEach((domain) => {
          const paths = Object.keys(idx[domain]);
          paths.forEach((path) => {
            const keys = Object.keys(idx[domain][path]);
            keys.forEach((key) => {
              if (key !== null) {
                cookies.push(idx[domain][path][key]);
              }
            });
          });
        });
        cookies.sort((a, b) => {
          return (a.creationIndex || 0) - (b.creationIndex || 0);
        });
        cb(null, cookies);
      }
    };
    [
      "findCookie",
      "findCookies",
      "putCookie",
      "updateCookie",
      "removeCookie",
      "removeCookies",
      "removeAllCookies",
      "getAllCookies"
    ].forEach((name) => {
      MemoryCookieStore.prototype[name] = fromCallback(
        MemoryCookieStore.prototype[name]
      );
    });
    exports2.MemoryCookieStore = MemoryCookieStore;
    function inspectFallback(val) {
      const domains = Object.keys(val);
      if (domains.length === 0) {
        return "[Object: null prototype] {}";
      }
      let result = "[Object: null prototype] {\n";
      Object.keys(val).forEach((domain, i) => {
        result += formatDomain(domain, val[domain]);
        if (i < domains.length - 1) {
          result += ",";
        }
        result += "\n";
      });
      result += "}";
      return result;
    }
    function formatDomain(domainName, domainValue) {
      const indent = "  ";
      let result = `${indent}'${domainName}': [Object: null prototype] {
`;
      Object.keys(domainValue).forEach((path, i, paths) => {
        result += formatPath(path, domainValue[path]);
        if (i < paths.length - 1) {
          result += ",";
        }
        result += "\n";
      });
      result += `${indent}}`;
      return result;
    }
    function formatPath(pathName, pathValue) {
      const indent = "    ";
      let result = `${indent}'${pathName}': [Object: null prototype] {
`;
      Object.keys(pathValue).forEach((cookieName, i, cookieNames) => {
        const cookie = pathValue[cookieName];
        result += `      ${cookieName}: ${cookie.inspect()}`;
        if (i < cookieNames.length - 1) {
          result += ",";
        }
        result += "\n";
      });
      result += `${indent}}`;
      return result;
    }
    exports2.inspectFallback = inspectFallback;
  }
});

// ../../../node_modules/tough-cookie/lib/validators.js
var require_validators = __commonJS({
  "../../../node_modules/tough-cookie/lib/validators.js"(exports2) {
    "use strict";
    var toString = Object.prototype.toString;
    function isFunction(data) {
      return typeof data === "function";
    }
    function isNonEmptyString(data) {
      return isString(data) && data !== "";
    }
    function isDate(data) {
      return isInstanceStrict(data, Date) && isInteger(data.getTime());
    }
    function isEmptyString(data) {
      return data === "" || data instanceof String && data.toString() === "";
    }
    function isString(data) {
      return typeof data === "string" || data instanceof String;
    }
    function isObject(data) {
      return toString.call(data) === "[object Object]";
    }
    function isInstanceStrict(data, prototype) {
      try {
        return data instanceof prototype;
      } catch (error2) {
        return false;
      }
    }
    function isUrlStringOrObject(data) {
      return isNonEmptyString(data) || isObject(data) && "hostname" in data && "pathname" in data && "protocol" in data || isInstanceStrict(data, URL);
    }
    function isInteger(data) {
      return typeof data === "number" && data % 1 === 0;
    }
    function validate(bool, cb, options) {
      if (!isFunction(cb)) {
        options = cb;
        cb = null;
      }
      if (!isObject(options)) options = { Error: "Failed Check" };
      if (!bool) {
        if (cb) {
          cb(new ParameterError(options));
        } else {
          throw new ParameterError(options);
        }
      }
    }
    var ParameterError = class extends Error {
      constructor(...params) {
        super(...params);
      }
    };
    exports2.ParameterError = ParameterError;
    exports2.isFunction = isFunction;
    exports2.isNonEmptyString = isNonEmptyString;
    exports2.isDate = isDate;
    exports2.isEmptyString = isEmptyString;
    exports2.isString = isString;
    exports2.isObject = isObject;
    exports2.isUrlStringOrObject = isUrlStringOrObject;
    exports2.validate = validate;
  }
});

// ../../../node_modules/tough-cookie/lib/version.js
var require_version = __commonJS({
  "../../../node_modules/tough-cookie/lib/version.js"(exports2, module2) {
    module2.exports = "4.1.4";
  }
});

// ../../../node_modules/tough-cookie/lib/cookie.js
var require_cookie = __commonJS({
  "../../../node_modules/tough-cookie/lib/cookie.js"(exports2) {
    "use strict";
    var punycode2 = (init_punycode_es6(), __toCommonJS(punycode_es6_exports));
    var urlParse = require_url_parse();
    var pubsuffix = require_pubsuffix_psl();
    var Store = require_store().Store;
    var MemoryCookieStore = require_memstore().MemoryCookieStore;
    var pathMatch = require_pathMatch().pathMatch;
    var validators = require_validators();
    var VERSION = require_version();
    var { fromCallback } = require_universalify();
    var { getCustomInspectSymbol } = require_utilHelper();
    var COOKIE_OCTETS = /^[\x21\x23-\x2B\x2D-\x3A\x3C-\x5B\x5D-\x7E]+$/;
    var CONTROL_CHARS = /[\x00-\x1F]/;
    var TERMINATORS = ["\n", "\r", "\0"];
    var PATH_VALUE = /[\x20-\x3A\x3C-\x7E]+/;
    var DATE_DELIM = /[\x09\x20-\x2F\x3B-\x40\x5B-\x60\x7B-\x7E]/;
    var MONTH_TO_NUM = {
      jan: 0,
      feb: 1,
      mar: 2,
      apr: 3,
      may: 4,
      jun: 5,
      jul: 6,
      aug: 7,
      sep: 8,
      oct: 9,
      nov: 10,
      dec: 11
    };
    var MAX_TIME = 2147483647e3;
    var MIN_TIME = 0;
    var SAME_SITE_CONTEXT_VAL_ERR = 'Invalid sameSiteContext option for getCookies(); expected one of "strict", "lax", or "none"';
    function checkSameSiteContext(value) {
      validators.validate(validators.isNonEmptyString(value), value);
      const context = String(value).toLowerCase();
      if (context === "none" || context === "lax" || context === "strict") {
        return context;
      } else {
        return null;
      }
    }
    var PrefixSecurityEnum = Object.freeze({
      SILENT: "silent",
      STRICT: "strict",
      DISABLED: "unsafe-disabled"
    });
    var IP_REGEX_LOWERCASE = /(?:^(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}$)|(?:^(?:(?:[a-f\d]{1,4}:){7}(?:[a-f\d]{1,4}|:)|(?:[a-f\d]{1,4}:){6}(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|:[a-f\d]{1,4}|:)|(?:[a-f\d]{1,4}:){5}(?::(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,2}|:)|(?:[a-f\d]{1,4}:){4}(?:(?::[a-f\d]{1,4}){0,1}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,3}|:)|(?:[a-f\d]{1,4}:){3}(?:(?::[a-f\d]{1,4}){0,2}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,4}|:)|(?:[a-f\d]{1,4}:){2}(?:(?::[a-f\d]{1,4}){0,3}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,5}|:)|(?:[a-f\d]{1,4}:){1}(?:(?::[a-f\d]{1,4}){0,4}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,6}|:)|(?::(?:(?::[a-f\d]{1,4}){0,5}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,7}|:)))$)/;
    var IP_V6_REGEX = `
\\[?(?:
(?:[a-fA-F\\d]{1,4}:){7}(?:[a-fA-F\\d]{1,4}|:)|
(?:[a-fA-F\\d]{1,4}:){6}(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|:[a-fA-F\\d]{1,4}|:)|
(?:[a-fA-F\\d]{1,4}:){5}(?::(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,2}|:)|
(?:[a-fA-F\\d]{1,4}:){4}(?:(?::[a-fA-F\\d]{1,4}){0,1}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,3}|:)|
(?:[a-fA-F\\d]{1,4}:){3}(?:(?::[a-fA-F\\d]{1,4}){0,2}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,4}|:)|
(?:[a-fA-F\\d]{1,4}:){2}(?:(?::[a-fA-F\\d]{1,4}){0,3}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,5}|:)|
(?:[a-fA-F\\d]{1,4}:){1}(?:(?::[a-fA-F\\d]{1,4}){0,4}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,6}|:)|
(?::(?:(?::[a-fA-F\\d]{1,4}){0,5}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,7}|:))
)(?:%[0-9a-zA-Z]{1,})?\\]?
`.replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
    var IP_V6_REGEX_OBJECT = new RegExp(`^${IP_V6_REGEX}$`);
    function parseDigits(token, minDigits, maxDigits, trailingOK) {
      let count = 0;
      while (count < token.length) {
        const c = token.charCodeAt(count);
        if (c <= 47 || c >= 58) {
          break;
        }
        count++;
      }
      if (count < minDigits || count > maxDigits) {
        return null;
      }
      if (!trailingOK && count != token.length) {
        return null;
      }
      return parseInt(token.substr(0, count), 10);
    }
    function parseTime(token) {
      const parts = token.split(":");
      const result = [0, 0, 0];
      if (parts.length !== 3) {
        return null;
      }
      for (let i = 0; i < 3; i++) {
        const trailingOK = i == 2;
        const num = parseDigits(parts[i], 1, 2, trailingOK);
        if (num === null) {
          return null;
        }
        result[i] = num;
      }
      return result;
    }
    function parseMonth(token) {
      token = String(token).substr(0, 3).toLowerCase();
      const num = MONTH_TO_NUM[token];
      return num >= 0 ? num : null;
    }
    function parseDate(str) {
      if (!str) {
        return;
      }
      const tokens = str.split(DATE_DELIM);
      if (!tokens) {
        return;
      }
      let hour = null;
      let minute = null;
      let second = null;
      let dayOfMonth = null;
      let month = null;
      let year = null;
      for (let i = 0; i < tokens.length; i++) {
        const token = tokens[i].trim();
        if (!token.length) {
          continue;
        }
        let result;
        if (second === null) {
          result = parseTime(token);
          if (result) {
            hour = result[0];
            minute = result[1];
            second = result[2];
            continue;
          }
        }
        if (dayOfMonth === null) {
          result = parseDigits(token, 1, 2, true);
          if (result !== null) {
            dayOfMonth = result;
            continue;
          }
        }
        if (month === null) {
          result = parseMonth(token);
          if (result !== null) {
            month = result;
            continue;
          }
        }
        if (year === null) {
          result = parseDigits(token, 2, 4, true);
          if (result !== null) {
            year = result;
            if (year >= 70 && year <= 99) {
              year += 1900;
            } else if (year >= 0 && year <= 69) {
              year += 2e3;
            }
          }
        }
      }
      if (dayOfMonth === null || month === null || year === null || second === null || dayOfMonth < 1 || dayOfMonth > 31 || year < 1601 || hour > 23 || minute > 59 || second > 59) {
        return;
      }
      return new Date(Date.UTC(year, month, dayOfMonth, hour, minute, second));
    }
    function formatDate(date) {
      validators.validate(validators.isDate(date), date);
      return date.toUTCString();
    }
    function canonicalDomain(str) {
      if (str == null) {
        return null;
      }
      str = str.trim().replace(/^\./, "");
      if (IP_V6_REGEX_OBJECT.test(str)) {
        str = str.replace("[", "").replace("]", "");
      }
      if (punycode2 && /[^\u0001-\u007f]/.test(str)) {
        str = punycode2.toASCII(str);
      }
      return str.toLowerCase();
    }
    function domainMatch(str, domStr, canonicalize) {
      if (str == null || domStr == null) {
        return null;
      }
      if (canonicalize !== false) {
        str = canonicalDomain(str);
        domStr = canonicalDomain(domStr);
      }
      if (str == domStr) {
        return true;
      }
      const idx = str.lastIndexOf(domStr);
      if (idx <= 0) {
        return false;
      }
      if (str.length !== domStr.length + idx) {
        return false;
      }
      if (str.substr(idx - 1, 1) !== ".") {
        return false;
      }
      if (IP_REGEX_LOWERCASE.test(str)) {
        return false;
      }
      return true;
    }
    function defaultPath(path) {
      if (!path || path.substr(0, 1) !== "/") {
        return "/";
      }
      if (path === "/") {
        return path;
      }
      const rightSlash = path.lastIndexOf("/");
      if (rightSlash === 0) {
        return "/";
      }
      return path.slice(0, rightSlash);
    }
    function trimTerminator(str) {
      if (validators.isEmptyString(str)) return str;
      for (let t = 0; t < TERMINATORS.length; t++) {
        const terminatorIdx = str.indexOf(TERMINATORS[t]);
        if (terminatorIdx !== -1) {
          str = str.substr(0, terminatorIdx);
        }
      }
      return str;
    }
    function parseCookiePair(cookiePair, looseMode) {
      cookiePair = trimTerminator(cookiePair);
      validators.validate(validators.isString(cookiePair), cookiePair);
      let firstEq = cookiePair.indexOf("=");
      if (looseMode) {
        if (firstEq === 0) {
          cookiePair = cookiePair.substr(1);
          firstEq = cookiePair.indexOf("=");
        }
      } else {
        if (firstEq <= 0) {
          return;
        }
      }
      let cookieName, cookieValue;
      if (firstEq <= 0) {
        cookieName = "";
        cookieValue = cookiePair.trim();
      } else {
        cookieName = cookiePair.substr(0, firstEq).trim();
        cookieValue = cookiePair.substr(firstEq + 1).trim();
      }
      if (CONTROL_CHARS.test(cookieName) || CONTROL_CHARS.test(cookieValue)) {
        return;
      }
      const c = new Cookie();
      c.key = cookieName;
      c.value = cookieValue;
      return c;
    }
    function parse(str, options) {
      if (!options || typeof options !== "object") {
        options = {};
      }
      if (validators.isEmptyString(str) || !validators.isString(str)) {
        return null;
      }
      str = str.trim();
      const firstSemi = str.indexOf(";");
      const cookiePair = firstSemi === -1 ? str : str.substr(0, firstSemi);
      const c = parseCookiePair(cookiePair, !!options.loose);
      if (!c) {
        return;
      }
      if (firstSemi === -1) {
        return c;
      }
      const unparsed = str.slice(firstSemi + 1).trim();
      if (unparsed.length === 0) {
        return c;
      }
      const cookie_avs = unparsed.split(";");
      while (cookie_avs.length) {
        const av = cookie_avs.shift().trim();
        if (av.length === 0) {
          continue;
        }
        const av_sep = av.indexOf("=");
        let av_key, av_value;
        if (av_sep === -1) {
          av_key = av;
          av_value = null;
        } else {
          av_key = av.substr(0, av_sep);
          av_value = av.substr(av_sep + 1);
        }
        av_key = av_key.trim().toLowerCase();
        if (av_value) {
          av_value = av_value.trim();
        }
        switch (av_key) {
          case "expires":
            if (av_value) {
              const exp = parseDate(av_value);
              if (exp) {
                c.expires = exp;
              }
            }
            break;
          case "max-age":
            if (av_value) {
              if (/^-?[0-9]+$/.test(av_value)) {
                const delta = parseInt(av_value, 10);
                c.setMaxAge(delta);
              }
            }
            break;
          case "domain":
            if (av_value) {
              const domain = av_value.trim().replace(/^\./, "");
              if (domain) {
                c.domain = domain.toLowerCase();
              }
            }
            break;
          case "path":
            c.path = av_value && av_value[0] === "/" ? av_value : null;
            break;
          case "secure":
            c.secure = true;
            break;
          case "httponly":
            c.httpOnly = true;
            break;
          case "samesite":
            const enforcement = av_value ? av_value.toLowerCase() : "";
            switch (enforcement) {
              case "strict":
                c.sameSite = "strict";
                break;
              case "lax":
                c.sameSite = "lax";
                break;
              case "none":
                c.sameSite = "none";
                break;
              default:
                c.sameSite = void 0;
                break;
            }
            break;
          default:
            c.extensions = c.extensions || [];
            c.extensions.push(av);
            break;
        }
      }
      return c;
    }
    function isSecurePrefixConditionMet(cookie) {
      validators.validate(validators.isObject(cookie), cookie);
      return !cookie.key.startsWith("__Secure-") || cookie.secure;
    }
    function isHostPrefixConditionMet(cookie) {
      validators.validate(validators.isObject(cookie));
      return !cookie.key.startsWith("__Host-") || cookie.secure && cookie.hostOnly && cookie.path != null && cookie.path === "/";
    }
    function jsonParse(str) {
      let obj;
      try {
        obj = JSON.parse(str);
      } catch (e) {
        return e;
      }
      return obj;
    }
    function fromJSON(str) {
      if (!str || validators.isEmptyString(str)) {
        return null;
      }
      let obj;
      if (typeof str === "string") {
        obj = jsonParse(str);
        if (obj instanceof Error) {
          return null;
        }
      } else {
        obj = str;
      }
      const c = new Cookie();
      for (let i = 0; i < Cookie.serializableProperties.length; i++) {
        const prop = Cookie.serializableProperties[i];
        if (obj[prop] === void 0 || obj[prop] === cookieDefaults[prop]) {
          continue;
        }
        if (prop === "expires" || prop === "creation" || prop === "lastAccessed") {
          if (obj[prop] === null) {
            c[prop] = null;
          } else {
            c[prop] = obj[prop] == "Infinity" ? "Infinity" : new Date(obj[prop]);
          }
        } else {
          c[prop] = obj[prop];
        }
      }
      return c;
    }
    function cookieCompare(a, b) {
      validators.validate(validators.isObject(a), a);
      validators.validate(validators.isObject(b), b);
      let cmp = 0;
      const aPathLen = a.path ? a.path.length : 0;
      const bPathLen = b.path ? b.path.length : 0;
      cmp = bPathLen - aPathLen;
      if (cmp !== 0) {
        return cmp;
      }
      const aTime = a.creation ? a.creation.getTime() : MAX_TIME;
      const bTime = b.creation ? b.creation.getTime() : MAX_TIME;
      cmp = aTime - bTime;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = a.creationIndex - b.creationIndex;
      return cmp;
    }
    function permutePath(path) {
      validators.validate(validators.isString(path));
      if (path === "/") {
        return ["/"];
      }
      const permutations = [path];
      while (path.length > 1) {
        const lindex = path.lastIndexOf("/");
        if (lindex === 0) {
          break;
        }
        path = path.substr(0, lindex);
        permutations.push(path);
      }
      permutations.push("/");
      return permutations;
    }
    function getCookieContext(url) {
      if (url instanceof Object) {
        return url;
      }
      try {
        url = decodeURI(url);
      } catch (err) {
      }
      return urlParse(url);
    }
    var cookieDefaults = {
      // the order in which the RFC has them:
      key: "",
      value: "",
      expires: "Infinity",
      maxAge: null,
      domain: null,
      path: null,
      secure: false,
      httpOnly: false,
      extensions: null,
      // set by the CookieJar:
      hostOnly: null,
      pathIsDefault: null,
      creation: null,
      lastAccessed: null,
      sameSite: void 0
    };
    var Cookie = class _Cookie {
      constructor(options = {}) {
        const customInspectSymbol = getCustomInspectSymbol();
        if (customInspectSymbol) {
          this[customInspectSymbol] = this.inspect;
        }
        Object.assign(this, cookieDefaults, options);
        this.creation = this.creation || /* @__PURE__ */ new Date();
        Object.defineProperty(this, "creationIndex", {
          configurable: false,
          enumerable: false,
          // important for assert.deepEqual checks
          writable: true,
          value: ++_Cookie.cookiesCreated
        });
      }
      inspect() {
        const now = Date.now();
        const hostOnly = this.hostOnly != null ? this.hostOnly : "?";
        const createAge = this.creation ? `${now - this.creation.getTime()}ms` : "?";
        const accessAge = this.lastAccessed ? `${now - this.lastAccessed.getTime()}ms` : "?";
        return `Cookie="${this.toString()}; hostOnly=${hostOnly}; aAge=${accessAge}; cAge=${createAge}"`;
      }
      toJSON() {
        const obj = {};
        for (const prop of _Cookie.serializableProperties) {
          if (this[prop] === cookieDefaults[prop]) {
            continue;
          }
          if (prop === "expires" || prop === "creation" || prop === "lastAccessed") {
            if (this[prop] === null) {
              obj[prop] = null;
            } else {
              obj[prop] = this[prop] == "Infinity" ? "Infinity" : this[prop].toISOString();
            }
          } else if (prop === "maxAge") {
            if (this[prop] !== null) {
              obj[prop] = this[prop] == Infinity || this[prop] == -Infinity ? this[prop].toString() : this[prop];
            }
          } else {
            if (this[prop] !== cookieDefaults[prop]) {
              obj[prop] = this[prop];
            }
          }
        }
        return obj;
      }
      clone() {
        return fromJSON(this.toJSON());
      }
      validate() {
        if (!COOKIE_OCTETS.test(this.value)) {
          return false;
        }
        if (this.expires != Infinity && !(this.expires instanceof Date) && !parseDate(this.expires)) {
          return false;
        }
        if (this.maxAge != null && this.maxAge <= 0) {
          return false;
        }
        if (this.path != null && !PATH_VALUE.test(this.path)) {
          return false;
        }
        const cdomain = this.cdomain();
        if (cdomain) {
          if (cdomain.match(/\.$/)) {
            return false;
          }
          const suffix = pubsuffix.getPublicSuffix(cdomain);
          if (suffix == null) {
            return false;
          }
        }
        return true;
      }
      setExpires(exp) {
        if (exp instanceof Date) {
          this.expires = exp;
        } else {
          this.expires = parseDate(exp) || "Infinity";
        }
      }
      setMaxAge(age) {
        if (age === Infinity || age === -Infinity) {
          this.maxAge = age.toString();
        } else {
          this.maxAge = age;
        }
      }
      cookieString() {
        let val = this.value;
        if (val == null) {
          val = "";
        }
        if (this.key === "") {
          return val;
        }
        return `${this.key}=${val}`;
      }
      // gives Set-Cookie header format
      toString() {
        let str = this.cookieString();
        if (this.expires != Infinity) {
          if (this.expires instanceof Date) {
            str += `; Expires=${formatDate(this.expires)}`;
          } else {
            str += `; Expires=${this.expires}`;
          }
        }
        if (this.maxAge != null && this.maxAge != Infinity) {
          str += `; Max-Age=${this.maxAge}`;
        }
        if (this.domain && !this.hostOnly) {
          str += `; Domain=${this.domain}`;
        }
        if (this.path) {
          str += `; Path=${this.path}`;
        }
        if (this.secure) {
          str += "; Secure";
        }
        if (this.httpOnly) {
          str += "; HttpOnly";
        }
        if (this.sameSite && this.sameSite !== "none") {
          const ssCanon = _Cookie.sameSiteCanonical[this.sameSite.toLowerCase()];
          str += `; SameSite=${ssCanon ? ssCanon : this.sameSite}`;
        }
        if (this.extensions) {
          this.extensions.forEach((ext) => {
            str += `; ${ext}`;
          });
        }
        return str;
      }
      // TTL() partially replaces the "expiry-time" parts of S5.3 step 3 (setCookie()
      // elsewhere)
      // S5.3 says to give the "latest representable date" for which we use Infinity
      // For "expired" we use 0
      TTL(now) {
        if (this.maxAge != null) {
          return this.maxAge <= 0 ? 0 : this.maxAge * 1e3;
        }
        let expires = this.expires;
        if (expires != Infinity) {
          if (!(expires instanceof Date)) {
            expires = parseDate(expires) || Infinity;
          }
          if (expires == Infinity) {
            return Infinity;
          }
          return expires.getTime() - (now || Date.now());
        }
        return Infinity;
      }
      // expiryTime() replaces the "expiry-time" parts of S5.3 step 3 (setCookie()
      // elsewhere)
      expiryTime(now) {
        if (this.maxAge != null) {
          const relativeTo = now || this.creation || /* @__PURE__ */ new Date();
          const age = this.maxAge <= 0 ? -Infinity : this.maxAge * 1e3;
          return relativeTo.getTime() + age;
        }
        if (this.expires == Infinity) {
          return Infinity;
        }
        return this.expires.getTime();
      }
      // expiryDate() replaces the "expiry-time" parts of S5.3 step 3 (setCookie()
      // elsewhere), except it returns a Date
      expiryDate(now) {
        const millisec = this.expiryTime(now);
        if (millisec == Infinity) {
          return new Date(MAX_TIME);
        } else if (millisec == -Infinity) {
          return new Date(MIN_TIME);
        } else {
          return new Date(millisec);
        }
      }
      // This replaces the "persistent-flag" parts of S5.3 step 3
      isPersistent() {
        return this.maxAge != null || this.expires != Infinity;
      }
      // Mostly S5.1.2 and S5.2.3:
      canonicalizedDomain() {
        if (this.domain == null) {
          return null;
        }
        return canonicalDomain(this.domain);
      }
      cdomain() {
        return this.canonicalizedDomain();
      }
    };
    Cookie.cookiesCreated = 0;
    Cookie.parse = parse;
    Cookie.fromJSON = fromJSON;
    Cookie.serializableProperties = Object.keys(cookieDefaults);
    Cookie.sameSiteLevel = {
      strict: 3,
      lax: 2,
      none: 1
    };
    Cookie.sameSiteCanonical = {
      strict: "Strict",
      lax: "Lax"
    };
    function getNormalizedPrefixSecurity(prefixSecurity) {
      if (prefixSecurity != null) {
        const normalizedPrefixSecurity = prefixSecurity.toLowerCase();
        switch (normalizedPrefixSecurity) {
          case PrefixSecurityEnum.STRICT:
          case PrefixSecurityEnum.SILENT:
          case PrefixSecurityEnum.DISABLED:
            return normalizedPrefixSecurity;
        }
      }
      return PrefixSecurityEnum.SILENT;
    }
    var CookieJar = class _CookieJar {
      constructor(store, options = { rejectPublicSuffixes: true }) {
        if (typeof options === "boolean") {
          options = { rejectPublicSuffixes: options };
        }
        validators.validate(validators.isObject(options), options);
        this.rejectPublicSuffixes = options.rejectPublicSuffixes;
        this.enableLooseMode = !!options.looseMode;
        this.allowSpecialUseDomain = typeof options.allowSpecialUseDomain === "boolean" ? options.allowSpecialUseDomain : true;
        this.store = store || new MemoryCookieStore();
        this.prefixSecurity = getNormalizedPrefixSecurity(options.prefixSecurity);
        this._cloneSync = syncWrap("clone");
        this._importCookiesSync = syncWrap("_importCookies");
        this.getCookiesSync = syncWrap("getCookies");
        this.getCookieStringSync = syncWrap("getCookieString");
        this.getSetCookieStringsSync = syncWrap("getSetCookieStrings");
        this.removeAllCookiesSync = syncWrap("removeAllCookies");
        this.setCookieSync = syncWrap("setCookie");
        this.serializeSync = syncWrap("serialize");
      }
      setCookie(cookie, url, options, cb) {
        validators.validate(validators.isUrlStringOrObject(url), cb, options);
        let err;
        if (validators.isFunction(url)) {
          cb = url;
          return cb(new Error("No URL was specified"));
        }
        const context = getCookieContext(url);
        if (validators.isFunction(options)) {
          cb = options;
          options = {};
        }
        validators.validate(validators.isFunction(cb), cb);
        if (!validators.isNonEmptyString(cookie) && !validators.isObject(cookie) && cookie instanceof String && cookie.length == 0) {
          return cb(null);
        }
        const host = canonicalDomain(context.hostname);
        const loose = options.loose || this.enableLooseMode;
        let sameSiteContext = null;
        if (options.sameSiteContext) {
          sameSiteContext = checkSameSiteContext(options.sameSiteContext);
          if (!sameSiteContext) {
            return cb(new Error(SAME_SITE_CONTEXT_VAL_ERR));
          }
        }
        if (typeof cookie === "string" || cookie instanceof String) {
          cookie = Cookie.parse(cookie, { loose });
          if (!cookie) {
            err = new Error("Cookie failed to parse");
            return cb(options.ignoreError ? null : err);
          }
        } else if (!(cookie instanceof Cookie)) {
          err = new Error(
            "First argument to setCookie must be a Cookie object or string"
          );
          return cb(options.ignoreError ? null : err);
        }
        const now = options.now || /* @__PURE__ */ new Date();
        if (this.rejectPublicSuffixes && cookie.domain) {
          const suffix = pubsuffix.getPublicSuffix(cookie.cdomain(), {
            allowSpecialUseDomain: this.allowSpecialUseDomain,
            ignoreError: options.ignoreError
          });
          if (suffix == null && !IP_V6_REGEX_OBJECT.test(cookie.domain)) {
            err = new Error("Cookie has domain set to a public suffix");
            return cb(options.ignoreError ? null : err);
          }
        }
        if (cookie.domain) {
          if (!domainMatch(host, cookie.cdomain(), false)) {
            err = new Error(
              `Cookie not in this host's domain. Cookie:${cookie.cdomain()} Request:${host}`
            );
            return cb(options.ignoreError ? null : err);
          }
          if (cookie.hostOnly == null) {
            cookie.hostOnly = false;
          }
        } else {
          cookie.hostOnly = true;
          cookie.domain = host;
        }
        if (!cookie.path || cookie.path[0] !== "/") {
          cookie.path = defaultPath(context.pathname);
          cookie.pathIsDefault = true;
        }
        if (options.http === false && cookie.httpOnly) {
          err = new Error("Cookie is HttpOnly and this isn't an HTTP API");
          return cb(options.ignoreError ? null : err);
        }
        if (cookie.sameSite !== "none" && cookie.sameSite !== void 0 && sameSiteContext) {
          if (sameSiteContext === "none") {
            err = new Error(
              "Cookie is SameSite but this is a cross-origin request"
            );
            return cb(options.ignoreError ? null : err);
          }
        }
        const ignoreErrorForPrefixSecurity = this.prefixSecurity === PrefixSecurityEnum.SILENT;
        const prefixSecurityDisabled = this.prefixSecurity === PrefixSecurityEnum.DISABLED;
        if (!prefixSecurityDisabled) {
          let errorFound = false;
          let errorMsg;
          if (!isSecurePrefixConditionMet(cookie)) {
            errorFound = true;
            errorMsg = "Cookie has __Secure prefix but Secure attribute is not set";
          } else if (!isHostPrefixConditionMet(cookie)) {
            errorFound = true;
            errorMsg = "Cookie has __Host prefix but either Secure or HostOnly attribute is not set or Path is not '/'";
          }
          if (errorFound) {
            return cb(
              options.ignoreError || ignoreErrorForPrefixSecurity ? null : new Error(errorMsg)
            );
          }
        }
        const store = this.store;
        if (!store.updateCookie) {
          store.updateCookie = function(oldCookie, newCookie, cb2) {
            this.putCookie(newCookie, cb2);
          };
        }
        function withCookie(err2, oldCookie) {
          if (err2) {
            return cb(err2);
          }
          const next = function(err3) {
            if (err3) {
              return cb(err3);
            } else {
              cb(null, cookie);
            }
          };
          if (oldCookie) {
            if (options.http === false && oldCookie.httpOnly) {
              err2 = new Error("old Cookie is HttpOnly and this isn't an HTTP API");
              return cb(options.ignoreError ? null : err2);
            }
            cookie.creation = oldCookie.creation;
            cookie.creationIndex = oldCookie.creationIndex;
            cookie.lastAccessed = now;
            store.updateCookie(oldCookie, cookie, next);
          } else {
            cookie.creation = cookie.lastAccessed = now;
            store.putCookie(cookie, next);
          }
        }
        store.findCookie(cookie.domain, cookie.path, cookie.key, withCookie);
      }
      // RFC6365 S5.4
      getCookies(url, options, cb) {
        validators.validate(validators.isUrlStringOrObject(url), cb, url);
        const context = getCookieContext(url);
        if (validators.isFunction(options)) {
          cb = options;
          options = {};
        }
        validators.validate(validators.isObject(options), cb, options);
        validators.validate(validators.isFunction(cb), cb);
        const host = canonicalDomain(context.hostname);
        const path = context.pathname || "/";
        let secure = options.secure;
        if (secure == null && context.protocol && (context.protocol == "https:" || context.protocol == "wss:")) {
          secure = true;
        }
        let sameSiteLevel = 0;
        if (options.sameSiteContext) {
          const sameSiteContext = checkSameSiteContext(options.sameSiteContext);
          sameSiteLevel = Cookie.sameSiteLevel[sameSiteContext];
          if (!sameSiteLevel) {
            return cb(new Error(SAME_SITE_CONTEXT_VAL_ERR));
          }
        }
        let http = options.http;
        if (http == null) {
          http = true;
        }
        const now = options.now || Date.now();
        const expireCheck = options.expire !== false;
        const allPaths = !!options.allPaths;
        const store = this.store;
        function matchingCookie(c) {
          if (c.hostOnly) {
            if (c.domain != host) {
              return false;
            }
          } else {
            if (!domainMatch(host, c.domain, false)) {
              return false;
            }
          }
          if (!allPaths && !pathMatch(path, c.path)) {
            return false;
          }
          if (c.secure && !secure) {
            return false;
          }
          if (c.httpOnly && !http) {
            return false;
          }
          if (sameSiteLevel) {
            const cookieLevel = Cookie.sameSiteLevel[c.sameSite || "none"];
            if (cookieLevel > sameSiteLevel) {
              return false;
            }
          }
          if (expireCheck && c.expiryTime() <= now) {
            store.removeCookie(c.domain, c.path, c.key, () => {
            });
            return false;
          }
          return true;
        }
        store.findCookies(
          host,
          allPaths ? null : path,
          this.allowSpecialUseDomain,
          (err, cookies) => {
            if (err) {
              return cb(err);
            }
            cookies = cookies.filter(matchingCookie);
            if (options.sort !== false) {
              cookies = cookies.sort(cookieCompare);
            }
            const now2 = /* @__PURE__ */ new Date();
            for (const cookie of cookies) {
              cookie.lastAccessed = now2;
            }
            cb(null, cookies);
          }
        );
      }
      getCookieString(...args) {
        const cb = args.pop();
        validators.validate(validators.isFunction(cb), cb);
        const next = function(err, cookies) {
          if (err) {
            cb(err);
          } else {
            cb(
              null,
              cookies.sort(cookieCompare).map((c) => c.cookieString()).join("; ")
            );
          }
        };
        args.push(next);
        this.getCookies.apply(this, args);
      }
      getSetCookieStrings(...args) {
        const cb = args.pop();
        validators.validate(validators.isFunction(cb), cb);
        const next = function(err, cookies) {
          if (err) {
            cb(err);
          } else {
            cb(
              null,
              cookies.map((c) => {
                return c.toString();
              })
            );
          }
        };
        args.push(next);
        this.getCookies.apply(this, args);
      }
      serialize(cb) {
        validators.validate(validators.isFunction(cb), cb);
        let type = this.store.constructor.name;
        if (validators.isObject(type)) {
          type = null;
        }
        const serialized = {
          // The version of tough-cookie that serialized this jar. Generally a good
          // practice since future versions can make data import decisions based on
          // known past behavior. When/if this matters, use `semver`.
          version: `tough-cookie@${VERSION}`,
          // add the store type, to make humans happy:
          storeType: type,
          // CookieJar configuration:
          rejectPublicSuffixes: !!this.rejectPublicSuffixes,
          enableLooseMode: !!this.enableLooseMode,
          allowSpecialUseDomain: !!this.allowSpecialUseDomain,
          prefixSecurity: getNormalizedPrefixSecurity(this.prefixSecurity),
          // this gets filled from getAllCookies:
          cookies: []
        };
        if (!(this.store.getAllCookies && typeof this.store.getAllCookies === "function")) {
          return cb(
            new Error(
              "store does not support getAllCookies and cannot be serialized"
            )
          );
        }
        this.store.getAllCookies((err, cookies) => {
          if (err) {
            return cb(err);
          }
          serialized.cookies = cookies.map((cookie) => {
            cookie = cookie instanceof Cookie ? cookie.toJSON() : cookie;
            delete cookie.creationIndex;
            return cookie;
          });
          return cb(null, serialized);
        });
      }
      toJSON() {
        return this.serializeSync();
      }
      // use the class method CookieJar.deserialize instead of calling this directly
      _importCookies(serialized, cb) {
        let cookies = serialized.cookies;
        if (!cookies || !Array.isArray(cookies)) {
          return cb(new Error("serialized jar has no cookies array"));
        }
        cookies = cookies.slice();
        const putNext = (err) => {
          if (err) {
            return cb(err);
          }
          if (!cookies.length) {
            return cb(err, this);
          }
          let cookie;
          try {
            cookie = fromJSON(cookies.shift());
          } catch (e) {
            return cb(e);
          }
          if (cookie === null) {
            return putNext(null);
          }
          this.store.putCookie(cookie, putNext);
        };
        putNext();
      }
      clone(newStore, cb) {
        if (arguments.length === 1) {
          cb = newStore;
          newStore = null;
        }
        this.serialize((err, serialized) => {
          if (err) {
            return cb(err);
          }
          _CookieJar.deserialize(serialized, newStore, cb);
        });
      }
      cloneSync(newStore) {
        if (arguments.length === 0) {
          return this._cloneSync();
        }
        if (!newStore.synchronous) {
          throw new Error(
            "CookieJar clone destination store is not synchronous; use async API instead."
          );
        }
        return this._cloneSync(newStore);
      }
      removeAllCookies(cb) {
        validators.validate(validators.isFunction(cb), cb);
        const store = this.store;
        if (typeof store.removeAllCookies === "function" && store.removeAllCookies !== Store.prototype.removeAllCookies) {
          return store.removeAllCookies(cb);
        }
        store.getAllCookies((err, cookies) => {
          if (err) {
            return cb(err);
          }
          if (cookies.length === 0) {
            return cb(null);
          }
          let completedCount = 0;
          const removeErrors = [];
          function removeCookieCb(removeErr) {
            if (removeErr) {
              removeErrors.push(removeErr);
            }
            completedCount++;
            if (completedCount === cookies.length) {
              return cb(removeErrors.length ? removeErrors[0] : null);
            }
          }
          cookies.forEach((cookie) => {
            store.removeCookie(
              cookie.domain,
              cookie.path,
              cookie.key,
              removeCookieCb
            );
          });
        });
      }
      static deserialize(strOrObj, store, cb) {
        if (arguments.length !== 3) {
          cb = store;
          store = null;
        }
        validators.validate(validators.isFunction(cb), cb);
        let serialized;
        if (typeof strOrObj === "string") {
          serialized = jsonParse(strOrObj);
          if (serialized instanceof Error) {
            return cb(serialized);
          }
        } else {
          serialized = strOrObj;
        }
        const jar = new _CookieJar(store, {
          rejectPublicSuffixes: serialized.rejectPublicSuffixes,
          looseMode: serialized.enableLooseMode,
          allowSpecialUseDomain: serialized.allowSpecialUseDomain,
          prefixSecurity: serialized.prefixSecurity
        });
        jar._importCookies(serialized, (err) => {
          if (err) {
            return cb(err);
          }
          cb(null, jar);
        });
      }
      static deserializeSync(strOrObj, store) {
        const serialized = typeof strOrObj === "string" ? JSON.parse(strOrObj) : strOrObj;
        const jar = new _CookieJar(store, {
          rejectPublicSuffixes: serialized.rejectPublicSuffixes,
          looseMode: serialized.enableLooseMode
        });
        if (!jar.store.synchronous) {
          throw new Error(
            "CookieJar store is not synchronous; use async API instead."
          );
        }
        jar._importCookiesSync(serialized);
        return jar;
      }
    };
    CookieJar.fromJSON = CookieJar.deserializeSync;
    [
      "_importCookies",
      "clone",
      "getCookies",
      "getCookieString",
      "getSetCookieStrings",
      "removeAllCookies",
      "serialize",
      "setCookie"
    ].forEach((name) => {
      CookieJar.prototype[name] = fromCallback(CookieJar.prototype[name]);
    });
    CookieJar.deserialize = fromCallback(CookieJar.deserialize);
    function syncWrap(method) {
      return function(...args) {
        if (!this.store.synchronous) {
          throw new Error(
            "CookieJar store is not synchronous; use async API instead."
          );
        }
        let syncErr, syncResult;
        this[method](...args, (err, result) => {
          syncErr = err;
          syncResult = result;
        });
        if (syncErr) {
          throw syncErr;
        }
        return syncResult;
      };
    }
    exports2.version = VERSION;
    exports2.CookieJar = CookieJar;
    exports2.Cookie = Cookie;
    exports2.Store = Store;
    exports2.MemoryCookieStore = MemoryCookieStore;
    exports2.parseDate = parseDate;
    exports2.formatDate = formatDate;
    exports2.parse = parse;
    exports2.fromJSON = fromJSON;
    exports2.domainMatch = domainMatch;
    exports2.defaultPath = defaultPath;
    exports2.pathMatch = pathMatch;
    exports2.getPublicSuffix = pubsuffix.getPublicSuffix;
    exports2.cookieCompare = cookieCompare;
    exports2.permuteDomain = require_permuteDomain().permuteDomain;
    exports2.permutePath = permutePath;
    exports2.canonicalDomain = canonicalDomain;
    exports2.PrefixSecurityEnum = PrefixSecurityEnum;
    exports2.ParameterError = validators.ParameterError;
  }
});

// ../../../node_modules/set-cookie-parser/lib/set-cookie.js
var require_set_cookie = __commonJS({
  "../../../node_modules/set-cookie-parser/lib/set-cookie.js"(exports2, module2) {
    "use strict";
    var defaultParseOptions = {
      decodeValues: true,
      map: false,
      silent: false
    };
    function isNonEmptyString(str) {
      return typeof str === "string" && !!str.trim();
    }
    function parseString(setCookieValue, options) {
      var parts = setCookieValue.split(";").filter(isNonEmptyString);
      var nameValuePairStr = parts.shift();
      var parsed = parseNameValuePair(nameValuePairStr);
      var name = parsed.name;
      var value = parsed.value;
      options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
      try {
        value = options.decodeValues ? decodeURIComponent(value) : value;
      } catch (e) {
        console.error(
          "set-cookie-parser encountered an error while decoding a cookie with value '" + value + "'. Set options.decodeValues to false to disable this feature.",
          e
        );
      }
      var cookie = {
        name,
        value
      };
      parts.forEach(function(part) {
        var sides = part.split("=");
        var key = sides.shift().trimLeft().toLowerCase();
        var value2 = sides.join("=");
        if (key === "expires") {
          cookie.expires = new Date(value2);
        } else if (key === "max-age") {
          cookie.maxAge = parseInt(value2, 10);
        } else if (key === "secure") {
          cookie.secure = true;
        } else if (key === "httponly") {
          cookie.httpOnly = true;
        } else if (key === "samesite") {
          cookie.sameSite = value2;
        } else if (key === "partitioned") {
          cookie.partitioned = true;
        } else {
          cookie[key] = value2;
        }
      });
      return cookie;
    }
    function parseNameValuePair(nameValuePairStr) {
      var name = "";
      var value = "";
      var nameValueArr = nameValuePairStr.split("=");
      if (nameValueArr.length > 1) {
        name = nameValueArr.shift();
        value = nameValueArr.join("=");
      } else {
        value = nameValuePairStr;
      }
      return { name, value };
    }
    function parse(input, options) {
      options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
      if (!input) {
        if (!options.map) {
          return [];
        } else {
          return {};
        }
      }
      if (input.headers) {
        if (typeof input.headers.getSetCookie === "function") {
          input = input.headers.getSetCookie();
        } else if (input.headers["set-cookie"]) {
          input = input.headers["set-cookie"];
        } else {
          var sch = input.headers[Object.keys(input.headers).find(function(key) {
            return key.toLowerCase() === "set-cookie";
          })];
          if (!sch && input.headers.cookie && !options.silent) {
            console.warn(
              "Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning."
            );
          }
          input = sch;
        }
      }
      if (!Array.isArray(input)) {
        input = [input];
      }
      if (!options.map) {
        return input.filter(isNonEmptyString).map(function(str) {
          return parseString(str, options);
        });
      } else {
        var cookies = {};
        return input.filter(isNonEmptyString).reduce(function(cookies2, str) {
          var cookie = parseString(str, options);
          cookies2[cookie.name] = cookie;
          return cookies2;
        }, cookies);
      }
    }
    function splitCookiesString(cookiesString) {
      if (Array.isArray(cookiesString)) {
        return cookiesString;
      }
      if (typeof cookiesString !== "string") {
        return [];
      }
      var cookiesStrings = [];
      var pos = 0;
      var start;
      var ch;
      var lastComma;
      var nextStart;
      var cookiesSeparatorFound;
      function skipWhitespace() {
        while (pos < cookiesString.length && /\s/.test(cookiesString.charAt(pos))) {
          pos += 1;
        }
        return pos < cookiesString.length;
      }
      function notSpecialChar() {
        ch = cookiesString.charAt(pos);
        return ch !== "=" && ch !== ";" && ch !== ",";
      }
      while (pos < cookiesString.length) {
        start = pos;
        cookiesSeparatorFound = false;
        while (skipWhitespace()) {
          ch = cookiesString.charAt(pos);
          if (ch === ",") {
            lastComma = pos;
            pos += 1;
            skipWhitespace();
            nextStart = pos;
            while (pos < cookiesString.length && notSpecialChar()) {
              pos += 1;
            }
            if (pos < cookiesString.length && cookiesString.charAt(pos) === "=") {
              cookiesSeparatorFound = true;
              pos = nextStart;
              cookiesStrings.push(cookiesString.substring(start, lastComma));
              start = pos;
            } else {
              pos = lastComma + 1;
            }
          } else {
            pos += 1;
          }
        }
        if (!cookiesSeparatorFound || pos >= cookiesString.length) {
          cookiesStrings.push(cookiesString.substring(start, cookiesString.length));
        }
      }
      return cookiesStrings;
    }
    module2.exports = parse;
    module2.exports.parse = parse;
    module2.exports.parseString = parseString;
    module2.exports.splitCookiesString = splitCookiesString;
  }
});

// ../../../node_modules/fetch-cookie/cjs/index.js
var require_cjs2 = __commonJS({
  "../../../node_modules/fetch-cookie/cjs/index.js"(exports2, module2) {
    var __create = Object.create;
    var __defProp = Object.defineProperty;
    var __defProps = Object.defineProperties;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getOwnPropSymbols = Object.getOwnPropertySymbols;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __propIsEnum = Object.prototype.propertyIsEnumerable;
    var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __spreadValues = (a, b) => {
      for (var prop in b || (b = {}))
        if (__hasOwnProp.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      if (__getOwnPropSymbols)
        for (var prop of __getOwnPropSymbols(b)) {
          if (__propIsEnum.call(b, prop))
            __defNormalProp(a, prop, b[prop]);
        }
      return a;
    };
    var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
    var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __reExport = (target, module22, copyDefault, desc) => {
      if (module22 && typeof module22 === "object" || typeof module22 === "function") {
        for (let key of __getOwnPropNames(module22))
          if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
            __defProp(target, key, { get: () => module22[key], enumerable: !(desc = __getOwnPropDesc(module22, key)) || desc.enumerable });
      }
      return target;
    };
    var __toESM = (module22, isNodeMode) => {
      return __reExport(__markAsModule(__defProp(module22 != null ? __create(__getProtoOf(module22)) : {}, "default", !isNodeMode && module22 && module22.__esModule ? { get: () => module22.default, enumerable: true } : { value: module22, enumerable: true })), module22);
    };
    var __toCommonJS2 = /* @__PURE__ */ ((cache) => {
      return (module22, temp) => {
        return cache && cache.get(module22) || (temp = __reExport(__markAsModule({}), module22, 1), cache && cache.set(module22, temp), temp);
      };
    })(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);
    var __async = (__this, __arguments, generator) => {
      return new Promise((resolve, reject) => {
        var fulfilled = (value) => {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        };
        var rejected = (value) => {
          try {
            step(generator.throw(value));
          } catch (e) {
            reject(e);
          }
        };
        var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
        step((generator = generator.apply(__this, __arguments)).next());
      });
    };
    var src_exports = {};
    __export2(src_exports, {
      default: () => fetchCookie
    });
    var tough = __toESM(require_cookie(), 1);
    var import_set_cookie_parser = require_set_cookie();
    function isDomainOrSubdomain(destination, original) {
      const orig = new URL(original).hostname;
      const dest = new URL(destination).hostname;
      return orig === dest || orig.endsWith(`.${dest}`);
    }
    var referrerPolicy = /* @__PURE__ */ new Set([
      "",
      "no-referrer",
      "no-referrer-when-downgrade",
      "same-origin",
      "origin",
      "strict-origin",
      "origin-when-cross-origin",
      "strict-origin-when-cross-origin",
      "unsafe-url"
    ]);
    function parseReferrerPolicy(policyHeader) {
      const policyTokens = policyHeader.split(/[,\s]+/);
      let policy = "";
      for (const token of policyTokens) {
        if (token !== "" && referrerPolicy.has(token)) {
          policy = token;
        }
      }
      return policy;
    }
    function doNothing(init, name) {
    }
    function callDeleteMethod(init, name) {
      init.headers.delete(name);
    }
    function deleteFromObject(init, name) {
      const headers = init.headers;
      for (const key of Object.keys(headers)) {
        if (key.toLowerCase() === name) {
          delete headers[key];
        }
      }
    }
    function identifyDeleteHeader(init) {
      if (init.headers == null) {
        return doNothing;
      }
      if (typeof init.headers.delete === "function") {
        return callDeleteMethod;
      }
      return deleteFromObject;
    }
    var redirectStatus = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]);
    function isRedirect(status) {
      return redirectStatus.has(status);
    }
    function handleRedirect(fetchImpl, init, response) {
      return __async(this, null, function* () {
        var _a, _b, _c;
        switch ((_a = init.redirect) != null ? _a : "follow") {
          case "error":
            throw new TypeError(`URI requested responded with a redirect and redirect mode is set to error: ${response.url}`);
          case "manual":
            return response;
          case "follow":
            break;
          default:
            throw new TypeError(`Invalid redirect option: ${init.redirect}`);
        }
        const locationUrl = response.headers.get("location");
        if (locationUrl === null) {
          return response;
        }
        const requestUrl = response.url;
        const redirectUrl = new URL(locationUrl, requestUrl).toString();
        const redirectCount = (_b = init.redirectCount) != null ? _b : 0;
        const maxRedirect = (_c = init.maxRedirect) != null ? _c : 20;
        if (redirectCount >= maxRedirect) {
          throw new TypeError(`Reached maximum redirect of ${maxRedirect} for URL: ${requestUrl}`);
        }
        init = __spreadProps(__spreadValues({}, init), {
          redirectCount: redirectCount + 1
        });
        const deleteHeader = identifyDeleteHeader(init);
        if (!isDomainOrSubdomain(requestUrl, redirectUrl)) {
          for (const name of ["authorization", "www-authenticate", "cookie", "cookie2"]) {
            deleteHeader(init, name);
          }
        }
        const maybeNodeStreamBody = init.body;
        const maybeStreamBody = init.body;
        if (response.status !== 303 && init.body != null && (typeof maybeNodeStreamBody.pipe === "function" || typeof maybeStreamBody.pipeTo === "function")) {
          throw new TypeError("Cannot follow redirect with body being a readable stream");
        }
        if (response.status === 303 || (response.status === 301 || response.status === 302) && init.method === "POST") {
          init.method = "GET";
          init.body = void 0;
          deleteHeader(init, "content-length");
        }
        if (response.headers.has("referrer-policy")) {
          init.referrerPolicy = parseReferrerPolicy(response.headers.get("referrer-policy"));
        }
        return yield fetchImpl(redirectUrl, init);
      });
    }
    function addCookiesToRequest(input, init, cookie) {
      if (cookie === "") {
        return init;
      }
      const maybeRequest = input;
      const maybeHeaders = init.headers;
      if (maybeRequest.headers && typeof maybeRequest.headers.append === "function") {
        maybeRequest.headers.append("cookie", cookie);
      } else if (maybeHeaders && typeof maybeHeaders.append === "function") {
        maybeHeaders.append("cookie", cookie);
      } else {
        init = __spreadProps(__spreadValues({}, init), { headers: __spreadProps(__spreadValues({}, init.headers), { cookie }) });
      }
      return init;
    }
    function getCookiesFromResponse(response) {
      const maybeNodeFetchHeaders = response.headers;
      if (typeof maybeNodeFetchHeaders.getAll === "function") {
        return maybeNodeFetchHeaders.getAll("set-cookie");
      }
      if (typeof maybeNodeFetchHeaders.raw === "function") {
        const headers = maybeNodeFetchHeaders.raw();
        if (Array.isArray(headers["set-cookie"])) {
          return headers["set-cookie"];
        }
        return [];
      }
      const cookieString = response.headers.get("set-cookie");
      if (cookieString !== null) {
        return (0, import_set_cookie_parser.splitCookiesString)(cookieString);
      }
      return [];
    }
    function fetchCookie(fetch, jar, ignoreError = true) {
      const actualFetch = fetch;
      const actualJar = jar != null ? jar : new tough.CookieJar();
      function fetchCookieWrapper(input, init) {
        return __async(this, null, function* () {
          var _a, _b;
          const originalInit = init != null ? init : {};
          init = __spreadProps(__spreadValues({}, init), { redirect: "manual" });
          const requestUrl = typeof input === "string" ? input : (_a = input.url) != null ? _a : input.href;
          const cookie = yield actualJar.getCookieString(requestUrl);
          init = addCookiesToRequest(input, init, cookie);
          const response = yield actualFetch(input, init);
          const cookies = getCookiesFromResponse(response);
          yield Promise.all(cookies.map((cookie2) => __async(this, null, function* () {
            return yield actualJar.setCookie(cookie2, response.url, { ignoreError });
          })));
          if (((_b = init.redirectCount) != null ? _b : 0) > 0) {
            Object.defineProperty(response, "redirected", { value: true });
          }
          if (!isRedirect(response.status)) {
            return response;
          }
          return yield handleRedirect(fetchCookieWrapper, originalInit, response);
        });
      }
      fetchCookieWrapper.toughCookie = tough;
      return fetchCookieWrapper;
    }
    fetchCookie.toughCookie = tough;
    module2.exports = __toCommonJS2(src_exports);
  }
});

// ../../../node_modules/fetch-cookie/cjs/index-wrapper.js
var require_index_wrapper = __commonJS({
  "../../../node_modules/fetch-cookie/cjs/index-wrapper.js"(exports2, module2) {
    module2.exports = require_cjs2().default;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/core/symbols.js
var require_symbols = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/core/symbols.js"(exports2, module2) {
    module2.exports = {
      kClose: Symbol("close"),
      kDestroy: Symbol("destroy"),
      kDispatch: Symbol("dispatch"),
      kUrl: Symbol("url"),
      kWriting: Symbol("writing"),
      kResuming: Symbol("resuming"),
      kQueue: Symbol("queue"),
      kConnect: Symbol("connect"),
      kConnecting: Symbol("connecting"),
      kKeepAliveDefaultTimeout: Symbol("default keep alive timeout"),
      kKeepAliveMaxTimeout: Symbol("max keep alive timeout"),
      kKeepAliveTimeoutThreshold: Symbol("keep alive timeout threshold"),
      kKeepAliveTimeoutValue: Symbol("keep alive timeout"),
      kKeepAlive: Symbol("keep alive"),
      kHeadersTimeout: Symbol("headers timeout"),
      kBodyTimeout: Symbol("body timeout"),
      kServerName: Symbol("server name"),
      kLocalAddress: Symbol("local address"),
      kHost: Symbol("host"),
      kNoRef: Symbol("no ref"),
      kBodyUsed: Symbol("used"),
      kBody: Symbol("abstracted request body"),
      kRunning: Symbol("running"),
      kBlocking: Symbol("blocking"),
      kPending: Symbol("pending"),
      kSize: Symbol("size"),
      kBusy: Symbol("busy"),
      kQueued: Symbol("queued"),
      kFree: Symbol("free"),
      kConnected: Symbol("connected"),
      kClosed: Symbol("closed"),
      kNeedDrain: Symbol("need drain"),
      kReset: Symbol("reset"),
      kDestroyed: Symbol.for("nodejs.stream.destroyed"),
      kResume: Symbol("resume"),
      kOnError: Symbol("on error"),
      kMaxHeadersSize: Symbol("max headers size"),
      kRunningIdx: Symbol("running index"),
      kPendingIdx: Symbol("pending index"),
      kError: Symbol("error"),
      kClients: Symbol("clients"),
      kClient: Symbol("client"),
      kParser: Symbol("parser"),
      kOnDestroyed: Symbol("destroy callbacks"),
      kPipelining: Symbol("pipelining"),
      kSocket: Symbol("socket"),
      kHostHeader: Symbol("host header"),
      kConnector: Symbol("connector"),
      kStrictContentLength: Symbol("strict content length"),
      kMaxRedirections: Symbol("maxRedirections"),
      kMaxRequests: Symbol("maxRequestsPerClient"),
      kProxy: Symbol("proxy agent options"),
      kCounter: Symbol("socket request counter"),
      kInterceptors: Symbol("dispatch interceptors"),
      kMaxResponseSize: Symbol("max response size"),
      kHTTP2Session: Symbol("http2Session"),
      kHTTP2SessionState: Symbol("http2Session state"),
      kRetryHandlerDefaultRetry: Symbol("retry agent default retry"),
      kConstruct: Symbol("constructable"),
      kListeners: Symbol("listeners"),
      kHTTPContext: Symbol("http context"),
      kMaxConcurrentStreams: Symbol("max concurrent streams"),
      kNoProxyAgent: Symbol("no proxy agent"),
      kHttpProxyAgent: Symbol("http proxy agent"),
      kHttpsProxyAgent: Symbol("https proxy agent")
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/core/errors.js
var require_errors = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/core/errors.js"(exports2, module2) {
    "use strict";
    var UndiciError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "UndiciError";
        this.code = "UND_ERR";
      }
    };
    var ConnectTimeoutError = class extends UndiciError {
      constructor(message) {
        super(message);
        this.name = "ConnectTimeoutError";
        this.message = message || "Connect Timeout Error";
        this.code = "UND_ERR_CONNECT_TIMEOUT";
      }
    };
    var HeadersTimeoutError = class extends UndiciError {
      constructor(message) {
        super(message);
        this.name = "HeadersTimeoutError";
        this.message = message || "Headers Timeout Error";
        this.code = "UND_ERR_HEADERS_TIMEOUT";
      }
    };
    var HeadersOverflowError = class extends UndiciError {
      constructor(message) {
        super(message);
        this.name = "HeadersOverflowError";
        this.message = message || "Headers Overflow Error";
        this.code = "UND_ERR_HEADERS_OVERFLOW";
      }
    };
    var BodyTimeoutError = class extends UndiciError {
      constructor(message) {
        super(message);
        this.name = "BodyTimeoutError";
        this.message = message || "Body Timeout Error";
        this.code = "UND_ERR_BODY_TIMEOUT";
      }
    };
    var ResponseStatusCodeError = class extends UndiciError {
      constructor(message, statusCode, headers, body) {
        super(message);
        this.name = "ResponseStatusCodeError";
        this.message = message || "Response Status Code Error";
        this.code = "UND_ERR_RESPONSE_STATUS_CODE";
        this.body = body;
        this.status = statusCode;
        this.statusCode = statusCode;
        this.headers = headers;
      }
    };
    var InvalidArgumentError = class extends UndiciError {
      constructor(message) {
        super(message);
        this.name = "InvalidArgumentError";
        this.message = message || "Invalid Argument Error";
        this.code = "UND_ERR_INVALID_ARG";
      }
    };
    var InvalidReturnValueError = class extends UndiciError {
      constructor(message) {
        super(message);
        this.name = "InvalidReturnValueError";
        this.message = message || "Invalid Return Value Error";
        this.code = "UND_ERR_INVALID_RETURN_VALUE";
      }
    };
    var AbortError = class extends UndiciError {
      constructor(message) {
        super(message);
        this.name = "AbortError";
        this.message = message || "The operation was aborted";
      }
    };
    var RequestAbortedError = class extends AbortError {
      constructor(message) {
        super(message);
        this.name = "AbortError";
        this.message = message || "Request aborted";
        this.code = "UND_ERR_ABORTED";
      }
    };
    var InformationalError = class extends UndiciError {
      constructor(message) {
        super(message);
        this.name = "InformationalError";
        this.message = message || "Request information";
        this.code = "UND_ERR_INFO";
      }
    };
    var RequestContentLengthMismatchError = class extends UndiciError {
      constructor(message) {
        super(message);
        this.name = "RequestContentLengthMismatchError";
        this.message = message || "Request body length does not match content-length header";
        this.code = "UND_ERR_REQ_CONTENT_LENGTH_MISMATCH";
      }
    };
    var ResponseContentLengthMismatchError = class extends UndiciError {
      constructor(message) {
        super(message);
        this.name = "ResponseContentLengthMismatchError";
        this.message = message || "Response body length does not match content-length header";
        this.code = "UND_ERR_RES_CONTENT_LENGTH_MISMATCH";
      }
    };
    var ClientDestroyedError = class extends UndiciError {
      constructor(message) {
        super(message);
        this.name = "ClientDestroyedError";
        this.message = message || "The client is destroyed";
        this.code = "UND_ERR_DESTROYED";
      }
    };
    var ClientClosedError = class extends UndiciError {
      constructor(message) {
        super(message);
        this.name = "ClientClosedError";
        this.message = message || "The client is closed";
        this.code = "UND_ERR_CLOSED";
      }
    };
    var SocketError = class extends UndiciError {
      constructor(message, socket) {
        super(message);
        this.name = "SocketError";
        this.message = message || "Socket error";
        this.code = "UND_ERR_SOCKET";
        this.socket = socket;
      }
    };
    var NotSupportedError = class extends UndiciError {
      constructor(message) {
        super(message);
        this.name = "NotSupportedError";
        this.message = message || "Not supported error";
        this.code = "UND_ERR_NOT_SUPPORTED";
      }
    };
    var BalancedPoolMissingUpstreamError = class extends UndiciError {
      constructor(message) {
        super(message);
        this.name = "MissingUpstreamError";
        this.message = message || "No upstream has been added to the BalancedPool";
        this.code = "UND_ERR_BPL_MISSING_UPSTREAM";
      }
    };
    var HTTPParserError = class extends Error {
      constructor(message, code, data) {
        super(message);
        this.name = "HTTPParserError";
        this.code = code ? `HPE_${code}` : void 0;
        this.data = data ? data.toString() : void 0;
      }
    };
    var ResponseExceededMaxSizeError = class extends UndiciError {
      constructor(message) {
        super(message);
        this.name = "ResponseExceededMaxSizeError";
        this.message = message || "Response content exceeded max size";
        this.code = "UND_ERR_RES_EXCEEDED_MAX_SIZE";
      }
    };
    var RequestRetryError = class extends UndiciError {
      constructor(message, code, { headers, data }) {
        super(message);
        this.name = "RequestRetryError";
        this.message = message || "Request retry error";
        this.code = "UND_ERR_REQ_RETRY";
        this.statusCode = code;
        this.data = data;
        this.headers = headers;
      }
    };
    var ResponseError = class extends UndiciError {
      constructor(message, code, { headers, data }) {
        super(message);
        this.name = "ResponseError";
        this.message = message || "Response error";
        this.code = "UND_ERR_RESPONSE";
        this.statusCode = code;
        this.data = data;
        this.headers = headers;
      }
    };
    var SecureProxyConnectionError = class extends UndiciError {
      constructor(cause, message, options) {
        super(message, { cause, ...options ?? {} });
        this.name = "SecureProxyConnectionError";
        this.message = message || "Secure Proxy Connection failed";
        this.code = "UND_ERR_PRX_TLS";
        this.cause = cause;
      }
    };
    module2.exports = {
      AbortError,
      HTTPParserError,
      UndiciError,
      HeadersTimeoutError,
      HeadersOverflowError,
      BodyTimeoutError,
      RequestContentLengthMismatchError,
      ConnectTimeoutError,
      ResponseStatusCodeError,
      InvalidArgumentError,
      InvalidReturnValueError,
      RequestAbortedError,
      ClientDestroyedError,
      ClientClosedError,
      InformationalError,
      SocketError,
      NotSupportedError,
      ResponseContentLengthMismatchError,
      BalancedPoolMissingUpstreamError,
      ResponseExceededMaxSizeError,
      RequestRetryError,
      ResponseError,
      SecureProxyConnectionError
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/core/constants.js
var require_constants = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/core/constants.js"(exports2, module2) {
    "use strict";
    var headerNameLowerCasedRecord = {};
    var wellknownHeaderNames = [
      "Accept",
      "Accept-Encoding",
      "Accept-Language",
      "Accept-Ranges",
      "Access-Control-Allow-Credentials",
      "Access-Control-Allow-Headers",
      "Access-Control-Allow-Methods",
      "Access-Control-Allow-Origin",
      "Access-Control-Expose-Headers",
      "Access-Control-Max-Age",
      "Access-Control-Request-Headers",
      "Access-Control-Request-Method",
      "Age",
      "Allow",
      "Alt-Svc",
      "Alt-Used",
      "Authorization",
      "Cache-Control",
      "Clear-Site-Data",
      "Connection",
      "Content-Disposition",
      "Content-Encoding",
      "Content-Language",
      "Content-Length",
      "Content-Location",
      "Content-Range",
      "Content-Security-Policy",
      "Content-Security-Policy-Report-Only",
      "Content-Type",
      "Cookie",
      "Cross-Origin-Embedder-Policy",
      "Cross-Origin-Opener-Policy",
      "Cross-Origin-Resource-Policy",
      "Date",
      "Device-Memory",
      "Downlink",
      "ECT",
      "ETag",
      "Expect",
      "Expect-CT",
      "Expires",
      "Forwarded",
      "From",
      "Host",
      "If-Match",
      "If-Modified-Since",
      "If-None-Match",
      "If-Range",
      "If-Unmodified-Since",
      "Keep-Alive",
      "Last-Modified",
      "Link",
      "Location",
      "Max-Forwards",
      "Origin",
      "Permissions-Policy",
      "Pragma",
      "Proxy-Authenticate",
      "Proxy-Authorization",
      "RTT",
      "Range",
      "Referer",
      "Referrer-Policy",
      "Refresh",
      "Retry-After",
      "Sec-WebSocket-Accept",
      "Sec-WebSocket-Extensions",
      "Sec-WebSocket-Key",
      "Sec-WebSocket-Protocol",
      "Sec-WebSocket-Version",
      "Server",
      "Server-Timing",
      "Service-Worker-Allowed",
      "Service-Worker-Navigation-Preload",
      "Set-Cookie",
      "SourceMap",
      "Strict-Transport-Security",
      "Supports-Loading-Mode",
      "TE",
      "Timing-Allow-Origin",
      "Trailer",
      "Transfer-Encoding",
      "Upgrade",
      "Upgrade-Insecure-Requests",
      "User-Agent",
      "Vary",
      "Via",
      "WWW-Authenticate",
      "X-Content-Type-Options",
      "X-DNS-Prefetch-Control",
      "X-Frame-Options",
      "X-Permitted-Cross-Domain-Policies",
      "X-Powered-By",
      "X-Requested-With",
      "X-XSS-Protection"
    ];
    for (let i = 0; i < wellknownHeaderNames.length; ++i) {
      const key = wellknownHeaderNames[i];
      const lowerCasedKey = key.toLowerCase();
      headerNameLowerCasedRecord[key] = headerNameLowerCasedRecord[lowerCasedKey] = lowerCasedKey;
    }
    Object.setPrototypeOf(headerNameLowerCasedRecord, null);
    module2.exports = {
      wellknownHeaderNames,
      headerNameLowerCasedRecord
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/core/tree.js
var require_tree = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/core/tree.js"(exports2, module2) {
    "use strict";
    var {
      wellknownHeaderNames,
      headerNameLowerCasedRecord
    } = require_constants();
    var TstNode = class _TstNode {
      /**
       * @param {string} key
       * @param {any} value
       * @param {number} index
       */
      constructor(key, value, index) {
        /** @type {any} */
        __publicField(this, "value", null);
        /** @type {null | TstNode} */
        __publicField(this, "left", null);
        /** @type {null | TstNode} */
        __publicField(this, "middle", null);
        /** @type {null | TstNode} */
        __publicField(this, "right", null);
        /** @type {number} */
        __publicField(this, "code");
        if (index === void 0 || index >= key.length) {
          throw new TypeError("Unreachable");
        }
        const code = this.code = key.charCodeAt(index);
        if (code > 127) {
          throw new TypeError("key must be ascii string");
        }
        if (key.length !== ++index) {
          this.middle = new _TstNode(key, value, index);
        } else {
          this.value = value;
        }
      }
      /**
       * @param {string} key
       * @param {any} value
       */
      add(key, value) {
        const length = key.length;
        if (length === 0) {
          throw new TypeError("Unreachable");
        }
        let index = 0;
        let node = this;
        while (true) {
          const code = key.charCodeAt(index);
          if (code > 127) {
            throw new TypeError("key must be ascii string");
          }
          if (node.code === code) {
            if (length === ++index) {
              node.value = value;
              break;
            } else if (node.middle !== null) {
              node = node.middle;
            } else {
              node.middle = new _TstNode(key, value, index);
              break;
            }
          } else if (node.code < code) {
            if (node.left !== null) {
              node = node.left;
            } else {
              node.left = new _TstNode(key, value, index);
              break;
            }
          } else if (node.right !== null) {
            node = node.right;
          } else {
            node.right = new _TstNode(key, value, index);
            break;
          }
        }
      }
      /**
       * @param {Uint8Array} key
       * @return {TstNode | null}
       */
      search(key) {
        const keylength = key.length;
        let index = 0;
        let node = this;
        while (node !== null && index < keylength) {
          let code = key[index];
          if (code <= 90 && code >= 65) {
            code |= 32;
          }
          while (node !== null) {
            if (code === node.code) {
              if (keylength === ++index) {
                return node;
              }
              node = node.middle;
              break;
            }
            node = node.code < code ? node.left : node.right;
          }
        }
        return null;
      }
    };
    var TernarySearchTree = class {
      constructor() {
        /** @type {TstNode | null} */
        __publicField(this, "node", null);
      }
      /**
       * @param {string} key
       * @param {any} value
       * */
      insert(key, value) {
        if (this.node === null) {
          this.node = new TstNode(key, value, 0);
        } else {
          this.node.add(key, value);
        }
      }
      /**
       * @param {Uint8Array} key
       * @return {any}
       */
      lookup(key) {
        var _a, _b;
        return ((_b = (_a = this.node) == null ? void 0 : _a.search(key)) == null ? void 0 : _b.value) ?? null;
      }
    };
    var tree = new TernarySearchTree();
    for (let i = 0; i < wellknownHeaderNames.length; ++i) {
      const key = headerNameLowerCasedRecord[wellknownHeaderNames[i]];
      tree.insert(key, key);
    }
    module2.exports = {
      TernarySearchTree,
      tree
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/core/util.js
var require_util2 = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/core/util.js"(exports2, module2) {
    "use strict";
    var assert = require_node_assert();
    var { kDestroyed, kBodyUsed, kListeners, kBody } = require_symbols();
    var { IncomingMessage } = require_node_http();
    var stream = require_node_stream();
    var net = require_node_net();
    var { Blob: Blob2 } = require_node_buffer();
    var nodeUtil = require_node_util();
    var { stringify } = require_node_querystring();
    var { EventEmitter: EE } = require_node_events();
    var { InvalidArgumentError } = require_errors();
    var { headerNameLowerCasedRecord } = require_constants();
    var { tree } = require_tree();
    var [nodeMajor, nodeMinor] = process.versions.node.split(".").map((v) => Number(v));
    var BodyAsyncIterable = class {
      constructor(body) {
        this[kBody] = body;
        this[kBodyUsed] = false;
      }
      async *[Symbol.asyncIterator]() {
        assert(!this[kBodyUsed], "disturbed");
        this[kBodyUsed] = true;
        yield* this[kBody];
      }
    };
    function wrapRequestBody(body) {
      if (isStream(body)) {
        if (bodyLength(body) === 0) {
          body.on("data", function() {
            assert(false);
          });
        }
        if (typeof body.readableDidRead !== "boolean") {
          body[kBodyUsed] = false;
          EE.prototype.on.call(body, "data", function() {
            this[kBodyUsed] = true;
          });
        }
        return body;
      } else if (body && typeof body.pipeTo === "function") {
        return new BodyAsyncIterable(body);
      } else if (body && typeof body !== "string" && !ArrayBuffer.isView(body) && isIterable(body)) {
        return new BodyAsyncIterable(body);
      } else {
        return body;
      }
    }
    function nop() {
    }
    function isStream(obj) {
      return obj && typeof obj === "object" && typeof obj.pipe === "function" && typeof obj.on === "function";
    }
    function isBlobLike(object) {
      if (object === null) {
        return false;
      } else if (object instanceof Blob2) {
        return true;
      } else if (typeof object !== "object") {
        return false;
      } else {
        const sTag = object[Symbol.toStringTag];
        return (sTag === "Blob" || sTag === "File") && ("stream" in object && typeof object.stream === "function" || "arrayBuffer" in object && typeof object.arrayBuffer === "function");
      }
    }
    function buildURL(url, queryParams) {
      if (url.includes("?") || url.includes("#")) {
        throw new Error('Query params cannot be passed when url already contains "?" or "#".');
      }
      const stringified = stringify(queryParams);
      if (stringified) {
        url += "?" + stringified;
      }
      return url;
    }
    function isValidPort(port) {
      const value = parseInt(port, 10);
      return value === Number(port) && value >= 0 && value <= 65535;
    }
    function isHttpOrHttpsPrefixed(value) {
      return value != null && value[0] === "h" && value[1] === "t" && value[2] === "t" && value[3] === "p" && (value[4] === ":" || value[4] === "s" && value[5] === ":");
    }
    function parseURL(url) {
      if (typeof url === "string") {
        url = new URL(url);
        if (!isHttpOrHttpsPrefixed(url.origin || url.protocol)) {
          throw new InvalidArgumentError("Invalid URL protocol: the URL must start with `http:` or `https:`.");
        }
        return url;
      }
      if (!url || typeof url !== "object") {
        throw new InvalidArgumentError("Invalid URL: The URL argument must be a non-null object.");
      }
      if (!(url instanceof URL)) {
        if (url.port != null && url.port !== "" && isValidPort(url.port) === false) {
          throw new InvalidArgumentError("Invalid URL: port must be a valid integer or a string representation of an integer.");
        }
        if (url.path != null && typeof url.path !== "string") {
          throw new InvalidArgumentError("Invalid URL path: the path must be a string or null/undefined.");
        }
        if (url.pathname != null && typeof url.pathname !== "string") {
          throw new InvalidArgumentError("Invalid URL pathname: the pathname must be a string or null/undefined.");
        }
        if (url.hostname != null && typeof url.hostname !== "string") {
          throw new InvalidArgumentError("Invalid URL hostname: the hostname must be a string or null/undefined.");
        }
        if (url.origin != null && typeof url.origin !== "string") {
          throw new InvalidArgumentError("Invalid URL origin: the origin must be a string or null/undefined.");
        }
        if (!isHttpOrHttpsPrefixed(url.origin || url.protocol)) {
          throw new InvalidArgumentError("Invalid URL protocol: the URL must start with `http:` or `https:`.");
        }
        const port = url.port != null ? url.port : url.protocol === "https:" ? 443 : 80;
        let origin = url.origin != null ? url.origin : `${url.protocol || ""}//${url.hostname || ""}:${port}`;
        let path = url.path != null ? url.path : `${url.pathname || ""}${url.search || ""}`;
        if (origin[origin.length - 1] === "/") {
          origin = origin.slice(0, origin.length - 1);
        }
        if (path && path[0] !== "/") {
          path = `/${path}`;
        }
        return new URL(`${origin}${path}`);
      }
      if (!isHttpOrHttpsPrefixed(url.origin || url.protocol)) {
        throw new InvalidArgumentError("Invalid URL protocol: the URL must start with `http:` or `https:`.");
      }
      return url;
    }
    function parseOrigin(url) {
      url = parseURL(url);
      if (url.pathname !== "/" || url.search || url.hash) {
        throw new InvalidArgumentError("invalid url");
      }
      return url;
    }
    function getHostname(host) {
      if (host[0] === "[") {
        const idx2 = host.indexOf("]");
        assert(idx2 !== -1);
        return host.substring(1, idx2);
      }
      const idx = host.indexOf(":");
      if (idx === -1) return host;
      return host.substring(0, idx);
    }
    function getServerName(host) {
      if (!host) {
        return null;
      }
      assert(typeof host === "string");
      const servername = getHostname(host);
      if (net.isIP(servername)) {
        return "";
      }
      return servername;
    }
    function deepClone(obj) {
      return JSON.parse(JSON.stringify(obj));
    }
    function isAsyncIterable(obj) {
      return !!(obj != null && typeof obj[Symbol.asyncIterator] === "function");
    }
    function isIterable(obj) {
      return !!(obj != null && (typeof obj[Symbol.iterator] === "function" || typeof obj[Symbol.asyncIterator] === "function"));
    }
    function bodyLength(body) {
      if (body == null) {
        return 0;
      } else if (isStream(body)) {
        const state = body._readableState;
        return state && state.objectMode === false && state.ended === true && Number.isFinite(state.length) ? state.length : null;
      } else if (isBlobLike(body)) {
        return body.size != null ? body.size : null;
      } else if (isBuffer(body)) {
        return body.byteLength;
      }
      return null;
    }
    function isDestroyed(body) {
      var _a;
      return body && !!(body.destroyed || body[kDestroyed] || ((_a = stream.isDestroyed) == null ? void 0 : _a.call(stream, body)));
    }
    function destroy(stream2, err) {
      if (stream2 == null || !isStream(stream2) || isDestroyed(stream2)) {
        return;
      }
      if (typeof stream2.destroy === "function") {
        if (Object.getPrototypeOf(stream2).constructor === IncomingMessage) {
          stream2.socket = null;
        }
        stream2.destroy(err);
      } else if (err) {
        queueMicrotask(() => {
          stream2.emit("error", err);
        });
      }
      if (stream2.destroyed !== true) {
        stream2[kDestroyed] = true;
      }
    }
    var KEEPALIVE_TIMEOUT_EXPR = /timeout=(\d+)/;
    function parseKeepAliveTimeout(val) {
      const m = val.toString().match(KEEPALIVE_TIMEOUT_EXPR);
      return m ? parseInt(m[1], 10) * 1e3 : null;
    }
    function headerNameToString(value) {
      return typeof value === "string" ? headerNameLowerCasedRecord[value] ?? value.toLowerCase() : tree.lookup(value) ?? value.toString("latin1").toLowerCase();
    }
    function bufferToLowerCasedHeaderName(value) {
      return tree.lookup(value) ?? value.toString("latin1").toLowerCase();
    }
    function parseHeaders(headers, obj) {
      if (obj === void 0) obj = {};
      for (let i = 0; i < headers.length; i += 2) {
        const key = headerNameToString(headers[i]);
        let val = obj[key];
        if (val) {
          if (typeof val === "string") {
            val = [val];
            obj[key] = val;
          }
          val.push(headers[i + 1].toString("utf8"));
        } else {
          const headersValue = headers[i + 1];
          if (typeof headersValue === "string") {
            obj[key] = headersValue;
          } else {
            obj[key] = Array.isArray(headersValue) ? headersValue.map((x) => x.toString("utf8")) : headersValue.toString("utf8");
          }
        }
      }
      if ("content-length" in obj && "content-disposition" in obj) {
        obj["content-disposition"] = Buffer.from(obj["content-disposition"]).toString("latin1");
      }
      return obj;
    }
    function parseRawHeaders(headers) {
      const len = headers.length;
      const ret = new Array(len);
      let hasContentLength = false;
      let contentDispositionIdx = -1;
      let key;
      let val;
      let kLen = 0;
      for (let n = 0; n < headers.length; n += 2) {
        key = headers[n];
        val = headers[n + 1];
        typeof key !== "string" && (key = key.toString());
        typeof val !== "string" && (val = val.toString("utf8"));
        kLen = key.length;
        if (kLen === 14 && key[7] === "-" && (key === "content-length" || key.toLowerCase() === "content-length")) {
          hasContentLength = true;
        } else if (kLen === 19 && key[7] === "-" && (key === "content-disposition" || key.toLowerCase() === "content-disposition")) {
          contentDispositionIdx = n + 1;
        }
        ret[n] = key;
        ret[n + 1] = val;
      }
      if (hasContentLength && contentDispositionIdx !== -1) {
        ret[contentDispositionIdx] = Buffer.from(ret[contentDispositionIdx]).toString("latin1");
      }
      return ret;
    }
    function isBuffer(buffer) {
      return buffer instanceof Uint8Array || Buffer.isBuffer(buffer);
    }
    function validateHandler(handler, method, upgrade) {
      if (!handler || typeof handler !== "object") {
        throw new InvalidArgumentError("handler must be an object");
      }
      if (typeof handler.onConnect !== "function") {
        throw new InvalidArgumentError("invalid onConnect method");
      }
      if (typeof handler.onError !== "function") {
        throw new InvalidArgumentError("invalid onError method");
      }
      if (typeof handler.onBodySent !== "function" && handler.onBodySent !== void 0) {
        throw new InvalidArgumentError("invalid onBodySent method");
      }
      if (upgrade || method === "CONNECT") {
        if (typeof handler.onUpgrade !== "function") {
          throw new InvalidArgumentError("invalid onUpgrade method");
        }
      } else {
        if (typeof handler.onHeaders !== "function") {
          throw new InvalidArgumentError("invalid onHeaders method");
        }
        if (typeof handler.onData !== "function") {
          throw new InvalidArgumentError("invalid onData method");
        }
        if (typeof handler.onComplete !== "function") {
          throw new InvalidArgumentError("invalid onComplete method");
        }
      }
    }
    function isDisturbed(body) {
      return !!(body && (stream.isDisturbed(body) || body[kBodyUsed]));
    }
    function isErrored(body) {
      return !!(body && stream.isErrored(body));
    }
    function isReadable(body) {
      return !!(body && stream.isReadable(body));
    }
    function getSocketInfo(socket) {
      return {
        localAddress: socket.localAddress,
        localPort: socket.localPort,
        remoteAddress: socket.remoteAddress,
        remotePort: socket.remotePort,
        remoteFamily: socket.remoteFamily,
        timeout: socket.timeout,
        bytesWritten: socket.bytesWritten,
        bytesRead: socket.bytesRead
      };
    }
    function ReadableStreamFrom(iterable) {
      let iterator;
      return new ReadableStream(
        {
          async start() {
            iterator = iterable[Symbol.asyncIterator]();
          },
          async pull(controller) {
            const { done, value } = await iterator.next();
            if (done) {
              queueMicrotask(() => {
                var _a;
                controller.close();
                (_a = controller.byobRequest) == null ? void 0 : _a.respond(0);
              });
            } else {
              const buf = Buffer.isBuffer(value) ? value : Buffer.from(value);
              if (buf.byteLength) {
                controller.enqueue(new Uint8Array(buf));
              }
            }
            return controller.desiredSize > 0;
          },
          async cancel(reason) {
            await iterator.return();
          },
          type: "bytes"
        }
      );
    }
    function isFormDataLike(object) {
      return object && typeof object === "object" && typeof object.append === "function" && typeof object.delete === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.has === "function" && typeof object.set === "function" && object[Symbol.toStringTag] === "FormData";
    }
    function addAbortListener(signal, listener) {
      if ("addEventListener" in signal) {
        signal.addEventListener("abort", listener, { once: true });
        return () => signal.removeEventListener("abort", listener);
      }
      signal.addListener("abort", listener);
      return () => signal.removeListener("abort", listener);
    }
    var hasToWellFormed = typeof String.prototype.toWellFormed === "function";
    var hasIsWellFormed = typeof String.prototype.isWellFormed === "function";
    function toUSVString(val) {
      return hasToWellFormed ? `${val}`.toWellFormed() : nodeUtil.toUSVString(val);
    }
    function isUSVString(val) {
      return hasIsWellFormed ? `${val}`.isWellFormed() : toUSVString(val) === `${val}`;
    }
    function isTokenCharCode(c) {
      switch (c) {
        case 34:
        case 40:
        case 41:
        case 44:
        case 47:
        case 58:
        case 59:
        case 60:
        case 61:
        case 62:
        case 63:
        case 64:
        case 91:
        case 92:
        case 93:
        case 123:
        case 125:
          return false;
        default:
          return c >= 33 && c <= 126;
      }
    }
    function isValidHTTPToken(characters) {
      if (characters.length === 0) {
        return false;
      }
      for (let i = 0; i < characters.length; ++i) {
        if (!isTokenCharCode(characters.charCodeAt(i))) {
          return false;
        }
      }
      return true;
    }
    var headerCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
    function isValidHeaderValue(characters) {
      return !headerCharRegex.test(characters);
    }
    function parseRangeHeader(range) {
      if (range == null || range === "") return { start: 0, end: null, size: null };
      const m = range ? range.match(/^bytes (\d+)-(\d+)\/(\d+)?$/) : null;
      return m ? {
        start: parseInt(m[1]),
        end: m[2] ? parseInt(m[2]) : null,
        size: m[3] ? parseInt(m[3]) : null
      } : null;
    }
    function addListener(obj, name, listener) {
      const listeners = obj[kListeners] ?? (obj[kListeners] = []);
      listeners.push([name, listener]);
      obj.on(name, listener);
      return obj;
    }
    function removeAllListeners(obj) {
      for (const [name, listener] of obj[kListeners] ?? []) {
        obj.removeListener(name, listener);
      }
      obj[kListeners] = null;
    }
    function errorRequest(client, request, err) {
      try {
        request.onError(err);
        assert(request.aborted);
      } catch (err2) {
        client.emit("error", err2);
      }
    }
    var kEnumerableProperty = /* @__PURE__ */ Object.create(null);
    kEnumerableProperty.enumerable = true;
    var normalizedMethodRecordsBase = {
      delete: "DELETE",
      DELETE: "DELETE",
      get: "GET",
      GET: "GET",
      head: "HEAD",
      HEAD: "HEAD",
      options: "OPTIONS",
      OPTIONS: "OPTIONS",
      post: "POST",
      POST: "POST",
      put: "PUT",
      PUT: "PUT"
    };
    var normalizedMethodRecords = {
      ...normalizedMethodRecordsBase,
      patch: "patch",
      PATCH: "PATCH"
    };
    Object.setPrototypeOf(normalizedMethodRecordsBase, null);
    Object.setPrototypeOf(normalizedMethodRecords, null);
    module2.exports = {
      kEnumerableProperty,
      nop,
      isDisturbed,
      isErrored,
      isReadable,
      toUSVString,
      isUSVString,
      isBlobLike,
      parseOrigin,
      parseURL,
      getServerName,
      isStream,
      isIterable,
      isAsyncIterable,
      isDestroyed,
      headerNameToString,
      bufferToLowerCasedHeaderName,
      addListener,
      removeAllListeners,
      errorRequest,
      parseRawHeaders,
      parseHeaders,
      parseKeepAliveTimeout,
      destroy,
      bodyLength,
      deepClone,
      ReadableStreamFrom,
      isBuffer,
      validateHandler,
      getSocketInfo,
      isFormDataLike,
      buildURL,
      addAbortListener,
      isValidHTTPToken,
      isValidHeaderValue,
      isTokenCharCode,
      parseRangeHeader,
      normalizedMethodRecordsBase,
      normalizedMethodRecords,
      isValidPort,
      isHttpOrHttpsPrefixed,
      nodeMajor,
      nodeMinor,
      safeHTTPMethods: ["GET", "HEAD", "OPTIONS", "TRACE"],
      wrapRequestBody
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/core/diagnostics.js
var require_diagnostics = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/core/diagnostics.js"(exports2, module2) {
    "use strict";
    var diagnosticsChannel = require_node_diagnostics_channel();
    var util = require_node_util();
    var undiciDebugLog = util.debuglog("undici");
    var fetchDebuglog = util.debuglog("fetch");
    var websocketDebuglog = util.debuglog("websocket");
    var isClientSet = false;
    var channels = {
      // Client
      beforeConnect: diagnosticsChannel.channel("undici:client:beforeConnect"),
      connected: diagnosticsChannel.channel("undici:client:connected"),
      connectError: diagnosticsChannel.channel("undici:client:connectError"),
      sendHeaders: diagnosticsChannel.channel("undici:client:sendHeaders"),
      // Request
      create: diagnosticsChannel.channel("undici:request:create"),
      bodySent: diagnosticsChannel.channel("undici:request:bodySent"),
      headers: diagnosticsChannel.channel("undici:request:headers"),
      trailers: diagnosticsChannel.channel("undici:request:trailers"),
      error: diagnosticsChannel.channel("undici:request:error"),
      // WebSocket
      open: diagnosticsChannel.channel("undici:websocket:open"),
      close: diagnosticsChannel.channel("undici:websocket:close"),
      socketError: diagnosticsChannel.channel("undici:websocket:socket_error"),
      ping: diagnosticsChannel.channel("undici:websocket:ping"),
      pong: diagnosticsChannel.channel("undici:websocket:pong")
    };
    if (undiciDebugLog.enabled || fetchDebuglog.enabled) {
      const debuglog = fetchDebuglog.enabled ? fetchDebuglog : undiciDebugLog;
      diagnosticsChannel.channel("undici:client:beforeConnect").subscribe((evt) => {
        const {
          connectParams: { version, protocol, port, host }
        } = evt;
        debuglog(
          "connecting to %s using %s%s",
          `${host}${port ? `:${port}` : ""}`,
          protocol,
          version
        );
      });
      diagnosticsChannel.channel("undici:client:connected").subscribe((evt) => {
        const {
          connectParams: { version, protocol, port, host }
        } = evt;
        debuglog(
          "connected to %s using %s%s",
          `${host}${port ? `:${port}` : ""}`,
          protocol,
          version
        );
      });
      diagnosticsChannel.channel("undici:client:connectError").subscribe((evt) => {
        const {
          connectParams: { version, protocol, port, host },
          error: error2
        } = evt;
        debuglog(
          "connection to %s using %s%s errored - %s",
          `${host}${port ? `:${port}` : ""}`,
          protocol,
          version,
          error2.message
        );
      });
      diagnosticsChannel.channel("undici:client:sendHeaders").subscribe((evt) => {
        const {
          request: { method, path, origin }
        } = evt;
        debuglog("sending request to %s %s/%s", method, origin, path);
      });
      diagnosticsChannel.channel("undici:request:headers").subscribe((evt) => {
        const {
          request: { method, path, origin },
          response: { statusCode }
        } = evt;
        debuglog(
          "received response to %s %s/%s - HTTP %d",
          method,
          origin,
          path,
          statusCode
        );
      });
      diagnosticsChannel.channel("undici:request:trailers").subscribe((evt) => {
        const {
          request: { method, path, origin }
        } = evt;
        debuglog("trailers received from %s %s/%s", method, origin, path);
      });
      diagnosticsChannel.channel("undici:request:error").subscribe((evt) => {
        const {
          request: { method, path, origin },
          error: error2
        } = evt;
        debuglog(
          "request to %s %s/%s errored - %s",
          method,
          origin,
          path,
          error2.message
        );
      });
      isClientSet = true;
    }
    if (websocketDebuglog.enabled) {
      if (!isClientSet) {
        const debuglog = undiciDebugLog.enabled ? undiciDebugLog : websocketDebuglog;
        diagnosticsChannel.channel("undici:client:beforeConnect").subscribe((evt) => {
          const {
            connectParams: { version, protocol, port, host }
          } = evt;
          debuglog(
            "connecting to %s%s using %s%s",
            host,
            port ? `:${port}` : "",
            protocol,
            version
          );
        });
        diagnosticsChannel.channel("undici:client:connected").subscribe((evt) => {
          const {
            connectParams: { version, protocol, port, host }
          } = evt;
          debuglog(
            "connected to %s%s using %s%s",
            host,
            port ? `:${port}` : "",
            protocol,
            version
          );
        });
        diagnosticsChannel.channel("undici:client:connectError").subscribe((evt) => {
          const {
            connectParams: { version, protocol, port, host },
            error: error2
          } = evt;
          debuglog(
            "connection to %s%s using %s%s errored - %s",
            host,
            port ? `:${port}` : "",
            protocol,
            version,
            error2.message
          );
        });
        diagnosticsChannel.channel("undici:client:sendHeaders").subscribe((evt) => {
          const {
            request: { method, path, origin }
          } = evt;
          debuglog("sending request to %s %s/%s", method, origin, path);
        });
      }
      diagnosticsChannel.channel("undici:websocket:open").subscribe((evt) => {
        const {
          address: { address, port }
        } = evt;
        websocketDebuglog("connection opened %s%s", address, port ? `:${port}` : "");
      });
      diagnosticsChannel.channel("undici:websocket:close").subscribe((evt) => {
        const { websocket, code, reason } = evt;
        websocketDebuglog(
          "closed connection to %s - %s %s",
          websocket.url,
          code,
          reason
        );
      });
      diagnosticsChannel.channel("undici:websocket:socket_error").subscribe((err) => {
        websocketDebuglog("connection errored - %s", err.message);
      });
      diagnosticsChannel.channel("undici:websocket:ping").subscribe((evt) => {
        websocketDebuglog("ping received");
      });
      diagnosticsChannel.channel("undici:websocket:pong").subscribe((evt) => {
        websocketDebuglog("pong received");
      });
    }
    module2.exports = {
      channels
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/core/request.js
var require_request = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/core/request.js"(exports2, module2) {
    "use strict";
    var {
      InvalidArgumentError,
      NotSupportedError
    } = require_errors();
    var assert = require_node_assert();
    var {
      isValidHTTPToken,
      isValidHeaderValue,
      isStream,
      destroy,
      isBuffer,
      isFormDataLike,
      isIterable,
      isBlobLike,
      buildURL,
      validateHandler,
      getServerName,
      normalizedMethodRecords
    } = require_util2();
    var { channels } = require_diagnostics();
    var { headerNameLowerCasedRecord } = require_constants();
    var invalidPathRegex = /[^\u0021-\u00ff]/;
    var kHandler = Symbol("handler");
    var Request = class {
      constructor(origin, {
        path,
        method,
        body,
        headers,
        query,
        idempotent,
        blocking,
        upgrade,
        headersTimeout,
        bodyTimeout,
        reset,
        throwOnError,
        expectContinue,
        servername
      }, handler) {
        if (typeof path !== "string") {
          throw new InvalidArgumentError("path must be a string");
        } else if (path[0] !== "/" && !(path.startsWith("http://") || path.startsWith("https://")) && method !== "CONNECT") {
          throw new InvalidArgumentError("path must be an absolute URL or start with a slash");
        } else if (invalidPathRegex.test(path)) {
          throw new InvalidArgumentError("invalid request path");
        }
        if (typeof method !== "string") {
          throw new InvalidArgumentError("method must be a string");
        } else if (normalizedMethodRecords[method] === void 0 && !isValidHTTPToken(method)) {
          throw new InvalidArgumentError("invalid request method");
        }
        if (upgrade && typeof upgrade !== "string") {
          throw new InvalidArgumentError("upgrade must be a string");
        }
        if (headersTimeout != null && (!Number.isFinite(headersTimeout) || headersTimeout < 0)) {
          throw new InvalidArgumentError("invalid headersTimeout");
        }
        if (bodyTimeout != null && (!Number.isFinite(bodyTimeout) || bodyTimeout < 0)) {
          throw new InvalidArgumentError("invalid bodyTimeout");
        }
        if (reset != null && typeof reset !== "boolean") {
          throw new InvalidArgumentError("invalid reset");
        }
        if (expectContinue != null && typeof expectContinue !== "boolean") {
          throw new InvalidArgumentError("invalid expectContinue");
        }
        this.headersTimeout = headersTimeout;
        this.bodyTimeout = bodyTimeout;
        this.throwOnError = throwOnError === true;
        this.method = method;
        this.abort = null;
        if (body == null) {
          this.body = null;
        } else if (isStream(body)) {
          this.body = body;
          const rState = this.body._readableState;
          if (!rState || !rState.autoDestroy) {
            this.endHandler = function autoDestroy() {
              destroy(this);
            };
            this.body.on("end", this.endHandler);
          }
          this.errorHandler = (err) => {
            if (this.abort) {
              this.abort(err);
            } else {
              this.error = err;
            }
          };
          this.body.on("error", this.errorHandler);
        } else if (isBuffer(body)) {
          this.body = body.byteLength ? body : null;
        } else if (ArrayBuffer.isView(body)) {
          this.body = body.buffer.byteLength ? Buffer.from(body.buffer, body.byteOffset, body.byteLength) : null;
        } else if (body instanceof ArrayBuffer) {
          this.body = body.byteLength ? Buffer.from(body) : null;
        } else if (typeof body === "string") {
          this.body = body.length ? Buffer.from(body) : null;
        } else if (isFormDataLike(body) || isIterable(body) || isBlobLike(body)) {
          this.body = body;
        } else {
          throw new InvalidArgumentError("body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable");
        }
        this.completed = false;
        this.aborted = false;
        this.upgrade = upgrade || null;
        this.path = query ? buildURL(path, query) : path;
        this.origin = origin;
        this.idempotent = idempotent == null ? method === "HEAD" || method === "GET" : idempotent;
        this.blocking = blocking == null ? false : blocking;
        this.reset = reset == null ? null : reset;
        this.host = null;
        this.contentLength = null;
        this.contentType = null;
        this.headers = [];
        this.expectContinue = expectContinue != null ? expectContinue : false;
        if (Array.isArray(headers)) {
          if (headers.length % 2 !== 0) {
            throw new InvalidArgumentError("headers array must be even");
          }
          for (let i = 0; i < headers.length; i += 2) {
            processHeader(this, headers[i], headers[i + 1]);
          }
        } else if (headers && typeof headers === "object") {
          if (headers[Symbol.iterator]) {
            for (const header of headers) {
              if (!Array.isArray(header) || header.length !== 2) {
                throw new InvalidArgumentError("headers must be in key-value pair format");
              }
              processHeader(this, header[0], header[1]);
            }
          } else {
            const keys = Object.keys(headers);
            for (let i = 0; i < keys.length; ++i) {
              processHeader(this, keys[i], headers[keys[i]]);
            }
          }
        } else if (headers != null) {
          throw new InvalidArgumentError("headers must be an object or an array");
        }
        validateHandler(handler, method, upgrade);
        this.servername = servername || getServerName(this.host);
        this[kHandler] = handler;
        if (channels.create.hasSubscribers) {
          channels.create.publish({ request: this });
        }
      }
      onBodySent(chunk) {
        if (this[kHandler].onBodySent) {
          try {
            return this[kHandler].onBodySent(chunk);
          } catch (err) {
            this.abort(err);
          }
        }
      }
      onRequestSent() {
        if (channels.bodySent.hasSubscribers) {
          channels.bodySent.publish({ request: this });
        }
        if (this[kHandler].onRequestSent) {
          try {
            return this[kHandler].onRequestSent();
          } catch (err) {
            this.abort(err);
          }
        }
      }
      onConnect(abort) {
        assert(!this.aborted);
        assert(!this.completed);
        if (this.error) {
          abort(this.error);
        } else {
          this.abort = abort;
          return this[kHandler].onConnect(abort);
        }
      }
      onResponseStarted() {
        var _a, _b;
        return (_b = (_a = this[kHandler]).onResponseStarted) == null ? void 0 : _b.call(_a);
      }
      onHeaders(statusCode, headers, resume, statusText) {
        assert(!this.aborted);
        assert(!this.completed);
        if (channels.headers.hasSubscribers) {
          channels.headers.publish({ request: this, response: { statusCode, headers, statusText } });
        }
        try {
          return this[kHandler].onHeaders(statusCode, headers, resume, statusText);
        } catch (err) {
          this.abort(err);
        }
      }
      onData(chunk) {
        assert(!this.aborted);
        assert(!this.completed);
        try {
          return this[kHandler].onData(chunk);
        } catch (err) {
          this.abort(err);
          return false;
        }
      }
      onUpgrade(statusCode, headers, socket) {
        assert(!this.aborted);
        assert(!this.completed);
        return this[kHandler].onUpgrade(statusCode, headers, socket);
      }
      onComplete(trailers) {
        this.onFinally();
        assert(!this.aborted);
        this.completed = true;
        if (channels.trailers.hasSubscribers) {
          channels.trailers.publish({ request: this, trailers });
        }
        try {
          return this[kHandler].onComplete(trailers);
        } catch (err) {
          this.onError(err);
        }
      }
      onError(error2) {
        this.onFinally();
        if (channels.error.hasSubscribers) {
          channels.error.publish({ request: this, error: error2 });
        }
        if (this.aborted) {
          return;
        }
        this.aborted = true;
        return this[kHandler].onError(error2);
      }
      onFinally() {
        if (this.errorHandler) {
          this.body.off("error", this.errorHandler);
          this.errorHandler = null;
        }
        if (this.endHandler) {
          this.body.off("end", this.endHandler);
          this.endHandler = null;
        }
      }
      addHeader(key, value) {
        processHeader(this, key, value);
        return this;
      }
    };
    function processHeader(request, key, val) {
      if (val && (typeof val === "object" && !Array.isArray(val))) {
        throw new InvalidArgumentError(`invalid ${key} header`);
      } else if (val === void 0) {
        return;
      }
      let headerName = headerNameLowerCasedRecord[key];
      if (headerName === void 0) {
        headerName = key.toLowerCase();
        if (headerNameLowerCasedRecord[headerName] === void 0 && !isValidHTTPToken(headerName)) {
          throw new InvalidArgumentError("invalid header key");
        }
      }
      if (Array.isArray(val)) {
        const arr = [];
        for (let i = 0; i < val.length; i++) {
          if (typeof val[i] === "string") {
            if (!isValidHeaderValue(val[i])) {
              throw new InvalidArgumentError(`invalid ${key} header`);
            }
            arr.push(val[i]);
          } else if (val[i] === null) {
            arr.push("");
          } else if (typeof val[i] === "object") {
            throw new InvalidArgumentError(`invalid ${key} header`);
          } else {
            arr.push(`${val[i]}`);
          }
        }
        val = arr;
      } else if (typeof val === "string") {
        if (!isValidHeaderValue(val)) {
          throw new InvalidArgumentError(`invalid ${key} header`);
        }
      } else if (val === null) {
        val = "";
      } else {
        val = `${val}`;
      }
      if (request.host === null && headerName === "host") {
        if (typeof val !== "string") {
          throw new InvalidArgumentError("invalid host header");
        }
        request.host = val;
      } else if (request.contentLength === null && headerName === "content-length") {
        request.contentLength = parseInt(val, 10);
        if (!Number.isFinite(request.contentLength)) {
          throw new InvalidArgumentError("invalid content-length header");
        }
      } else if (request.contentType === null && headerName === "content-type") {
        request.contentType = val;
        request.headers.push(key, val);
      } else if (headerName === "transfer-encoding" || headerName === "keep-alive" || headerName === "upgrade") {
        throw new InvalidArgumentError(`invalid ${headerName} header`);
      } else if (headerName === "connection") {
        const value = typeof val === "string" ? val.toLowerCase() : null;
        if (value !== "close" && value !== "keep-alive") {
          throw new InvalidArgumentError("invalid connection header");
        }
        if (value === "close") {
          request.reset = true;
        }
      } else if (headerName === "expect") {
        throw new NotSupportedError("expect header not supported");
      } else {
        request.headers.push(key, val);
      }
    }
    module2.exports = Request;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/dispatcher/dispatcher.js
var require_dispatcher = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/dispatcher/dispatcher.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require_node_events();
    var Dispatcher = class extends EventEmitter {
      dispatch() {
        throw new Error("not implemented");
      }
      close() {
        throw new Error("not implemented");
      }
      destroy() {
        throw new Error("not implemented");
      }
      compose(...args) {
        const interceptors = Array.isArray(args[0]) ? args[0] : args;
        let dispatch = this.dispatch.bind(this);
        for (const interceptor of interceptors) {
          if (interceptor == null) {
            continue;
          }
          if (typeof interceptor !== "function") {
            throw new TypeError(`invalid interceptor, expected function received ${typeof interceptor}`);
          }
          dispatch = interceptor(dispatch);
          if (dispatch == null || typeof dispatch !== "function" || dispatch.length !== 2) {
            throw new TypeError("invalid interceptor");
          }
        }
        return new ComposedDispatcher(this, dispatch);
      }
    };
    var _dispatcher, _dispatch;
    var ComposedDispatcher = class extends Dispatcher {
      constructor(dispatcher, dispatch) {
        super();
        __privateAdd(this, _dispatcher, null);
        __privateAdd(this, _dispatch, null);
        __privateSet(this, _dispatcher, dispatcher);
        __privateSet(this, _dispatch, dispatch);
      }
      dispatch(...args) {
        __privateGet(this, _dispatch).call(this, ...args);
      }
      close(...args) {
        return __privateGet(this, _dispatcher).close(...args);
      }
      destroy(...args) {
        return __privateGet(this, _dispatcher).destroy(...args);
      }
    };
    _dispatcher = new WeakMap();
    _dispatch = new WeakMap();
    module2.exports = Dispatcher;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/dispatcher/dispatcher-base.js
var require_dispatcher_base = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/dispatcher/dispatcher-base.js"(exports2, module2) {
    "use strict";
    var Dispatcher = require_dispatcher();
    var {
      ClientDestroyedError,
      ClientClosedError,
      InvalidArgumentError
    } = require_errors();
    var { kDestroy, kClose, kClosed, kDestroyed, kDispatch, kInterceptors } = require_symbols();
    var kOnDestroyed = Symbol("onDestroyed");
    var kOnClosed = Symbol("onClosed");
    var kInterceptedDispatch = Symbol("Intercepted Dispatch");
    var DispatcherBase = class extends Dispatcher {
      constructor() {
        super();
        this[kDestroyed] = false;
        this[kOnDestroyed] = null;
        this[kClosed] = false;
        this[kOnClosed] = [];
      }
      get destroyed() {
        return this[kDestroyed];
      }
      get closed() {
        return this[kClosed];
      }
      get interceptors() {
        return this[kInterceptors];
      }
      set interceptors(newInterceptors) {
        if (newInterceptors) {
          for (let i = newInterceptors.length - 1; i >= 0; i--) {
            const interceptor = this[kInterceptors][i];
            if (typeof interceptor !== "function") {
              throw new InvalidArgumentError("interceptor must be an function");
            }
          }
        }
        this[kInterceptors] = newInterceptors;
      }
      close(callback) {
        if (callback === void 0) {
          return new Promise((resolve, reject) => {
            this.close((err, data) => {
              return err ? reject(err) : resolve(data);
            });
          });
        }
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        if (this[kDestroyed]) {
          queueMicrotask(() => callback(new ClientDestroyedError(), null));
          return;
        }
        if (this[kClosed]) {
          if (this[kOnClosed]) {
            this[kOnClosed].push(callback);
          } else {
            queueMicrotask(() => callback(null, null));
          }
          return;
        }
        this[kClosed] = true;
        this[kOnClosed].push(callback);
        const onClosed = () => {
          const callbacks = this[kOnClosed];
          this[kOnClosed] = null;
          for (let i = 0; i < callbacks.length; i++) {
            callbacks[i](null, null);
          }
        };
        this[kClose]().then(() => this.destroy()).then(() => {
          queueMicrotask(onClosed);
        });
      }
      destroy(err, callback) {
        if (typeof err === "function") {
          callback = err;
          err = null;
        }
        if (callback === void 0) {
          return new Promise((resolve, reject) => {
            this.destroy(err, (err2, data) => {
              return err2 ? (
                /* istanbul ignore next: should never error */
                reject(err2)
              ) : resolve(data);
            });
          });
        }
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        if (this[kDestroyed]) {
          if (this[kOnDestroyed]) {
            this[kOnDestroyed].push(callback);
          } else {
            queueMicrotask(() => callback(null, null));
          }
          return;
        }
        if (!err) {
          err = new ClientDestroyedError();
        }
        this[kDestroyed] = true;
        this[kOnDestroyed] = this[kOnDestroyed] || [];
        this[kOnDestroyed].push(callback);
        const onDestroyed = () => {
          const callbacks = this[kOnDestroyed];
          this[kOnDestroyed] = null;
          for (let i = 0; i < callbacks.length; i++) {
            callbacks[i](null, null);
          }
        };
        this[kDestroy](err).then(() => {
          queueMicrotask(onDestroyed);
        });
      }
      [kInterceptedDispatch](opts, handler) {
        if (!this[kInterceptors] || this[kInterceptors].length === 0) {
          this[kInterceptedDispatch] = this[kDispatch];
          return this[kDispatch](opts, handler);
        }
        let dispatch = this[kDispatch].bind(this);
        for (let i = this[kInterceptors].length - 1; i >= 0; i--) {
          dispatch = this[kInterceptors][i](dispatch);
        }
        this[kInterceptedDispatch] = dispatch;
        return dispatch(opts, handler);
      }
      dispatch(opts, handler) {
        if (!handler || typeof handler !== "object") {
          throw new InvalidArgumentError("handler must be an object");
        }
        try {
          if (!opts || typeof opts !== "object") {
            throw new InvalidArgumentError("opts must be an object.");
          }
          if (this[kDestroyed] || this[kOnDestroyed]) {
            throw new ClientDestroyedError();
          }
          if (this[kClosed]) {
            throw new ClientClosedError();
          }
          return this[kInterceptedDispatch](opts, handler);
        } catch (err) {
          if (typeof handler.onError !== "function") {
            throw new InvalidArgumentError("invalid onError method");
          }
          handler.onError(err);
          return false;
        }
      }
    };
    module2.exports = DispatcherBase;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/util/timers.js
var require_timers = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/util/timers.js"(exports2, module2) {
    "use strict";
    var fastNow = 0;
    var RESOLUTION_MS = 1e3;
    var TICK_MS = (RESOLUTION_MS >> 1) - 1;
    var fastNowTimeout;
    var kFastTimer = Symbol("kFastTimer");
    var fastTimers = [];
    var NOT_IN_LIST = -2;
    var TO_BE_CLEARED = -1;
    var PENDING = 0;
    var ACTIVE = 1;
    function onTick() {
      fastNow += TICK_MS;
      let idx = 0;
      let len = fastTimers.length;
      while (idx < len) {
        const timer = fastTimers[idx];
        if (timer._state === PENDING) {
          timer._idleStart = fastNow - TICK_MS;
          timer._state = ACTIVE;
        } else if (timer._state === ACTIVE && fastNow >= timer._idleStart + timer._idleTimeout) {
          timer._state = TO_BE_CLEARED;
          timer._idleStart = -1;
          timer._onTimeout(timer._timerArg);
        }
        if (timer._state === TO_BE_CLEARED) {
          timer._state = NOT_IN_LIST;
          if (--len !== 0) {
            fastTimers[idx] = fastTimers[len];
          }
        } else {
          ++idx;
        }
      }
      fastTimers.length = len;
      if (fastTimers.length !== 0) {
        refreshTimeout();
      }
    }
    function refreshTimeout() {
      if (fastNowTimeout) {
        fastNowTimeout.refresh();
      } else {
        clearTimeout(fastNowTimeout);
        fastNowTimeout = setTimeout(onTick, TICK_MS);
        if (fastNowTimeout.unref) {
          fastNowTimeout.unref();
        }
      }
    }
    var _a;
    _a = kFastTimer;
    var FastTimer = class {
      /**
       * @constructor
       * @param {Function} callback A function to be executed after the timer
       * expires.
       * @param {number} delay The time, in milliseconds that the timer should wait
       * before the specified function or code is executed.
       * @param {*} arg
       */
      constructor(callback, delay, arg) {
        __publicField(this, _a, true);
        /**
         * The state of the timer, which can be one of the following:
         * - NOT_IN_LIST (-2)
         * - TO_BE_CLEARED (-1)
         * - PENDING (0)
         * - ACTIVE (1)
         *
         * @type {-2|-1|0|1}
         * @private
         */
        __publicField(this, "_state", NOT_IN_LIST);
        /**
         * The number of milliseconds to wait before calling the callback.
         *
         * @type {number}
         * @private
         */
        __publicField(this, "_idleTimeout", -1);
        /**
         * The time in milliseconds when the timer was started. This value is used to
         * calculate when the timer should expire.
         *
         * @type {number}
         * @default -1
         * @private
         */
        __publicField(this, "_idleStart", -1);
        /**
         * The function to be executed when the timer expires.
         * @type {Function}
         * @private
         */
        __publicField(this, "_onTimeout");
        /**
         * The argument to be passed to the callback when the timer expires.
         *
         * @type {*}
         * @private
         */
        __publicField(this, "_timerArg");
        this._onTimeout = callback;
        this._idleTimeout = delay;
        this._timerArg = arg;
        this.refresh();
      }
      /**
       * Sets the timer's start time to the current time, and reschedules the timer
       * to call its callback at the previously specified duration adjusted to the
       * current time.
       * Using this on a timer that has already called its callback will reactivate
       * the timer.
       *
       * @returns {void}
       */
      refresh() {
        if (this._state === NOT_IN_LIST) {
          fastTimers.push(this);
        }
        if (!fastNowTimeout || fastTimers.length === 1) {
          refreshTimeout();
        }
        this._state = PENDING;
      }
      /**
       * The `clear` method cancels the timer, preventing it from executing.
       *
       * @returns {void}
       * @private
       */
      clear() {
        this._state = TO_BE_CLEARED;
        this._idleStart = -1;
      }
    };
    module2.exports = {
      /**
       * The setTimeout() method sets a timer which executes a function once the
       * timer expires.
       * @param {Function} callback A function to be executed after the timer
       * expires.
       * @param {number} delay The time, in milliseconds that the timer should
       * wait before the specified function or code is executed.
       * @param {*} [arg] An optional argument to be passed to the callback function
       * when the timer expires.
       * @returns {NodeJS.Timeout|FastTimer}
       */
      setTimeout(callback, delay, arg) {
        return delay <= RESOLUTION_MS ? setTimeout(callback, delay, arg) : new FastTimer(callback, delay, arg);
      },
      /**
       * The clearTimeout method cancels an instantiated Timer previously created
       * by calling setTimeout.
       *
       * @param {NodeJS.Timeout|FastTimer} timeout
       */
      clearTimeout(timeout) {
        if (timeout[kFastTimer]) {
          timeout.clear();
        } else {
          clearTimeout(timeout);
        }
      },
      /**
       * The setFastTimeout() method sets a fastTimer which executes a function once
       * the timer expires.
       * @param {Function} callback A function to be executed after the timer
       * expires.
       * @param {number} delay The time, in milliseconds that the timer should
       * wait before the specified function or code is executed.
       * @param {*} [arg] An optional argument to be passed to the callback function
       * when the timer expires.
       * @returns {FastTimer}
       */
      setFastTimeout(callback, delay, arg) {
        return new FastTimer(callback, delay, arg);
      },
      /**
       * The clearTimeout method cancels an instantiated FastTimer previously
       * created by calling setFastTimeout.
       *
       * @param {FastTimer} timeout
       */
      clearFastTimeout(timeout) {
        timeout.clear();
      },
      /**
       * The now method returns the value of the internal fast timer clock.
       *
       * @returns {number}
       */
      now() {
        return fastNow;
      },
      /**
       * Trigger the onTick function to process the fastTimers array.
       * Exported for testing purposes only.
       * Marking as deprecated to discourage any use outside of testing.
       * @deprecated
       * @param {number} [delay=0] The delay in milliseconds to add to the now value.
       */
      tick(delay = 0) {
        fastNow += delay - RESOLUTION_MS + 1;
        onTick();
        onTick();
      },
      /**
       * Reset FastTimers.
       * Exported for testing purposes only.
       * Marking as deprecated to discourage any use outside of testing.
       * @deprecated
       */
      reset() {
        fastNow = 0;
        fastTimers.length = 0;
        clearTimeout(fastNowTimeout);
        fastNowTimeout = null;
      },
      /**
       * Exporting for testing purposes only.
       * Marking as deprecated to discourage any use outside of testing.
       * @deprecated
       */
      kFastTimer
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/core/connect.js
var require_connect = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/core/connect.js"(exports2, module2) {
    "use strict";
    var net = require_node_net();
    var assert = require_node_assert();
    var util = require_util2();
    var { InvalidArgumentError, ConnectTimeoutError } = require_errors();
    var timers = require_timers();
    function noop() {
    }
    var tls;
    var SessionCache;
    if (global.FinalizationRegistry && !(process.env.NODE_V8_COVERAGE || process.env.UNDICI_NO_FG)) {
      SessionCache = class WeakSessionCache {
        constructor(maxCachedSessions) {
          this._maxCachedSessions = maxCachedSessions;
          this._sessionCache = /* @__PURE__ */ new Map();
          this._sessionRegistry = new global.FinalizationRegistry((key) => {
            if (this._sessionCache.size < this._maxCachedSessions) {
              return;
            }
            const ref = this._sessionCache.get(key);
            if (ref !== void 0 && ref.deref() === void 0) {
              this._sessionCache.delete(key);
            }
          });
        }
        get(sessionKey) {
          const ref = this._sessionCache.get(sessionKey);
          return ref ? ref.deref() : null;
        }
        set(sessionKey, session) {
          if (this._maxCachedSessions === 0) {
            return;
          }
          this._sessionCache.set(sessionKey, new WeakRef(session));
          this._sessionRegistry.register(session, sessionKey);
        }
      };
    } else {
      SessionCache = class SimpleSessionCache {
        constructor(maxCachedSessions) {
          this._maxCachedSessions = maxCachedSessions;
          this._sessionCache = /* @__PURE__ */ new Map();
        }
        get(sessionKey) {
          return this._sessionCache.get(sessionKey);
        }
        set(sessionKey, session) {
          if (this._maxCachedSessions === 0) {
            return;
          }
          if (this._sessionCache.size >= this._maxCachedSessions) {
            const { value: oldestKey } = this._sessionCache.keys().next();
            this._sessionCache.delete(oldestKey);
          }
          this._sessionCache.set(sessionKey, session);
        }
      };
    }
    function buildConnector({ allowH2, maxCachedSessions, socketPath, timeout, session: customSession, ...opts }) {
      if (maxCachedSessions != null && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)) {
        throw new InvalidArgumentError("maxCachedSessions must be a positive integer or zero");
      }
      const options = { path: socketPath, ...opts };
      const sessionCache = new SessionCache(maxCachedSessions == null ? 100 : maxCachedSessions);
      timeout = timeout == null ? 1e4 : timeout;
      allowH2 = allowH2 != null ? allowH2 : false;
      return function connect({ hostname, host, protocol, port, servername, localAddress, httpSocket }, callback) {
        let socket;
        if (protocol === "https:") {
          if (!tls) {
            tls = require_node_tls();
          }
          servername = servername || options.servername || util.getServerName(host) || null;
          const sessionKey = servername || hostname;
          assert(sessionKey);
          const session = customSession || sessionCache.get(sessionKey) || null;
          port = port || 443;
          socket = tls.connect({
            highWaterMark: 16384,
            // TLS in node can't have bigger HWM anyway...
            ...options,
            servername,
            session,
            localAddress,
            // TODO(HTTP/2): Add support for h2c
            ALPNProtocols: allowH2 ? ["http/1.1", "h2"] : ["http/1.1"],
            socket: httpSocket,
            // upgrade socket connection
            port,
            host: hostname
          });
          socket.on("session", function(session2) {
            sessionCache.set(sessionKey, session2);
          });
        } else {
          assert(!httpSocket, "httpSocket can only be sent on TLS update");
          port = port || 80;
          socket = net.connect({
            highWaterMark: 64 * 1024,
            // Same as nodejs fs streams.
            ...options,
            localAddress,
            port,
            host: hostname
          });
        }
        if (options.keepAlive == null || options.keepAlive) {
          const keepAliveInitialDelay = options.keepAliveInitialDelay === void 0 ? 6e4 : options.keepAliveInitialDelay;
          socket.setKeepAlive(true, keepAliveInitialDelay);
        }
        const clearConnectTimeout = setupConnectTimeout(new WeakRef(socket), { timeout, hostname, port });
        socket.setNoDelay(true).once(protocol === "https:" ? "secureConnect" : "connect", function() {
          queueMicrotask(clearConnectTimeout);
          if (callback) {
            const cb = callback;
            callback = null;
            cb(null, this);
          }
        }).on("error", function(err) {
          queueMicrotask(clearConnectTimeout);
          if (callback) {
            const cb = callback;
            callback = null;
            cb(err);
          }
        });
        return socket;
      };
    }
    var setupConnectTimeout = process.platform === "win32" ? (socketWeakRef, opts) => {
      if (!opts.timeout) {
        return noop;
      }
      let s1 = null;
      let s2 = null;
      const fastTimer = timers.setFastTimeout(() => {
        s1 = setImmediate(() => {
          s2 = setImmediate(() => onConnectTimeout(socketWeakRef.deref(), opts));
        });
      }, opts.timeout);
      return () => {
        timers.clearFastTimeout(fastTimer);
        clearImmediate(s1);
        clearImmediate(s2);
      };
    } : (socketWeakRef, opts) => {
      if (!opts.timeout) {
        return noop;
      }
      let s1 = null;
      const fastTimer = timers.setFastTimeout(() => {
        s1 = setImmediate(() => {
          onConnectTimeout(socketWeakRef.deref(), opts);
        });
      }, opts.timeout);
      return () => {
        timers.clearFastTimeout(fastTimer);
        clearImmediate(s1);
      };
    };
    function onConnectTimeout(socket, opts) {
      if (socket == null) {
        return;
      }
      let message = "Connect Timeout Error";
      if (Array.isArray(socket.autoSelectFamilyAttemptedAddresses)) {
        message += ` (attempted addresses: ${socket.autoSelectFamilyAttemptedAddresses.join(", ")},`;
      } else {
        message += ` (attempted address: ${opts.hostname}:${opts.port},`;
      }
      message += ` timeout: ${opts.timeout}ms)`;
      util.destroy(socket, new ConnectTimeoutError(message));
    }
    module2.exports = buildConnector;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/llhttp/utils.js
var require_utils = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/llhttp/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.enumToMap = void 0;
    function enumToMap(obj) {
      const res = {};
      Object.keys(obj).forEach((key) => {
        const value = obj[key];
        if (typeof value === "number") {
          res[key] = value;
        }
      });
      return res;
    }
    exports2.enumToMap = enumToMap;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/llhttp/constants.js
var require_constants2 = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/llhttp/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SPECIAL_HEADERS = exports2.HEADER_STATE = exports2.MINOR = exports2.MAJOR = exports2.CONNECTION_TOKEN_CHARS = exports2.HEADER_CHARS = exports2.TOKEN = exports2.STRICT_TOKEN = exports2.HEX = exports2.URL_CHAR = exports2.STRICT_URL_CHAR = exports2.USERINFO_CHARS = exports2.MARK = exports2.ALPHANUM = exports2.NUM = exports2.HEX_MAP = exports2.NUM_MAP = exports2.ALPHA = exports2.FINISH = exports2.H_METHOD_MAP = exports2.METHOD_MAP = exports2.METHODS_RTSP = exports2.METHODS_ICE = exports2.METHODS_HTTP = exports2.METHODS = exports2.LENIENT_FLAGS = exports2.FLAGS = exports2.TYPE = exports2.ERROR = void 0;
    var utils_1 = require_utils();
    var ERROR;
    (function(ERROR2) {
      ERROR2[ERROR2["OK"] = 0] = "OK";
      ERROR2[ERROR2["INTERNAL"] = 1] = "INTERNAL";
      ERROR2[ERROR2["STRICT"] = 2] = "STRICT";
      ERROR2[ERROR2["LF_EXPECTED"] = 3] = "LF_EXPECTED";
      ERROR2[ERROR2["UNEXPECTED_CONTENT_LENGTH"] = 4] = "UNEXPECTED_CONTENT_LENGTH";
      ERROR2[ERROR2["CLOSED_CONNECTION"] = 5] = "CLOSED_CONNECTION";
      ERROR2[ERROR2["INVALID_METHOD"] = 6] = "INVALID_METHOD";
      ERROR2[ERROR2["INVALID_URL"] = 7] = "INVALID_URL";
      ERROR2[ERROR2["INVALID_CONSTANT"] = 8] = "INVALID_CONSTANT";
      ERROR2[ERROR2["INVALID_VERSION"] = 9] = "INVALID_VERSION";
      ERROR2[ERROR2["INVALID_HEADER_TOKEN"] = 10] = "INVALID_HEADER_TOKEN";
      ERROR2[ERROR2["INVALID_CONTENT_LENGTH"] = 11] = "INVALID_CONTENT_LENGTH";
      ERROR2[ERROR2["INVALID_CHUNK_SIZE"] = 12] = "INVALID_CHUNK_SIZE";
      ERROR2[ERROR2["INVALID_STATUS"] = 13] = "INVALID_STATUS";
      ERROR2[ERROR2["INVALID_EOF_STATE"] = 14] = "INVALID_EOF_STATE";
      ERROR2[ERROR2["INVALID_TRANSFER_ENCODING"] = 15] = "INVALID_TRANSFER_ENCODING";
      ERROR2[ERROR2["CB_MESSAGE_BEGIN"] = 16] = "CB_MESSAGE_BEGIN";
      ERROR2[ERROR2["CB_HEADERS_COMPLETE"] = 17] = "CB_HEADERS_COMPLETE";
      ERROR2[ERROR2["CB_MESSAGE_COMPLETE"] = 18] = "CB_MESSAGE_COMPLETE";
      ERROR2[ERROR2["CB_CHUNK_HEADER"] = 19] = "CB_CHUNK_HEADER";
      ERROR2[ERROR2["CB_CHUNK_COMPLETE"] = 20] = "CB_CHUNK_COMPLETE";
      ERROR2[ERROR2["PAUSED"] = 21] = "PAUSED";
      ERROR2[ERROR2["PAUSED_UPGRADE"] = 22] = "PAUSED_UPGRADE";
      ERROR2[ERROR2["PAUSED_H2_UPGRADE"] = 23] = "PAUSED_H2_UPGRADE";
      ERROR2[ERROR2["USER"] = 24] = "USER";
    })(ERROR = exports2.ERROR || (exports2.ERROR = {}));
    var TYPE;
    (function(TYPE2) {
      TYPE2[TYPE2["BOTH"] = 0] = "BOTH";
      TYPE2[TYPE2["REQUEST"] = 1] = "REQUEST";
      TYPE2[TYPE2["RESPONSE"] = 2] = "RESPONSE";
    })(TYPE = exports2.TYPE || (exports2.TYPE = {}));
    var FLAGS;
    (function(FLAGS2) {
      FLAGS2[FLAGS2["CONNECTION_KEEP_ALIVE"] = 1] = "CONNECTION_KEEP_ALIVE";
      FLAGS2[FLAGS2["CONNECTION_CLOSE"] = 2] = "CONNECTION_CLOSE";
      FLAGS2[FLAGS2["CONNECTION_UPGRADE"] = 4] = "CONNECTION_UPGRADE";
      FLAGS2[FLAGS2["CHUNKED"] = 8] = "CHUNKED";
      FLAGS2[FLAGS2["UPGRADE"] = 16] = "UPGRADE";
      FLAGS2[FLAGS2["CONTENT_LENGTH"] = 32] = "CONTENT_LENGTH";
      FLAGS2[FLAGS2["SKIPBODY"] = 64] = "SKIPBODY";
      FLAGS2[FLAGS2["TRAILING"] = 128] = "TRAILING";
      FLAGS2[FLAGS2["TRANSFER_ENCODING"] = 512] = "TRANSFER_ENCODING";
    })(FLAGS = exports2.FLAGS || (exports2.FLAGS = {}));
    var LENIENT_FLAGS;
    (function(LENIENT_FLAGS2) {
      LENIENT_FLAGS2[LENIENT_FLAGS2["HEADERS"] = 1] = "HEADERS";
      LENIENT_FLAGS2[LENIENT_FLAGS2["CHUNKED_LENGTH"] = 2] = "CHUNKED_LENGTH";
      LENIENT_FLAGS2[LENIENT_FLAGS2["KEEP_ALIVE"] = 4] = "KEEP_ALIVE";
    })(LENIENT_FLAGS = exports2.LENIENT_FLAGS || (exports2.LENIENT_FLAGS = {}));
    var METHODS;
    (function(METHODS2) {
      METHODS2[METHODS2["DELETE"] = 0] = "DELETE";
      METHODS2[METHODS2["GET"] = 1] = "GET";
      METHODS2[METHODS2["HEAD"] = 2] = "HEAD";
      METHODS2[METHODS2["POST"] = 3] = "POST";
      METHODS2[METHODS2["PUT"] = 4] = "PUT";
      METHODS2[METHODS2["CONNECT"] = 5] = "CONNECT";
      METHODS2[METHODS2["OPTIONS"] = 6] = "OPTIONS";
      METHODS2[METHODS2["TRACE"] = 7] = "TRACE";
      METHODS2[METHODS2["COPY"] = 8] = "COPY";
      METHODS2[METHODS2["LOCK"] = 9] = "LOCK";
      METHODS2[METHODS2["MKCOL"] = 10] = "MKCOL";
      METHODS2[METHODS2["MOVE"] = 11] = "MOVE";
      METHODS2[METHODS2["PROPFIND"] = 12] = "PROPFIND";
      METHODS2[METHODS2["PROPPATCH"] = 13] = "PROPPATCH";
      METHODS2[METHODS2["SEARCH"] = 14] = "SEARCH";
      METHODS2[METHODS2["UNLOCK"] = 15] = "UNLOCK";
      METHODS2[METHODS2["BIND"] = 16] = "BIND";
      METHODS2[METHODS2["REBIND"] = 17] = "REBIND";
      METHODS2[METHODS2["UNBIND"] = 18] = "UNBIND";
      METHODS2[METHODS2["ACL"] = 19] = "ACL";
      METHODS2[METHODS2["REPORT"] = 20] = "REPORT";
      METHODS2[METHODS2["MKACTIVITY"] = 21] = "MKACTIVITY";
      METHODS2[METHODS2["CHECKOUT"] = 22] = "CHECKOUT";
      METHODS2[METHODS2["MERGE"] = 23] = "MERGE";
      METHODS2[METHODS2["M-SEARCH"] = 24] = "M-SEARCH";
      METHODS2[METHODS2["NOTIFY"] = 25] = "NOTIFY";
      METHODS2[METHODS2["SUBSCRIBE"] = 26] = "SUBSCRIBE";
      METHODS2[METHODS2["UNSUBSCRIBE"] = 27] = "UNSUBSCRIBE";
      METHODS2[METHODS2["PATCH"] = 28] = "PATCH";
      METHODS2[METHODS2["PURGE"] = 29] = "PURGE";
      METHODS2[METHODS2["MKCALENDAR"] = 30] = "MKCALENDAR";
      METHODS2[METHODS2["LINK"] = 31] = "LINK";
      METHODS2[METHODS2["UNLINK"] = 32] = "UNLINK";
      METHODS2[METHODS2["SOURCE"] = 33] = "SOURCE";
      METHODS2[METHODS2["PRI"] = 34] = "PRI";
      METHODS2[METHODS2["DESCRIBE"] = 35] = "DESCRIBE";
      METHODS2[METHODS2["ANNOUNCE"] = 36] = "ANNOUNCE";
      METHODS2[METHODS2["SETUP"] = 37] = "SETUP";
      METHODS2[METHODS2["PLAY"] = 38] = "PLAY";
      METHODS2[METHODS2["PAUSE"] = 39] = "PAUSE";
      METHODS2[METHODS2["TEARDOWN"] = 40] = "TEARDOWN";
      METHODS2[METHODS2["GET_PARAMETER"] = 41] = "GET_PARAMETER";
      METHODS2[METHODS2["SET_PARAMETER"] = 42] = "SET_PARAMETER";
      METHODS2[METHODS2["REDIRECT"] = 43] = "REDIRECT";
      METHODS2[METHODS2["RECORD"] = 44] = "RECORD";
      METHODS2[METHODS2["FLUSH"] = 45] = "FLUSH";
    })(METHODS = exports2.METHODS || (exports2.METHODS = {}));
    exports2.METHODS_HTTP = [
      METHODS.DELETE,
      METHODS.GET,
      METHODS.HEAD,
      METHODS.POST,
      METHODS.PUT,
      METHODS.CONNECT,
      METHODS.OPTIONS,
      METHODS.TRACE,
      METHODS.COPY,
      METHODS.LOCK,
      METHODS.MKCOL,
      METHODS.MOVE,
      METHODS.PROPFIND,
      METHODS.PROPPATCH,
      METHODS.SEARCH,
      METHODS.UNLOCK,
      METHODS.BIND,
      METHODS.REBIND,
      METHODS.UNBIND,
      METHODS.ACL,
      METHODS.REPORT,
      METHODS.MKACTIVITY,
      METHODS.CHECKOUT,
      METHODS.MERGE,
      METHODS["M-SEARCH"],
      METHODS.NOTIFY,
      METHODS.SUBSCRIBE,
      METHODS.UNSUBSCRIBE,
      METHODS.PATCH,
      METHODS.PURGE,
      METHODS.MKCALENDAR,
      METHODS.LINK,
      METHODS.UNLINK,
      METHODS.PRI,
      // TODO(indutny): should we allow it with HTTP?
      METHODS.SOURCE
    ];
    exports2.METHODS_ICE = [
      METHODS.SOURCE
    ];
    exports2.METHODS_RTSP = [
      METHODS.OPTIONS,
      METHODS.DESCRIBE,
      METHODS.ANNOUNCE,
      METHODS.SETUP,
      METHODS.PLAY,
      METHODS.PAUSE,
      METHODS.TEARDOWN,
      METHODS.GET_PARAMETER,
      METHODS.SET_PARAMETER,
      METHODS.REDIRECT,
      METHODS.RECORD,
      METHODS.FLUSH,
      // For AirPlay
      METHODS.GET,
      METHODS.POST
    ];
    exports2.METHOD_MAP = utils_1.enumToMap(METHODS);
    exports2.H_METHOD_MAP = {};
    Object.keys(exports2.METHOD_MAP).forEach((key) => {
      if (/^H/.test(key)) {
        exports2.H_METHOD_MAP[key] = exports2.METHOD_MAP[key];
      }
    });
    var FINISH;
    (function(FINISH2) {
      FINISH2[FINISH2["SAFE"] = 0] = "SAFE";
      FINISH2[FINISH2["SAFE_WITH_CB"] = 1] = "SAFE_WITH_CB";
      FINISH2[FINISH2["UNSAFE"] = 2] = "UNSAFE";
    })(FINISH = exports2.FINISH || (exports2.FINISH = {}));
    exports2.ALPHA = [];
    for (let i = "A".charCodeAt(0); i <= "Z".charCodeAt(0); i++) {
      exports2.ALPHA.push(String.fromCharCode(i));
      exports2.ALPHA.push(String.fromCharCode(i + 32));
    }
    exports2.NUM_MAP = {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9
    };
    exports2.HEX_MAP = {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9,
      A: 10,
      B: 11,
      C: 12,
      D: 13,
      E: 14,
      F: 15,
      a: 10,
      b: 11,
      c: 12,
      d: 13,
      e: 14,
      f: 15
    };
    exports2.NUM = [
      "0",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9"
    ];
    exports2.ALPHANUM = exports2.ALPHA.concat(exports2.NUM);
    exports2.MARK = ["-", "_", ".", "!", "~", "*", "'", "(", ")"];
    exports2.USERINFO_CHARS = exports2.ALPHANUM.concat(exports2.MARK).concat(["%", ";", ":", "&", "=", "+", "$", ","]);
    exports2.STRICT_URL_CHAR = [
      "!",
      '"',
      "$",
      "%",
      "&",
      "'",
      "(",
      ")",
      "*",
      "+",
      ",",
      "-",
      ".",
      "/",
      ":",
      ";",
      "<",
      "=",
      ">",
      "@",
      "[",
      "\\",
      "]",
      "^",
      "_",
      "`",
      "{",
      "|",
      "}",
      "~"
    ].concat(exports2.ALPHANUM);
    exports2.URL_CHAR = exports2.STRICT_URL_CHAR.concat(["	", "\f"]);
    for (let i = 128; i <= 255; i++) {
      exports2.URL_CHAR.push(i);
    }
    exports2.HEX = exports2.NUM.concat(["a", "b", "c", "d", "e", "f", "A", "B", "C", "D", "E", "F"]);
    exports2.STRICT_TOKEN = [
      "!",
      "#",
      "$",
      "%",
      "&",
      "'",
      "*",
      "+",
      "-",
      ".",
      "^",
      "_",
      "`",
      "|",
      "~"
    ].concat(exports2.ALPHANUM);
    exports2.TOKEN = exports2.STRICT_TOKEN.concat([" "]);
    exports2.HEADER_CHARS = ["	"];
    for (let i = 32; i <= 255; i++) {
      if (i !== 127) {
        exports2.HEADER_CHARS.push(i);
      }
    }
    exports2.CONNECTION_TOKEN_CHARS = exports2.HEADER_CHARS.filter((c) => c !== 44);
    exports2.MAJOR = exports2.NUM_MAP;
    exports2.MINOR = exports2.MAJOR;
    var HEADER_STATE;
    (function(HEADER_STATE2) {
      HEADER_STATE2[HEADER_STATE2["GENERAL"] = 0] = "GENERAL";
      HEADER_STATE2[HEADER_STATE2["CONNECTION"] = 1] = "CONNECTION";
      HEADER_STATE2[HEADER_STATE2["CONTENT_LENGTH"] = 2] = "CONTENT_LENGTH";
      HEADER_STATE2[HEADER_STATE2["TRANSFER_ENCODING"] = 3] = "TRANSFER_ENCODING";
      HEADER_STATE2[HEADER_STATE2["UPGRADE"] = 4] = "UPGRADE";
      HEADER_STATE2[HEADER_STATE2["CONNECTION_KEEP_ALIVE"] = 5] = "CONNECTION_KEEP_ALIVE";
      HEADER_STATE2[HEADER_STATE2["CONNECTION_CLOSE"] = 6] = "CONNECTION_CLOSE";
      HEADER_STATE2[HEADER_STATE2["CONNECTION_UPGRADE"] = 7] = "CONNECTION_UPGRADE";
      HEADER_STATE2[HEADER_STATE2["TRANSFER_ENCODING_CHUNKED"] = 8] = "TRANSFER_ENCODING_CHUNKED";
    })(HEADER_STATE = exports2.HEADER_STATE || (exports2.HEADER_STATE = {}));
    exports2.SPECIAL_HEADERS = {
      "connection": HEADER_STATE.CONNECTION,
      "content-length": HEADER_STATE.CONTENT_LENGTH,
      "proxy-connection": HEADER_STATE.CONNECTION,
      "transfer-encoding": HEADER_STATE.TRANSFER_ENCODING,
      "upgrade": HEADER_STATE.UPGRADE
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/llhttp/llhttp-wasm.js
var require_llhttp_wasm = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/llhttp/llhttp-wasm.js"(exports2, module2) {
    "use strict";
    var { Buffer: Buffer2 } = require_node_buffer();
    module2.exports = Buffer2.from("AGFzbQEAAAABJwdgAX8Bf2ADf39/AX9gAX8AYAJ/fwBgBH9/f38Bf2AAAGADf39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQAEA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAAy0sBQYAAAIAAAAAAAACAQIAAgICAAADAAAAAAMDAwMBAQEBAQEBAQEAAAIAAAAEBQFwARISBQMBAAIGCAF/AUGA1AQLB9EFIgZtZW1vcnkCAAtfaW5pdGlhbGl6ZQAIGV9faW5kaXJlY3RfZnVuY3Rpb25fdGFibGUBAAtsbGh0dHBfaW5pdAAJGGxsaHR0cF9zaG91bGRfa2VlcF9hbGl2ZQAvDGxsaHR0cF9hbGxvYwALBm1hbGxvYwAxC2xsaHR0cF9mcmVlAAwEZnJlZQAMD2xsaHR0cF9nZXRfdHlwZQANFWxsaHR0cF9nZXRfaHR0cF9tYWpvcgAOFWxsaHR0cF9nZXRfaHR0cF9taW5vcgAPEWxsaHR0cF9nZXRfbWV0aG9kABAWbGxodHRwX2dldF9zdGF0dXNfY29kZQAREmxsaHR0cF9nZXRfdXBncmFkZQASDGxsaHR0cF9yZXNldAATDmxsaHR0cF9leGVjdXRlABQUbGxodHRwX3NldHRpbmdzX2luaXQAFQ1sbGh0dHBfZmluaXNoABYMbGxodHRwX3BhdXNlABcNbGxodHRwX3Jlc3VtZQAYG2xsaHR0cF9yZXN1bWVfYWZ0ZXJfdXBncmFkZQAZEGxsaHR0cF9nZXRfZXJybm8AGhdsbGh0dHBfZ2V0X2Vycm9yX3JlYXNvbgAbF2xsaHR0cF9zZXRfZXJyb3JfcmVhc29uABwUbGxodHRwX2dldF9lcnJvcl9wb3MAHRFsbGh0dHBfZXJybm9fbmFtZQAeEmxsaHR0cF9tZXRob2RfbmFtZQAfEmxsaHR0cF9zdGF0dXNfbmFtZQAgGmxsaHR0cF9zZXRfbGVuaWVudF9oZWFkZXJzACEhbGxodHRwX3NldF9sZW5pZW50X2NodW5rZWRfbGVuZ3RoACIdbGxodHRwX3NldF9sZW5pZW50X2tlZXBfYWxpdmUAIyRsbGh0dHBfc2V0X2xlbmllbnRfdHJhbnNmZXJfZW5jb2RpbmcAJBhsbGh0dHBfbWVzc2FnZV9uZWVkc19lb2YALgkXAQBBAQsRAQIDBAUKBgcrLSwqKSglJyYK07MCLBYAQYjQACgCAARAAAtBiNAAQQE2AgALFAAgABAwIAAgAjYCOCAAIAE6ACgLFAAgACAALwEyIAAtAC4gABAvEAALHgEBf0HAABAyIgEQMCABQYAINgI4IAEgADoAKCABC48MAQd/AkAgAEUNACAAQQhrIgEgAEEEaygCACIAQXhxIgRqIQUCQCAAQQFxDQAgAEEDcUUNASABIAEoAgAiAGsiAUGc0AAoAgBJDQEgACAEaiEEAkACQEGg0AAoAgAgAUcEQCAAQf8BTQRAIABBA3YhAyABKAIIIgAgASgCDCICRgRAQYzQAEGM0AAoAgBBfiADd3E2AgAMBQsgAiAANgIIIAAgAjYCDAwECyABKAIYIQYgASABKAIMIgBHBEAgACABKAIIIgI2AgggAiAANgIMDAMLIAFBFGoiAygCACICRQRAIAEoAhAiAkUNAiABQRBqIQMLA0AgAyEHIAIiAEEUaiIDKAIAIgINACAAQRBqIQMgACgCECICDQALIAdBADYCAAwCCyAFKAIEIgBBA3FBA0cNAiAFIABBfnE2AgRBlNAAIAQ2AgAgBSAENgIAIAEgBEEBcjYCBAwDC0EAIQALIAZFDQACQCABKAIcIgJBAnRBvNIAaiIDKAIAIAFGBEAgAyAANgIAIAANAUGQ0ABBkNAAKAIAQX4gAndxNgIADAILIAZBEEEUIAYoAhAgAUYbaiAANgIAIABFDQELIAAgBjYCGCABKAIQIgIEQCAAIAI2AhAgAiAANgIYCyABQRRqKAIAIgJFDQAgAEEUaiACNgIAIAIgADYCGAsgASAFTw0AIAUoAgQiAEEBcUUNAAJAAkACQAJAIABBAnFFBEBBpNAAKAIAIAVGBEBBpNAAIAE2AgBBmNAAQZjQACgCACAEaiIANgIAIAEgAEEBcjYCBCABQaDQACgCAEcNBkGU0ABBADYCAEGg0ABBADYCAAwGC0Gg0AAoAgAgBUYEQEGg0AAgATYCAEGU0ABBlNAAKAIAIARqIgA2AgAgASAAQQFyNgIEIAAgAWogADYCAAwGCyAAQXhxIARqIQQgAEH/AU0EQCAAQQN2IQMgBSgCCCIAIAUoAgwiAkYEQEGM0ABBjNAAKAIAQX4gA3dxNgIADAULIAIgADYCCCAAIAI2AgwMBAsgBSgCGCEGIAUgBSgCDCIARwRAQZzQACgCABogACAFKAIIIgI2AgggAiAANgIMDAMLIAVBFGoiAygCACICRQRAIAUoAhAiAkUNAiAFQRBqIQMLA0AgAyEHIAIiAEEUaiIDKAIAIgINACAAQRBqIQMgACgCECICDQALIAdBADYCAAwCCyAFIABBfnE2AgQgASAEaiAENgIAIAEgBEEBcjYCBAwDC0EAIQALIAZFDQACQCAFKAIcIgJBAnRBvNIAaiIDKAIAIAVGBEAgAyAANgIAIAANAUGQ0ABBkNAAKAIAQX4gAndxNgIADAILIAZBEEEUIAYoAhAgBUYbaiAANgIAIABFDQELIAAgBjYCGCAFKAIQIgIEQCAAIAI2AhAgAiAANgIYCyAFQRRqKAIAIgJFDQAgAEEUaiACNgIAIAIgADYCGAsgASAEaiAENgIAIAEgBEEBcjYCBCABQaDQACgCAEcNAEGU0AAgBDYCAAwBCyAEQf8BTQRAIARBeHFBtNAAaiEAAn9BjNAAKAIAIgJBASAEQQN2dCIDcUUEQEGM0AAgAiADcjYCACAADAELIAAoAggLIgIgATYCDCAAIAE2AgggASAANgIMIAEgAjYCCAwBC0EfIQIgBEH///8HTQRAIARBJiAEQQh2ZyIAa3ZBAXEgAEEBdGtBPmohAgsgASACNgIcIAFCADcCECACQQJ0QbzSAGohAAJAQZDQACgCACIDQQEgAnQiB3FFBEAgACABNgIAQZDQACADIAdyNgIAIAEgADYCGCABIAE2AgggASABNgIMDAELIARBGSACQQF2a0EAIAJBH0cbdCECIAAoAgAhAAJAA0AgACIDKAIEQXhxIARGDQEgAkEddiEAIAJBAXQhAiADIABBBHFqQRBqIgcoAgAiAA0ACyAHIAE2AgAgASADNgIYIAEgATYCDCABIAE2AggMAQsgAygCCCIAIAE2AgwgAyABNgIIIAFBADYCGCABIAM2AgwgASAANgIIC0Gs0ABBrNAAKAIAQQFrIgBBfyAAGzYCAAsLBwAgAC0AKAsHACAALQAqCwcAIAAtACsLBwAgAC0AKQsHACAALwEyCwcAIAAtAC4LQAEEfyAAKAIYIQEgAC0ALSECIAAtACghAyAAKAI4IQQgABAwIAAgBDYCOCAAIAM6ACggACACOgAtIAAgATYCGAu74gECB38DfiABIAJqIQQCQCAAIgIoAgwiAA0AIAIoAgQEQCACIAE2AgQLIwBBEGsiCCQAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAIoAhwiA0EBaw7dAdoBAdkBAgMEBQYHCAkKCwwNDtgBDxDXARES1gETFBUWFxgZGhvgAd8BHB0e1QEfICEiIyQl1AEmJygpKiss0wHSAS0u0QHQAS8wMTIzNDU2Nzg5Ojs8PT4/QEFCQ0RFRtsBR0hJSs8BzgFLzQFMzAFNTk9QUVJTVFVWV1hZWltcXV5fYGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6e3x9fn+AAYEBggGDAYQBhQGGAYcBiAGJAYoBiwGMAY0BjgGPAZABkQGSAZMBlAGVAZYBlwGYAZkBmgGbAZwBnQGeAZ8BoAGhAaIBowGkAaUBpgGnAagBqQGqAasBrAGtAa4BrwGwAbEBsgGzAbQBtQG2AbcBywHKAbgByQG5AcgBugG7AbwBvQG+Ab8BwAHBAcIBwwHEAcUBxgEA3AELQQAMxgELQQ4MxQELQQ0MxAELQQ8MwwELQRAMwgELQRMMwQELQRQMwAELQRUMvwELQRYMvgELQRgMvQELQRkMvAELQRoMuwELQRsMugELQRwMuQELQR0MuAELQQgMtwELQR4MtgELQSAMtQELQR8MtAELQQcMswELQSEMsgELQSIMsQELQSMMsAELQSQMrwELQRIMrgELQREMrQELQSUMrAELQSYMqwELQScMqgELQSgMqQELQcMBDKgBC0EqDKcBC0ErDKYBC0EsDKUBC0EtDKQBC0EuDKMBC0EvDKIBC0HEAQyhAQtBMAygAQtBNAyfAQtBDAyeAQtBMQydAQtBMgycAQtBMwybAQtBOQyaAQtBNQyZAQtBxQEMmAELQQsMlwELQToMlgELQTYMlQELQQoMlAELQTcMkwELQTgMkgELQTwMkQELQTsMkAELQT0MjwELQQkMjgELQSkMjQELQT4MjAELQT8MiwELQcAADIoBC0HBAAyJAQtBwgAMiAELQcMADIcBC0HEAAyGAQtBxQAMhQELQcYADIQBC0EXDIMBC0HHAAyCAQtByAAMgQELQckADIABC0HKAAx/C0HLAAx+C0HNAAx9C0HMAAx8C0HOAAx7C0HPAAx6C0HQAAx5C0HRAAx4C0HSAAx3C0HTAAx2C0HUAAx1C0HWAAx0C0HVAAxzC0EGDHILQdcADHELQQUMcAtB2AAMbwtBBAxuC0HZAAxtC0HaAAxsC0HbAAxrC0HcAAxqC0EDDGkLQd0ADGgLQd4ADGcLQd8ADGYLQeEADGULQeAADGQLQeIADGMLQeMADGILQQIMYQtB5AAMYAtB5QAMXwtB5gAMXgtB5wAMXQtB6AAMXAtB6QAMWwtB6gAMWgtB6wAMWQtB7AAMWAtB7QAMVwtB7gAMVgtB7wAMVQtB8AAMVAtB8QAMUwtB8gAMUgtB8wAMUQtB9AAMUAtB9QAMTwtB9gAMTgtB9wAMTQtB+AAMTAtB+QAMSwtB+gAMSgtB+wAMSQtB/AAMSAtB/QAMRwtB/gAMRgtB/wAMRQtBgAEMRAtBgQEMQwtBggEMQgtBgwEMQQtBhAEMQAtBhQEMPwtBhgEMPgtBhwEMPQtBiAEMPAtBiQEMOwtBigEMOgtBiwEMOQtBjAEMOAtBjQEMNwtBjgEMNgtBjwEMNQtBkAEMNAtBkQEMMwtBkgEMMgtBkwEMMQtBlAEMMAtBlQEMLwtBlgEMLgtBlwEMLQtBmAEMLAtBmQEMKwtBmgEMKgtBmwEMKQtBnAEMKAtBnQEMJwtBngEMJgtBnwEMJQtBoAEMJAtBoQEMIwtBogEMIgtBowEMIQtBpAEMIAtBpQEMHwtBpgEMHgtBpwEMHQtBqAEMHAtBqQEMGwtBqgEMGgtBqwEMGQtBrAEMGAtBrQEMFwtBrgEMFgtBAQwVC0GvAQwUC0GwAQwTC0GxAQwSC0GzAQwRC0GyAQwQC0G0AQwPC0G1AQwOC0G2AQwNC0G3AQwMC0G4AQwLC0G5AQwKC0G6AQwJC0G7AQwIC0HGAQwHC0G8AQwGC0G9AQwFC0G+AQwEC0G/AQwDC0HAAQwCC0HCAQwBC0HBAQshAwNAAkACQAJAAkACQAJAAkACQAJAIAICfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAgJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACQAJAAn8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCADDsYBAAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHyAhIyUmKCorLC8wMTIzNDU2Nzk6Ozw9lANAQkRFRklLTk9QUVJTVFVWWFpbXF1eX2BhYmNkZWZnaGpsb3Bxc3V2eHl6e3x/gAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEBkgGTAZQBlQGWAZcBmAGZAZoBmwGcAZ0BngGfAaABoQGiAaMBpAGlAaYBpwGoAakBqgGrAawBrQGuAa8BsAGxAbIBswG0AbUBtgG3AbgBuQG6AbsBvAG9Ab4BvwHAAcEBwgHDAcQBxQHGAccByAHJAcsBzAHNAc4BzwGKA4kDiAOHA4QDgwOAA/sC+gL5AvgC9wL0AvMC8gLLAsECsALZAQsgASAERw3wAkHdASEDDLMDCyABIARHDcgBQcMBIQMMsgMLIAEgBEcNe0H3ACEDDLEDCyABIARHDXBB7wAhAwywAwsgASAERw1pQeoAIQMMrwMLIAEgBEcNZUHoACEDDK4DCyABIARHDWJB5gAhAwytAwsgASAERw0aQRghAwysAwsgASAERw0VQRIhAwyrAwsgASAERw1CQcUAIQMMqgMLIAEgBEcNNEE/IQMMqQMLIAEgBEcNMkE8IQMMqAMLIAEgBEcNK0ExIQMMpwMLIAItAC5BAUYNnwMMwQILQQAhAAJAAkACQCACLQAqRQ0AIAItACtFDQAgAi8BMCIDQQJxRQ0BDAILIAIvATAiA0EBcUUNAQtBASEAIAItAChBAUYNACACLwEyIgVB5ABrQeQASQ0AIAVBzAFGDQAgBUGwAkYNACADQcAAcQ0AQQAhACADQYgEcUGABEYNACADQShxQQBHIQALIAJBADsBMCACQQA6AC8gAEUN3wIgAkIANwMgDOACC0EAIQACQCACKAI4IgNFDQAgAygCLCIDRQ0AIAIgAxEAACEACyAARQ3MASAAQRVHDd0CIAJBBDYCHCACIAE2AhQgAkGwGDYCECACQRU2AgxBACEDDKQDCyABIARGBEBBBiEDDKQDCyABQQFqIQFBACEAAkAgAigCOCIDRQ0AIAMoAlQiA0UNACACIAMRAAAhAAsgAA3ZAgwcCyACQgA3AyBBEiEDDIkDCyABIARHDRZBHSEDDKEDCyABIARHBEAgAUEBaiEBQRAhAwyIAwtBByEDDKADCyACIAIpAyAiCiAEIAFrrSILfSIMQgAgCiAMWhs3AyAgCiALWA3UAkEIIQMMnwMLIAEgBEcEQCACQQk2AgggAiABNgIEQRQhAwyGAwtBCSEDDJ4DCyACKQMgQgBSDccBIAIgAi8BMEGAAXI7ATAMQgsgASAERw0/QdAAIQMMnAMLIAEgBEYEQEELIQMMnAMLIAFBAWohAUEAIQACQCACKAI4IgNFDQAgAygCUCIDRQ0AIAIgAxEAACEACyAADc8CDMYBC0EAIQACQCACKAI4IgNFDQAgAygCSCIDRQ0AIAIgAxEAACEACyAARQ3GASAAQRVHDc0CIAJBCzYCHCACIAE2AhQgAkGCGTYCECACQRU2AgxBACEDDJoDC0EAIQACQCACKAI4IgNFDQAgAygCSCIDRQ0AIAIgAxEAACEACyAARQ0MIABBFUcNygIgAkEaNgIcIAIgATYCFCACQYIZNgIQIAJBFTYCDEEAIQMMmQMLQQAhAAJAIAIoAjgiA0UNACADKAJMIgNFDQAgAiADEQAAIQALIABFDcQBIABBFUcNxwIgAkELNgIcIAIgATYCFCACQZEXNgIQIAJBFTYCDEEAIQMMmAMLIAEgBEYEQEEPIQMMmAMLIAEtAAAiAEE7Rg0HIABBDUcNxAIgAUEBaiEBDMMBC0EAIQACQCACKAI4IgNFDQAgAygCTCIDRQ0AIAIgAxEAACEACyAARQ3DASAAQRVHDcICIAJBDzYCHCACIAE2AhQgAkGRFzYCECACQRU2AgxBACEDDJYDCwNAIAEtAABB8DVqLQAAIgBBAUcEQCAAQQJHDcECIAIoAgQhAEEAIQMgAkEANgIEIAIgACABQQFqIgEQLSIADcICDMUBCyAEIAFBAWoiAUcNAAtBEiEDDJUDC0EAIQACQCACKAI4IgNFDQAgAygCTCIDRQ0AIAIgAxEAACEACyAARQ3FASAAQRVHDb0CIAJBGzYCHCACIAE2AhQgAkGRFzYCECACQRU2AgxBACEDDJQDCyABIARGBEBBFiEDDJQDCyACQQo2AgggAiABNgIEQQAhAAJAIAIoAjgiA0UNACADKAJIIgNFDQAgAiADEQAAIQALIABFDcIBIABBFUcNuQIgAkEVNgIcIAIgATYCFCACQYIZNgIQIAJBFTYCDEEAIQMMkwMLIAEgBEcEQANAIAEtAABB8DdqLQAAIgBBAkcEQAJAIABBAWsOBMQCvQIAvgK9AgsgAUEBaiEBQQghAwz8AgsgBCABQQFqIgFHDQALQRUhAwyTAwtBFSEDDJIDCwNAIAEtAABB8DlqLQAAIgBBAkcEQCAAQQFrDgTFArcCwwK4ArcCCyAEIAFBAWoiAUcNAAtBGCEDDJEDCyABIARHBEAgAkELNgIIIAIgATYCBEEHIQMM+AILQRkhAwyQAwsgAUEBaiEBDAILIAEgBEYEQEEaIQMMjwMLAkAgAS0AAEENaw4UtQG/Ab8BvwG/Ab8BvwG/Ab8BvwG/Ab8BvwG/Ab8BvwG/Ab8BvwEAvwELQQAhAyACQQA2AhwgAkGvCzYCECACQQI2AgwgAiABQQFqNgIUDI4DCyABIARGBEBBGyEDDI4DCyABLQAAIgBBO0cEQCAAQQ1HDbECIAFBAWohAQy6AQsgAUEBaiEBC0EiIQMM8wILIAEgBEYEQEEcIQMMjAMLQgAhCgJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAS0AAEEwaw43wQLAAgABAgMEBQYH0AHQAdAB0AHQAdAB0AEICQoLDA3QAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdABDg8QERIT0AELQgIhCgzAAgtCAyEKDL8CC0IEIQoMvgILQgUhCgy9AgtCBiEKDLwCC0IHIQoMuwILQgghCgy6AgtCCSEKDLkCC0IKIQoMuAILQgshCgy3AgtCDCEKDLYCC0INIQoMtQILQg4hCgy0AgtCDyEKDLMCC0IKIQoMsgILQgshCgyxAgtCDCEKDLACC0INIQoMrwILQg4hCgyuAgtCDyEKDK0CC0IAIQoCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAEtAABBMGsON8ACvwIAAQIDBAUGB74CvgK+Ar4CvgK+Ar4CCAkKCwwNvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ag4PEBESE74CC0ICIQoMvwILQgMhCgy+AgtCBCEKDL0CC0IFIQoMvAILQgYhCgy7AgtCByEKDLoCC0IIIQoMuQILQgkhCgy4AgtCCiEKDLcCC0ILIQoMtgILQgwhCgy1AgtCDSEKDLQCC0IOIQoMswILQg8hCgyyAgtCCiEKDLECC0ILIQoMsAILQgwhCgyvAgtCDSEKDK4CC0IOIQoMrQILQg8hCgysAgsgAiACKQMgIgogBCABa60iC30iDEIAIAogDFobNwMgIAogC1gNpwJBHyEDDIkDCyABIARHBEAgAkEJNgIIIAIgATYCBEElIQMM8AILQSAhAwyIAwtBASEFIAIvATAiA0EIcUUEQCACKQMgQgBSIQULAkAgAi0ALgRAQQEhACACLQApQQVGDQEgA0HAAHFFIAVxRQ0BC0EAIQAgA0HAAHENAEECIQAgA0EIcQ0AIANBgARxBEACQCACLQAoQQFHDQAgAi0ALUEKcQ0AQQUhAAwCC0EEIQAMAQsgA0EgcUUEQAJAIAItAChBAUYNACACLwEyIgBB5ABrQeQASQ0AIABBzAFGDQAgAEGwAkYNAEEEIQAgA0EocUUNAiADQYgEcUGABEYNAgtBACEADAELQQBBAyACKQMgUBshAAsgAEEBaw4FvgIAsAEBpAKhAgtBESEDDO0CCyACQQE6AC8MhAMLIAEgBEcNnQJBJCEDDIQDCyABIARHDRxBxgAhAwyDAwtBACEAAkAgAigCOCIDRQ0AIAMoAkQiA0UNACACIAMRAAAhAAsgAEUNJyAAQRVHDZgCIAJB0AA2AhwgAiABNgIUIAJBkRg2AhAgAkEVNgIMQQAhAwyCAwsgASAERgRAQSghAwyCAwtBACEDIAJBADYCBCACQQw2AgggAiABIAEQKiIARQ2UAiACQSc2AhwgAiABNgIUIAIgADYCDAyBAwsgASAERgRAQSkhAwyBAwsgAS0AACIAQSBGDRMgAEEJRw2VAiABQQFqIQEMFAsgASAERwRAIAFBAWohAQwWC0EqIQMM/wILIAEgBEYEQEErIQMM/wILIAEtAAAiAEEJRyAAQSBHcQ2QAiACLQAsQQhHDd0CIAJBADoALAzdAgsgASAERgRAQSwhAwz+AgsgAS0AAEEKRw2OAiABQQFqIQEMsAELIAEgBEcNigJBLyEDDPwCCwNAIAEtAAAiAEEgRwRAIABBCmsOBIQCiAKIAoQChgILIAQgAUEBaiIBRw0AC0ExIQMM+wILQTIhAyABIARGDfoCIAIoAgAiACAEIAFraiEHIAEgAGtBA2ohBgJAA0AgAEHwO2otAAAgAS0AACIFQSByIAUgBUHBAGtB/wFxQRpJG0H/AXFHDQEgAEEDRgRAQQYhAQziAgsgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAc2AgAM+wILIAJBADYCAAyGAgtBMyEDIAQgASIARg35AiAEIAFrIAIoAgAiAWohByAAIAFrQQhqIQYCQANAIAFB9DtqLQAAIAAtAAAiBUEgciAFIAVBwQBrQf8BcUEaSRtB/wFxRw0BIAFBCEYEQEEFIQEM4QILIAFBAWohASAEIABBAWoiAEcNAAsgAiAHNgIADPoCCyACQQA2AgAgACEBDIUCC0E0IQMgBCABIgBGDfgCIAQgAWsgAigCACIBaiEHIAAgAWtBBWohBgJAA0AgAUHQwgBqLQAAIAAtAAAiBUEgciAFIAVBwQBrQf8BcUEaSRtB/wFxRw0BIAFBBUYEQEEHIQEM4AILIAFBAWohASAEIABBAWoiAEcNAAsgAiAHNgIADPkCCyACQQA2AgAgACEBDIQCCyABIARHBEADQCABLQAAQYA+ai0AACIAQQFHBEAgAEECRg0JDIECCyAEIAFBAWoiAUcNAAtBMCEDDPgCC0EwIQMM9wILIAEgBEcEQANAIAEtAAAiAEEgRwRAIABBCmsOBP8B/gH+Af8B/gELIAQgAUEBaiIBRw0AC0E4IQMM9wILQTghAwz2AgsDQCABLQAAIgBBIEcgAEEJR3EN9gEgBCABQQFqIgFHDQALQTwhAwz1AgsDQCABLQAAIgBBIEcEQAJAIABBCmsOBPkBBAT5AQALIABBLEYN9QEMAwsgBCABQQFqIgFHDQALQT8hAwz0AgtBwAAhAyABIARGDfMCIAIoAgAiACAEIAFraiEFIAEgAGtBBmohBgJAA0AgAEGAQGstAAAgAS0AAEEgckcNASAAQQZGDdsCIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADPQCCyACQQA2AgALQTYhAwzZAgsgASAERgRAQcEAIQMM8gILIAJBDDYCCCACIAE2AgQgAi0ALEEBaw4E+wHuAewB6wHUAgsgAUEBaiEBDPoBCyABIARHBEADQAJAIAEtAAAiAEEgciAAIABBwQBrQf8BcUEaSRtB/wFxIgBBCUYNACAAQSBGDQACQAJAAkACQCAAQeMAaw4TAAMDAwMDAwMBAwMDAwMDAwMDAgMLIAFBAWohAUExIQMM3AILIAFBAWohAUEyIQMM2wILIAFBAWohAUEzIQMM2gILDP4BCyAEIAFBAWoiAUcNAAtBNSEDDPACC0E1IQMM7wILIAEgBEcEQANAIAEtAABBgDxqLQAAQQFHDfcBIAQgAUEBaiIBRw0AC0E9IQMM7wILQT0hAwzuAgtBACEAAkAgAigCOCIDRQ0AIAMoAkAiA0UNACACIAMRAAAhAAsgAEUNASAAQRVHDeYBIAJBwgA2AhwgAiABNgIUIAJB4xg2AhAgAkEVNgIMQQAhAwztAgsgAUEBaiEBC0E8IQMM0gILIAEgBEYEQEHCACEDDOsCCwJAA0ACQCABLQAAQQlrDhgAAswCzALRAswCzALMAswCzALMAswCzALMAswCzALMAswCzALMAswCzALMAgDMAgsgBCABQQFqIgFHDQALQcIAIQMM6wILIAFBAWohASACLQAtQQFxRQ3+AQtBLCEDDNACCyABIARHDd4BQcQAIQMM6AILA0AgAS0AAEGQwABqLQAAQQFHDZwBIAQgAUEBaiIBRw0AC0HFACEDDOcCCyABLQAAIgBBIEYN/gEgAEE6Rw3AAiACKAIEIQBBACEDIAJBADYCBCACIAAgARApIgAN3gEM3QELQccAIQMgBCABIgBGDeUCIAQgAWsgAigCACIBaiEHIAAgAWtBBWohBgNAIAFBkMIAai0AACAALQAAIgVBIHIgBSAFQcEAa0H/AXFBGkkbQf8BcUcNvwIgAUEFRg3CAiABQQFqIQEgBCAAQQFqIgBHDQALIAIgBzYCAAzlAgtByAAhAyAEIAEiAEYN5AIgBCABayACKAIAIgFqIQcgACABa0EJaiEGA0AgAUGWwgBqLQAAIAAtAAAiBUEgciAFIAVBwQBrQf8BcUEaSRtB/wFxRw2+AkECIAFBCUYNwgIaIAFBAWohASAEIABBAWoiAEcNAAsgAiAHNgIADOQCCyABIARGBEBByQAhAwzkAgsCQAJAIAEtAAAiAEEgciAAIABBwQBrQf8BcUEaSRtB/wFxQe4Aaw4HAL8CvwK/Ar8CvwIBvwILIAFBAWohAUE+IQMMywILIAFBAWohAUE/IQMMygILQcoAIQMgBCABIgBGDeICIAQgAWsgAigCACIBaiEGIAAgAWtBAWohBwNAIAFBoMIAai0AACAALQAAIgVBIHIgBSAFQcEAa0H/AXFBGkkbQf8BcUcNvAIgAUEBRg2+AiABQQFqIQEgBCAAQQFqIgBHDQALIAIgBjYCAAziAgtBywAhAyAEIAEiAEYN4QIgBCABayACKAIAIgFqIQcgACABa0EOaiEGA0AgAUGiwgBqLQAAIAAtAAAiBUEgciAFIAVBwQBrQf8BcUEaSRtB/wFxRw27AiABQQ5GDb4CIAFBAWohASAEIABBAWoiAEcNAAsgAiAHNgIADOECC0HMACEDIAQgASIARg3gAiAEIAFrIAIoAgAiAWohByAAIAFrQQ9qIQYDQCABQcDCAGotAAAgAC0AACIFQSByIAUgBUHBAGtB/wFxQRpJG0H/AXFHDboCQQMgAUEPRg2+AhogAUEBaiEBIAQgAEEBaiIARw0ACyACIAc2AgAM4AILQc0AIQMgBCABIgBGDd8CIAQgAWsgAigCACIBaiEHIAAgAWtBBWohBgNAIAFB0MIAai0AACAALQAAIgVBIHIgBSAFQcEAa0H/AXFBGkkbQf8BcUcNuQJBBCABQQVGDb0CGiABQQFqIQEgBCAAQQFqIgBHDQALIAIgBzYCAAzfAgsgASAERgRAQc4AIQMM3wILAkACQAJAAkAgAS0AACIAQSByIAAgAEHBAGtB/wFxQRpJG0H/AXFB4wBrDhMAvAK8ArwCvAK8ArwCvAK8ArwCvAK8ArwCAbwCvAK8AgIDvAILIAFBAWohAUHBACEDDMgCCyABQQFqIQFBwgAhAwzHAgsgAUEBaiEBQcMAIQMMxgILIAFBAWohAUHEACEDDMUCCyABIARHBEAgAkENNgIIIAIgATYCBEHFACEDDMUCC0HPACEDDN0CCwJAAkAgAS0AAEEKaw4EAZABkAEAkAELIAFBAWohAQtBKCEDDMMCCyABIARGBEBB0QAhAwzcAgsgAS0AAEEgRw0AIAFBAWohASACLQAtQQFxRQ3QAQtBFyEDDMECCyABIARHDcsBQdIAIQMM2QILQdMAIQMgASAERg3YAiACKAIAIgAgBCABa2ohBiABIABrQQFqIQUDQCABLQAAIABB1sIAai0AAEcNxwEgAEEBRg3KASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBjYCAAzYAgsgASAERgRAQdUAIQMM2AILIAEtAABBCkcNwgEgAUEBaiEBDMoBCyABIARGBEBB1gAhAwzXAgsCQAJAIAEtAABBCmsOBADDAcMBAcMBCyABQQFqIQEMygELIAFBAWohAUHKACEDDL0CC0EAIQACQCACKAI4IgNFDQAgAygCPCIDRQ0AIAIgAxEAACEACyAADb8BQc0AIQMMvAILIAItAClBIkYNzwIMiQELIAQgASIFRgRAQdsAIQMM1AILQQAhAEEBIQFBASEGQQAhAwJAAn8CQAJAAkACQAJAAkACQCAFLQAAQTBrDgrFAcQBAAECAwQFBgjDAQtBAgwGC0EDDAULQQQMBAtBBQwDC0EGDAILQQcMAQtBCAshA0EAIQFBACEGDL0BC0EJIQNBASEAQQAhAUEAIQYMvAELIAEgBEYEQEHdACEDDNMCCyABLQAAQS5HDbgBIAFBAWohAQyIAQsgASAERw22AUHfACEDDNECCyABIARHBEAgAkEONgIIIAIgATYCBEHQACEDDLgCC0HgACEDDNACC0HhACEDIAEgBEYNzwIgAigCACIAIAQgAWtqIQUgASAAa0EDaiEGA0AgAS0AACAAQeLCAGotAABHDbEBIABBA0YNswEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMzwILQeIAIQMgASAERg3OAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYDQCABLQAAIABB5sIAai0AAEcNsAEgAEECRg2vASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAzOAgtB4wAhAyABIARGDc0CIAIoAgAiACAEIAFraiEFIAEgAGtBA2ohBgNAIAEtAAAgAEHpwgBqLQAARw2vASAAQQNGDa0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADM0CCyABIARGBEBB5QAhAwzNAgsgAUEBaiEBQQAhAAJAIAIoAjgiA0UNACADKAIwIgNFDQAgAiADEQAAIQALIAANqgFB1gAhAwyzAgsgASAERwRAA0AgAS0AACIAQSBHBEACQAJAAkAgAEHIAGsOCwABswGzAbMBswGzAbMBswGzAQKzAQsgAUEBaiEBQdIAIQMMtwILIAFBAWohAUHTACEDDLYCCyABQQFqIQFB1AAhAwy1AgsgBCABQQFqIgFHDQALQeQAIQMMzAILQeQAIQMMywILA0AgAS0AAEHwwgBqLQAAIgBBAUcEQCAAQQJrDgOnAaYBpQGkAQsgBCABQQFqIgFHDQALQeYAIQMMygILIAFBAWogASAERw0CGkHnACEDDMkCCwNAIAEtAABB8MQAai0AACIAQQFHBEACQCAAQQJrDgSiAaEBoAEAnwELQdcAIQMMsQILIAQgAUEBaiIBRw0AC0HoACEDDMgCCyABIARGBEBB6QAhAwzIAgsCQCABLQAAIgBBCmsOGrcBmwGbAbQBmwGbAZsBmwGbAZsBmwGbAZsBmwGbAZsBmwGbAZsBmwGbAZsBpAGbAZsBAJkBCyABQQFqCyEBQQYhAwytAgsDQCABLQAAQfDGAGotAABBAUcNfSAEIAFBAWoiAUcNAAtB6gAhAwzFAgsgAUEBaiABIARHDQIaQesAIQMMxAILIAEgBEYEQEHsACEDDMQCCyABQQFqDAELIAEgBEYEQEHtACEDDMMCCyABQQFqCyEBQQQhAwyoAgsgASAERgRAQe4AIQMMwQILAkACQAJAIAEtAABB8MgAai0AAEEBaw4HkAGPAY4BAHwBAo0BCyABQQFqIQEMCwsgAUEBagyTAQtBACEDIAJBADYCHCACQZsSNgIQIAJBBzYCDCACIAFBAWo2AhQMwAILAkADQCABLQAAQfDIAGotAAAiAEEERwRAAkACQCAAQQFrDgeUAZMBkgGNAQAEAY0BC0HaACEDDKoCCyABQQFqIQFB3AAhAwypAgsgBCABQQFqIgFHDQALQe8AIQMMwAILIAFBAWoMkQELIAQgASIARgRAQfAAIQMMvwILIAAtAABBL0cNASAAQQFqIQEMBwsgBCABIgBGBEBB8QAhAwy+AgsgAC0AACIBQS9GBEAgAEEBaiEBQd0AIQMMpQILIAFBCmsiA0EWSw0AIAAhAUEBIAN0QYmAgAJxDfkBC0EAIQMgAkEANgIcIAIgADYCFCACQYwcNgIQIAJBBzYCDAy8AgsgASAERwRAIAFBAWohAUHeACEDDKMCC0HyACEDDLsCCyABIARGBEBB9AAhAwy7AgsCQCABLQAAQfDMAGotAABBAWsOA/cBcwCCAQtB4QAhAwyhAgsgASAERwRAA0AgAS0AAEHwygBqLQAAIgBBA0cEQAJAIABBAWsOAvkBAIUBC0HfACEDDKMCCyAEIAFBAWoiAUcNAAtB8wAhAwy6AgtB8wAhAwy5AgsgASAERwRAIAJBDzYCCCACIAE2AgRB4AAhAwygAgtB9QAhAwy4AgsgASAERgRAQfYAIQMMuAILIAJBDzYCCCACIAE2AgQLQQMhAwydAgsDQCABLQAAQSBHDY4CIAQgAUEBaiIBRw0AC0H3ACEDDLUCCyABIARGBEBB+AAhAwy1AgsgAS0AAEEgRw16IAFBAWohAQxbC0EAIQACQCACKAI4IgNFDQAgAygCOCIDRQ0AIAIgAxEAACEACyAADXgMgAILIAEgBEYEQEH6ACEDDLMCCyABLQAAQcwARw10IAFBAWohAUETDHYLQfsAIQMgASAERg2xAiACKAIAIgAgBCABa2ohBSABIABrQQVqIQYDQCABLQAAIABB8M4Aai0AAEcNcyAAQQVGDXUgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMsQILIAEgBEYEQEH8ACEDDLECCwJAAkAgAS0AAEHDAGsODAB0dHR0dHR0dHR0AXQLIAFBAWohAUHmACEDDJgCCyABQQFqIQFB5wAhAwyXAgtB/QAhAyABIARGDa8CIAIoAgAiACAEIAFraiEFIAEgAGtBAmohBgJAA0AgAS0AACAAQe3PAGotAABHDXIgAEECRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADLACCyACQQA2AgAgBkEBaiEBQRAMcwtB/gAhAyABIARGDa4CIAIoAgAiACAEIAFraiEFIAEgAGtBBWohBgJAA0AgAS0AACAAQfbOAGotAABHDXEgAEEFRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADK8CCyACQQA2AgAgBkEBaiEBQRYMcgtB/wAhAyABIARGDa0CIAIoAgAiACAEIAFraiEFIAEgAGtBA2ohBgJAA0AgAS0AACAAQfzOAGotAABHDXAgAEEDRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADK4CCyACQQA2AgAgBkEBaiEBQQUMcQsgASAERgRAQYABIQMMrQILIAEtAABB2QBHDW4gAUEBaiEBQQgMcAsgASAERgRAQYEBIQMMrAILAkACQCABLQAAQc4Aaw4DAG8BbwsgAUEBaiEBQesAIQMMkwILIAFBAWohAUHsACEDDJICCyABIARGBEBBggEhAwyrAgsCQAJAIAEtAABByABrDggAbm5ubm5uAW4LIAFBAWohAUHqACEDDJICCyABQQFqIQFB7QAhAwyRAgtBgwEhAyABIARGDakCIAIoAgAiACAEIAFraiEFIAEgAGtBAmohBgJAA0AgAS0AACAAQYDPAGotAABHDWwgAEECRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADKoCCyACQQA2AgAgBkEBaiEBQQAMbQtBhAEhAyABIARGDagCIAIoAgAiACAEIAFraiEFIAEgAGtBBGohBgJAA0AgAS0AACAAQYPPAGotAABHDWsgAEEERg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADKkCCyACQQA2AgAgBkEBaiEBQSMMbAsgASAERgRAQYUBIQMMqAILAkACQCABLQAAQcwAaw4IAGtra2trawFrCyABQQFqIQFB7wAhAwyPAgsgAUEBaiEBQfAAIQMMjgILIAEgBEYEQEGGASEDDKcCCyABLQAAQcUARw1oIAFBAWohAQxgC0GHASEDIAEgBEYNpQIgAigCACIAIAQgAWtqIQUgASAAa0EDaiEGAkADQCABLQAAIABBiM8Aai0AAEcNaCAAQQNGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMpgILIAJBADYCACAGQQFqIQFBLQxpC0GIASEDIAEgBEYNpAIgAigCACIAIAQgAWtqIQUgASAAa0EIaiEGAkADQCABLQAAIABB0M8Aai0AAEcNZyAAQQhGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMpQILIAJBADYCACAGQQFqIQFBKQxoCyABIARGBEBBiQEhAwykAgtBASABLQAAQd8ARw1nGiABQQFqIQEMXgtBigEhAyABIARGDaICIAIoAgAiACAEIAFraiEFIAEgAGtBAWohBgNAIAEtAAAgAEGMzwBqLQAARw1kIABBAUYN+gEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMogILQYsBIQMgASAERg2hAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGOzwBqLQAARw1kIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyiAgsgAkEANgIAIAZBAWohAUECDGULQYwBIQMgASAERg2gAiACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHwzwBqLQAARw1jIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyhAgsgAkEANgIAIAZBAWohAUEfDGQLQY0BIQMgASAERg2fAiACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHyzwBqLQAARw1iIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAygAgsgAkEANgIAIAZBAWohAUEJDGMLIAEgBEYEQEGOASEDDJ8CCwJAAkAgAS0AAEHJAGsOBwBiYmJiYgFiCyABQQFqIQFB+AAhAwyGAgsgAUEBaiEBQfkAIQMMhQILQY8BIQMgASAERg2dAiACKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEGRzwBqLQAARw1gIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyeAgsgAkEANgIAIAZBAWohAUEYDGELQZABIQMgASAERg2cAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGXzwBqLQAARw1fIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAydAgsgAkEANgIAIAZBAWohAUEXDGALQZEBIQMgASAERg2bAiACKAIAIgAgBCABa2ohBSABIABrQQZqIQYCQANAIAEtAAAgAEGazwBqLQAARw1eIABBBkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAycAgsgAkEANgIAIAZBAWohAUEVDF8LQZIBIQMgASAERg2aAiACKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEGhzwBqLQAARw1dIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAybAgsgAkEANgIAIAZBAWohAUEeDF4LIAEgBEYEQEGTASEDDJoCCyABLQAAQcwARw1bIAFBAWohAUEKDF0LIAEgBEYEQEGUASEDDJkCCwJAAkAgAS0AAEHBAGsODwBcXFxcXFxcXFxcXFxcAVwLIAFBAWohAUH+ACEDDIACCyABQQFqIQFB/wAhAwz/AQsgASAERgRAQZUBIQMMmAILAkACQCABLQAAQcEAaw4DAFsBWwsgAUEBaiEBQf0AIQMM/wELIAFBAWohAUGAASEDDP4BC0GWASEDIAEgBEYNlgIgAigCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABBp88Aai0AAEcNWSAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMlwILIAJBADYCACAGQQFqIQFBCwxaCyABIARGBEBBlwEhAwyWAgsCQAJAAkACQCABLQAAQS1rDiMAW1tbW1tbW1tbW1tbW1tbW1tbW1tbW1sBW1tbW1sCW1tbA1sLIAFBAWohAUH7ACEDDP8BCyABQQFqIQFB/AAhAwz+AQsgAUEBaiEBQYEBIQMM/QELIAFBAWohAUGCASEDDPwBC0GYASEDIAEgBEYNlAIgAigCACIAIAQgAWtqIQUgASAAa0EEaiEGAkADQCABLQAAIABBqc8Aai0AAEcNVyAAQQRGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMlQILIAJBADYCACAGQQFqIQFBGQxYC0GZASEDIAEgBEYNkwIgAigCACIAIAQgAWtqIQUgASAAa0EFaiEGAkADQCABLQAAIABBrs8Aai0AAEcNViAAQQVGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMlAILIAJBADYCACAGQQFqIQFBBgxXC0GaASEDIAEgBEYNkgIgAigCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABBtM8Aai0AAEcNVSAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMkwILIAJBADYCACAGQQFqIQFBHAxWC0GbASEDIAEgBEYNkQIgAigCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABBts8Aai0AAEcNVCAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMkgILIAJBADYCACAGQQFqIQFBJwxVCyABIARGBEBBnAEhAwyRAgsCQAJAIAEtAABB1ABrDgIAAVQLIAFBAWohAUGGASEDDPgBCyABQQFqIQFBhwEhAwz3AQtBnQEhAyABIARGDY8CIAIoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQbjPAGotAABHDVIgAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADJACCyACQQA2AgAgBkEBaiEBQSYMUwtBngEhAyABIARGDY4CIAIoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQbrPAGotAABHDVEgAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADI8CCyACQQA2AgAgBkEBaiEBQQMMUgtBnwEhAyABIARGDY0CIAIoAgAiACAEIAFraiEFIAEgAGtBAmohBgJAA0AgAS0AACAAQe3PAGotAABHDVAgAEECRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADI4CCyACQQA2AgAgBkEBaiEBQQwMUQtBoAEhAyABIARGDYwCIAIoAgAiACAEIAFraiEFIAEgAGtBA2ohBgJAA0AgAS0AACAAQbzPAGotAABHDU8gAEEDRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADI0CCyACQQA2AgAgBkEBaiEBQQ0MUAsgASAERgRAQaEBIQMMjAILAkACQCABLQAAQcYAaw4LAE9PT09PT09PTwFPCyABQQFqIQFBiwEhAwzzAQsgAUEBaiEBQYwBIQMM8gELIAEgBEYEQEGiASEDDIsCCyABLQAAQdAARw1MIAFBAWohAQxGCyABIARGBEBBowEhAwyKAgsCQAJAIAEtAABByQBrDgcBTU1NTU0ATQsgAUEBaiEBQY4BIQMM8QELIAFBAWohAUEiDE0LQaQBIQMgASAERg2IAiACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHAzwBqLQAARw1LIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyJAgsgAkEANgIAIAZBAWohAUEdDEwLIAEgBEYEQEGlASEDDIgCCwJAAkAgAS0AAEHSAGsOAwBLAUsLIAFBAWohAUGQASEDDO8BCyABQQFqIQFBBAxLCyABIARGBEBBpgEhAwyHAgsCQAJAAkACQAJAIAEtAABBwQBrDhUATU1NTU1NTU1NTQFNTQJNTQNNTQRNCyABQQFqIQFBiAEhAwzxAQsgAUEBaiEBQYkBIQMM8AELIAFBAWohAUGKASEDDO8BCyABQQFqIQFBjwEhAwzuAQsgAUEBaiEBQZEBIQMM7QELQacBIQMgASAERg2FAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHtzwBqLQAARw1IIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyGAgsgAkEANgIAIAZBAWohAUERDEkLQagBIQMgASAERg2EAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHCzwBqLQAARw1HIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyFAgsgAkEANgIAIAZBAWohAUEsDEgLQakBIQMgASAERg2DAiACKAIAIgAgBCABa2ohBSABIABrQQRqIQYCQANAIAEtAAAgAEHFzwBqLQAARw1GIABBBEYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyEAgsgAkEANgIAIAZBAWohAUErDEcLQaoBIQMgASAERg2CAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHKzwBqLQAARw1FIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyDAgsgAkEANgIAIAZBAWohAUEUDEYLIAEgBEYEQEGrASEDDIICCwJAAkACQAJAIAEtAABBwgBrDg8AAQJHR0dHR0dHR0dHRwNHCyABQQFqIQFBkwEhAwzrAQsgAUEBaiEBQZQBIQMM6gELIAFBAWohAUGVASEDDOkBCyABQQFqIQFBlgEhAwzoAQsgASAERgRAQawBIQMMgQILIAEtAABBxQBHDUIgAUEBaiEBDD0LQa0BIQMgASAERg3/ASACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHNzwBqLQAARw1CIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyAAgsgAkEANgIAIAZBAWohAUEODEMLIAEgBEYEQEGuASEDDP8BCyABLQAAQdAARw1AIAFBAWohAUElDEILQa8BIQMgASAERg39ASACKAIAIgAgBCABa2ohBSABIABrQQhqIQYCQANAIAEtAAAgAEHQzwBqLQAARw1AIABBCEYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAz+AQsgAkEANgIAIAZBAWohAUEqDEELIAEgBEYEQEGwASEDDP0BCwJAAkAgAS0AAEHVAGsOCwBAQEBAQEBAQEABQAsgAUEBaiEBQZoBIQMM5AELIAFBAWohAUGbASEDDOMBCyABIARGBEBBsQEhAwz8AQsCQAJAIAEtAABBwQBrDhQAPz8/Pz8/Pz8/Pz8/Pz8/Pz8/AT8LIAFBAWohAUGZASEDDOMBCyABQQFqIQFBnAEhAwziAQtBsgEhAyABIARGDfoBIAIoAgAiACAEIAFraiEFIAEgAGtBA2ohBgJAA0AgAS0AACAAQdnPAGotAABHDT0gAEEDRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADPsBCyACQQA2AgAgBkEBaiEBQSEMPgtBswEhAyABIARGDfkBIAIoAgAiACAEIAFraiEFIAEgAGtBBmohBgJAA0AgAS0AACAAQd3PAGotAABHDTwgAEEGRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADPoBCyACQQA2AgAgBkEBaiEBQRoMPQsgASAERgRAQbQBIQMM+QELAkACQAJAIAEtAABBxQBrDhEAPT09PT09PT09AT09PT09Aj0LIAFBAWohAUGdASEDDOEBCyABQQFqIQFBngEhAwzgAQsgAUEBaiEBQZ8BIQMM3wELQbUBIQMgASAERg33ASACKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEHkzwBqLQAARw06IABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAz4AQsgAkEANgIAIAZBAWohAUEoDDsLQbYBIQMgASAERg32ASACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHqzwBqLQAARw05IABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAz3AQsgAkEANgIAIAZBAWohAUEHDDoLIAEgBEYEQEG3ASEDDPYBCwJAAkAgAS0AAEHFAGsODgA5OTk5OTk5OTk5OTkBOQsgAUEBaiEBQaEBIQMM3QELIAFBAWohAUGiASEDDNwBC0G4ASEDIAEgBEYN9AEgAigCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABB7c8Aai0AAEcNNyAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAM9QELIAJBADYCACAGQQFqIQFBEgw4C0G5ASEDIAEgBEYN8wEgAigCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABB8M8Aai0AAEcNNiAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAM9AELIAJBADYCACAGQQFqIQFBIAw3C0G6ASEDIAEgBEYN8gEgAigCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABB8s8Aai0AAEcNNSAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAM8wELIAJBADYCACAGQQFqIQFBDww2CyABIARGBEBBuwEhAwzyAQsCQAJAIAEtAABByQBrDgcANTU1NTUBNQsgAUEBaiEBQaUBIQMM2QELIAFBAWohAUGmASEDDNgBC0G8ASEDIAEgBEYN8AEgAigCACIAIAQgAWtqIQUgASAAa0EHaiEGAkADQCABLQAAIABB9M8Aai0AAEcNMyAAQQdGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAM8QELIAJBADYCACAGQQFqIQFBGww0CyABIARGBEBBvQEhAwzwAQsCQAJAAkAgAS0AAEHCAGsOEgA0NDQ0NDQ0NDQBNDQ0NDQ0AjQLIAFBAWohAUGkASEDDNgBCyABQQFqIQFBpwEhAwzXAQsgAUEBaiEBQagBIQMM1gELIAEgBEYEQEG+ASEDDO8BCyABLQAAQc4ARw0wIAFBAWohAQwsCyABIARGBEBBvwEhAwzuAQsCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCABLQAAQcEAaw4VAAECAz8EBQY/Pz8HCAkKCz8MDQ4PPwsgAUEBaiEBQegAIQMM4wELIAFBAWohAUHpACEDDOIBCyABQQFqIQFB7gAhAwzhAQsgAUEBaiEBQfIAIQMM4AELIAFBAWohAUHzACEDDN8BCyABQQFqIQFB9gAhAwzeAQsgAUEBaiEBQfcAIQMM3QELIAFBAWohAUH6ACEDDNwBCyABQQFqIQFBgwEhAwzbAQsgAUEBaiEBQYQBIQMM2gELIAFBAWohAUGFASEDDNkBCyABQQFqIQFBkgEhAwzYAQsgAUEBaiEBQZgBIQMM1wELIAFBAWohAUGgASEDDNYBCyABQQFqIQFBowEhAwzVAQsgAUEBaiEBQaoBIQMM1AELIAEgBEcEQCACQRA2AgggAiABNgIEQasBIQMM1AELQcABIQMM7AELQQAhAAJAIAIoAjgiA0UNACADKAI0IgNFDQAgAiADEQAAIQALIABFDV4gAEEVRw0HIAJB0QA2AhwgAiABNgIUIAJBsBc2AhAgAkEVNgIMQQAhAwzrAQsgAUEBaiABIARHDQgaQcIBIQMM6gELA0ACQCABLQAAQQprDgQIAAALAAsgBCABQQFqIgFHDQALQcMBIQMM6QELIAEgBEcEQCACQRE2AgggAiABNgIEQQEhAwzQAQtBxAEhAwzoAQsgASAERgRAQcUBIQMM6AELAkACQCABLQAAQQprDgQBKCgAKAsgAUEBagwJCyABQQFqDAULIAEgBEYEQEHGASEDDOcBCwJAAkAgAS0AAEEKaw4XAQsLAQsLCwsLCwsLCwsLCwsLCwsLCwALCyABQQFqIQELQbABIQMMzQELIAEgBEYEQEHIASEDDOYBCyABLQAAQSBHDQkgAkEAOwEyIAFBAWohAUGzASEDDMwBCwNAIAEhAAJAIAEgBEcEQCABLQAAQTBrQf8BcSIDQQpJDQEMJwtBxwEhAwzmAQsCQCACLwEyIgFBmTNLDQAgAiABQQpsIgU7ATIgBUH+/wNxIANB//8Dc0sNACAAQQFqIQEgAiADIAVqIgM7ATIgA0H//wNxQegHSQ0BCwtBACEDIAJBADYCHCACQcEJNgIQIAJBDTYCDCACIABBAWo2AhQM5AELIAJBADYCHCACIAE2AhQgAkHwDDYCECACQRs2AgxBACEDDOMBCyACKAIEIQAgAkEANgIEIAIgACABECYiAA0BIAFBAWoLIQFBrQEhAwzIAQsgAkHBATYCHCACIAA2AgwgAiABQQFqNgIUQQAhAwzgAQsgAigCBCEAIAJBADYCBCACIAAgARAmIgANASABQQFqCyEBQa4BIQMMxQELIAJBwgE2AhwgAiAANgIMIAIgAUEBajYCFEEAIQMM3QELIAJBADYCHCACIAE2AhQgAkGXCzYCECACQQ02AgxBACEDDNwBCyACQQA2AhwgAiABNgIUIAJB4xA2AhAgAkEJNgIMQQAhAwzbAQsgAkECOgAoDKwBC0EAIQMgAkEANgIcIAJBrws2AhAgAkECNgIMIAIgAUEBajYCFAzZAQtBAiEDDL8BC0ENIQMMvgELQSYhAwy9AQtBFSEDDLwBC0EWIQMMuwELQRghAwy6AQtBHCEDDLkBC0EdIQMMuAELQSAhAwy3AQtBISEDDLYBC0EjIQMMtQELQcYAIQMMtAELQS4hAwyzAQtBPSEDDLIBC0HLACEDDLEBC0HOACEDDLABC0HYACEDDK8BC0HZACEDDK4BC0HbACEDDK0BC0HxACEDDKwBC0H0ACEDDKsBC0GNASEDDKoBC0GXASEDDKkBC0GpASEDDKgBC0GvASEDDKcBC0GxASEDDKYBCyACQQA2AgALQQAhAyACQQA2AhwgAiABNgIUIAJB8Rs2AhAgAkEGNgIMDL0BCyACQQA2AgAgBkEBaiEBQSQLOgApIAIoAgQhACACQQA2AgQgAiAAIAEQJyIARQRAQeUAIQMMowELIAJB+QA2AhwgAiABNgIUIAIgADYCDEEAIQMMuwELIABBFUcEQCACQQA2AhwgAiABNgIUIAJBzA42AhAgAkEgNgIMQQAhAwy7AQsgAkH4ADYCHCACIAE2AhQgAkHKGDYCECACQRU2AgxBACEDDLoBCyACQQA2AhwgAiABNgIUIAJBjhs2AhAgAkEGNgIMQQAhAwy5AQsgAkEANgIcIAIgATYCFCACQf4RNgIQIAJBBzYCDEEAIQMMuAELIAJBADYCHCACIAE2AhQgAkGMHDYCECACQQc2AgxBACEDDLcBCyACQQA2AhwgAiABNgIUIAJBww82AhAgAkEHNgIMQQAhAwy2AQsgAkEANgIcIAIgATYCFCACQcMPNgIQIAJBBzYCDEEAIQMMtQELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0RIAJB5QA2AhwgAiABNgIUIAIgADYCDEEAIQMMtAELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0gIAJB0wA2AhwgAiABNgIUIAIgADYCDEEAIQMMswELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0iIAJB0gA2AhwgAiABNgIUIAIgADYCDEEAIQMMsgELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0OIAJB5QA2AhwgAiABNgIUIAIgADYCDEEAIQMMsQELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0dIAJB0wA2AhwgAiABNgIUIAIgADYCDEEAIQMMsAELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0fIAJB0gA2AhwgAiABNgIUIAIgADYCDEEAIQMMrwELIABBP0cNASABQQFqCyEBQQUhAwyUAQtBACEDIAJBADYCHCACIAE2AhQgAkH9EjYCECACQQc2AgwMrAELIAJBADYCHCACIAE2AhQgAkHcCDYCECACQQc2AgxBACEDDKsBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNByACQeUANgIcIAIgATYCFCACIAA2AgxBACEDDKoBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNFiACQdMANgIcIAIgATYCFCACIAA2AgxBACEDDKkBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNGCACQdIANgIcIAIgATYCFCACIAA2AgxBACEDDKgBCyACQQA2AhwgAiABNgIUIAJBxgo2AhAgAkEHNgIMQQAhAwynAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDQMgAkHlADYCHCACIAE2AhQgAiAANgIMQQAhAwymAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDRIgAkHTADYCHCACIAE2AhQgAiAANgIMQQAhAwylAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDRQgAkHSADYCHCACIAE2AhQgAiAANgIMQQAhAwykAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDQAgAkHlADYCHCACIAE2AhQgAiAANgIMQQAhAwyjAQtB1QAhAwyJAQsgAEEVRwRAIAJBADYCHCACIAE2AhQgAkG5DTYCECACQRo2AgxBACEDDKIBCyACQeQANgIcIAIgATYCFCACQeMXNgIQIAJBFTYCDEEAIQMMoQELIAJBADYCACAGQQFqIQEgAi0AKSIAQSNrQQtJDQQCQCAAQQZLDQBBASAAdEHKAHFFDQAMBQtBACEDIAJBADYCHCACIAE2AhQgAkH3CTYCECACQQg2AgwMoAELIAJBADYCACAGQQFqIQEgAi0AKUEhRg0DIAJBADYCHCACIAE2AhQgAkGbCjYCECACQQg2AgxBACEDDJ8BCyACQQA2AgALQQAhAyACQQA2AhwgAiABNgIUIAJBkDM2AhAgAkEINgIMDJ0BCyACQQA2AgAgBkEBaiEBIAItAClBI0kNACACQQA2AhwgAiABNgIUIAJB0wk2AhAgAkEINgIMQQAhAwycAQtB0QAhAwyCAQsgAS0AAEEwayIAQf8BcUEKSQRAIAIgADoAKiABQQFqIQFBzwAhAwyCAQsgAigCBCEAIAJBADYCBCACIAAgARAoIgBFDYYBIAJB3gA2AhwgAiABNgIUIAIgADYCDEEAIQMMmgELIAIoAgQhACACQQA2AgQgAiAAIAEQKCIARQ2GASACQdwANgIcIAIgATYCFCACIAA2AgxBACEDDJkBCyACKAIEIQAgAkEANgIEIAIgACAFECgiAEUEQCAFIQEMhwELIAJB2gA2AhwgAiAFNgIUIAIgADYCDAyYAQtBACEBQQEhAwsgAiADOgArIAVBAWohAwJAAkACQCACLQAtQRBxDQACQAJAAkAgAi0AKg4DAQACBAsgBkUNAwwCCyAADQEMAgsgAUUNAQsgAigCBCEAIAJBADYCBCACIAAgAxAoIgBFBEAgAyEBDAILIAJB2AA2AhwgAiADNgIUIAIgADYCDEEAIQMMmAELIAIoAgQhACACQQA2AgQgAiAAIAMQKCIARQRAIAMhAQyHAQsgAkHZADYCHCACIAM2AhQgAiAANgIMQQAhAwyXAQtBzAAhAwx9CyAAQRVHBEAgAkEANgIcIAIgATYCFCACQZQNNgIQIAJBITYCDEEAIQMMlgELIAJB1wA2AhwgAiABNgIUIAJByRc2AhAgAkEVNgIMQQAhAwyVAQtBACEDIAJBADYCHCACIAE2AhQgAkGAETYCECACQQk2AgwMlAELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0AIAJB0wA2AhwgAiABNgIUIAIgADYCDEEAIQMMkwELQckAIQMMeQsgAkEANgIcIAIgATYCFCACQcEoNgIQIAJBBzYCDCACQQA2AgBBACEDDJEBCyACKAIEIQBBACEDIAJBADYCBCACIAAgARAlIgBFDQAgAkHSADYCHCACIAE2AhQgAiAANgIMDJABC0HIACEDDHYLIAJBADYCACAFIQELIAJBgBI7ASogAUEBaiEBQQAhAAJAIAIoAjgiA0UNACADKAIwIgNFDQAgAiADEQAAIQALIAANAQtBxwAhAwxzCyAAQRVGBEAgAkHRADYCHCACIAE2AhQgAkHjFzYCECACQRU2AgxBACEDDIwBC0EAIQMgAkEANgIcIAIgATYCFCACQbkNNgIQIAJBGjYCDAyLAQtBACEDIAJBADYCHCACIAE2AhQgAkGgGTYCECACQR42AgwMigELIAEtAABBOkYEQCACKAIEIQBBACEDIAJBADYCBCACIAAgARApIgBFDQEgAkHDADYCHCACIAA2AgwgAiABQQFqNgIUDIoBC0EAIQMgAkEANgIcIAIgATYCFCACQbERNgIQIAJBCjYCDAyJAQsgAUEBaiEBQTshAwxvCyACQcMANgIcIAIgADYCDCACIAFBAWo2AhQMhwELQQAhAyACQQA2AhwgAiABNgIUIAJB8A42AhAgAkEcNgIMDIYBCyACIAIvATBBEHI7ATAMZgsCQCACLwEwIgBBCHFFDQAgAi0AKEEBRw0AIAItAC1BCHFFDQMLIAIgAEH3+wNxQYAEcjsBMAwECyABIARHBEACQANAIAEtAABBMGsiAEH/AXFBCk8EQEE1IQMMbgsgAikDICIKQpmz5syZs+bMGVYNASACIApCCn4iCjcDICAKIACtQv8BgyILQn+FVg0BIAIgCiALfDcDICAEIAFBAWoiAUcNAAtBOSEDDIUBCyACKAIEIQBBACEDIAJBADYCBCACIAAgAUEBaiIBECoiAA0MDHcLQTkhAwyDAQsgAi0AMEEgcQ0GQcUBIQMMaQtBACEDIAJBADYCBCACIAEgARAqIgBFDQQgAkE6NgIcIAIgADYCDCACIAFBAWo2AhQMgQELIAItAChBAUcNACACLQAtQQhxRQ0BC0E3IQMMZgsgAigCBCEAQQAhAyACQQA2AgQgAiAAIAEQKiIABEAgAkE7NgIcIAIgADYCDCACIAFBAWo2AhQMfwsgAUEBaiEBDG4LIAJBCDoALAwECyABQQFqIQEMbQtBACEDIAJBADYCHCACIAE2AhQgAkHkEjYCECACQQQ2AgwMewsgAigCBCEAQQAhAyACQQA2AgQgAiAAIAEQKiIARQ1sIAJBNzYCHCACIAE2AhQgAiAANgIMDHoLIAIgAi8BMEEgcjsBMAtBMCEDDF8LIAJBNjYCHCACIAE2AhQgAiAANgIMDHcLIABBLEcNASABQQFqIQBBASEBAkACQAJAAkACQCACLQAsQQVrDgQDAQIEAAsgACEBDAQLQQIhAQwBC0EEIQELIAJBAToALCACIAIvATAgAXI7ATAgACEBDAELIAIgAi8BMEEIcjsBMCAAIQELQTkhAwxcCyACQQA6ACwLQTQhAwxaCyABIARGBEBBLSEDDHMLAkACQANAAkAgAS0AAEEKaw4EAgAAAwALIAQgAUEBaiIBRw0AC0EtIQMMdAsgAigCBCEAQQAhAyACQQA2AgQgAiAAIAEQKiIARQ0CIAJBLDYCHCACIAE2AhQgAiAANgIMDHMLIAIoAgQhAEEAIQMgAkEANgIEIAIgACABECoiAEUEQCABQQFqIQEMAgsgAkEsNgIcIAIgADYCDCACIAFBAWo2AhQMcgsgAS0AAEENRgRAIAIoAgQhAEEAIQMgAkEANgIEIAIgACABECoiAEUEQCABQQFqIQEMAgsgAkEsNgIcIAIgADYCDCACIAFBAWo2AhQMcgsgAi0ALUEBcQRAQcQBIQMMWQsgAigCBCEAQQAhAyACQQA2AgQgAiAAIAEQKiIADQEMZQtBLyEDDFcLIAJBLjYCHCACIAE2AhQgAiAANgIMDG8LQQAhAyACQQA2AhwgAiABNgIUIAJB8BQ2AhAgAkEDNgIMDG4LQQEhAwJAAkACQAJAIAItACxBBWsOBAMBAgAECyACIAIvATBBCHI7ATAMAwtBAiEDDAELQQQhAwsgAkEBOgAsIAIgAi8BMCADcjsBMAtBKiEDDFMLQQAhAyACQQA2AhwgAiABNgIUIAJB4Q82AhAgAkEKNgIMDGsLQQEhAwJAAkACQAJAAkACQCACLQAsQQJrDgcFBAQDAQIABAsgAiACLwEwQQhyOwEwDAMLQQIhAwwBC0EEIQMLIAJBAToALCACIAIvATAgA3I7ATALQSshAwxSC0EAIQMgAkEANgIcIAIgATYCFCACQasSNgIQIAJBCzYCDAxqC0EAIQMgAkEANgIcIAIgATYCFCACQf0NNgIQIAJBHTYCDAxpCyABIARHBEADQCABLQAAQSBHDUggBCABQQFqIgFHDQALQSUhAwxpC0ElIQMMaAsgAi0ALUEBcQRAQcMBIQMMTwsgAigCBCEAQQAhAyACQQA2AgQgAiAAIAEQKSIABEAgAkEmNgIcIAIgADYCDCACIAFBAWo2AhQMaAsgAUEBaiEBDFwLIAFBAWohASACLwEwIgBBgAFxBEBBACEAAkAgAigCOCIDRQ0AIAMoAlQiA0UNACACIAMRAAAhAAsgAEUNBiAAQRVHDR8gAkEFNgIcIAIgATYCFCACQfkXNgIQIAJBFTYCDEEAIQMMZwsCQCAAQaAEcUGgBEcNACACLQAtQQJxDQBBACEDIAJBADYCHCACIAE2AhQgAkGWEzYCECACQQQ2AgwMZwsgAgJ/IAIvATBBFHFBFEYEQEEBIAItAChBAUYNARogAi8BMkHlAEYMAQsgAi0AKUEFRgs6AC5BACEAAkAgAigCOCIDRQ0AIAMoAiQiA0UNACACIAMRAAAhAAsCQAJAAkACQAJAIAAOFgIBAAQEBAQEBAQEBAQEBAQEBAQEBAMECyACQQE6AC4LIAIgAi8BMEHAAHI7ATALQSchAwxPCyACQSM2AhwgAiABNgIUIAJBpRY2AhAgAkEVNgIMQQAhAwxnC0EAIQMgAkEANgIcIAIgATYCFCACQdULNgIQIAJBETYCDAxmC0EAIQACQCACKAI4IgNFDQAgAygCLCIDRQ0AIAIgAxEAACEACyAADQELQQ4hAwxLCyAAQRVGBEAgAkECNgIcIAIgATYCFCACQbAYNgIQIAJBFTYCDEEAIQMMZAtBACEDIAJBADYCHCACIAE2AhQgAkGnDjYCECACQRI2AgwMYwtBACEDIAJBADYCHCACIAE2AhQgAkGqHDYCECACQQ82AgwMYgsgAigCBCEAQQAhAyACQQA2AgQgAiAAIAEgCqdqIgEQKyIARQ0AIAJBBTYCHCACIAE2AhQgAiAANgIMDGELQQ8hAwxHC0EAIQMgAkEANgIcIAIgATYCFCACQc0TNgIQIAJBDDYCDAxfC0IBIQoLIAFBAWohAQJAIAIpAyAiC0L//////////w9YBEAgAiALQgSGIAqENwMgDAELQQAhAyACQQA2AhwgAiABNgIUIAJBrQk2AhAgAkEMNgIMDF4LQSQhAwxEC0EAIQMgAkEANgIcIAIgATYCFCACQc0TNgIQIAJBDDYCDAxcCyACKAIEIQBBACEDIAJBADYCBCACIAAgARAsIgBFBEAgAUEBaiEBDFILIAJBFzYCHCACIAA2AgwgAiABQQFqNgIUDFsLIAIoAgQhAEEAIQMgAkEANgIEAkAgAiAAIAEQLCIARQRAIAFBAWohAQwBCyACQRY2AhwgAiAANgIMIAIgAUEBajYCFAxbC0EfIQMMQQtBACEDIAJBADYCHCACIAE2AhQgAkGaDzYCECACQSI2AgwMWQsgAigCBCEAQQAhAyACQQA2AgQgAiAAIAEQLSIARQRAIAFBAWohAQxQCyACQRQ2AhwgAiAANgIMIAIgAUEBajYCFAxYCyACKAIEIQBBACEDIAJBADYCBAJAIAIgACABEC0iAEUEQCABQQFqIQEMAQsgAkETNgIcIAIgADYCDCACIAFBAWo2AhQMWAtBHiEDDD4LQQAhAyACQQA2AhwgAiABNgIUIAJBxgw2AhAgAkEjNgIMDFYLIAIoAgQhAEEAIQMgAkEANgIEIAIgACABEC0iAEUEQCABQQFqIQEMTgsgAkERNgIcIAIgADYCDCACIAFBAWo2AhQMVQsgAkEQNgIcIAIgATYCFCACIAA2AgwMVAtBACEDIAJBADYCHCACIAE2AhQgAkHGDDYCECACQSM2AgwMUwtBACEDIAJBADYCHCACIAE2AhQgAkHAFTYCECACQQI2AgwMUgsgAigCBCEAQQAhAyACQQA2AgQCQCACIAAgARAtIgBFBEAgAUEBaiEBDAELIAJBDjYCHCACIAA2AgwgAiABQQFqNgIUDFILQRshAww4C0EAIQMgAkEANgIcIAIgATYCFCACQcYMNgIQIAJBIzYCDAxQCyACKAIEIQBBACEDIAJBADYCBAJAIAIgACABECwiAEUEQCABQQFqIQEMAQsgAkENNgIcIAIgADYCDCACIAFBAWo2AhQMUAtBGiEDDDYLQQAhAyACQQA2AhwgAiABNgIUIAJBmg82AhAgAkEiNgIMDE4LIAIoAgQhAEEAIQMgAkEANgIEAkAgAiAAIAEQLCIARQRAIAFBAWohAQwBCyACQQw2AhwgAiAANgIMIAIgAUEBajYCFAxOC0EZIQMMNAtBACEDIAJBADYCHCACIAE2AhQgAkGaDzYCECACQSI2AgwMTAsgAEEVRwRAQQAhAyACQQA2AhwgAiABNgIUIAJBgww2AhAgAkETNgIMDEwLIAJBCjYCHCACIAE2AhQgAkHkFjYCECACQRU2AgxBACEDDEsLIAIoAgQhAEEAIQMgAkEANgIEIAIgACABIAqnaiIBECsiAARAIAJBBzYCHCACIAE2AhQgAiAANgIMDEsLQRMhAwwxCyAAQRVHBEBBACEDIAJBADYCHCACIAE2AhQgAkHaDTYCECACQRQ2AgwMSgsgAkEeNgIcIAIgATYCFCACQfkXNgIQIAJBFTYCDEEAIQMMSQtBACEAAkAgAigCOCIDRQ0AIAMoAiwiA0UNACACIAMRAAAhAAsgAEUNQSAAQRVGBEAgAkEDNgIcIAIgATYCFCACQbAYNgIQIAJBFTYCDEEAIQMMSQtBACEDIAJBADYCHCACIAE2AhQgAkGnDjYCECACQRI2AgwMSAtBACEDIAJBADYCHCACIAE2AhQgAkHaDTYCECACQRQ2AgwMRwtBACEDIAJBADYCHCACIAE2AhQgAkGnDjYCECACQRI2AgwMRgsgAkEAOgAvIAItAC1BBHFFDT8LIAJBADoALyACQQE6ADRBACEDDCsLQQAhAyACQQA2AhwgAkHkETYCECACQQc2AgwgAiABQQFqNgIUDEMLAkADQAJAIAEtAABBCmsOBAACAgACCyAEIAFBAWoiAUcNAAtB3QEhAwxDCwJAAkAgAi0ANEEBRw0AQQAhAAJAIAIoAjgiA0UNACADKAJYIgNFDQAgAiADEQAAIQALIABFDQAgAEEVRw0BIAJB3AE2AhwgAiABNgIUIAJB1RY2AhAgAkEVNgIMQQAhAwxEC0HBASEDDCoLIAJBADYCHCACIAE2AhQgAkHpCzYCECACQR82AgxBACEDDEILAkACQCACLQAoQQFrDgIEAQALQcABIQMMKQtBuQEhAwwoCyACQQI6AC9BACEAAkAgAigCOCIDRQ0AIAMoAgAiA0UNACACIAMRAAAhAAsgAEUEQEHCASEDDCgLIABBFUcEQCACQQA2AhwgAiABNgIUIAJBpAw2AhAgAkEQNgIMQQAhAwxBCyACQdsBNgIcIAIgATYCFCACQfoWNgIQIAJBFTYCDEEAIQMMQAsgASAERgRAQdoBIQMMQAsgAS0AAEHIAEYNASACQQE6ACgLQawBIQMMJQtBvwEhAwwkCyABIARHBEAgAkEQNgIIIAIgATYCBEG+ASEDDCQLQdkBIQMMPAsgASAERgRAQdgBIQMMPAsgAS0AAEHIAEcNBCABQQFqIQFBvQEhAwwiCyABIARGBEBB1wEhAww7CwJAAkAgAS0AAEHFAGsOEAAFBQUFBQUFBQUFBQUFBQEFCyABQQFqIQFBuwEhAwwiCyABQQFqIQFBvAEhAwwhC0HWASEDIAEgBEYNOSACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGD0ABqLQAARw0DIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAw6CyACKAIEIQAgAkIANwMAIAIgACAGQQFqIgEQJyIARQRAQcYBIQMMIQsgAkHVATYCHCACIAE2AhQgAiAANgIMQQAhAww5C0HUASEDIAEgBEYNOCACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEGB0ABqLQAARw0CIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAw5CyACQYEEOwEoIAIoAgQhACACQgA3AwAgAiAAIAZBAWoiARAnIgANAwwCCyACQQA2AgALQQAhAyACQQA2AhwgAiABNgIUIAJB2Bs2AhAgAkEINgIMDDYLQboBIQMMHAsgAkHTATYCHCACIAE2AhQgAiAANgIMQQAhAww0C0EAIQACQCACKAI4IgNFDQAgAygCOCIDRQ0AIAIgAxEAACEACyAARQ0AIABBFUYNASACQQA2AhwgAiABNgIUIAJBzA42AhAgAkEgNgIMQQAhAwwzC0HkACEDDBkLIAJB+AA2AhwgAiABNgIUIAJByhg2AhAgAkEVNgIMQQAhAwwxC0HSASEDIAQgASIARg0wIAQgAWsgAigCACIBaiEFIAAgAWtBBGohBgJAA0AgAC0AACABQfzPAGotAABHDQEgAUEERg0DIAFBAWohASAEIABBAWoiAEcNAAsgAiAFNgIADDELIAJBADYCHCACIAA2AhQgAkGQMzYCECACQQg2AgwgAkEANgIAQQAhAwwwCyABIARHBEAgAkEONgIIIAIgATYCBEG3ASEDDBcLQdEBIQMMLwsgAkEANgIAIAZBAWohAQtBuAEhAwwUCyABIARGBEBB0AEhAwwtCyABLQAAQTBrIgBB/wFxQQpJBEAgAiAAOgAqIAFBAWohAUG2ASEDDBQLIAIoAgQhACACQQA2AgQgAiAAIAEQKCIARQ0UIAJBzwE2AhwgAiABNgIUIAIgADYCDEEAIQMMLAsgASAERgRAQc4BIQMMLAsCQCABLQAAQS5GBEAgAUEBaiEBDAELIAIoAgQhACACQQA2AgQgAiAAIAEQKCIARQ0VIAJBzQE2AhwgAiABNgIUIAIgADYCDEEAIQMMLAtBtQEhAwwSCyAEIAEiBUYEQEHMASEDDCsLQQAhAEEBIQFBASEGQQAhAwJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAIAUtAABBMGsOCgoJAAECAwQFBggLC0ECDAYLQQMMBQtBBAwEC0EFDAMLQQYMAgtBBwwBC0EICyEDQQAhAUEAIQYMAgtBCSEDQQEhAEEAIQFBACEGDAELQQAhAUEBIQMLIAIgAzoAKyAFQQFqIQMCQAJAIAItAC1BEHENAAJAAkACQCACLQAqDgMBAAIECyAGRQ0DDAILIAANAQwCCyABRQ0BCyACKAIEIQAgAkEANgIEIAIgACADECgiAEUEQCADIQEMAwsgAkHJATYCHCACIAM2AhQgAiAANgIMQQAhAwwtCyACKAIEIQAgAkEANgIEIAIgACADECgiAEUEQCADIQEMGAsgAkHKATYCHCACIAM2AhQgAiAANgIMQQAhAwwsCyACKAIEIQAgAkEANgIEIAIgACAFECgiAEUEQCAFIQEMFgsgAkHLATYCHCACIAU2AhQgAiAANgIMDCsLQbQBIQMMEQtBACEAAkAgAigCOCIDRQ0AIAMoAjwiA0UNACACIAMRAAAhAAsCQCAABEAgAEEVRg0BIAJBADYCHCACIAE2AhQgAkGUDTYCECACQSE2AgxBACEDDCsLQbIBIQMMEQsgAkHIATYCHCACIAE2AhQgAkHJFzYCECACQRU2AgxBACEDDCkLIAJBADYCACAGQQFqIQFB9QAhAwwPCyACLQApQQVGBEBB4wAhAwwPC0HiACEDDA4LIAAhASACQQA2AgALIAJBADoALEEJIQMMDAsgAkEANgIAIAdBAWohAUHAACEDDAsLQQELOgAsIAJBADYCACAGQQFqIQELQSkhAwwIC0E4IQMMBwsCQCABIARHBEADQCABLQAAQYA+ai0AACIAQQFHBEAgAEECRw0DIAFBAWohAQwFCyAEIAFBAWoiAUcNAAtBPiEDDCELQT4hAwwgCwsgAkEAOgAsDAELQQshAwwEC0E6IQMMAwsgAUEBaiEBQS0hAwwCCyACIAE6ACwgAkEANgIAIAZBAWohAUEMIQMMAQsgAkEANgIAIAZBAWohAUEKIQMMAAsAC0EAIQMgAkEANgIcIAIgATYCFCACQc0QNgIQIAJBCTYCDAwXC0EAIQMgAkEANgIcIAIgATYCFCACQekKNgIQIAJBCTYCDAwWC0EAIQMgAkEANgIcIAIgATYCFCACQbcQNgIQIAJBCTYCDAwVC0EAIQMgAkEANgIcIAIgATYCFCACQZwRNgIQIAJBCTYCDAwUC0EAIQMgAkEANgIcIAIgATYCFCACQc0QNgIQIAJBCTYCDAwTC0EAIQMgAkEANgIcIAIgATYCFCACQekKNgIQIAJBCTYCDAwSC0EAIQMgAkEANgIcIAIgATYCFCACQbcQNgIQIAJBCTYCDAwRC0EAIQMgAkEANgIcIAIgATYCFCACQZwRNgIQIAJBCTYCDAwQC0EAIQMgAkEANgIcIAIgATYCFCACQZcVNgIQIAJBDzYCDAwPC0EAIQMgAkEANgIcIAIgATYCFCACQZcVNgIQIAJBDzYCDAwOC0EAIQMgAkEANgIcIAIgATYCFCACQcASNgIQIAJBCzYCDAwNC0EAIQMgAkEANgIcIAIgATYCFCACQZUJNgIQIAJBCzYCDAwMC0EAIQMgAkEANgIcIAIgATYCFCACQeEPNgIQIAJBCjYCDAwLC0EAIQMgAkEANgIcIAIgATYCFCACQfsPNgIQIAJBCjYCDAwKC0EAIQMgAkEANgIcIAIgATYCFCACQfEZNgIQIAJBAjYCDAwJC0EAIQMgAkEANgIcIAIgATYCFCACQcQUNgIQIAJBAjYCDAwIC0EAIQMgAkEANgIcIAIgATYCFCACQfIVNgIQIAJBAjYCDAwHCyACQQI2AhwgAiABNgIUIAJBnBo2AhAgAkEWNgIMQQAhAwwGC0EBIQMMBQtB1AAhAyABIARGDQQgCEEIaiEJIAIoAgAhBQJAAkAgASAERwRAIAVB2MIAaiEHIAQgBWogAWshACAFQX9zQQpqIgUgAWohBgNAIAEtAAAgBy0AAEcEQEECIQcMAwsgBUUEQEEAIQcgBiEBDAMLIAVBAWshBSAHQQFqIQcgBCABQQFqIgFHDQALIAAhBSAEIQELIAlBATYCACACIAU2AgAMAQsgAkEANgIAIAkgBzYCAAsgCSABNgIEIAgoAgwhACAIKAIIDgMBBAIACwALIAJBADYCHCACQbUaNgIQIAJBFzYCDCACIABBAWo2AhRBACEDDAILIAJBADYCHCACIAA2AhQgAkHKGjYCECACQQk2AgxBACEDDAELIAEgBEYEQEEiIQMMAQsgAkEJNgIIIAIgATYCBEEhIQMLIAhBEGokACADRQRAIAIoAgwhAAwBCyACIAM2AhxBACEAIAIoAgQiAUUNACACIAEgBCACKAIIEQEAIgFFDQAgAiAENgIUIAIgATYCDCABIQALIAALvgIBAn8gAEEAOgAAIABB3ABqIgFBAWtBADoAACAAQQA6AAIgAEEAOgABIAFBA2tBADoAACABQQJrQQA6AAAgAEEAOgADIAFBBGtBADoAAEEAIABrQQNxIgEgAGoiAEEANgIAQdwAIAFrQXxxIgIgAGoiAUEEa0EANgIAAkAgAkEJSQ0AIABBADYCCCAAQQA2AgQgAUEIa0EANgIAIAFBDGtBADYCACACQRlJDQAgAEEANgIYIABBADYCFCAAQQA2AhAgAEEANgIMIAFBEGtBADYCACABQRRrQQA2AgAgAUEYa0EANgIAIAFBHGtBADYCACACIABBBHFBGHIiAmsiAUEgSQ0AIAAgAmohAANAIABCADcDGCAAQgA3AxAgAEIANwMIIABCADcDACAAQSBqIQAgAUEgayIBQR9LDQALCwtWAQF/AkAgACgCDA0AAkACQAJAAkAgAC0ALw4DAQADAgsgACgCOCIBRQ0AIAEoAiwiAUUNACAAIAERAAAiAQ0DC0EADwsACyAAQcMWNgIQQQ4hAQsgAQsaACAAKAIMRQRAIABB0Rs2AhAgAEEVNgIMCwsUACAAKAIMQRVGBEAgAEEANgIMCwsUACAAKAIMQRZGBEAgAEEANgIMCwsHACAAKAIMCwcAIAAoAhALCQAgACABNgIQCwcAIAAoAhQLFwAgAEEkTwRAAAsgAEECdEGgM2ooAgALFwAgAEEuTwRAAAsgAEECdEGwNGooAgALvwkBAX9B6yghAQJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABB5ABrDvQDY2IAAWFhYWFhYQIDBAVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhBgcICQoLDA0OD2FhYWFhEGFhYWFhYWFhYWFhEWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYRITFBUWFxgZGhthYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2YTc4OTphYWFhYWFhYTthYWE8YWFhYT0+P2FhYWFhYWFhQGFhQWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYUJDREVGR0hJSktMTU5PUFFSU2FhYWFhYWFhVFVWV1hZWlthXF1hYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFeYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhX2BhC0HhJw8LQaQhDwtByywPC0H+MQ8LQcAkDwtBqyQPC0GNKA8LQeImDwtBgDAPC0G5Lw8LQdckDwtB7x8PC0HhHw8LQfofDwtB8iAPC0GoLw8LQa4yDwtBiDAPC0HsJw8LQYIiDwtBjh0PC0HQLg8LQcojDwtBxTIPC0HfHA8LQdIcDwtBxCAPC0HXIA8LQaIfDwtB7S4PC0GrMA8LQdQlDwtBzC4PC0H6Lg8LQfwrDwtB0jAPC0HxHQ8LQbsgDwtB9ysPC0GQMQ8LQdcxDwtBoi0PC0HUJw8LQeArDwtBnywPC0HrMQ8LQdUfDwtByjEPC0HeJQ8LQdQeDwtB9BwPC0GnMg8LQbEdDwtBoB0PC0G5MQ8LQbwwDwtBkiEPC0GzJg8LQeksDwtBrB4PC0HUKw8LQfcmDwtBgCYPC0GwIQ8LQf4eDwtBjSMPC0GJLQ8LQfciDwtBoDEPC0GuHw8LQcYlDwtB6B4PC0GTIg8LQcIvDwtBwx0PC0GLLA8LQeEdDwtBjS8PC0HqIQ8LQbQtDwtB0i8PC0HfMg8LQdIyDwtB8DAPC0GpIg8LQfkjDwtBmR4PC0G1LA8LQZswDwtBkjIPC0G2Kw8LQcIiDwtB+DIPC0GeJQ8LQdAiDwtBuh4PC0GBHg8LAAtB1iEhAQsgAQsWACAAIAAtAC1B/gFxIAFBAEdyOgAtCxkAIAAgAC0ALUH9AXEgAUEAR0EBdHI6AC0LGQAgACAALQAtQfsBcSABQQBHQQJ0cjoALQsZACAAIAAtAC1B9wFxIAFBAEdBA3RyOgAtCz4BAn8CQCAAKAI4IgNFDQAgAygCBCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBxhE2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCCCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB9go2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCDCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB7Ro2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCECIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBlRA2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCFCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBqhs2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCGCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB7RM2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCKCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB9gg2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCHCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBwhk2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCICIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBlBQ2AhBBGCEECyAEC1kBAn8CQCAALQAoQQFGDQAgAC8BMiIBQeQAa0HkAEkNACABQcwBRg0AIAFBsAJGDQAgAC8BMCIAQcAAcQ0AQQEhAiAAQYgEcUGABEYNACAAQShxRSECCyACC4wBAQJ/AkACQAJAIAAtACpFDQAgAC0AK0UNACAALwEwIgFBAnFFDQEMAgsgAC8BMCIBQQFxRQ0BC0EBIQIgAC0AKEEBRg0AIAAvATIiAEHkAGtB5ABJDQAgAEHMAUYNACAAQbACRg0AIAFBwABxDQBBACECIAFBiARxQYAERg0AIAFBKHFBAEchAgsgAgtXACAAQRhqQgA3AwAgAEIANwMAIABBOGpCADcDACAAQTBqQgA3AwAgAEEoakIANwMAIABBIGpCADcDACAAQRBqQgA3AwAgAEEIakIANwMAIABB3QE2AhwLBgAgABAyC5otAQt/IwBBEGsiCiQAQaTQACgCACIJRQRAQeTTACgCACIFRQRAQfDTAEJ/NwIAQejTAEKAgISAgIDAADcCAEHk0wAgCkEIakFwcUHYqtWqBXMiBTYCAEH40wBBADYCAEHI0wBBADYCAAtBzNMAQYDUBDYCAEGc0ABBgNQENgIAQbDQACAFNgIAQazQAEF/NgIAQdDTAEGArAM2AgADQCABQcjQAGogAUG80ABqIgI2AgAgAiABQbTQAGoiAzYCACABQcDQAGogAzYCACABQdDQAGogAUHE0ABqIgM2AgAgAyACNgIAIAFB2NAAaiABQczQAGoiAjYCACACIAM2AgAgAUHU0ABqIAI2AgAgAUEgaiIBQYACRw0AC0GM1ARBwasDNgIAQajQAEH00wAoAgA2AgBBmNAAQcCrAzYCAEGk0ABBiNQENgIAQcz/B0E4NgIAQYjUBCEJCwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABB7AFNBEBBjNAAKAIAIgZBECAAQRNqQXBxIABBC0kbIgRBA3YiAHYiAUEDcQRAAkAgAUEBcSAAckEBcyICQQN0IgBBtNAAaiIBIABBvNAAaigCACIAKAIIIgNGBEBBjNAAIAZBfiACd3E2AgAMAQsgASADNgIIIAMgATYCDAsgAEEIaiEBIAAgAkEDdCICQQNyNgIEIAAgAmoiACAAKAIEQQFyNgIEDBELQZTQACgCACIIIARPDQEgAQRAAkBBAiAAdCICQQAgAmtyIAEgAHRxaCIAQQN0IgJBtNAAaiIBIAJBvNAAaigCACICKAIIIgNGBEBBjNAAIAZBfiAAd3EiBjYCAAwBCyABIAM2AgggAyABNgIMCyACIARBA3I2AgQgAEEDdCIAIARrIQUgACACaiAFNgIAIAIgBGoiBCAFQQFyNgIEIAgEQCAIQXhxQbTQAGohAEGg0AAoAgAhAwJ/QQEgCEEDdnQiASAGcUUEQEGM0AAgASAGcjYCACAADAELIAAoAggLIgEgAzYCDCAAIAM2AgggAyAANgIMIAMgATYCCAsgAkEIaiEBQaDQACAENgIAQZTQACAFNgIADBELQZDQACgCACILRQ0BIAtoQQJ0QbzSAGooAgAiACgCBEF4cSAEayEFIAAhAgNAAkAgAigCECIBRQRAIAJBFGooAgAiAUUNAQsgASgCBEF4cSAEayIDIAVJIQIgAyAFIAIbIQUgASAAIAIbIQAgASECDAELCyAAKAIYIQkgACgCDCIDIABHBEBBnNAAKAIAGiADIAAoAggiATYCCCABIAM2AgwMEAsgAEEUaiICKAIAIgFFBEAgACgCECIBRQ0DIABBEGohAgsDQCACIQcgASIDQRRqIgIoAgAiAQ0AIANBEGohAiADKAIQIgENAAsgB0EANgIADA8LQX8hBCAAQb9/Sw0AIABBE2oiAUFwcSEEQZDQACgCACIIRQ0AQQAgBGshBQJAAkACQAJ/QQAgBEGAAkkNABpBHyAEQf///wdLDQAaIARBJiABQQh2ZyIAa3ZBAXEgAEEBdGtBPmoLIgZBAnRBvNIAaigCACICRQRAQQAhAUEAIQMMAQtBACEBIARBGSAGQQF2a0EAIAZBH0cbdCEAQQAhAwNAAkAgAigCBEF4cSAEayIHIAVPDQAgAiEDIAciBQ0AQQAhBSACIQEMAwsgASACQRRqKAIAIgcgByACIABBHXZBBHFqQRBqKAIAIgJGGyABIAcbIQEgAEEBdCEAIAINAAsLIAEgA3JFBEBBACEDQQIgBnQiAEEAIABrciAIcSIARQ0DIABoQQJ0QbzSAGooAgAhAQsgAUUNAQsDQCABKAIEQXhxIARrIgIgBUkhACACIAUgABshBSABIAMgABshAyABKAIQIgAEfyAABSABQRRqKAIACyIBDQALCyADRQ0AIAVBlNAAKAIAIARrTw0AIAMoAhghByADIAMoAgwiAEcEQEGc0AAoAgAaIAAgAygCCCIBNgIIIAEgADYCDAwOCyADQRRqIgIoAgAiAUUEQCADKAIQIgFFDQMgA0EQaiECCwNAIAIhBiABIgBBFGoiAigCACIBDQAgAEEQaiECIAAoAhAiAQ0ACyAGQQA2AgAMDQtBlNAAKAIAIgMgBE8EQEGg0AAoAgAhAQJAIAMgBGsiAkEQTwRAIAEgBGoiACACQQFyNgIEIAEgA2ogAjYCACABIARBA3I2AgQMAQsgASADQQNyNgIEIAEgA2oiACAAKAIEQQFyNgIEQQAhAEEAIQILQZTQACACNgIAQaDQACAANgIAIAFBCGohAQwPC0GY0AAoAgAiAyAESwRAIAQgCWoiACADIARrIgFBAXI2AgRBpNAAIAA2AgBBmNAAIAE2AgAgCSAEQQNyNgIEIAlBCGohAQwPC0EAIQEgBAJ/QeTTACgCAARAQezTACgCAAwBC0Hw0wBCfzcCAEHo0wBCgICEgICAwAA3AgBB5NMAIApBDGpBcHFB2KrVqgVzNgIAQfjTAEEANgIAQcjTAEEANgIAQYCABAsiACAEQccAaiIFaiIGQQAgAGsiB3EiAk8EQEH80wBBMDYCAAwPCwJAQcTTACgCACIBRQ0AQbzTACgCACIIIAJqIQAgACABTSAAIAhLcQ0AQQAhAUH80wBBMDYCAAwPC0HI0wAtAABBBHENBAJAAkAgCQRAQczTACEBA0AgASgCACIAIAlNBEAgACABKAIEaiAJSw0DCyABKAIIIgENAAsLQQAQMyIAQX9GDQUgAiEGQejTACgCACIBQQFrIgMgAHEEQCACIABrIAAgA2pBACABa3FqIQYLIAQgBk8NBSAGQf7///8HSw0FQcTTACgCACIDBEBBvNMAKAIAIgcgBmohASABIAdNDQYgASADSw0GCyAGEDMiASAARw0BDAcLIAYgA2sgB3EiBkH+////B0sNBCAGEDMhACAAIAEoAgAgASgCBGpGDQMgACEBCwJAIAYgBEHIAGpPDQAgAUF/Rg0AQezTACgCACIAIAUgBmtqQQAgAGtxIgBB/v///wdLBEAgASEADAcLIAAQM0F/RwRAIAAgBmohBiABIQAMBwtBACAGaxAzGgwECyABIgBBf0cNBQwDC0EAIQMMDAtBACEADAoLIABBf0cNAgtByNMAQcjTACgCAEEEcjYCAAsgAkH+////B0sNASACEDMhAEEAEDMhASAAQX9GDQEgAUF/Rg0BIAAgAU8NASABIABrIgYgBEE4ak0NAQtBvNMAQbzTACgCACAGaiIBNgIAQcDTACgCACABSQRAQcDTACABNgIACwJAAkACQEGk0AAoAgAiAgRAQczTACEBA0AgACABKAIAIgMgASgCBCIFakYNAiABKAIIIgENAAsMAgtBnNAAKAIAIgFBAEcgACABT3FFBEBBnNAAIAA2AgALQQAhAUHQ0wAgBjYCAEHM0wAgADYCAEGs0ABBfzYCAEGw0ABB5NMAKAIANgIAQdjTAEEANgIAA0AgAUHI0ABqIAFBvNAAaiICNgIAIAIgAUG00ABqIgM2AgAgAUHA0ABqIAM2AgAgAUHQ0ABqIAFBxNAAaiIDNgIAIAMgAjYCACABQdjQAGogAUHM0ABqIgI2AgAgAiADNgIAIAFB1NAAaiACNgIAIAFBIGoiAUGAAkcNAAtBeCAAa0EPcSIBIABqIgIgBkE4ayIDIAFrIgFBAXI2AgRBqNAAQfTTACgCADYCAEGY0AAgATYCAEGk0AAgAjYCACAAIANqQTg2AgQMAgsgACACTQ0AIAIgA0kNACABKAIMQQhxDQBBeCACa0EPcSIAIAJqIgNBmNAAKAIAIAZqIgcgAGsiAEEBcjYCBCABIAUgBmo2AgRBqNAAQfTTACgCADYCAEGY0AAgADYCAEGk0AAgAzYCACACIAdqQTg2AgQMAQsgAEGc0AAoAgBJBEBBnNAAIAA2AgALIAAgBmohA0HM0wAhAQJAAkACQANAIAMgASgCAEcEQCABKAIIIgENAQwCCwsgAS0ADEEIcUUNAQtBzNMAIQEDQCABKAIAIgMgAk0EQCADIAEoAgRqIgUgAksNAwsgASgCCCEBDAALAAsgASAANgIAIAEgASgCBCAGajYCBCAAQXggAGtBD3FqIgkgBEEDcjYCBCADQXggA2tBD3FqIgYgBCAJaiIEayEBIAIgBkYEQEGk0AAgBDYCAEGY0ABBmNAAKAIAIAFqIgA2AgAgBCAAQQFyNgIEDAgLQaDQACgCACAGRgRAQaDQACAENgIAQZTQAEGU0AAoAgAgAWoiADYCACAEIABBAXI2AgQgACAEaiAANgIADAgLIAYoAgQiBUEDcUEBRw0GIAVBeHEhCCAFQf8BTQRAIAVBA3YhAyAGKAIIIgAgBigCDCICRgRAQYzQAEGM0AAoAgBBfiADd3E2AgAMBwsgAiAANgIIIAAgAjYCDAwGCyAGKAIYIQcgBiAGKAIMIgBHBEAgACAGKAIIIgI2AgggAiAANgIMDAULIAZBFGoiAigCACIFRQRAIAYoAhAiBUUNBCAGQRBqIQILA0AgAiEDIAUiAEEUaiICKAIAIgUNACAAQRBqIQIgACgCECIFDQALIANBADYCAAwEC0F4IABrQQ9xIgEgAGoiByAGQThrIgMgAWsiAUEBcjYCBCAAIANqQTg2AgQgAiAFQTcgBWtBD3FqQT9rIgMgAyACQRBqSRsiA0EjNgIEQajQAEH00wAoAgA2AgBBmNAAIAE2AgBBpNAAIAc2AgAgA0EQakHU0wApAgA3AgAgA0HM0wApAgA3AghB1NMAIANBCGo2AgBB0NMAIAY2AgBBzNMAIAA2AgBB2NMAQQA2AgAgA0EkaiEBA0AgAUEHNgIAIAUgAUEEaiIBSw0ACyACIANGDQAgAyADKAIEQX5xNgIEIAMgAyACayIFNgIAIAIgBUEBcjYCBCAFQf8BTQRAIAVBeHFBtNAAaiEAAn9BjNAAKAIAIgFBASAFQQN2dCIDcUUEQEGM0AAgASADcjYCACAADAELIAAoAggLIgEgAjYCDCAAIAI2AgggAiAANgIMIAIgATYCCAwBC0EfIQEgBUH///8HTQRAIAVBJiAFQQh2ZyIAa3ZBAXEgAEEBdGtBPmohAQsgAiABNgIcIAJCADcCECABQQJ0QbzSAGohAEGQ0AAoAgAiA0EBIAF0IgZxRQRAIAAgAjYCAEGQ0AAgAyAGcjYCACACIAA2AhggAiACNgIIIAIgAjYCDAwBCyAFQRkgAUEBdmtBACABQR9HG3QhASAAKAIAIQMCQANAIAMiACgCBEF4cSAFRg0BIAFBHXYhAyABQQF0IQEgACADQQRxakEQaiIGKAIAIgMNAAsgBiACNgIAIAIgADYCGCACIAI2AgwgAiACNgIIDAELIAAoAggiASACNgIMIAAgAjYCCCACQQA2AhggAiAANgIMIAIgATYCCAtBmNAAKAIAIgEgBE0NAEGk0AAoAgAiACAEaiICIAEgBGsiAUEBcjYCBEGY0AAgATYCAEGk0AAgAjYCACAAIARBA3I2AgQgAEEIaiEBDAgLQQAhAUH80wBBMDYCAAwHC0EAIQALIAdFDQACQCAGKAIcIgJBAnRBvNIAaiIDKAIAIAZGBEAgAyAANgIAIAANAUGQ0ABBkNAAKAIAQX4gAndxNgIADAILIAdBEEEUIAcoAhAgBkYbaiAANgIAIABFDQELIAAgBzYCGCAGKAIQIgIEQCAAIAI2AhAgAiAANgIYCyAGQRRqKAIAIgJFDQAgAEEUaiACNgIAIAIgADYCGAsgASAIaiEBIAYgCGoiBigCBCEFCyAGIAVBfnE2AgQgASAEaiABNgIAIAQgAUEBcjYCBCABQf8BTQRAIAFBeHFBtNAAaiEAAn9BjNAAKAIAIgJBASABQQN2dCIBcUUEQEGM0AAgASACcjYCACAADAELIAAoAggLIgEgBDYCDCAAIAQ2AgggBCAANgIMIAQgATYCCAwBC0EfIQUgAUH///8HTQRAIAFBJiABQQh2ZyIAa3ZBAXEgAEEBdGtBPmohBQsgBCAFNgIcIARCADcCECAFQQJ0QbzSAGohAEGQ0AAoAgAiAkEBIAV0IgNxRQRAIAAgBDYCAEGQ0AAgAiADcjYCACAEIAA2AhggBCAENgIIIAQgBDYCDAwBCyABQRkgBUEBdmtBACAFQR9HG3QhBSAAKAIAIQACQANAIAAiAigCBEF4cSABRg0BIAVBHXYhACAFQQF0IQUgAiAAQQRxakEQaiIDKAIAIgANAAsgAyAENgIAIAQgAjYCGCAEIAQ2AgwgBCAENgIIDAELIAIoAggiACAENgIMIAIgBDYCCCAEQQA2AhggBCACNgIMIAQgADYCCAsgCUEIaiEBDAILAkAgB0UNAAJAIAMoAhwiAUECdEG80gBqIgIoAgAgA0YEQCACIAA2AgAgAA0BQZDQACAIQX4gAXdxIgg2AgAMAgsgB0EQQRQgBygCECADRhtqIAA2AgAgAEUNAQsgACAHNgIYIAMoAhAiAQRAIAAgATYCECABIAA2AhgLIANBFGooAgAiAUUNACAAQRRqIAE2AgAgASAANgIYCwJAIAVBD00EQCADIAQgBWoiAEEDcjYCBCAAIANqIgAgACgCBEEBcjYCBAwBCyADIARqIgIgBUEBcjYCBCADIARBA3I2AgQgAiAFaiAFNgIAIAVB/wFNBEAgBUF4cUG00ABqIQACf0GM0AAoAgAiAUEBIAVBA3Z0IgVxRQRAQYzQACABIAVyNgIAIAAMAQsgACgCCAsiASACNgIMIAAgAjYCCCACIAA2AgwgAiABNgIIDAELQR8hASAFQf///wdNBEAgBUEmIAVBCHZnIgBrdkEBcSAAQQF0a0E+aiEBCyACIAE2AhwgAkIANwIQIAFBAnRBvNIAaiEAQQEgAXQiBCAIcUUEQCAAIAI2AgBBkNAAIAQgCHI2AgAgAiAANgIYIAIgAjYCCCACIAI2AgwMAQsgBUEZIAFBAXZrQQAgAUEfRxt0IQEgACgCACEEAkADQCAEIgAoAgRBeHEgBUYNASABQR12IQQgAUEBdCEBIAAgBEEEcWpBEGoiBigCACIEDQALIAYgAjYCACACIAA2AhggAiACNgIMIAIgAjYCCAwBCyAAKAIIIgEgAjYCDCAAIAI2AgggAkEANgIYIAIgADYCDCACIAE2AggLIANBCGohAQwBCwJAIAlFDQACQCAAKAIcIgFBAnRBvNIAaiICKAIAIABGBEAgAiADNgIAIAMNAUGQ0AAgC0F+IAF3cTYCAAwCCyAJQRBBFCAJKAIQIABGG2ogAzYCACADRQ0BCyADIAk2AhggACgCECIBBEAgAyABNgIQIAEgAzYCGAsgAEEUaigCACIBRQ0AIANBFGogATYCACABIAM2AhgLAkAgBUEPTQRAIAAgBCAFaiIBQQNyNgIEIAAgAWoiASABKAIEQQFyNgIEDAELIAAgBGoiByAFQQFyNgIEIAAgBEEDcjYCBCAFIAdqIAU2AgAgCARAIAhBeHFBtNAAaiEBQaDQACgCACEDAn9BASAIQQN2dCICIAZxRQRAQYzQACACIAZyNgIAIAEMAQsgASgCCAsiAiADNgIMIAEgAzYCCCADIAE2AgwgAyACNgIIC0Gg0AAgBzYCAEGU0AAgBTYCAAsgAEEIaiEBCyAKQRBqJAAgAQtDACAARQRAPwBBEHQPCwJAIABB//8DcQ0AIABBAEgNACAAQRB2QAAiAEF/RgRAQfzTAEEwNgIAQX8PCyAAQRB0DwsACwvcPyIAQYAICwkBAAAAAgAAAAMAQZQICwUEAAAABQBBpAgLCQYAAAAHAAAACABB3AgLii1JbnZhbGlkIGNoYXIgaW4gdXJsIHF1ZXJ5AFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fYm9keQBDb250ZW50LUxlbmd0aCBvdmVyZmxvdwBDaHVuayBzaXplIG92ZXJmbG93AFJlc3BvbnNlIG92ZXJmbG93AEludmFsaWQgbWV0aG9kIGZvciBIVFRQL3gueCByZXF1ZXN0AEludmFsaWQgbWV0aG9kIGZvciBSVFNQL3gueCByZXF1ZXN0AEV4cGVjdGVkIFNPVVJDRSBtZXRob2QgZm9yIElDRS94LnggcmVxdWVzdABJbnZhbGlkIGNoYXIgaW4gdXJsIGZyYWdtZW50IHN0YXJ0AEV4cGVjdGVkIGRvdABTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3N0YXR1cwBJbnZhbGlkIHJlc3BvbnNlIHN0YXR1cwBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zAFVzZXIgY2FsbGJhY2sgZXJyb3IAYG9uX3Jlc2V0YCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfaGVhZGVyYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9iZWdpbmAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3N0YXR1c19jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3ZlcnNpb25fY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl91cmxfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2hlYWRlcl92YWx1ZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX21lc3NhZ2VfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXRob2RfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfZmllbGRfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fbmFtZWAgY2FsbGJhY2sgZXJyb3IAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzZXJ2ZXIASW52YWxpZCBoZWFkZXIgdmFsdWUgY2hhcgBJbnZhbGlkIGhlYWRlciBmaWVsZCBjaGFyAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fdmVyc2lvbgBJbnZhbGlkIG1pbm9yIHZlcnNpb24ASW52YWxpZCBtYWpvciB2ZXJzaW9uAEV4cGVjdGVkIHNwYWNlIGFmdGVyIHZlcnNpb24ARXhwZWN0ZWQgQ1JMRiBhZnRlciB2ZXJzaW9uAEludmFsaWQgSFRUUCB2ZXJzaW9uAEludmFsaWQgaGVhZGVyIHRva2VuAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fdXJsAEludmFsaWQgY2hhcmFjdGVycyBpbiB1cmwAVW5leHBlY3RlZCBzdGFydCBjaGFyIGluIHVybABEb3VibGUgQCBpbiB1cmwARW1wdHkgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyYWN0ZXIgaW4gQ29udGVudC1MZW5ndGgARHVwbGljYXRlIENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhciBpbiB1cmwgcGF0aABDb250ZW50LUxlbmd0aCBjYW4ndCBiZSBwcmVzZW50IHdpdGggVHJhbnNmZXItRW5jb2RpbmcASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgc2l6ZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2hlYWRlcl92YWx1ZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHZhbHVlAE1pc3NpbmcgZXhwZWN0ZWQgTEYgYWZ0ZXIgaGVhZGVyIHZhbHVlAEludmFsaWQgYFRyYW5zZmVyLUVuY29kaW5nYCBoZWFkZXIgdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZSB2YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHF1b3RlZCB2YWx1ZQBQYXVzZWQgYnkgb25faGVhZGVyc19jb21wbGV0ZQBJbnZhbGlkIEVPRiBzdGF0ZQBvbl9yZXNldCBwYXVzZQBvbl9jaHVua19oZWFkZXIgcGF1c2UAb25fbWVzc2FnZV9iZWdpbiBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fdmFsdWUgcGF1c2UAb25fc3RhdHVzX2NvbXBsZXRlIHBhdXNlAG9uX3ZlcnNpb25fY29tcGxldGUgcGF1c2UAb25fdXJsX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl92YWx1ZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXNzYWdlX2NvbXBsZXRlIHBhdXNlAG9uX21ldGhvZF9jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfZmllbGRfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX25hbWUgcGF1c2UAVW5leHBlY3RlZCBzcGFjZSBhZnRlciBzdGFydCBsaW5lAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fY2h1bmtfZXh0ZW5zaW9uX25hbWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBuYW1lAFBhdXNlIG9uIENPTk5FQ1QvVXBncmFkZQBQYXVzZSBvbiBQUkkvVXBncmFkZQBFeHBlY3RlZCBIVFRQLzIgQ29ubmVjdGlvbiBQcmVmYWNlAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fbWV0aG9kAEV4cGVjdGVkIHNwYWNlIGFmdGVyIG1ldGhvZABTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2hlYWRlcl9maWVsZABQYXVzZWQASW52YWxpZCB3b3JkIGVuY291bnRlcmVkAEludmFsaWQgbWV0aG9kIGVuY291bnRlcmVkAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2NoZW1hAFJlcXVlc3QgaGFzIGludmFsaWQgYFRyYW5zZmVyLUVuY29kaW5nYABTV0lUQ0hfUFJPWFkAVVNFX1BST1hZAE1LQUNUSVZJVFkAVU5QUk9DRVNTQUJMRV9FTlRJVFkAQ09QWQBNT1ZFRF9QRVJNQU5FTlRMWQBUT09fRUFSTFkATk9USUZZAEZBSUxFRF9ERVBFTkRFTkNZAEJBRF9HQVRFV0FZAFBMQVkAUFVUAENIRUNLT1VUAEdBVEVXQVlfVElNRU9VVABSRVFVRVNUX1RJTUVPVVQATkVUV09SS19DT05ORUNUX1RJTUVPVVQAQ09OTkVDVElPTl9USU1FT1VUAExPR0lOX1RJTUVPVVQATkVUV09SS19SRUFEX1RJTUVPVVQAUE9TVABNSVNESVJFQ1RFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX0xPQURfQkFMQU5DRURfUkVRVUVTVABCQURfUkVRVUVTVABIVFRQX1JFUVVFU1RfU0VOVF9UT19IVFRQU19QT1JUAFJFUE9SVABJTV9BX1RFQVBPVABSRVNFVF9DT05URU5UAE5PX0NPTlRFTlQAUEFSVElBTF9DT05URU5UAEhQRV9JTlZBTElEX0NPTlNUQU5UAEhQRV9DQl9SRVNFVABHRVQASFBFX1NUUklDVABDT05GTElDVABURU1QT1JBUllfUkVESVJFQ1QAUEVSTUFORU5UX1JFRElSRUNUAENPTk5FQ1QATVVMVElfU1RBVFVTAEhQRV9JTlZBTElEX1NUQVRVUwBUT09fTUFOWV9SRVFVRVNUUwBFQVJMWV9ISU5UUwBVTkFWQUlMQUJMRV9GT1JfTEVHQUxfUkVBU09OUwBPUFRJT05TAFNXSVRDSElOR19QUk9UT0NPTFMAVkFSSUFOVF9BTFNPX05FR09USUFURVMATVVMVElQTEVfQ0hPSUNFUwBJTlRFUk5BTF9TRVJWRVJfRVJST1IAV0VCX1NFUlZFUl9VTktOT1dOX0VSUk9SAFJBSUxHVU5fRVJST1IASURFTlRJVFlfUFJPVklERVJfQVVUSEVOVElDQVRJT05fRVJST1IAU1NMX0NFUlRJRklDQVRFX0VSUk9SAElOVkFMSURfWF9GT1JXQVJERURfRk9SAFNFVF9QQVJBTUVURVIAR0VUX1BBUkFNRVRFUgBIUEVfVVNFUgBTRUVfT1RIRVIASFBFX0NCX0NIVU5LX0hFQURFUgBNS0NBTEVOREFSAFNFVFVQAFdFQl9TRVJWRVJfSVNfRE9XTgBURUFSRE9XTgBIUEVfQ0xPU0VEX0NPTk5FQ1RJT04ASEVVUklTVElDX0VYUElSQVRJT04ARElTQ09OTkVDVEVEX09QRVJBVElPTgBOT05fQVVUSE9SSVRBVElWRV9JTkZPUk1BVElPTgBIUEVfSU5WQUxJRF9WRVJTSU9OAEhQRV9DQl9NRVNTQUdFX0JFR0lOAFNJVEVfSVNfRlJPWkVOAEhQRV9JTlZBTElEX0hFQURFUl9UT0tFTgBJTlZBTElEX1RPS0VOAEZPUkJJRERFTgBFTkhBTkNFX1lPVVJfQ0FMTQBIUEVfSU5WQUxJRF9VUkwAQkxPQ0tFRF9CWV9QQVJFTlRBTF9DT05UUk9MAE1LQ09MAEFDTABIUEVfSU5URVJOQUwAUkVRVUVTVF9IRUFERVJfRklFTERTX1RPT19MQVJHRV9VTk9GRklDSUFMAEhQRV9PSwBVTkxJTksAVU5MT0NLAFBSSQBSRVRSWV9XSVRIAEhQRV9JTlZBTElEX0NPTlRFTlRfTEVOR1RIAEhQRV9VTkVYUEVDVEVEX0NPTlRFTlRfTEVOR1RIAEZMVVNIAFBST1BQQVRDSABNLVNFQVJDSABVUklfVE9PX0xPTkcAUFJPQ0VTU0lORwBNSVNDRUxMQU5FT1VTX1BFUlNJU1RFTlRfV0FSTklORwBNSVNDRUxMQU5FT1VTX1dBUk5JTkcASFBFX0lOVkFMSURfVFJBTlNGRVJfRU5DT0RJTkcARXhwZWN0ZWQgQ1JMRgBIUEVfSU5WQUxJRF9DSFVOS19TSVpFAE1PVkUAQ09OVElOVUUASFBFX0NCX1NUQVRVU19DT01QTEVURQBIUEVfQ0JfSEVBREVSU19DT01QTEVURQBIUEVfQ0JfVkVSU0lPTl9DT01QTEVURQBIUEVfQ0JfVVJMX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19DT01QTEVURQBIUEVfQ0JfSEVBREVSX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9OQU1FX0NPTVBMRVRFAEhQRV9DQl9NRVNTQUdFX0NPTVBMRVRFAEhQRV9DQl9NRVRIT0RfQ09NUExFVEUASFBFX0NCX0hFQURFUl9GSUVMRF9DT01QTEVURQBERUxFVEUASFBFX0lOVkFMSURfRU9GX1NUQVRFAElOVkFMSURfU1NMX0NFUlRJRklDQVRFAFBBVVNFAE5PX1JFU1BPTlNFAFVOU1VQUE9SVEVEX01FRElBX1RZUEUAR09ORQBOT1RfQUNDRVBUQUJMRQBTRVJWSUNFX1VOQVZBSUxBQkxFAFJBTkdFX05PVF9TQVRJU0ZJQUJMRQBPUklHSU5fSVNfVU5SRUFDSEFCTEUAUkVTUE9OU0VfSVNfU1RBTEUAUFVSR0UATUVSR0UAUkVRVUVTVF9IRUFERVJfRklFTERTX1RPT19MQVJHRQBSRVFVRVNUX0hFQURFUl9UT09fTEFSR0UAUEFZTE9BRF9UT09fTEFSR0UASU5TVUZGSUNJRU5UX1NUT1JBR0UASFBFX1BBVVNFRF9VUEdSQURFAEhQRV9QQVVTRURfSDJfVVBHUkFERQBTT1VSQ0UAQU5OT1VOQ0UAVFJBQ0UASFBFX1VORVhQRUNURURfU1BBQ0UAREVTQ1JJQkUAVU5TVUJTQ1JJQkUAUkVDT1JEAEhQRV9JTlZBTElEX01FVEhPRABOT1RfRk9VTkQAUFJPUEZJTkQAVU5CSU5EAFJFQklORABVTkFVVEhPUklaRUQATUVUSE9EX05PVF9BTExPV0VEAEhUVFBfVkVSU0lPTl9OT1RfU1VQUE9SVEVEAEFMUkVBRFlfUkVQT1JURUQAQUNDRVBURUQATk9UX0lNUExFTUVOVEVEAExPT1BfREVURUNURUQASFBFX0NSX0VYUEVDVEVEAEhQRV9MRl9FWFBFQ1RFRABDUkVBVEVEAElNX1VTRUQASFBFX1BBVVNFRABUSU1FT1VUX09DQ1VSRUQAUEFZTUVOVF9SRVFVSVJFRABQUkVDT05ESVRJT05fUkVRVUlSRUQAUFJPWFlfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATkVUV09SS19BVVRIRU5USUNBVElPTl9SRVFVSVJFRABMRU5HVEhfUkVRVUlSRUQAU1NMX0NFUlRJRklDQVRFX1JFUVVJUkVEAFVQR1JBREVfUkVRVUlSRUQAUEFHRV9FWFBJUkVEAFBSRUNPTkRJVElPTl9GQUlMRUQARVhQRUNUQVRJT05fRkFJTEVEAFJFVkFMSURBVElPTl9GQUlMRUQAU1NMX0hBTkRTSEFLRV9GQUlMRUQATE9DS0VEAFRSQU5TRk9STUFUSU9OX0FQUExJRUQATk9UX01PRElGSUVEAE5PVF9FWFRFTkRFRABCQU5EV0lEVEhfTElNSVRfRVhDRUVERUQAU0lURV9JU19PVkVSTE9BREVEAEhFQUQARXhwZWN0ZWQgSFRUUC8AAF4TAAAmEwAAMBAAAPAXAACdEwAAFRIAADkXAADwEgAAChAAAHUSAACtEgAAghMAAE8UAAB/EAAAoBUAACMUAACJEgAAixQAAE0VAADUEQAAzxQAABAYAADJFgAA3BYAAMERAADgFwAAuxQAAHQUAAB8FQAA5RQAAAgXAAAfEAAAZRUAAKMUAAAoFQAAAhUAAJkVAAAsEAAAixkAAE8PAADUDgAAahAAAM4QAAACFwAAiQ4AAG4TAAAcEwAAZhQAAFYXAADBEwAAzRMAAGwTAABoFwAAZhcAAF8XAAAiEwAAzg8AAGkOAADYDgAAYxYAAMsTAACqDgAAKBcAACYXAADFEwAAXRYAAOgRAABnEwAAZRMAAPIWAABzEwAAHRcAAPkWAADzEQAAzw4AAM4VAAAMEgAAsxEAAKURAABhEAAAMhcAALsTAEH5NQsBAQBBkDYL4AEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBB/TcLAQEAQZE4C14CAwICAgICAAACAgACAgACAgICAgICAgICAAQAAAAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgACAEH9OQsBAQBBkToLXgIAAgICAgIAAAICAAICAAICAgICAgICAgIAAwAEAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAQfA7Cw1sb3NlZWVwLWFsaXZlAEGJPAsBAQBBoDwL4AEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBBiT4LAQEAQaA+C+cBAQEBAQEBAQEBAQEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQFjaHVua2VkAEGwwAALXwEBAAEBAQEBAAABAQABAQABAQEBAQEBAQEBAAAAAAAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAEGQwgALIWVjdGlvbmVudC1sZW5ndGhvbnJveHktY29ubmVjdGlvbgBBwMIACy1yYW5zZmVyLWVuY29kaW5ncGdyYWRlDQoNCg0KU00NCg0KVFRQL0NFL1RTUC8AQfnCAAsFAQIAAQMAQZDDAAvgAQQBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAEH5xAALBQECAAEDAEGQxQAL4AEEAQEFAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBB+cYACwQBAAABAEGRxwAL3wEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAEH6yAALBAEAAAIAQZDJAAtfAwQAAAQEBAQEBAQEBAQEBQQEBAQEBAQEBAQEBAAEAAYHBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQAQfrKAAsEAQAAAQBBkMsACwEBAEGqywALQQIAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAEH6zAALBAEAAAEAQZDNAAsBAQBBms0ACwYCAAAAAAIAQbHNAAs6AwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwBB8M4AC5YBTk9VTkNFRUNLT1VUTkVDVEVURUNSSUJFTFVTSEVURUFEU0VBUkNIUkdFQ1RJVklUWUxFTkRBUlZFT1RJRllQVElPTlNDSFNFQVlTVEFUQ0hHRU9SRElSRUNUT1JUUkNIUEFSQU1FVEVSVVJDRUJTQ1JJQkVBUkRPV05BQ0VJTkROS0NLVUJTQ1JJQkVIVFRQL0FEVFAv", "base64");
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/llhttp/llhttp_simd-wasm.js
var require_llhttp_simd_wasm = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/llhttp/llhttp_simd-wasm.js"(exports2, module2) {
    "use strict";
    var { Buffer: Buffer2 } = require_node_buffer();
    module2.exports = Buffer2.from("AGFzbQEAAAABJwdgAX8Bf2ADf39/AX9gAX8AYAJ/fwBgBH9/f38Bf2AAAGADf39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQAEA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAAy0sBQYAAAIAAAAAAAACAQIAAgICAAADAAAAAAMDAwMBAQEBAQEBAQEAAAIAAAAEBQFwARISBQMBAAIGCAF/AUGA1AQLB9EFIgZtZW1vcnkCAAtfaW5pdGlhbGl6ZQAIGV9faW5kaXJlY3RfZnVuY3Rpb25fdGFibGUBAAtsbGh0dHBfaW5pdAAJGGxsaHR0cF9zaG91bGRfa2VlcF9hbGl2ZQAvDGxsaHR0cF9hbGxvYwALBm1hbGxvYwAxC2xsaHR0cF9mcmVlAAwEZnJlZQAMD2xsaHR0cF9nZXRfdHlwZQANFWxsaHR0cF9nZXRfaHR0cF9tYWpvcgAOFWxsaHR0cF9nZXRfaHR0cF9taW5vcgAPEWxsaHR0cF9nZXRfbWV0aG9kABAWbGxodHRwX2dldF9zdGF0dXNfY29kZQAREmxsaHR0cF9nZXRfdXBncmFkZQASDGxsaHR0cF9yZXNldAATDmxsaHR0cF9leGVjdXRlABQUbGxodHRwX3NldHRpbmdzX2luaXQAFQ1sbGh0dHBfZmluaXNoABYMbGxodHRwX3BhdXNlABcNbGxodHRwX3Jlc3VtZQAYG2xsaHR0cF9yZXN1bWVfYWZ0ZXJfdXBncmFkZQAZEGxsaHR0cF9nZXRfZXJybm8AGhdsbGh0dHBfZ2V0X2Vycm9yX3JlYXNvbgAbF2xsaHR0cF9zZXRfZXJyb3JfcmVhc29uABwUbGxodHRwX2dldF9lcnJvcl9wb3MAHRFsbGh0dHBfZXJybm9fbmFtZQAeEmxsaHR0cF9tZXRob2RfbmFtZQAfEmxsaHR0cF9zdGF0dXNfbmFtZQAgGmxsaHR0cF9zZXRfbGVuaWVudF9oZWFkZXJzACEhbGxodHRwX3NldF9sZW5pZW50X2NodW5rZWRfbGVuZ3RoACIdbGxodHRwX3NldF9sZW5pZW50X2tlZXBfYWxpdmUAIyRsbGh0dHBfc2V0X2xlbmllbnRfdHJhbnNmZXJfZW5jb2RpbmcAJBhsbGh0dHBfbWVzc2FnZV9uZWVkc19lb2YALgkXAQBBAQsRAQIDBAUKBgcrLSwqKSglJyYK77MCLBYAQYjQACgCAARAAAtBiNAAQQE2AgALFAAgABAwIAAgAjYCOCAAIAE6ACgLFAAgACAALwEyIAAtAC4gABAvEAALHgEBf0HAABAyIgEQMCABQYAINgI4IAEgADoAKCABC48MAQd/AkAgAEUNACAAQQhrIgEgAEEEaygCACIAQXhxIgRqIQUCQCAAQQFxDQAgAEEDcUUNASABIAEoAgAiAGsiAUGc0AAoAgBJDQEgACAEaiEEAkACQEGg0AAoAgAgAUcEQCAAQf8BTQRAIABBA3YhAyABKAIIIgAgASgCDCICRgRAQYzQAEGM0AAoAgBBfiADd3E2AgAMBQsgAiAANgIIIAAgAjYCDAwECyABKAIYIQYgASABKAIMIgBHBEAgACABKAIIIgI2AgggAiAANgIMDAMLIAFBFGoiAygCACICRQRAIAEoAhAiAkUNAiABQRBqIQMLA0AgAyEHIAIiAEEUaiIDKAIAIgINACAAQRBqIQMgACgCECICDQALIAdBADYCAAwCCyAFKAIEIgBBA3FBA0cNAiAFIABBfnE2AgRBlNAAIAQ2AgAgBSAENgIAIAEgBEEBcjYCBAwDC0EAIQALIAZFDQACQCABKAIcIgJBAnRBvNIAaiIDKAIAIAFGBEAgAyAANgIAIAANAUGQ0ABBkNAAKAIAQX4gAndxNgIADAILIAZBEEEUIAYoAhAgAUYbaiAANgIAIABFDQELIAAgBjYCGCABKAIQIgIEQCAAIAI2AhAgAiAANgIYCyABQRRqKAIAIgJFDQAgAEEUaiACNgIAIAIgADYCGAsgASAFTw0AIAUoAgQiAEEBcUUNAAJAAkACQAJAIABBAnFFBEBBpNAAKAIAIAVGBEBBpNAAIAE2AgBBmNAAQZjQACgCACAEaiIANgIAIAEgAEEBcjYCBCABQaDQACgCAEcNBkGU0ABBADYCAEGg0ABBADYCAAwGC0Gg0AAoAgAgBUYEQEGg0AAgATYCAEGU0ABBlNAAKAIAIARqIgA2AgAgASAAQQFyNgIEIAAgAWogADYCAAwGCyAAQXhxIARqIQQgAEH/AU0EQCAAQQN2IQMgBSgCCCIAIAUoAgwiAkYEQEGM0ABBjNAAKAIAQX4gA3dxNgIADAULIAIgADYCCCAAIAI2AgwMBAsgBSgCGCEGIAUgBSgCDCIARwRAQZzQACgCABogACAFKAIIIgI2AgggAiAANgIMDAMLIAVBFGoiAygCACICRQRAIAUoAhAiAkUNAiAFQRBqIQMLA0AgAyEHIAIiAEEUaiIDKAIAIgINACAAQRBqIQMgACgCECICDQALIAdBADYCAAwCCyAFIABBfnE2AgQgASAEaiAENgIAIAEgBEEBcjYCBAwDC0EAIQALIAZFDQACQCAFKAIcIgJBAnRBvNIAaiIDKAIAIAVGBEAgAyAANgIAIAANAUGQ0ABBkNAAKAIAQX4gAndxNgIADAILIAZBEEEUIAYoAhAgBUYbaiAANgIAIABFDQELIAAgBjYCGCAFKAIQIgIEQCAAIAI2AhAgAiAANgIYCyAFQRRqKAIAIgJFDQAgAEEUaiACNgIAIAIgADYCGAsgASAEaiAENgIAIAEgBEEBcjYCBCABQaDQACgCAEcNAEGU0AAgBDYCAAwBCyAEQf8BTQRAIARBeHFBtNAAaiEAAn9BjNAAKAIAIgJBASAEQQN2dCIDcUUEQEGM0AAgAiADcjYCACAADAELIAAoAggLIgIgATYCDCAAIAE2AgggASAANgIMIAEgAjYCCAwBC0EfIQIgBEH///8HTQRAIARBJiAEQQh2ZyIAa3ZBAXEgAEEBdGtBPmohAgsgASACNgIcIAFCADcCECACQQJ0QbzSAGohAAJAQZDQACgCACIDQQEgAnQiB3FFBEAgACABNgIAQZDQACADIAdyNgIAIAEgADYCGCABIAE2AgggASABNgIMDAELIARBGSACQQF2a0EAIAJBH0cbdCECIAAoAgAhAAJAA0AgACIDKAIEQXhxIARGDQEgAkEddiEAIAJBAXQhAiADIABBBHFqQRBqIgcoAgAiAA0ACyAHIAE2AgAgASADNgIYIAEgATYCDCABIAE2AggMAQsgAygCCCIAIAE2AgwgAyABNgIIIAFBADYCGCABIAM2AgwgASAANgIIC0Gs0ABBrNAAKAIAQQFrIgBBfyAAGzYCAAsLBwAgAC0AKAsHACAALQAqCwcAIAAtACsLBwAgAC0AKQsHACAALwEyCwcAIAAtAC4LQAEEfyAAKAIYIQEgAC0ALSECIAAtACghAyAAKAI4IQQgABAwIAAgBDYCOCAAIAM6ACggACACOgAtIAAgATYCGAu74gECB38DfiABIAJqIQQCQCAAIgIoAgwiAA0AIAIoAgQEQCACIAE2AgQLIwBBEGsiCCQAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAIoAhwiA0EBaw7dAdoBAdkBAgMEBQYHCAkKCwwNDtgBDxDXARES1gETFBUWFxgZGhvgAd8BHB0e1QEfICEiIyQl1AEmJygpKiss0wHSAS0u0QHQAS8wMTIzNDU2Nzg5Ojs8PT4/QEFCQ0RFRtsBR0hJSs8BzgFLzQFMzAFNTk9QUVJTVFVWV1hZWltcXV5fYGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6e3x9fn+AAYEBggGDAYQBhQGGAYcBiAGJAYoBiwGMAY0BjgGPAZABkQGSAZMBlAGVAZYBlwGYAZkBmgGbAZwBnQGeAZ8BoAGhAaIBowGkAaUBpgGnAagBqQGqAasBrAGtAa4BrwGwAbEBsgGzAbQBtQG2AbcBywHKAbgByQG5AcgBugG7AbwBvQG+Ab8BwAHBAcIBwwHEAcUBxgEA3AELQQAMxgELQQ4MxQELQQ0MxAELQQ8MwwELQRAMwgELQRMMwQELQRQMwAELQRUMvwELQRYMvgELQRgMvQELQRkMvAELQRoMuwELQRsMugELQRwMuQELQR0MuAELQQgMtwELQR4MtgELQSAMtQELQR8MtAELQQcMswELQSEMsgELQSIMsQELQSMMsAELQSQMrwELQRIMrgELQREMrQELQSUMrAELQSYMqwELQScMqgELQSgMqQELQcMBDKgBC0EqDKcBC0ErDKYBC0EsDKUBC0EtDKQBC0EuDKMBC0EvDKIBC0HEAQyhAQtBMAygAQtBNAyfAQtBDAyeAQtBMQydAQtBMgycAQtBMwybAQtBOQyaAQtBNQyZAQtBxQEMmAELQQsMlwELQToMlgELQTYMlQELQQoMlAELQTcMkwELQTgMkgELQTwMkQELQTsMkAELQT0MjwELQQkMjgELQSkMjQELQT4MjAELQT8MiwELQcAADIoBC0HBAAyJAQtBwgAMiAELQcMADIcBC0HEAAyGAQtBxQAMhQELQcYADIQBC0EXDIMBC0HHAAyCAQtByAAMgQELQckADIABC0HKAAx/C0HLAAx+C0HNAAx9C0HMAAx8C0HOAAx7C0HPAAx6C0HQAAx5C0HRAAx4C0HSAAx3C0HTAAx2C0HUAAx1C0HWAAx0C0HVAAxzC0EGDHILQdcADHELQQUMcAtB2AAMbwtBBAxuC0HZAAxtC0HaAAxsC0HbAAxrC0HcAAxqC0EDDGkLQd0ADGgLQd4ADGcLQd8ADGYLQeEADGULQeAADGQLQeIADGMLQeMADGILQQIMYQtB5AAMYAtB5QAMXwtB5gAMXgtB5wAMXQtB6AAMXAtB6QAMWwtB6gAMWgtB6wAMWQtB7AAMWAtB7QAMVwtB7gAMVgtB7wAMVQtB8AAMVAtB8QAMUwtB8gAMUgtB8wAMUQtB9AAMUAtB9QAMTwtB9gAMTgtB9wAMTQtB+AAMTAtB+QAMSwtB+gAMSgtB+wAMSQtB/AAMSAtB/QAMRwtB/gAMRgtB/wAMRQtBgAEMRAtBgQEMQwtBggEMQgtBgwEMQQtBhAEMQAtBhQEMPwtBhgEMPgtBhwEMPQtBiAEMPAtBiQEMOwtBigEMOgtBiwEMOQtBjAEMOAtBjQEMNwtBjgEMNgtBjwEMNQtBkAEMNAtBkQEMMwtBkgEMMgtBkwEMMQtBlAEMMAtBlQEMLwtBlgEMLgtBlwEMLQtBmAEMLAtBmQEMKwtBmgEMKgtBmwEMKQtBnAEMKAtBnQEMJwtBngEMJgtBnwEMJQtBoAEMJAtBoQEMIwtBogEMIgtBowEMIQtBpAEMIAtBpQEMHwtBpgEMHgtBpwEMHQtBqAEMHAtBqQEMGwtBqgEMGgtBqwEMGQtBrAEMGAtBrQEMFwtBrgEMFgtBAQwVC0GvAQwUC0GwAQwTC0GxAQwSC0GzAQwRC0GyAQwQC0G0AQwPC0G1AQwOC0G2AQwNC0G3AQwMC0G4AQwLC0G5AQwKC0G6AQwJC0G7AQwIC0HGAQwHC0G8AQwGC0G9AQwFC0G+AQwEC0G/AQwDC0HAAQwCC0HCAQwBC0HBAQshAwNAAkACQAJAAkACQAJAAkACQAJAIAICfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAgJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACQAJAAn8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCADDsYBAAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHyAhIyUmKCorLC8wMTIzNDU2Nzk6Ozw9lANAQkRFRklLTk9QUVJTVFVWWFpbXF1eX2BhYmNkZWZnaGpsb3Bxc3V2eHl6e3x/gAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEBkgGTAZQBlQGWAZcBmAGZAZoBmwGcAZ0BngGfAaABoQGiAaMBpAGlAaYBpwGoAakBqgGrAawBrQGuAa8BsAGxAbIBswG0AbUBtgG3AbgBuQG6AbsBvAG9Ab4BvwHAAcEBwgHDAcQBxQHGAccByAHJAcsBzAHNAc4BzwGKA4kDiAOHA4QDgwOAA/sC+gL5AvgC9wL0AvMC8gLLAsECsALZAQsgASAERw3wAkHdASEDDLMDCyABIARHDcgBQcMBIQMMsgMLIAEgBEcNe0H3ACEDDLEDCyABIARHDXBB7wAhAwywAwsgASAERw1pQeoAIQMMrwMLIAEgBEcNZUHoACEDDK4DCyABIARHDWJB5gAhAwytAwsgASAERw0aQRghAwysAwsgASAERw0VQRIhAwyrAwsgASAERw1CQcUAIQMMqgMLIAEgBEcNNEE/IQMMqQMLIAEgBEcNMkE8IQMMqAMLIAEgBEcNK0ExIQMMpwMLIAItAC5BAUYNnwMMwQILQQAhAAJAAkACQCACLQAqRQ0AIAItACtFDQAgAi8BMCIDQQJxRQ0BDAILIAIvATAiA0EBcUUNAQtBASEAIAItAChBAUYNACACLwEyIgVB5ABrQeQASQ0AIAVBzAFGDQAgBUGwAkYNACADQcAAcQ0AQQAhACADQYgEcUGABEYNACADQShxQQBHIQALIAJBADsBMCACQQA6AC8gAEUN3wIgAkIANwMgDOACC0EAIQACQCACKAI4IgNFDQAgAygCLCIDRQ0AIAIgAxEAACEACyAARQ3MASAAQRVHDd0CIAJBBDYCHCACIAE2AhQgAkGwGDYCECACQRU2AgxBACEDDKQDCyABIARGBEBBBiEDDKQDCyABQQFqIQFBACEAAkAgAigCOCIDRQ0AIAMoAlQiA0UNACACIAMRAAAhAAsgAA3ZAgwcCyACQgA3AyBBEiEDDIkDCyABIARHDRZBHSEDDKEDCyABIARHBEAgAUEBaiEBQRAhAwyIAwtBByEDDKADCyACIAIpAyAiCiAEIAFrrSILfSIMQgAgCiAMWhs3AyAgCiALWA3UAkEIIQMMnwMLIAEgBEcEQCACQQk2AgggAiABNgIEQRQhAwyGAwtBCSEDDJ4DCyACKQMgQgBSDccBIAIgAi8BMEGAAXI7ATAMQgsgASAERw0/QdAAIQMMnAMLIAEgBEYEQEELIQMMnAMLIAFBAWohAUEAIQACQCACKAI4IgNFDQAgAygCUCIDRQ0AIAIgAxEAACEACyAADc8CDMYBC0EAIQACQCACKAI4IgNFDQAgAygCSCIDRQ0AIAIgAxEAACEACyAARQ3GASAAQRVHDc0CIAJBCzYCHCACIAE2AhQgAkGCGTYCECACQRU2AgxBACEDDJoDC0EAIQACQCACKAI4IgNFDQAgAygCSCIDRQ0AIAIgAxEAACEACyAARQ0MIABBFUcNygIgAkEaNgIcIAIgATYCFCACQYIZNgIQIAJBFTYCDEEAIQMMmQMLQQAhAAJAIAIoAjgiA0UNACADKAJMIgNFDQAgAiADEQAAIQALIABFDcQBIABBFUcNxwIgAkELNgIcIAIgATYCFCACQZEXNgIQIAJBFTYCDEEAIQMMmAMLIAEgBEYEQEEPIQMMmAMLIAEtAAAiAEE7Rg0HIABBDUcNxAIgAUEBaiEBDMMBC0EAIQACQCACKAI4IgNFDQAgAygCTCIDRQ0AIAIgAxEAACEACyAARQ3DASAAQRVHDcICIAJBDzYCHCACIAE2AhQgAkGRFzYCECACQRU2AgxBACEDDJYDCwNAIAEtAABB8DVqLQAAIgBBAUcEQCAAQQJHDcECIAIoAgQhAEEAIQMgAkEANgIEIAIgACABQQFqIgEQLSIADcICDMUBCyAEIAFBAWoiAUcNAAtBEiEDDJUDC0EAIQACQCACKAI4IgNFDQAgAygCTCIDRQ0AIAIgAxEAACEACyAARQ3FASAAQRVHDb0CIAJBGzYCHCACIAE2AhQgAkGRFzYCECACQRU2AgxBACEDDJQDCyABIARGBEBBFiEDDJQDCyACQQo2AgggAiABNgIEQQAhAAJAIAIoAjgiA0UNACADKAJIIgNFDQAgAiADEQAAIQALIABFDcIBIABBFUcNuQIgAkEVNgIcIAIgATYCFCACQYIZNgIQIAJBFTYCDEEAIQMMkwMLIAEgBEcEQANAIAEtAABB8DdqLQAAIgBBAkcEQAJAIABBAWsOBMQCvQIAvgK9AgsgAUEBaiEBQQghAwz8AgsgBCABQQFqIgFHDQALQRUhAwyTAwtBFSEDDJIDCwNAIAEtAABB8DlqLQAAIgBBAkcEQCAAQQFrDgTFArcCwwK4ArcCCyAEIAFBAWoiAUcNAAtBGCEDDJEDCyABIARHBEAgAkELNgIIIAIgATYCBEEHIQMM+AILQRkhAwyQAwsgAUEBaiEBDAILIAEgBEYEQEEaIQMMjwMLAkAgAS0AAEENaw4UtQG/Ab8BvwG/Ab8BvwG/Ab8BvwG/Ab8BvwG/Ab8BvwG/Ab8BvwEAvwELQQAhAyACQQA2AhwgAkGvCzYCECACQQI2AgwgAiABQQFqNgIUDI4DCyABIARGBEBBGyEDDI4DCyABLQAAIgBBO0cEQCAAQQ1HDbECIAFBAWohAQy6AQsgAUEBaiEBC0EiIQMM8wILIAEgBEYEQEEcIQMMjAMLQgAhCgJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAS0AAEEwaw43wQLAAgABAgMEBQYH0AHQAdAB0AHQAdAB0AEICQoLDA3QAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdABDg8QERIT0AELQgIhCgzAAgtCAyEKDL8CC0IEIQoMvgILQgUhCgy9AgtCBiEKDLwCC0IHIQoMuwILQgghCgy6AgtCCSEKDLkCC0IKIQoMuAILQgshCgy3AgtCDCEKDLYCC0INIQoMtQILQg4hCgy0AgtCDyEKDLMCC0IKIQoMsgILQgshCgyxAgtCDCEKDLACC0INIQoMrwILQg4hCgyuAgtCDyEKDK0CC0IAIQoCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAEtAABBMGsON8ACvwIAAQIDBAUGB74CvgK+Ar4CvgK+Ar4CCAkKCwwNvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ag4PEBESE74CC0ICIQoMvwILQgMhCgy+AgtCBCEKDL0CC0IFIQoMvAILQgYhCgy7AgtCByEKDLoCC0IIIQoMuQILQgkhCgy4AgtCCiEKDLcCC0ILIQoMtgILQgwhCgy1AgtCDSEKDLQCC0IOIQoMswILQg8hCgyyAgtCCiEKDLECC0ILIQoMsAILQgwhCgyvAgtCDSEKDK4CC0IOIQoMrQILQg8hCgysAgsgAiACKQMgIgogBCABa60iC30iDEIAIAogDFobNwMgIAogC1gNpwJBHyEDDIkDCyABIARHBEAgAkEJNgIIIAIgATYCBEElIQMM8AILQSAhAwyIAwtBASEFIAIvATAiA0EIcUUEQCACKQMgQgBSIQULAkAgAi0ALgRAQQEhACACLQApQQVGDQEgA0HAAHFFIAVxRQ0BC0EAIQAgA0HAAHENAEECIQAgA0EIcQ0AIANBgARxBEACQCACLQAoQQFHDQAgAi0ALUEKcQ0AQQUhAAwCC0EEIQAMAQsgA0EgcUUEQAJAIAItAChBAUYNACACLwEyIgBB5ABrQeQASQ0AIABBzAFGDQAgAEGwAkYNAEEEIQAgA0EocUUNAiADQYgEcUGABEYNAgtBACEADAELQQBBAyACKQMgUBshAAsgAEEBaw4FvgIAsAEBpAKhAgtBESEDDO0CCyACQQE6AC8MhAMLIAEgBEcNnQJBJCEDDIQDCyABIARHDRxBxgAhAwyDAwtBACEAAkAgAigCOCIDRQ0AIAMoAkQiA0UNACACIAMRAAAhAAsgAEUNJyAAQRVHDZgCIAJB0AA2AhwgAiABNgIUIAJBkRg2AhAgAkEVNgIMQQAhAwyCAwsgASAERgRAQSghAwyCAwtBACEDIAJBADYCBCACQQw2AgggAiABIAEQKiIARQ2UAiACQSc2AhwgAiABNgIUIAIgADYCDAyBAwsgASAERgRAQSkhAwyBAwsgAS0AACIAQSBGDRMgAEEJRw2VAiABQQFqIQEMFAsgASAERwRAIAFBAWohAQwWC0EqIQMM/wILIAEgBEYEQEErIQMM/wILIAEtAAAiAEEJRyAAQSBHcQ2QAiACLQAsQQhHDd0CIAJBADoALAzdAgsgASAERgRAQSwhAwz+AgsgAS0AAEEKRw2OAiABQQFqIQEMsAELIAEgBEcNigJBLyEDDPwCCwNAIAEtAAAiAEEgRwRAIABBCmsOBIQCiAKIAoQChgILIAQgAUEBaiIBRw0AC0ExIQMM+wILQTIhAyABIARGDfoCIAIoAgAiACAEIAFraiEHIAEgAGtBA2ohBgJAA0AgAEHwO2otAAAgAS0AACIFQSByIAUgBUHBAGtB/wFxQRpJG0H/AXFHDQEgAEEDRgRAQQYhAQziAgsgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAc2AgAM+wILIAJBADYCAAyGAgtBMyEDIAQgASIARg35AiAEIAFrIAIoAgAiAWohByAAIAFrQQhqIQYCQANAIAFB9DtqLQAAIAAtAAAiBUEgciAFIAVBwQBrQf8BcUEaSRtB/wFxRw0BIAFBCEYEQEEFIQEM4QILIAFBAWohASAEIABBAWoiAEcNAAsgAiAHNgIADPoCCyACQQA2AgAgACEBDIUCC0E0IQMgBCABIgBGDfgCIAQgAWsgAigCACIBaiEHIAAgAWtBBWohBgJAA0AgAUHQwgBqLQAAIAAtAAAiBUEgciAFIAVBwQBrQf8BcUEaSRtB/wFxRw0BIAFBBUYEQEEHIQEM4AILIAFBAWohASAEIABBAWoiAEcNAAsgAiAHNgIADPkCCyACQQA2AgAgACEBDIQCCyABIARHBEADQCABLQAAQYA+ai0AACIAQQFHBEAgAEECRg0JDIECCyAEIAFBAWoiAUcNAAtBMCEDDPgCC0EwIQMM9wILIAEgBEcEQANAIAEtAAAiAEEgRwRAIABBCmsOBP8B/gH+Af8B/gELIAQgAUEBaiIBRw0AC0E4IQMM9wILQTghAwz2AgsDQCABLQAAIgBBIEcgAEEJR3EN9gEgBCABQQFqIgFHDQALQTwhAwz1AgsDQCABLQAAIgBBIEcEQAJAIABBCmsOBPkBBAT5AQALIABBLEYN9QEMAwsgBCABQQFqIgFHDQALQT8hAwz0AgtBwAAhAyABIARGDfMCIAIoAgAiACAEIAFraiEFIAEgAGtBBmohBgJAA0AgAEGAQGstAAAgAS0AAEEgckcNASAAQQZGDdsCIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADPQCCyACQQA2AgALQTYhAwzZAgsgASAERgRAQcEAIQMM8gILIAJBDDYCCCACIAE2AgQgAi0ALEEBaw4E+wHuAewB6wHUAgsgAUEBaiEBDPoBCyABIARHBEADQAJAIAEtAAAiAEEgciAAIABBwQBrQf8BcUEaSRtB/wFxIgBBCUYNACAAQSBGDQACQAJAAkACQCAAQeMAaw4TAAMDAwMDAwMBAwMDAwMDAwMDAgMLIAFBAWohAUExIQMM3AILIAFBAWohAUEyIQMM2wILIAFBAWohAUEzIQMM2gILDP4BCyAEIAFBAWoiAUcNAAtBNSEDDPACC0E1IQMM7wILIAEgBEcEQANAIAEtAABBgDxqLQAAQQFHDfcBIAQgAUEBaiIBRw0AC0E9IQMM7wILQT0hAwzuAgtBACEAAkAgAigCOCIDRQ0AIAMoAkAiA0UNACACIAMRAAAhAAsgAEUNASAAQRVHDeYBIAJBwgA2AhwgAiABNgIUIAJB4xg2AhAgAkEVNgIMQQAhAwztAgsgAUEBaiEBC0E8IQMM0gILIAEgBEYEQEHCACEDDOsCCwJAA0ACQCABLQAAQQlrDhgAAswCzALRAswCzALMAswCzALMAswCzALMAswCzALMAswCzALMAswCzALMAgDMAgsgBCABQQFqIgFHDQALQcIAIQMM6wILIAFBAWohASACLQAtQQFxRQ3+AQtBLCEDDNACCyABIARHDd4BQcQAIQMM6AILA0AgAS0AAEGQwABqLQAAQQFHDZwBIAQgAUEBaiIBRw0AC0HFACEDDOcCCyABLQAAIgBBIEYN/gEgAEE6Rw3AAiACKAIEIQBBACEDIAJBADYCBCACIAAgARApIgAN3gEM3QELQccAIQMgBCABIgBGDeUCIAQgAWsgAigCACIBaiEHIAAgAWtBBWohBgNAIAFBkMIAai0AACAALQAAIgVBIHIgBSAFQcEAa0H/AXFBGkkbQf8BcUcNvwIgAUEFRg3CAiABQQFqIQEgBCAAQQFqIgBHDQALIAIgBzYCAAzlAgtByAAhAyAEIAEiAEYN5AIgBCABayACKAIAIgFqIQcgACABa0EJaiEGA0AgAUGWwgBqLQAAIAAtAAAiBUEgciAFIAVBwQBrQf8BcUEaSRtB/wFxRw2+AkECIAFBCUYNwgIaIAFBAWohASAEIABBAWoiAEcNAAsgAiAHNgIADOQCCyABIARGBEBByQAhAwzkAgsCQAJAIAEtAAAiAEEgciAAIABBwQBrQf8BcUEaSRtB/wFxQe4Aaw4HAL8CvwK/Ar8CvwIBvwILIAFBAWohAUE+IQMMywILIAFBAWohAUE/IQMMygILQcoAIQMgBCABIgBGDeICIAQgAWsgAigCACIBaiEGIAAgAWtBAWohBwNAIAFBoMIAai0AACAALQAAIgVBIHIgBSAFQcEAa0H/AXFBGkkbQf8BcUcNvAIgAUEBRg2+AiABQQFqIQEgBCAAQQFqIgBHDQALIAIgBjYCAAziAgtBywAhAyAEIAEiAEYN4QIgBCABayACKAIAIgFqIQcgACABa0EOaiEGA0AgAUGiwgBqLQAAIAAtAAAiBUEgciAFIAVBwQBrQf8BcUEaSRtB/wFxRw27AiABQQ5GDb4CIAFBAWohASAEIABBAWoiAEcNAAsgAiAHNgIADOECC0HMACEDIAQgASIARg3gAiAEIAFrIAIoAgAiAWohByAAIAFrQQ9qIQYDQCABQcDCAGotAAAgAC0AACIFQSByIAUgBUHBAGtB/wFxQRpJG0H/AXFHDboCQQMgAUEPRg2+AhogAUEBaiEBIAQgAEEBaiIARw0ACyACIAc2AgAM4AILQc0AIQMgBCABIgBGDd8CIAQgAWsgAigCACIBaiEHIAAgAWtBBWohBgNAIAFB0MIAai0AACAALQAAIgVBIHIgBSAFQcEAa0H/AXFBGkkbQf8BcUcNuQJBBCABQQVGDb0CGiABQQFqIQEgBCAAQQFqIgBHDQALIAIgBzYCAAzfAgsgASAERgRAQc4AIQMM3wILAkACQAJAAkAgAS0AACIAQSByIAAgAEHBAGtB/wFxQRpJG0H/AXFB4wBrDhMAvAK8ArwCvAK8ArwCvAK8ArwCvAK8ArwCAbwCvAK8AgIDvAILIAFBAWohAUHBACEDDMgCCyABQQFqIQFBwgAhAwzHAgsgAUEBaiEBQcMAIQMMxgILIAFBAWohAUHEACEDDMUCCyABIARHBEAgAkENNgIIIAIgATYCBEHFACEDDMUCC0HPACEDDN0CCwJAAkAgAS0AAEEKaw4EAZABkAEAkAELIAFBAWohAQtBKCEDDMMCCyABIARGBEBB0QAhAwzcAgsgAS0AAEEgRw0AIAFBAWohASACLQAtQQFxRQ3QAQtBFyEDDMECCyABIARHDcsBQdIAIQMM2QILQdMAIQMgASAERg3YAiACKAIAIgAgBCABa2ohBiABIABrQQFqIQUDQCABLQAAIABB1sIAai0AAEcNxwEgAEEBRg3KASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBjYCAAzYAgsgASAERgRAQdUAIQMM2AILIAEtAABBCkcNwgEgAUEBaiEBDMoBCyABIARGBEBB1gAhAwzXAgsCQAJAIAEtAABBCmsOBADDAcMBAcMBCyABQQFqIQEMygELIAFBAWohAUHKACEDDL0CC0EAIQACQCACKAI4IgNFDQAgAygCPCIDRQ0AIAIgAxEAACEACyAADb8BQc0AIQMMvAILIAItAClBIkYNzwIMiQELIAQgASIFRgRAQdsAIQMM1AILQQAhAEEBIQFBASEGQQAhAwJAAn8CQAJAAkACQAJAAkACQCAFLQAAQTBrDgrFAcQBAAECAwQFBgjDAQtBAgwGC0EDDAULQQQMBAtBBQwDC0EGDAILQQcMAQtBCAshA0EAIQFBACEGDL0BC0EJIQNBASEAQQAhAUEAIQYMvAELIAEgBEYEQEHdACEDDNMCCyABLQAAQS5HDbgBIAFBAWohAQyIAQsgASAERw22AUHfACEDDNECCyABIARHBEAgAkEONgIIIAIgATYCBEHQACEDDLgCC0HgACEDDNACC0HhACEDIAEgBEYNzwIgAigCACIAIAQgAWtqIQUgASAAa0EDaiEGA0AgAS0AACAAQeLCAGotAABHDbEBIABBA0YNswEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMzwILQeIAIQMgASAERg3OAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYDQCABLQAAIABB5sIAai0AAEcNsAEgAEECRg2vASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAzOAgtB4wAhAyABIARGDc0CIAIoAgAiACAEIAFraiEFIAEgAGtBA2ohBgNAIAEtAAAgAEHpwgBqLQAARw2vASAAQQNGDa0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADM0CCyABIARGBEBB5QAhAwzNAgsgAUEBaiEBQQAhAAJAIAIoAjgiA0UNACADKAIwIgNFDQAgAiADEQAAIQALIAANqgFB1gAhAwyzAgsgASAERwRAA0AgAS0AACIAQSBHBEACQAJAAkAgAEHIAGsOCwABswGzAbMBswGzAbMBswGzAQKzAQsgAUEBaiEBQdIAIQMMtwILIAFBAWohAUHTACEDDLYCCyABQQFqIQFB1AAhAwy1AgsgBCABQQFqIgFHDQALQeQAIQMMzAILQeQAIQMMywILA0AgAS0AAEHwwgBqLQAAIgBBAUcEQCAAQQJrDgOnAaYBpQGkAQsgBCABQQFqIgFHDQALQeYAIQMMygILIAFBAWogASAERw0CGkHnACEDDMkCCwNAIAEtAABB8MQAai0AACIAQQFHBEACQCAAQQJrDgSiAaEBoAEAnwELQdcAIQMMsQILIAQgAUEBaiIBRw0AC0HoACEDDMgCCyABIARGBEBB6QAhAwzIAgsCQCABLQAAIgBBCmsOGrcBmwGbAbQBmwGbAZsBmwGbAZsBmwGbAZsBmwGbAZsBmwGbAZsBmwGbAZsBpAGbAZsBAJkBCyABQQFqCyEBQQYhAwytAgsDQCABLQAAQfDGAGotAABBAUcNfSAEIAFBAWoiAUcNAAtB6gAhAwzFAgsgAUEBaiABIARHDQIaQesAIQMMxAILIAEgBEYEQEHsACEDDMQCCyABQQFqDAELIAEgBEYEQEHtACEDDMMCCyABQQFqCyEBQQQhAwyoAgsgASAERgRAQe4AIQMMwQILAkACQAJAIAEtAABB8MgAai0AAEEBaw4HkAGPAY4BAHwBAo0BCyABQQFqIQEMCwsgAUEBagyTAQtBACEDIAJBADYCHCACQZsSNgIQIAJBBzYCDCACIAFBAWo2AhQMwAILAkADQCABLQAAQfDIAGotAAAiAEEERwRAAkACQCAAQQFrDgeUAZMBkgGNAQAEAY0BC0HaACEDDKoCCyABQQFqIQFB3AAhAwypAgsgBCABQQFqIgFHDQALQe8AIQMMwAILIAFBAWoMkQELIAQgASIARgRAQfAAIQMMvwILIAAtAABBL0cNASAAQQFqIQEMBwsgBCABIgBGBEBB8QAhAwy+AgsgAC0AACIBQS9GBEAgAEEBaiEBQd0AIQMMpQILIAFBCmsiA0EWSw0AIAAhAUEBIAN0QYmAgAJxDfkBC0EAIQMgAkEANgIcIAIgADYCFCACQYwcNgIQIAJBBzYCDAy8AgsgASAERwRAIAFBAWohAUHeACEDDKMCC0HyACEDDLsCCyABIARGBEBB9AAhAwy7AgsCQCABLQAAQfDMAGotAABBAWsOA/cBcwCCAQtB4QAhAwyhAgsgASAERwRAA0AgAS0AAEHwygBqLQAAIgBBA0cEQAJAIABBAWsOAvkBAIUBC0HfACEDDKMCCyAEIAFBAWoiAUcNAAtB8wAhAwy6AgtB8wAhAwy5AgsgASAERwRAIAJBDzYCCCACIAE2AgRB4AAhAwygAgtB9QAhAwy4AgsgASAERgRAQfYAIQMMuAILIAJBDzYCCCACIAE2AgQLQQMhAwydAgsDQCABLQAAQSBHDY4CIAQgAUEBaiIBRw0AC0H3ACEDDLUCCyABIARGBEBB+AAhAwy1AgsgAS0AAEEgRw16IAFBAWohAQxbC0EAIQACQCACKAI4IgNFDQAgAygCOCIDRQ0AIAIgAxEAACEACyAADXgMgAILIAEgBEYEQEH6ACEDDLMCCyABLQAAQcwARw10IAFBAWohAUETDHYLQfsAIQMgASAERg2xAiACKAIAIgAgBCABa2ohBSABIABrQQVqIQYDQCABLQAAIABB8M4Aai0AAEcNcyAAQQVGDXUgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMsQILIAEgBEYEQEH8ACEDDLECCwJAAkAgAS0AAEHDAGsODAB0dHR0dHR0dHR0AXQLIAFBAWohAUHmACEDDJgCCyABQQFqIQFB5wAhAwyXAgtB/QAhAyABIARGDa8CIAIoAgAiACAEIAFraiEFIAEgAGtBAmohBgJAA0AgAS0AACAAQe3PAGotAABHDXIgAEECRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADLACCyACQQA2AgAgBkEBaiEBQRAMcwtB/gAhAyABIARGDa4CIAIoAgAiACAEIAFraiEFIAEgAGtBBWohBgJAA0AgAS0AACAAQfbOAGotAABHDXEgAEEFRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADK8CCyACQQA2AgAgBkEBaiEBQRYMcgtB/wAhAyABIARGDa0CIAIoAgAiACAEIAFraiEFIAEgAGtBA2ohBgJAA0AgAS0AACAAQfzOAGotAABHDXAgAEEDRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADK4CCyACQQA2AgAgBkEBaiEBQQUMcQsgASAERgRAQYABIQMMrQILIAEtAABB2QBHDW4gAUEBaiEBQQgMcAsgASAERgRAQYEBIQMMrAILAkACQCABLQAAQc4Aaw4DAG8BbwsgAUEBaiEBQesAIQMMkwILIAFBAWohAUHsACEDDJICCyABIARGBEBBggEhAwyrAgsCQAJAIAEtAABByABrDggAbm5ubm5uAW4LIAFBAWohAUHqACEDDJICCyABQQFqIQFB7QAhAwyRAgtBgwEhAyABIARGDakCIAIoAgAiACAEIAFraiEFIAEgAGtBAmohBgJAA0AgAS0AACAAQYDPAGotAABHDWwgAEECRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADKoCCyACQQA2AgAgBkEBaiEBQQAMbQtBhAEhAyABIARGDagCIAIoAgAiACAEIAFraiEFIAEgAGtBBGohBgJAA0AgAS0AACAAQYPPAGotAABHDWsgAEEERg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADKkCCyACQQA2AgAgBkEBaiEBQSMMbAsgASAERgRAQYUBIQMMqAILAkACQCABLQAAQcwAaw4IAGtra2trawFrCyABQQFqIQFB7wAhAwyPAgsgAUEBaiEBQfAAIQMMjgILIAEgBEYEQEGGASEDDKcCCyABLQAAQcUARw1oIAFBAWohAQxgC0GHASEDIAEgBEYNpQIgAigCACIAIAQgAWtqIQUgASAAa0EDaiEGAkADQCABLQAAIABBiM8Aai0AAEcNaCAAQQNGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMpgILIAJBADYCACAGQQFqIQFBLQxpC0GIASEDIAEgBEYNpAIgAigCACIAIAQgAWtqIQUgASAAa0EIaiEGAkADQCABLQAAIABB0M8Aai0AAEcNZyAAQQhGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMpQILIAJBADYCACAGQQFqIQFBKQxoCyABIARGBEBBiQEhAwykAgtBASABLQAAQd8ARw1nGiABQQFqIQEMXgtBigEhAyABIARGDaICIAIoAgAiACAEIAFraiEFIAEgAGtBAWohBgNAIAEtAAAgAEGMzwBqLQAARw1kIABBAUYN+gEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMogILQYsBIQMgASAERg2hAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGOzwBqLQAARw1kIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyiAgsgAkEANgIAIAZBAWohAUECDGULQYwBIQMgASAERg2gAiACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHwzwBqLQAARw1jIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyhAgsgAkEANgIAIAZBAWohAUEfDGQLQY0BIQMgASAERg2fAiACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHyzwBqLQAARw1iIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAygAgsgAkEANgIAIAZBAWohAUEJDGMLIAEgBEYEQEGOASEDDJ8CCwJAAkAgAS0AAEHJAGsOBwBiYmJiYgFiCyABQQFqIQFB+AAhAwyGAgsgAUEBaiEBQfkAIQMMhQILQY8BIQMgASAERg2dAiACKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEGRzwBqLQAARw1gIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyeAgsgAkEANgIAIAZBAWohAUEYDGELQZABIQMgASAERg2cAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGXzwBqLQAARw1fIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAydAgsgAkEANgIAIAZBAWohAUEXDGALQZEBIQMgASAERg2bAiACKAIAIgAgBCABa2ohBSABIABrQQZqIQYCQANAIAEtAAAgAEGazwBqLQAARw1eIABBBkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAycAgsgAkEANgIAIAZBAWohAUEVDF8LQZIBIQMgASAERg2aAiACKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEGhzwBqLQAARw1dIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAybAgsgAkEANgIAIAZBAWohAUEeDF4LIAEgBEYEQEGTASEDDJoCCyABLQAAQcwARw1bIAFBAWohAUEKDF0LIAEgBEYEQEGUASEDDJkCCwJAAkAgAS0AAEHBAGsODwBcXFxcXFxcXFxcXFxcAVwLIAFBAWohAUH+ACEDDIACCyABQQFqIQFB/wAhAwz/AQsgASAERgRAQZUBIQMMmAILAkACQCABLQAAQcEAaw4DAFsBWwsgAUEBaiEBQf0AIQMM/wELIAFBAWohAUGAASEDDP4BC0GWASEDIAEgBEYNlgIgAigCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABBp88Aai0AAEcNWSAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMlwILIAJBADYCACAGQQFqIQFBCwxaCyABIARGBEBBlwEhAwyWAgsCQAJAAkACQCABLQAAQS1rDiMAW1tbW1tbW1tbW1tbW1tbW1tbW1tbW1sBW1tbW1sCW1tbA1sLIAFBAWohAUH7ACEDDP8BCyABQQFqIQFB/AAhAwz+AQsgAUEBaiEBQYEBIQMM/QELIAFBAWohAUGCASEDDPwBC0GYASEDIAEgBEYNlAIgAigCACIAIAQgAWtqIQUgASAAa0EEaiEGAkADQCABLQAAIABBqc8Aai0AAEcNVyAAQQRGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMlQILIAJBADYCACAGQQFqIQFBGQxYC0GZASEDIAEgBEYNkwIgAigCACIAIAQgAWtqIQUgASAAa0EFaiEGAkADQCABLQAAIABBrs8Aai0AAEcNViAAQQVGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMlAILIAJBADYCACAGQQFqIQFBBgxXC0GaASEDIAEgBEYNkgIgAigCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABBtM8Aai0AAEcNVSAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMkwILIAJBADYCACAGQQFqIQFBHAxWC0GbASEDIAEgBEYNkQIgAigCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABBts8Aai0AAEcNVCAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMkgILIAJBADYCACAGQQFqIQFBJwxVCyABIARGBEBBnAEhAwyRAgsCQAJAIAEtAABB1ABrDgIAAVQLIAFBAWohAUGGASEDDPgBCyABQQFqIQFBhwEhAwz3AQtBnQEhAyABIARGDY8CIAIoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQbjPAGotAABHDVIgAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADJACCyACQQA2AgAgBkEBaiEBQSYMUwtBngEhAyABIARGDY4CIAIoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQbrPAGotAABHDVEgAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADI8CCyACQQA2AgAgBkEBaiEBQQMMUgtBnwEhAyABIARGDY0CIAIoAgAiACAEIAFraiEFIAEgAGtBAmohBgJAA0AgAS0AACAAQe3PAGotAABHDVAgAEECRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADI4CCyACQQA2AgAgBkEBaiEBQQwMUQtBoAEhAyABIARGDYwCIAIoAgAiACAEIAFraiEFIAEgAGtBA2ohBgJAA0AgAS0AACAAQbzPAGotAABHDU8gAEEDRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADI0CCyACQQA2AgAgBkEBaiEBQQ0MUAsgASAERgRAQaEBIQMMjAILAkACQCABLQAAQcYAaw4LAE9PT09PT09PTwFPCyABQQFqIQFBiwEhAwzzAQsgAUEBaiEBQYwBIQMM8gELIAEgBEYEQEGiASEDDIsCCyABLQAAQdAARw1MIAFBAWohAQxGCyABIARGBEBBowEhAwyKAgsCQAJAIAEtAABByQBrDgcBTU1NTU0ATQsgAUEBaiEBQY4BIQMM8QELIAFBAWohAUEiDE0LQaQBIQMgASAERg2IAiACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHAzwBqLQAARw1LIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyJAgsgAkEANgIAIAZBAWohAUEdDEwLIAEgBEYEQEGlASEDDIgCCwJAAkAgAS0AAEHSAGsOAwBLAUsLIAFBAWohAUGQASEDDO8BCyABQQFqIQFBBAxLCyABIARGBEBBpgEhAwyHAgsCQAJAAkACQAJAIAEtAABBwQBrDhUATU1NTU1NTU1NTQFNTQJNTQNNTQRNCyABQQFqIQFBiAEhAwzxAQsgAUEBaiEBQYkBIQMM8AELIAFBAWohAUGKASEDDO8BCyABQQFqIQFBjwEhAwzuAQsgAUEBaiEBQZEBIQMM7QELQacBIQMgASAERg2FAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHtzwBqLQAARw1IIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyGAgsgAkEANgIAIAZBAWohAUERDEkLQagBIQMgASAERg2EAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHCzwBqLQAARw1HIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyFAgsgAkEANgIAIAZBAWohAUEsDEgLQakBIQMgASAERg2DAiACKAIAIgAgBCABa2ohBSABIABrQQRqIQYCQANAIAEtAAAgAEHFzwBqLQAARw1GIABBBEYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyEAgsgAkEANgIAIAZBAWohAUErDEcLQaoBIQMgASAERg2CAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHKzwBqLQAARw1FIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyDAgsgAkEANgIAIAZBAWohAUEUDEYLIAEgBEYEQEGrASEDDIICCwJAAkACQAJAIAEtAABBwgBrDg8AAQJHR0dHR0dHR0dHRwNHCyABQQFqIQFBkwEhAwzrAQsgAUEBaiEBQZQBIQMM6gELIAFBAWohAUGVASEDDOkBCyABQQFqIQFBlgEhAwzoAQsgASAERgRAQawBIQMMgQILIAEtAABBxQBHDUIgAUEBaiEBDD0LQa0BIQMgASAERg3/ASACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHNzwBqLQAARw1CIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyAAgsgAkEANgIAIAZBAWohAUEODEMLIAEgBEYEQEGuASEDDP8BCyABLQAAQdAARw1AIAFBAWohAUElDEILQa8BIQMgASAERg39ASACKAIAIgAgBCABa2ohBSABIABrQQhqIQYCQANAIAEtAAAgAEHQzwBqLQAARw1AIABBCEYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAz+AQsgAkEANgIAIAZBAWohAUEqDEELIAEgBEYEQEGwASEDDP0BCwJAAkAgAS0AAEHVAGsOCwBAQEBAQEBAQEABQAsgAUEBaiEBQZoBIQMM5AELIAFBAWohAUGbASEDDOMBCyABIARGBEBBsQEhAwz8AQsCQAJAIAEtAABBwQBrDhQAPz8/Pz8/Pz8/Pz8/Pz8/Pz8/AT8LIAFBAWohAUGZASEDDOMBCyABQQFqIQFBnAEhAwziAQtBsgEhAyABIARGDfoBIAIoAgAiACAEIAFraiEFIAEgAGtBA2ohBgJAA0AgAS0AACAAQdnPAGotAABHDT0gAEEDRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADPsBCyACQQA2AgAgBkEBaiEBQSEMPgtBswEhAyABIARGDfkBIAIoAgAiACAEIAFraiEFIAEgAGtBBmohBgJAA0AgAS0AACAAQd3PAGotAABHDTwgAEEGRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADPoBCyACQQA2AgAgBkEBaiEBQRoMPQsgASAERgRAQbQBIQMM+QELAkACQAJAIAEtAABBxQBrDhEAPT09PT09PT09AT09PT09Aj0LIAFBAWohAUGdASEDDOEBCyABQQFqIQFBngEhAwzgAQsgAUEBaiEBQZ8BIQMM3wELQbUBIQMgASAERg33ASACKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEHkzwBqLQAARw06IABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAz4AQsgAkEANgIAIAZBAWohAUEoDDsLQbYBIQMgASAERg32ASACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHqzwBqLQAARw05IABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAz3AQsgAkEANgIAIAZBAWohAUEHDDoLIAEgBEYEQEG3ASEDDPYBCwJAAkAgAS0AAEHFAGsODgA5OTk5OTk5OTk5OTkBOQsgAUEBaiEBQaEBIQMM3QELIAFBAWohAUGiASEDDNwBC0G4ASEDIAEgBEYN9AEgAigCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABB7c8Aai0AAEcNNyAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAM9QELIAJBADYCACAGQQFqIQFBEgw4C0G5ASEDIAEgBEYN8wEgAigCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABB8M8Aai0AAEcNNiAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAM9AELIAJBADYCACAGQQFqIQFBIAw3C0G6ASEDIAEgBEYN8gEgAigCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABB8s8Aai0AAEcNNSAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAM8wELIAJBADYCACAGQQFqIQFBDww2CyABIARGBEBBuwEhAwzyAQsCQAJAIAEtAABByQBrDgcANTU1NTUBNQsgAUEBaiEBQaUBIQMM2QELIAFBAWohAUGmASEDDNgBC0G8ASEDIAEgBEYN8AEgAigCACIAIAQgAWtqIQUgASAAa0EHaiEGAkADQCABLQAAIABB9M8Aai0AAEcNMyAAQQdGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAM8QELIAJBADYCACAGQQFqIQFBGww0CyABIARGBEBBvQEhAwzwAQsCQAJAAkAgAS0AAEHCAGsOEgA0NDQ0NDQ0NDQBNDQ0NDQ0AjQLIAFBAWohAUGkASEDDNgBCyABQQFqIQFBpwEhAwzXAQsgAUEBaiEBQagBIQMM1gELIAEgBEYEQEG+ASEDDO8BCyABLQAAQc4ARw0wIAFBAWohAQwsCyABIARGBEBBvwEhAwzuAQsCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCABLQAAQcEAaw4VAAECAz8EBQY/Pz8HCAkKCz8MDQ4PPwsgAUEBaiEBQegAIQMM4wELIAFBAWohAUHpACEDDOIBCyABQQFqIQFB7gAhAwzhAQsgAUEBaiEBQfIAIQMM4AELIAFBAWohAUHzACEDDN8BCyABQQFqIQFB9gAhAwzeAQsgAUEBaiEBQfcAIQMM3QELIAFBAWohAUH6ACEDDNwBCyABQQFqIQFBgwEhAwzbAQsgAUEBaiEBQYQBIQMM2gELIAFBAWohAUGFASEDDNkBCyABQQFqIQFBkgEhAwzYAQsgAUEBaiEBQZgBIQMM1wELIAFBAWohAUGgASEDDNYBCyABQQFqIQFBowEhAwzVAQsgAUEBaiEBQaoBIQMM1AELIAEgBEcEQCACQRA2AgggAiABNgIEQasBIQMM1AELQcABIQMM7AELQQAhAAJAIAIoAjgiA0UNACADKAI0IgNFDQAgAiADEQAAIQALIABFDV4gAEEVRw0HIAJB0QA2AhwgAiABNgIUIAJBsBc2AhAgAkEVNgIMQQAhAwzrAQsgAUEBaiABIARHDQgaQcIBIQMM6gELA0ACQCABLQAAQQprDgQIAAALAAsgBCABQQFqIgFHDQALQcMBIQMM6QELIAEgBEcEQCACQRE2AgggAiABNgIEQQEhAwzQAQtBxAEhAwzoAQsgASAERgRAQcUBIQMM6AELAkACQCABLQAAQQprDgQBKCgAKAsgAUEBagwJCyABQQFqDAULIAEgBEYEQEHGASEDDOcBCwJAAkAgAS0AAEEKaw4XAQsLAQsLCwsLCwsLCwsLCwsLCwsLCwALCyABQQFqIQELQbABIQMMzQELIAEgBEYEQEHIASEDDOYBCyABLQAAQSBHDQkgAkEAOwEyIAFBAWohAUGzASEDDMwBCwNAIAEhAAJAIAEgBEcEQCABLQAAQTBrQf8BcSIDQQpJDQEMJwtBxwEhAwzmAQsCQCACLwEyIgFBmTNLDQAgAiABQQpsIgU7ATIgBUH+/wNxIANB//8Dc0sNACAAQQFqIQEgAiADIAVqIgM7ATIgA0H//wNxQegHSQ0BCwtBACEDIAJBADYCHCACQcEJNgIQIAJBDTYCDCACIABBAWo2AhQM5AELIAJBADYCHCACIAE2AhQgAkHwDDYCECACQRs2AgxBACEDDOMBCyACKAIEIQAgAkEANgIEIAIgACABECYiAA0BIAFBAWoLIQFBrQEhAwzIAQsgAkHBATYCHCACIAA2AgwgAiABQQFqNgIUQQAhAwzgAQsgAigCBCEAIAJBADYCBCACIAAgARAmIgANASABQQFqCyEBQa4BIQMMxQELIAJBwgE2AhwgAiAANgIMIAIgAUEBajYCFEEAIQMM3QELIAJBADYCHCACIAE2AhQgAkGXCzYCECACQQ02AgxBACEDDNwBCyACQQA2AhwgAiABNgIUIAJB4xA2AhAgAkEJNgIMQQAhAwzbAQsgAkECOgAoDKwBC0EAIQMgAkEANgIcIAJBrws2AhAgAkECNgIMIAIgAUEBajYCFAzZAQtBAiEDDL8BC0ENIQMMvgELQSYhAwy9AQtBFSEDDLwBC0EWIQMMuwELQRghAwy6AQtBHCEDDLkBC0EdIQMMuAELQSAhAwy3AQtBISEDDLYBC0EjIQMMtQELQcYAIQMMtAELQS4hAwyzAQtBPSEDDLIBC0HLACEDDLEBC0HOACEDDLABC0HYACEDDK8BC0HZACEDDK4BC0HbACEDDK0BC0HxACEDDKwBC0H0ACEDDKsBC0GNASEDDKoBC0GXASEDDKkBC0GpASEDDKgBC0GvASEDDKcBC0GxASEDDKYBCyACQQA2AgALQQAhAyACQQA2AhwgAiABNgIUIAJB8Rs2AhAgAkEGNgIMDL0BCyACQQA2AgAgBkEBaiEBQSQLOgApIAIoAgQhACACQQA2AgQgAiAAIAEQJyIARQRAQeUAIQMMowELIAJB+QA2AhwgAiABNgIUIAIgADYCDEEAIQMMuwELIABBFUcEQCACQQA2AhwgAiABNgIUIAJBzA42AhAgAkEgNgIMQQAhAwy7AQsgAkH4ADYCHCACIAE2AhQgAkHKGDYCECACQRU2AgxBACEDDLoBCyACQQA2AhwgAiABNgIUIAJBjhs2AhAgAkEGNgIMQQAhAwy5AQsgAkEANgIcIAIgATYCFCACQf4RNgIQIAJBBzYCDEEAIQMMuAELIAJBADYCHCACIAE2AhQgAkGMHDYCECACQQc2AgxBACEDDLcBCyACQQA2AhwgAiABNgIUIAJBww82AhAgAkEHNgIMQQAhAwy2AQsgAkEANgIcIAIgATYCFCACQcMPNgIQIAJBBzYCDEEAIQMMtQELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0RIAJB5QA2AhwgAiABNgIUIAIgADYCDEEAIQMMtAELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0gIAJB0wA2AhwgAiABNgIUIAIgADYCDEEAIQMMswELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0iIAJB0gA2AhwgAiABNgIUIAIgADYCDEEAIQMMsgELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0OIAJB5QA2AhwgAiABNgIUIAIgADYCDEEAIQMMsQELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0dIAJB0wA2AhwgAiABNgIUIAIgADYCDEEAIQMMsAELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0fIAJB0gA2AhwgAiABNgIUIAIgADYCDEEAIQMMrwELIABBP0cNASABQQFqCyEBQQUhAwyUAQtBACEDIAJBADYCHCACIAE2AhQgAkH9EjYCECACQQc2AgwMrAELIAJBADYCHCACIAE2AhQgAkHcCDYCECACQQc2AgxBACEDDKsBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNByACQeUANgIcIAIgATYCFCACIAA2AgxBACEDDKoBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNFiACQdMANgIcIAIgATYCFCACIAA2AgxBACEDDKkBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNGCACQdIANgIcIAIgATYCFCACIAA2AgxBACEDDKgBCyACQQA2AhwgAiABNgIUIAJBxgo2AhAgAkEHNgIMQQAhAwynAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDQMgAkHlADYCHCACIAE2AhQgAiAANgIMQQAhAwymAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDRIgAkHTADYCHCACIAE2AhQgAiAANgIMQQAhAwylAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDRQgAkHSADYCHCACIAE2AhQgAiAANgIMQQAhAwykAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDQAgAkHlADYCHCACIAE2AhQgAiAANgIMQQAhAwyjAQtB1QAhAwyJAQsgAEEVRwRAIAJBADYCHCACIAE2AhQgAkG5DTYCECACQRo2AgxBACEDDKIBCyACQeQANgIcIAIgATYCFCACQeMXNgIQIAJBFTYCDEEAIQMMoQELIAJBADYCACAGQQFqIQEgAi0AKSIAQSNrQQtJDQQCQCAAQQZLDQBBASAAdEHKAHFFDQAMBQtBACEDIAJBADYCHCACIAE2AhQgAkH3CTYCECACQQg2AgwMoAELIAJBADYCACAGQQFqIQEgAi0AKUEhRg0DIAJBADYCHCACIAE2AhQgAkGbCjYCECACQQg2AgxBACEDDJ8BCyACQQA2AgALQQAhAyACQQA2AhwgAiABNgIUIAJBkDM2AhAgAkEINgIMDJ0BCyACQQA2AgAgBkEBaiEBIAItAClBI0kNACACQQA2AhwgAiABNgIUIAJB0wk2AhAgAkEINgIMQQAhAwycAQtB0QAhAwyCAQsgAS0AAEEwayIAQf8BcUEKSQRAIAIgADoAKiABQQFqIQFBzwAhAwyCAQsgAigCBCEAIAJBADYCBCACIAAgARAoIgBFDYYBIAJB3gA2AhwgAiABNgIUIAIgADYCDEEAIQMMmgELIAIoAgQhACACQQA2AgQgAiAAIAEQKCIARQ2GASACQdwANgIcIAIgATYCFCACIAA2AgxBACEDDJkBCyACKAIEIQAgAkEANgIEIAIgACAFECgiAEUEQCAFIQEMhwELIAJB2gA2AhwgAiAFNgIUIAIgADYCDAyYAQtBACEBQQEhAwsgAiADOgArIAVBAWohAwJAAkACQCACLQAtQRBxDQACQAJAAkAgAi0AKg4DAQACBAsgBkUNAwwCCyAADQEMAgsgAUUNAQsgAigCBCEAIAJBADYCBCACIAAgAxAoIgBFBEAgAyEBDAILIAJB2AA2AhwgAiADNgIUIAIgADYCDEEAIQMMmAELIAIoAgQhACACQQA2AgQgAiAAIAMQKCIARQRAIAMhAQyHAQsgAkHZADYCHCACIAM2AhQgAiAANgIMQQAhAwyXAQtBzAAhAwx9CyAAQRVHBEAgAkEANgIcIAIgATYCFCACQZQNNgIQIAJBITYCDEEAIQMMlgELIAJB1wA2AhwgAiABNgIUIAJByRc2AhAgAkEVNgIMQQAhAwyVAQtBACEDIAJBADYCHCACIAE2AhQgAkGAETYCECACQQk2AgwMlAELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0AIAJB0wA2AhwgAiABNgIUIAIgADYCDEEAIQMMkwELQckAIQMMeQsgAkEANgIcIAIgATYCFCACQcEoNgIQIAJBBzYCDCACQQA2AgBBACEDDJEBCyACKAIEIQBBACEDIAJBADYCBCACIAAgARAlIgBFDQAgAkHSADYCHCACIAE2AhQgAiAANgIMDJABC0HIACEDDHYLIAJBADYCACAFIQELIAJBgBI7ASogAUEBaiEBQQAhAAJAIAIoAjgiA0UNACADKAIwIgNFDQAgAiADEQAAIQALIAANAQtBxwAhAwxzCyAAQRVGBEAgAkHRADYCHCACIAE2AhQgAkHjFzYCECACQRU2AgxBACEDDIwBC0EAIQMgAkEANgIcIAIgATYCFCACQbkNNgIQIAJBGjYCDAyLAQtBACEDIAJBADYCHCACIAE2AhQgAkGgGTYCECACQR42AgwMigELIAEtAABBOkYEQCACKAIEIQBBACEDIAJBADYCBCACIAAgARApIgBFDQEgAkHDADYCHCACIAA2AgwgAiABQQFqNgIUDIoBC0EAIQMgAkEANgIcIAIgATYCFCACQbERNgIQIAJBCjYCDAyJAQsgAUEBaiEBQTshAwxvCyACQcMANgIcIAIgADYCDCACIAFBAWo2AhQMhwELQQAhAyACQQA2AhwgAiABNgIUIAJB8A42AhAgAkEcNgIMDIYBCyACIAIvATBBEHI7ATAMZgsCQCACLwEwIgBBCHFFDQAgAi0AKEEBRw0AIAItAC1BCHFFDQMLIAIgAEH3+wNxQYAEcjsBMAwECyABIARHBEACQANAIAEtAABBMGsiAEH/AXFBCk8EQEE1IQMMbgsgAikDICIKQpmz5syZs+bMGVYNASACIApCCn4iCjcDICAKIACtQv8BgyILQn+FVg0BIAIgCiALfDcDICAEIAFBAWoiAUcNAAtBOSEDDIUBCyACKAIEIQBBACEDIAJBADYCBCACIAAgAUEBaiIBECoiAA0MDHcLQTkhAwyDAQsgAi0AMEEgcQ0GQcUBIQMMaQtBACEDIAJBADYCBCACIAEgARAqIgBFDQQgAkE6NgIcIAIgADYCDCACIAFBAWo2AhQMgQELIAItAChBAUcNACACLQAtQQhxRQ0BC0E3IQMMZgsgAigCBCEAQQAhAyACQQA2AgQgAiAAIAEQKiIABEAgAkE7NgIcIAIgADYCDCACIAFBAWo2AhQMfwsgAUEBaiEBDG4LIAJBCDoALAwECyABQQFqIQEMbQtBACEDIAJBADYCHCACIAE2AhQgAkHkEjYCECACQQQ2AgwMewsgAigCBCEAQQAhAyACQQA2AgQgAiAAIAEQKiIARQ1sIAJBNzYCHCACIAE2AhQgAiAANgIMDHoLIAIgAi8BMEEgcjsBMAtBMCEDDF8LIAJBNjYCHCACIAE2AhQgAiAANgIMDHcLIABBLEcNASABQQFqIQBBASEBAkACQAJAAkACQCACLQAsQQVrDgQDAQIEAAsgACEBDAQLQQIhAQwBC0EEIQELIAJBAToALCACIAIvATAgAXI7ATAgACEBDAELIAIgAi8BMEEIcjsBMCAAIQELQTkhAwxcCyACQQA6ACwLQTQhAwxaCyABIARGBEBBLSEDDHMLAkACQANAAkAgAS0AAEEKaw4EAgAAAwALIAQgAUEBaiIBRw0AC0EtIQMMdAsgAigCBCEAQQAhAyACQQA2AgQgAiAAIAEQKiIARQ0CIAJBLDYCHCACIAE2AhQgAiAANgIMDHMLIAIoAgQhAEEAIQMgAkEANgIEIAIgACABECoiAEUEQCABQQFqIQEMAgsgAkEsNgIcIAIgADYCDCACIAFBAWo2AhQMcgsgAS0AAEENRgRAIAIoAgQhAEEAIQMgAkEANgIEIAIgACABECoiAEUEQCABQQFqIQEMAgsgAkEsNgIcIAIgADYCDCACIAFBAWo2AhQMcgsgAi0ALUEBcQRAQcQBIQMMWQsgAigCBCEAQQAhAyACQQA2AgQgAiAAIAEQKiIADQEMZQtBLyEDDFcLIAJBLjYCHCACIAE2AhQgAiAANgIMDG8LQQAhAyACQQA2AhwgAiABNgIUIAJB8BQ2AhAgAkEDNgIMDG4LQQEhAwJAAkACQAJAIAItACxBBWsOBAMBAgAECyACIAIvATBBCHI7ATAMAwtBAiEDDAELQQQhAwsgAkEBOgAsIAIgAi8BMCADcjsBMAtBKiEDDFMLQQAhAyACQQA2AhwgAiABNgIUIAJB4Q82AhAgAkEKNgIMDGsLQQEhAwJAAkACQAJAAkACQCACLQAsQQJrDgcFBAQDAQIABAsgAiACLwEwQQhyOwEwDAMLQQIhAwwBC0EEIQMLIAJBAToALCACIAIvATAgA3I7ATALQSshAwxSC0EAIQMgAkEANgIcIAIgATYCFCACQasSNgIQIAJBCzYCDAxqC0EAIQMgAkEANgIcIAIgATYCFCACQf0NNgIQIAJBHTYCDAxpCyABIARHBEADQCABLQAAQSBHDUggBCABQQFqIgFHDQALQSUhAwxpC0ElIQMMaAsgAi0ALUEBcQRAQcMBIQMMTwsgAigCBCEAQQAhAyACQQA2AgQgAiAAIAEQKSIABEAgAkEmNgIcIAIgADYCDCACIAFBAWo2AhQMaAsgAUEBaiEBDFwLIAFBAWohASACLwEwIgBBgAFxBEBBACEAAkAgAigCOCIDRQ0AIAMoAlQiA0UNACACIAMRAAAhAAsgAEUNBiAAQRVHDR8gAkEFNgIcIAIgATYCFCACQfkXNgIQIAJBFTYCDEEAIQMMZwsCQCAAQaAEcUGgBEcNACACLQAtQQJxDQBBACEDIAJBADYCHCACIAE2AhQgAkGWEzYCECACQQQ2AgwMZwsgAgJ/IAIvATBBFHFBFEYEQEEBIAItAChBAUYNARogAi8BMkHlAEYMAQsgAi0AKUEFRgs6AC5BACEAAkAgAigCOCIDRQ0AIAMoAiQiA0UNACACIAMRAAAhAAsCQAJAAkACQAJAIAAOFgIBAAQEBAQEBAQEBAQEBAQEBAQEBAMECyACQQE6AC4LIAIgAi8BMEHAAHI7ATALQSchAwxPCyACQSM2AhwgAiABNgIUIAJBpRY2AhAgAkEVNgIMQQAhAwxnC0EAIQMgAkEANgIcIAIgATYCFCACQdULNgIQIAJBETYCDAxmC0EAIQACQCACKAI4IgNFDQAgAygCLCIDRQ0AIAIgAxEAACEACyAADQELQQ4hAwxLCyAAQRVGBEAgAkECNgIcIAIgATYCFCACQbAYNgIQIAJBFTYCDEEAIQMMZAtBACEDIAJBADYCHCACIAE2AhQgAkGnDjYCECACQRI2AgwMYwtBACEDIAJBADYCHCACIAE2AhQgAkGqHDYCECACQQ82AgwMYgsgAigCBCEAQQAhAyACQQA2AgQgAiAAIAEgCqdqIgEQKyIARQ0AIAJBBTYCHCACIAE2AhQgAiAANgIMDGELQQ8hAwxHC0EAIQMgAkEANgIcIAIgATYCFCACQc0TNgIQIAJBDDYCDAxfC0IBIQoLIAFBAWohAQJAIAIpAyAiC0L//////////w9YBEAgAiALQgSGIAqENwMgDAELQQAhAyACQQA2AhwgAiABNgIUIAJBrQk2AhAgAkEMNgIMDF4LQSQhAwxEC0EAIQMgAkEANgIcIAIgATYCFCACQc0TNgIQIAJBDDYCDAxcCyACKAIEIQBBACEDIAJBADYCBCACIAAgARAsIgBFBEAgAUEBaiEBDFILIAJBFzYCHCACIAA2AgwgAiABQQFqNgIUDFsLIAIoAgQhAEEAIQMgAkEANgIEAkAgAiAAIAEQLCIARQRAIAFBAWohAQwBCyACQRY2AhwgAiAANgIMIAIgAUEBajYCFAxbC0EfIQMMQQtBACEDIAJBADYCHCACIAE2AhQgAkGaDzYCECACQSI2AgwMWQsgAigCBCEAQQAhAyACQQA2AgQgAiAAIAEQLSIARQRAIAFBAWohAQxQCyACQRQ2AhwgAiAANgIMIAIgAUEBajYCFAxYCyACKAIEIQBBACEDIAJBADYCBAJAIAIgACABEC0iAEUEQCABQQFqIQEMAQsgAkETNgIcIAIgADYCDCACIAFBAWo2AhQMWAtBHiEDDD4LQQAhAyACQQA2AhwgAiABNgIUIAJBxgw2AhAgAkEjNgIMDFYLIAIoAgQhAEEAIQMgAkEANgIEIAIgACABEC0iAEUEQCABQQFqIQEMTgsgAkERNgIcIAIgADYCDCACIAFBAWo2AhQMVQsgAkEQNgIcIAIgATYCFCACIAA2AgwMVAtBACEDIAJBADYCHCACIAE2AhQgAkHGDDYCECACQSM2AgwMUwtBACEDIAJBADYCHCACIAE2AhQgAkHAFTYCECACQQI2AgwMUgsgAigCBCEAQQAhAyACQQA2AgQCQCACIAAgARAtIgBFBEAgAUEBaiEBDAELIAJBDjYCHCACIAA2AgwgAiABQQFqNgIUDFILQRshAww4C0EAIQMgAkEANgIcIAIgATYCFCACQcYMNgIQIAJBIzYCDAxQCyACKAIEIQBBACEDIAJBADYCBAJAIAIgACABECwiAEUEQCABQQFqIQEMAQsgAkENNgIcIAIgADYCDCACIAFBAWo2AhQMUAtBGiEDDDYLQQAhAyACQQA2AhwgAiABNgIUIAJBmg82AhAgAkEiNgIMDE4LIAIoAgQhAEEAIQMgAkEANgIEAkAgAiAAIAEQLCIARQRAIAFBAWohAQwBCyACQQw2AhwgAiAANgIMIAIgAUEBajYCFAxOC0EZIQMMNAtBACEDIAJBADYCHCACIAE2AhQgAkGaDzYCECACQSI2AgwMTAsgAEEVRwRAQQAhAyACQQA2AhwgAiABNgIUIAJBgww2AhAgAkETNgIMDEwLIAJBCjYCHCACIAE2AhQgAkHkFjYCECACQRU2AgxBACEDDEsLIAIoAgQhAEEAIQMgAkEANgIEIAIgACABIAqnaiIBECsiAARAIAJBBzYCHCACIAE2AhQgAiAANgIMDEsLQRMhAwwxCyAAQRVHBEBBACEDIAJBADYCHCACIAE2AhQgAkHaDTYCECACQRQ2AgwMSgsgAkEeNgIcIAIgATYCFCACQfkXNgIQIAJBFTYCDEEAIQMMSQtBACEAAkAgAigCOCIDRQ0AIAMoAiwiA0UNACACIAMRAAAhAAsgAEUNQSAAQRVGBEAgAkEDNgIcIAIgATYCFCACQbAYNgIQIAJBFTYCDEEAIQMMSQtBACEDIAJBADYCHCACIAE2AhQgAkGnDjYCECACQRI2AgwMSAtBACEDIAJBADYCHCACIAE2AhQgAkHaDTYCECACQRQ2AgwMRwtBACEDIAJBADYCHCACIAE2AhQgAkGnDjYCECACQRI2AgwMRgsgAkEAOgAvIAItAC1BBHFFDT8LIAJBADoALyACQQE6ADRBACEDDCsLQQAhAyACQQA2AhwgAkHkETYCECACQQc2AgwgAiABQQFqNgIUDEMLAkADQAJAIAEtAABBCmsOBAACAgACCyAEIAFBAWoiAUcNAAtB3QEhAwxDCwJAAkAgAi0ANEEBRw0AQQAhAAJAIAIoAjgiA0UNACADKAJYIgNFDQAgAiADEQAAIQALIABFDQAgAEEVRw0BIAJB3AE2AhwgAiABNgIUIAJB1RY2AhAgAkEVNgIMQQAhAwxEC0HBASEDDCoLIAJBADYCHCACIAE2AhQgAkHpCzYCECACQR82AgxBACEDDEILAkACQCACLQAoQQFrDgIEAQALQcABIQMMKQtBuQEhAwwoCyACQQI6AC9BACEAAkAgAigCOCIDRQ0AIAMoAgAiA0UNACACIAMRAAAhAAsgAEUEQEHCASEDDCgLIABBFUcEQCACQQA2AhwgAiABNgIUIAJBpAw2AhAgAkEQNgIMQQAhAwxBCyACQdsBNgIcIAIgATYCFCACQfoWNgIQIAJBFTYCDEEAIQMMQAsgASAERgRAQdoBIQMMQAsgAS0AAEHIAEYNASACQQE6ACgLQawBIQMMJQtBvwEhAwwkCyABIARHBEAgAkEQNgIIIAIgATYCBEG+ASEDDCQLQdkBIQMMPAsgASAERgRAQdgBIQMMPAsgAS0AAEHIAEcNBCABQQFqIQFBvQEhAwwiCyABIARGBEBB1wEhAww7CwJAAkAgAS0AAEHFAGsOEAAFBQUFBQUFBQUFBQUFBQEFCyABQQFqIQFBuwEhAwwiCyABQQFqIQFBvAEhAwwhC0HWASEDIAEgBEYNOSACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGD0ABqLQAARw0DIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAw6CyACKAIEIQAgAkIANwMAIAIgACAGQQFqIgEQJyIARQRAQcYBIQMMIQsgAkHVATYCHCACIAE2AhQgAiAANgIMQQAhAww5C0HUASEDIAEgBEYNOCACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEGB0ABqLQAARw0CIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAw5CyACQYEEOwEoIAIoAgQhACACQgA3AwAgAiAAIAZBAWoiARAnIgANAwwCCyACQQA2AgALQQAhAyACQQA2AhwgAiABNgIUIAJB2Bs2AhAgAkEINgIMDDYLQboBIQMMHAsgAkHTATYCHCACIAE2AhQgAiAANgIMQQAhAww0C0EAIQACQCACKAI4IgNFDQAgAygCOCIDRQ0AIAIgAxEAACEACyAARQ0AIABBFUYNASACQQA2AhwgAiABNgIUIAJBzA42AhAgAkEgNgIMQQAhAwwzC0HkACEDDBkLIAJB+AA2AhwgAiABNgIUIAJByhg2AhAgAkEVNgIMQQAhAwwxC0HSASEDIAQgASIARg0wIAQgAWsgAigCACIBaiEFIAAgAWtBBGohBgJAA0AgAC0AACABQfzPAGotAABHDQEgAUEERg0DIAFBAWohASAEIABBAWoiAEcNAAsgAiAFNgIADDELIAJBADYCHCACIAA2AhQgAkGQMzYCECACQQg2AgwgAkEANgIAQQAhAwwwCyABIARHBEAgAkEONgIIIAIgATYCBEG3ASEDDBcLQdEBIQMMLwsgAkEANgIAIAZBAWohAQtBuAEhAwwUCyABIARGBEBB0AEhAwwtCyABLQAAQTBrIgBB/wFxQQpJBEAgAiAAOgAqIAFBAWohAUG2ASEDDBQLIAIoAgQhACACQQA2AgQgAiAAIAEQKCIARQ0UIAJBzwE2AhwgAiABNgIUIAIgADYCDEEAIQMMLAsgASAERgRAQc4BIQMMLAsCQCABLQAAQS5GBEAgAUEBaiEBDAELIAIoAgQhACACQQA2AgQgAiAAIAEQKCIARQ0VIAJBzQE2AhwgAiABNgIUIAIgADYCDEEAIQMMLAtBtQEhAwwSCyAEIAEiBUYEQEHMASEDDCsLQQAhAEEBIQFBASEGQQAhAwJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAIAUtAABBMGsOCgoJAAECAwQFBggLC0ECDAYLQQMMBQtBBAwEC0EFDAMLQQYMAgtBBwwBC0EICyEDQQAhAUEAIQYMAgtBCSEDQQEhAEEAIQFBACEGDAELQQAhAUEBIQMLIAIgAzoAKyAFQQFqIQMCQAJAIAItAC1BEHENAAJAAkACQCACLQAqDgMBAAIECyAGRQ0DDAILIAANAQwCCyABRQ0BCyACKAIEIQAgAkEANgIEIAIgACADECgiAEUEQCADIQEMAwsgAkHJATYCHCACIAM2AhQgAiAANgIMQQAhAwwtCyACKAIEIQAgAkEANgIEIAIgACADECgiAEUEQCADIQEMGAsgAkHKATYCHCACIAM2AhQgAiAANgIMQQAhAwwsCyACKAIEIQAgAkEANgIEIAIgACAFECgiAEUEQCAFIQEMFgsgAkHLATYCHCACIAU2AhQgAiAANgIMDCsLQbQBIQMMEQtBACEAAkAgAigCOCIDRQ0AIAMoAjwiA0UNACACIAMRAAAhAAsCQCAABEAgAEEVRg0BIAJBADYCHCACIAE2AhQgAkGUDTYCECACQSE2AgxBACEDDCsLQbIBIQMMEQsgAkHIATYCHCACIAE2AhQgAkHJFzYCECACQRU2AgxBACEDDCkLIAJBADYCACAGQQFqIQFB9QAhAwwPCyACLQApQQVGBEBB4wAhAwwPC0HiACEDDA4LIAAhASACQQA2AgALIAJBADoALEEJIQMMDAsgAkEANgIAIAdBAWohAUHAACEDDAsLQQELOgAsIAJBADYCACAGQQFqIQELQSkhAwwIC0E4IQMMBwsCQCABIARHBEADQCABLQAAQYA+ai0AACIAQQFHBEAgAEECRw0DIAFBAWohAQwFCyAEIAFBAWoiAUcNAAtBPiEDDCELQT4hAwwgCwsgAkEAOgAsDAELQQshAwwEC0E6IQMMAwsgAUEBaiEBQS0hAwwCCyACIAE6ACwgAkEANgIAIAZBAWohAUEMIQMMAQsgAkEANgIAIAZBAWohAUEKIQMMAAsAC0EAIQMgAkEANgIcIAIgATYCFCACQc0QNgIQIAJBCTYCDAwXC0EAIQMgAkEANgIcIAIgATYCFCACQekKNgIQIAJBCTYCDAwWC0EAIQMgAkEANgIcIAIgATYCFCACQbcQNgIQIAJBCTYCDAwVC0EAIQMgAkEANgIcIAIgATYCFCACQZwRNgIQIAJBCTYCDAwUC0EAIQMgAkEANgIcIAIgATYCFCACQc0QNgIQIAJBCTYCDAwTC0EAIQMgAkEANgIcIAIgATYCFCACQekKNgIQIAJBCTYCDAwSC0EAIQMgAkEANgIcIAIgATYCFCACQbcQNgIQIAJBCTYCDAwRC0EAIQMgAkEANgIcIAIgATYCFCACQZwRNgIQIAJBCTYCDAwQC0EAIQMgAkEANgIcIAIgATYCFCACQZcVNgIQIAJBDzYCDAwPC0EAIQMgAkEANgIcIAIgATYCFCACQZcVNgIQIAJBDzYCDAwOC0EAIQMgAkEANgIcIAIgATYCFCACQcASNgIQIAJBCzYCDAwNC0EAIQMgAkEANgIcIAIgATYCFCACQZUJNgIQIAJBCzYCDAwMC0EAIQMgAkEANgIcIAIgATYCFCACQeEPNgIQIAJBCjYCDAwLC0EAIQMgAkEANgIcIAIgATYCFCACQfsPNgIQIAJBCjYCDAwKC0EAIQMgAkEANgIcIAIgATYCFCACQfEZNgIQIAJBAjYCDAwJC0EAIQMgAkEANgIcIAIgATYCFCACQcQUNgIQIAJBAjYCDAwIC0EAIQMgAkEANgIcIAIgATYCFCACQfIVNgIQIAJBAjYCDAwHCyACQQI2AhwgAiABNgIUIAJBnBo2AhAgAkEWNgIMQQAhAwwGC0EBIQMMBQtB1AAhAyABIARGDQQgCEEIaiEJIAIoAgAhBQJAAkAgASAERwRAIAVB2MIAaiEHIAQgBWogAWshACAFQX9zQQpqIgUgAWohBgNAIAEtAAAgBy0AAEcEQEECIQcMAwsgBUUEQEEAIQcgBiEBDAMLIAVBAWshBSAHQQFqIQcgBCABQQFqIgFHDQALIAAhBSAEIQELIAlBATYCACACIAU2AgAMAQsgAkEANgIAIAkgBzYCAAsgCSABNgIEIAgoAgwhACAIKAIIDgMBBAIACwALIAJBADYCHCACQbUaNgIQIAJBFzYCDCACIABBAWo2AhRBACEDDAILIAJBADYCHCACIAA2AhQgAkHKGjYCECACQQk2AgxBACEDDAELIAEgBEYEQEEiIQMMAQsgAkEJNgIIIAIgATYCBEEhIQMLIAhBEGokACADRQRAIAIoAgwhAAwBCyACIAM2AhxBACEAIAIoAgQiAUUNACACIAEgBCACKAIIEQEAIgFFDQAgAiAENgIUIAIgATYCDCABIQALIAALvgIBAn8gAEEAOgAAIABB3ABqIgFBAWtBADoAACAAQQA6AAIgAEEAOgABIAFBA2tBADoAACABQQJrQQA6AAAgAEEAOgADIAFBBGtBADoAAEEAIABrQQNxIgEgAGoiAEEANgIAQdwAIAFrQXxxIgIgAGoiAUEEa0EANgIAAkAgAkEJSQ0AIABBADYCCCAAQQA2AgQgAUEIa0EANgIAIAFBDGtBADYCACACQRlJDQAgAEEANgIYIABBADYCFCAAQQA2AhAgAEEANgIMIAFBEGtBADYCACABQRRrQQA2AgAgAUEYa0EANgIAIAFBHGtBADYCACACIABBBHFBGHIiAmsiAUEgSQ0AIAAgAmohAANAIABCADcDGCAAQgA3AxAgAEIANwMIIABCADcDACAAQSBqIQAgAUEgayIBQR9LDQALCwtWAQF/AkAgACgCDA0AAkACQAJAAkAgAC0ALw4DAQADAgsgACgCOCIBRQ0AIAEoAiwiAUUNACAAIAERAAAiAQ0DC0EADwsACyAAQcMWNgIQQQ4hAQsgAQsaACAAKAIMRQRAIABB0Rs2AhAgAEEVNgIMCwsUACAAKAIMQRVGBEAgAEEANgIMCwsUACAAKAIMQRZGBEAgAEEANgIMCwsHACAAKAIMCwcAIAAoAhALCQAgACABNgIQCwcAIAAoAhQLFwAgAEEkTwRAAAsgAEECdEGgM2ooAgALFwAgAEEuTwRAAAsgAEECdEGwNGooAgALvwkBAX9B6yghAQJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABB5ABrDvQDY2IAAWFhYWFhYQIDBAVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhBgcICQoLDA0OD2FhYWFhEGFhYWFhYWFhYWFhEWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYRITFBUWFxgZGhthYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2YTc4OTphYWFhYWFhYTthYWE8YWFhYT0+P2FhYWFhYWFhQGFhQWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYUJDREVGR0hJSktMTU5PUFFSU2FhYWFhYWFhVFVWV1hZWlthXF1hYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFeYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhX2BhC0HhJw8LQaQhDwtByywPC0H+MQ8LQcAkDwtBqyQPC0GNKA8LQeImDwtBgDAPC0G5Lw8LQdckDwtB7x8PC0HhHw8LQfofDwtB8iAPC0GoLw8LQa4yDwtBiDAPC0HsJw8LQYIiDwtBjh0PC0HQLg8LQcojDwtBxTIPC0HfHA8LQdIcDwtBxCAPC0HXIA8LQaIfDwtB7S4PC0GrMA8LQdQlDwtBzC4PC0H6Lg8LQfwrDwtB0jAPC0HxHQ8LQbsgDwtB9ysPC0GQMQ8LQdcxDwtBoi0PC0HUJw8LQeArDwtBnywPC0HrMQ8LQdUfDwtByjEPC0HeJQ8LQdQeDwtB9BwPC0GnMg8LQbEdDwtBoB0PC0G5MQ8LQbwwDwtBkiEPC0GzJg8LQeksDwtBrB4PC0HUKw8LQfcmDwtBgCYPC0GwIQ8LQf4eDwtBjSMPC0GJLQ8LQfciDwtBoDEPC0GuHw8LQcYlDwtB6B4PC0GTIg8LQcIvDwtBwx0PC0GLLA8LQeEdDwtBjS8PC0HqIQ8LQbQtDwtB0i8PC0HfMg8LQdIyDwtB8DAPC0GpIg8LQfkjDwtBmR4PC0G1LA8LQZswDwtBkjIPC0G2Kw8LQcIiDwtB+DIPC0GeJQ8LQdAiDwtBuh4PC0GBHg8LAAtB1iEhAQsgAQsWACAAIAAtAC1B/gFxIAFBAEdyOgAtCxkAIAAgAC0ALUH9AXEgAUEAR0EBdHI6AC0LGQAgACAALQAtQfsBcSABQQBHQQJ0cjoALQsZACAAIAAtAC1B9wFxIAFBAEdBA3RyOgAtCz4BAn8CQCAAKAI4IgNFDQAgAygCBCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBxhE2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCCCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB9go2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCDCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB7Ro2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCECIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBlRA2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCFCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBqhs2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCGCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB7RM2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCKCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB9gg2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCHCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBwhk2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCICIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBlBQ2AhBBGCEECyAEC1kBAn8CQCAALQAoQQFGDQAgAC8BMiIBQeQAa0HkAEkNACABQcwBRg0AIAFBsAJGDQAgAC8BMCIAQcAAcQ0AQQEhAiAAQYgEcUGABEYNACAAQShxRSECCyACC4wBAQJ/AkACQAJAIAAtACpFDQAgAC0AK0UNACAALwEwIgFBAnFFDQEMAgsgAC8BMCIBQQFxRQ0BC0EBIQIgAC0AKEEBRg0AIAAvATIiAEHkAGtB5ABJDQAgAEHMAUYNACAAQbACRg0AIAFBwABxDQBBACECIAFBiARxQYAERg0AIAFBKHFBAEchAgsgAgtzACAAQRBq/QwAAAAAAAAAAAAAAAAAAAAA/QsDACAA/QwAAAAAAAAAAAAAAAAAAAAA/QsDACAAQTBq/QwAAAAAAAAAAAAAAAAAAAAA/QsDACAAQSBq/QwAAAAAAAAAAAAAAAAAAAAA/QsDACAAQd0BNgIcCwYAIAAQMguaLQELfyMAQRBrIgokAEGk0AAoAgAiCUUEQEHk0wAoAgAiBUUEQEHw0wBCfzcCAEHo0wBCgICEgICAwAA3AgBB5NMAIApBCGpBcHFB2KrVqgVzIgU2AgBB+NMAQQA2AgBByNMAQQA2AgALQczTAEGA1AQ2AgBBnNAAQYDUBDYCAEGw0AAgBTYCAEGs0ABBfzYCAEHQ0wBBgKwDNgIAA0AgAUHI0ABqIAFBvNAAaiICNgIAIAIgAUG00ABqIgM2AgAgAUHA0ABqIAM2AgAgAUHQ0ABqIAFBxNAAaiIDNgIAIAMgAjYCACABQdjQAGogAUHM0ABqIgI2AgAgAiADNgIAIAFB1NAAaiACNgIAIAFBIGoiAUGAAkcNAAtBjNQEQcGrAzYCAEGo0ABB9NMAKAIANgIAQZjQAEHAqwM2AgBBpNAAQYjUBDYCAEHM/wdBODYCAEGI1AQhCQsCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAQewBTQRAQYzQACgCACIGQRAgAEETakFwcSAAQQtJGyIEQQN2IgB2IgFBA3EEQAJAIAFBAXEgAHJBAXMiAkEDdCIAQbTQAGoiASAAQbzQAGooAgAiACgCCCIDRgRAQYzQACAGQX4gAndxNgIADAELIAEgAzYCCCADIAE2AgwLIABBCGohASAAIAJBA3QiAkEDcjYCBCAAIAJqIgAgACgCBEEBcjYCBAwRC0GU0AAoAgAiCCAETw0BIAEEQAJAQQIgAHQiAkEAIAJrciABIAB0cWgiAEEDdCICQbTQAGoiASACQbzQAGooAgAiAigCCCIDRgRAQYzQACAGQX4gAHdxIgY2AgAMAQsgASADNgIIIAMgATYCDAsgAiAEQQNyNgIEIABBA3QiACAEayEFIAAgAmogBTYCACACIARqIgQgBUEBcjYCBCAIBEAgCEF4cUG00ABqIQBBoNAAKAIAIQMCf0EBIAhBA3Z0IgEgBnFFBEBBjNAAIAEgBnI2AgAgAAwBCyAAKAIICyIBIAM2AgwgACADNgIIIAMgADYCDCADIAE2AggLIAJBCGohAUGg0AAgBDYCAEGU0AAgBTYCAAwRC0GQ0AAoAgAiC0UNASALaEECdEG80gBqKAIAIgAoAgRBeHEgBGshBSAAIQIDQAJAIAIoAhAiAUUEQCACQRRqKAIAIgFFDQELIAEoAgRBeHEgBGsiAyAFSSECIAMgBSACGyEFIAEgACACGyEAIAEhAgwBCwsgACgCGCEJIAAoAgwiAyAARwRAQZzQACgCABogAyAAKAIIIgE2AgggASADNgIMDBALIABBFGoiAigCACIBRQRAIAAoAhAiAUUNAyAAQRBqIQILA0AgAiEHIAEiA0EUaiICKAIAIgENACADQRBqIQIgAygCECIBDQALIAdBADYCAAwPC0F/IQQgAEG/f0sNACAAQRNqIgFBcHEhBEGQ0AAoAgAiCEUNAEEAIARrIQUCQAJAAkACf0EAIARBgAJJDQAaQR8gBEH///8HSw0AGiAEQSYgAUEIdmciAGt2QQFxIABBAXRrQT5qCyIGQQJ0QbzSAGooAgAiAkUEQEEAIQFBACEDDAELQQAhASAEQRkgBkEBdmtBACAGQR9HG3QhAEEAIQMDQAJAIAIoAgRBeHEgBGsiByAFTw0AIAIhAyAHIgUNAEEAIQUgAiEBDAMLIAEgAkEUaigCACIHIAcgAiAAQR12QQRxakEQaigCACICRhsgASAHGyEBIABBAXQhACACDQALCyABIANyRQRAQQAhA0ECIAZ0IgBBACAAa3IgCHEiAEUNAyAAaEECdEG80gBqKAIAIQELIAFFDQELA0AgASgCBEF4cSAEayICIAVJIQAgAiAFIAAbIQUgASADIAAbIQMgASgCECIABH8gAAUgAUEUaigCAAsiAQ0ACwsgA0UNACAFQZTQACgCACAEa08NACADKAIYIQcgAyADKAIMIgBHBEBBnNAAKAIAGiAAIAMoAggiATYCCCABIAA2AgwMDgsgA0EUaiICKAIAIgFFBEAgAygCECIBRQ0DIANBEGohAgsDQCACIQYgASIAQRRqIgIoAgAiAQ0AIABBEGohAiAAKAIQIgENAAsgBkEANgIADA0LQZTQACgCACIDIARPBEBBoNAAKAIAIQECQCADIARrIgJBEE8EQCABIARqIgAgAkEBcjYCBCABIANqIAI2AgAgASAEQQNyNgIEDAELIAEgA0EDcjYCBCABIANqIgAgACgCBEEBcjYCBEEAIQBBACECC0GU0AAgAjYCAEGg0AAgADYCACABQQhqIQEMDwtBmNAAKAIAIgMgBEsEQCAEIAlqIgAgAyAEayIBQQFyNgIEQaTQACAANgIAQZjQACABNgIAIAkgBEEDcjYCBCAJQQhqIQEMDwtBACEBIAQCf0Hk0wAoAgAEQEHs0wAoAgAMAQtB8NMAQn83AgBB6NMAQoCAhICAgMAANwIAQeTTACAKQQxqQXBxQdiq1aoFczYCAEH40wBBADYCAEHI0wBBADYCAEGAgAQLIgAgBEHHAGoiBWoiBkEAIABrIgdxIgJPBEBB/NMAQTA2AgAMDwsCQEHE0wAoAgAiAUUNAEG80wAoAgAiCCACaiEAIAAgAU0gACAIS3ENAEEAIQFB/NMAQTA2AgAMDwtByNMALQAAQQRxDQQCQAJAIAkEQEHM0wAhAQNAIAEoAgAiACAJTQRAIAAgASgCBGogCUsNAwsgASgCCCIBDQALC0EAEDMiAEF/Rg0FIAIhBkHo0wAoAgAiAUEBayIDIABxBEAgAiAAayAAIANqQQAgAWtxaiEGCyAEIAZPDQUgBkH+////B0sNBUHE0wAoAgAiAwRAQbzTACgCACIHIAZqIQEgASAHTQ0GIAEgA0sNBgsgBhAzIgEgAEcNAQwHCyAGIANrIAdxIgZB/v///wdLDQQgBhAzIQAgACABKAIAIAEoAgRqRg0DIAAhAQsCQCAGIARByABqTw0AIAFBf0YNAEHs0wAoAgAiACAFIAZrakEAIABrcSIAQf7///8HSwRAIAEhAAwHCyAAEDNBf0cEQCAAIAZqIQYgASEADAcLQQAgBmsQMxoMBAsgASIAQX9HDQUMAwtBACEDDAwLQQAhAAwKCyAAQX9HDQILQcjTAEHI0wAoAgBBBHI2AgALIAJB/v///wdLDQEgAhAzIQBBABAzIQEgAEF/Rg0BIAFBf0YNASAAIAFPDQEgASAAayIGIARBOGpNDQELQbzTAEG80wAoAgAgBmoiATYCAEHA0wAoAgAgAUkEQEHA0wAgATYCAAsCQAJAAkBBpNAAKAIAIgIEQEHM0wAhAQNAIAAgASgCACIDIAEoAgQiBWpGDQIgASgCCCIBDQALDAILQZzQACgCACIBQQBHIAAgAU9xRQRAQZzQACAANgIAC0EAIQFB0NMAIAY2AgBBzNMAIAA2AgBBrNAAQX82AgBBsNAAQeTTACgCADYCAEHY0wBBADYCAANAIAFByNAAaiABQbzQAGoiAjYCACACIAFBtNAAaiIDNgIAIAFBwNAAaiADNgIAIAFB0NAAaiABQcTQAGoiAzYCACADIAI2AgAgAUHY0ABqIAFBzNAAaiICNgIAIAIgAzYCACABQdTQAGogAjYCACABQSBqIgFBgAJHDQALQXggAGtBD3EiASAAaiICIAZBOGsiAyABayIBQQFyNgIEQajQAEH00wAoAgA2AgBBmNAAIAE2AgBBpNAAIAI2AgAgACADakE4NgIEDAILIAAgAk0NACACIANJDQAgASgCDEEIcQ0AQXggAmtBD3EiACACaiIDQZjQACgCACAGaiIHIABrIgBBAXI2AgQgASAFIAZqNgIEQajQAEH00wAoAgA2AgBBmNAAIAA2AgBBpNAAIAM2AgAgAiAHakE4NgIEDAELIABBnNAAKAIASQRAQZzQACAANgIACyAAIAZqIQNBzNMAIQECQAJAAkADQCADIAEoAgBHBEAgASgCCCIBDQEMAgsLIAEtAAxBCHFFDQELQczTACEBA0AgASgCACIDIAJNBEAgAyABKAIEaiIFIAJLDQMLIAEoAgghAQwACwALIAEgADYCACABIAEoAgQgBmo2AgQgAEF4IABrQQ9xaiIJIARBA3I2AgQgA0F4IANrQQ9xaiIGIAQgCWoiBGshASACIAZGBEBBpNAAIAQ2AgBBmNAAQZjQACgCACABaiIANgIAIAQgAEEBcjYCBAwIC0Gg0AAoAgAgBkYEQEGg0AAgBDYCAEGU0ABBlNAAKAIAIAFqIgA2AgAgBCAAQQFyNgIEIAAgBGogADYCAAwICyAGKAIEIgVBA3FBAUcNBiAFQXhxIQggBUH/AU0EQCAFQQN2IQMgBigCCCIAIAYoAgwiAkYEQEGM0ABBjNAAKAIAQX4gA3dxNgIADAcLIAIgADYCCCAAIAI2AgwMBgsgBigCGCEHIAYgBigCDCIARwRAIAAgBigCCCICNgIIIAIgADYCDAwFCyAGQRRqIgIoAgAiBUUEQCAGKAIQIgVFDQQgBkEQaiECCwNAIAIhAyAFIgBBFGoiAigCACIFDQAgAEEQaiECIAAoAhAiBQ0ACyADQQA2AgAMBAtBeCAAa0EPcSIBIABqIgcgBkE4ayIDIAFrIgFBAXI2AgQgACADakE4NgIEIAIgBUE3IAVrQQ9xakE/ayIDIAMgAkEQakkbIgNBIzYCBEGo0ABB9NMAKAIANgIAQZjQACABNgIAQaTQACAHNgIAIANBEGpB1NMAKQIANwIAIANBzNMAKQIANwIIQdTTACADQQhqNgIAQdDTACAGNgIAQczTACAANgIAQdjTAEEANgIAIANBJGohAQNAIAFBBzYCACAFIAFBBGoiAUsNAAsgAiADRg0AIAMgAygCBEF+cTYCBCADIAMgAmsiBTYCACACIAVBAXI2AgQgBUH/AU0EQCAFQXhxQbTQAGohAAJ/QYzQACgCACIBQQEgBUEDdnQiA3FFBEBBjNAAIAEgA3I2AgAgAAwBCyAAKAIICyIBIAI2AgwgACACNgIIIAIgADYCDCACIAE2AggMAQtBHyEBIAVB////B00EQCAFQSYgBUEIdmciAGt2QQFxIABBAXRrQT5qIQELIAIgATYCHCACQgA3AhAgAUECdEG80gBqIQBBkNAAKAIAIgNBASABdCIGcUUEQCAAIAI2AgBBkNAAIAMgBnI2AgAgAiAANgIYIAIgAjYCCCACIAI2AgwMAQsgBUEZIAFBAXZrQQAgAUEfRxt0IQEgACgCACEDAkADQCADIgAoAgRBeHEgBUYNASABQR12IQMgAUEBdCEBIAAgA0EEcWpBEGoiBigCACIDDQALIAYgAjYCACACIAA2AhggAiACNgIMIAIgAjYCCAwBCyAAKAIIIgEgAjYCDCAAIAI2AgggAkEANgIYIAIgADYCDCACIAE2AggLQZjQACgCACIBIARNDQBBpNAAKAIAIgAgBGoiAiABIARrIgFBAXI2AgRBmNAAIAE2AgBBpNAAIAI2AgAgACAEQQNyNgIEIABBCGohAQwIC0EAIQFB/NMAQTA2AgAMBwtBACEACyAHRQ0AAkAgBigCHCICQQJ0QbzSAGoiAygCACAGRgRAIAMgADYCACAADQFBkNAAQZDQACgCAEF+IAJ3cTYCAAwCCyAHQRBBFCAHKAIQIAZGG2ogADYCACAARQ0BCyAAIAc2AhggBigCECICBEAgACACNgIQIAIgADYCGAsgBkEUaigCACICRQ0AIABBFGogAjYCACACIAA2AhgLIAEgCGohASAGIAhqIgYoAgQhBQsgBiAFQX5xNgIEIAEgBGogATYCACAEIAFBAXI2AgQgAUH/AU0EQCABQXhxQbTQAGohAAJ/QYzQACgCACICQQEgAUEDdnQiAXFFBEBBjNAAIAEgAnI2AgAgAAwBCyAAKAIICyIBIAQ2AgwgACAENgIIIAQgADYCDCAEIAE2AggMAQtBHyEFIAFB////B00EQCABQSYgAUEIdmciAGt2QQFxIABBAXRrQT5qIQULIAQgBTYCHCAEQgA3AhAgBUECdEG80gBqIQBBkNAAKAIAIgJBASAFdCIDcUUEQCAAIAQ2AgBBkNAAIAIgA3I2AgAgBCAANgIYIAQgBDYCCCAEIAQ2AgwMAQsgAUEZIAVBAXZrQQAgBUEfRxt0IQUgACgCACEAAkADQCAAIgIoAgRBeHEgAUYNASAFQR12IQAgBUEBdCEFIAIgAEEEcWpBEGoiAygCACIADQALIAMgBDYCACAEIAI2AhggBCAENgIMIAQgBDYCCAwBCyACKAIIIgAgBDYCDCACIAQ2AgggBEEANgIYIAQgAjYCDCAEIAA2AggLIAlBCGohAQwCCwJAIAdFDQACQCADKAIcIgFBAnRBvNIAaiICKAIAIANGBEAgAiAANgIAIAANAUGQ0AAgCEF+IAF3cSIINgIADAILIAdBEEEUIAcoAhAgA0YbaiAANgIAIABFDQELIAAgBzYCGCADKAIQIgEEQCAAIAE2AhAgASAANgIYCyADQRRqKAIAIgFFDQAgAEEUaiABNgIAIAEgADYCGAsCQCAFQQ9NBEAgAyAEIAVqIgBBA3I2AgQgACADaiIAIAAoAgRBAXI2AgQMAQsgAyAEaiICIAVBAXI2AgQgAyAEQQNyNgIEIAIgBWogBTYCACAFQf8BTQRAIAVBeHFBtNAAaiEAAn9BjNAAKAIAIgFBASAFQQN2dCIFcUUEQEGM0AAgASAFcjYCACAADAELIAAoAggLIgEgAjYCDCAAIAI2AgggAiAANgIMIAIgATYCCAwBC0EfIQEgBUH///8HTQRAIAVBJiAFQQh2ZyIAa3ZBAXEgAEEBdGtBPmohAQsgAiABNgIcIAJCADcCECABQQJ0QbzSAGohAEEBIAF0IgQgCHFFBEAgACACNgIAQZDQACAEIAhyNgIAIAIgADYCGCACIAI2AgggAiACNgIMDAELIAVBGSABQQF2a0EAIAFBH0cbdCEBIAAoAgAhBAJAA0AgBCIAKAIEQXhxIAVGDQEgAUEddiEEIAFBAXQhASAAIARBBHFqQRBqIgYoAgAiBA0ACyAGIAI2AgAgAiAANgIYIAIgAjYCDCACIAI2AggMAQsgACgCCCIBIAI2AgwgACACNgIIIAJBADYCGCACIAA2AgwgAiABNgIICyADQQhqIQEMAQsCQCAJRQ0AAkAgACgCHCIBQQJ0QbzSAGoiAigCACAARgRAIAIgAzYCACADDQFBkNAAIAtBfiABd3E2AgAMAgsgCUEQQRQgCSgCECAARhtqIAM2AgAgA0UNAQsgAyAJNgIYIAAoAhAiAQRAIAMgATYCECABIAM2AhgLIABBFGooAgAiAUUNACADQRRqIAE2AgAgASADNgIYCwJAIAVBD00EQCAAIAQgBWoiAUEDcjYCBCAAIAFqIgEgASgCBEEBcjYCBAwBCyAAIARqIgcgBUEBcjYCBCAAIARBA3I2AgQgBSAHaiAFNgIAIAgEQCAIQXhxQbTQAGohAUGg0AAoAgAhAwJ/QQEgCEEDdnQiAiAGcUUEQEGM0AAgAiAGcjYCACABDAELIAEoAggLIgIgAzYCDCABIAM2AgggAyABNgIMIAMgAjYCCAtBoNAAIAc2AgBBlNAAIAU2AgALIABBCGohAQsgCkEQaiQAIAELQwAgAEUEQD8AQRB0DwsCQCAAQf//A3ENACAAQQBIDQAgAEEQdkAAIgBBf0YEQEH80wBBMDYCAEF/DwsgAEEQdA8LAAsL3D8iAEGACAsJAQAAAAIAAAADAEGUCAsFBAAAAAUAQaQICwkGAAAABwAAAAgAQdwIC4otSW52YWxpZCBjaGFyIGluIHVybCBxdWVyeQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2JvZHkAQ29udGVudC1MZW5ndGggb3ZlcmZsb3cAQ2h1bmsgc2l6ZSBvdmVyZmxvdwBSZXNwb25zZSBvdmVyZmxvdwBJbnZhbGlkIG1ldGhvZCBmb3IgSFRUUC94LnggcmVxdWVzdABJbnZhbGlkIG1ldGhvZCBmb3IgUlRTUC94LnggcmVxdWVzdABFeHBlY3RlZCBTT1VSQ0UgbWV0aG9kIGZvciBJQ0UveC54IHJlcXVlc3QASW52YWxpZCBjaGFyIGluIHVybCBmcmFnbWVudCBzdGFydABFeHBlY3RlZCBkb3QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9zdGF0dXMASW52YWxpZCByZXNwb25zZSBzdGF0dXMASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucwBVc2VyIGNhbGxiYWNrIGVycm9yAGBvbl9yZXNldGAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2hlYWRlcmAgY2FsbGJhY2sgZXJyb3IAYG9uX21lc3NhZ2VfYmVnaW5gIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fdmFsdWVgIGNhbGxiYWNrIGVycm9yAGBvbl9zdGF0dXNfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl92ZXJzaW9uX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdXJsX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWV0aG9kX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX25hbWVgIGNhbGxiYWNrIGVycm9yAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2VydmVyAEludmFsaWQgaGVhZGVyIHZhbHVlIGNoYXIASW52YWxpZCBoZWFkZXIgZmllbGQgY2hhcgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3ZlcnNpb24ASW52YWxpZCBtaW5vciB2ZXJzaW9uAEludmFsaWQgbWFqb3IgdmVyc2lvbgBFeHBlY3RlZCBzcGFjZSBhZnRlciB2ZXJzaW9uAEV4cGVjdGVkIENSTEYgYWZ0ZXIgdmVyc2lvbgBJbnZhbGlkIEhUVFAgdmVyc2lvbgBJbnZhbGlkIGhlYWRlciB0b2tlbgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3VybABJbnZhbGlkIGNoYXJhY3RlcnMgaW4gdXJsAFVuZXhwZWN0ZWQgc3RhcnQgY2hhciBpbiB1cmwARG91YmxlIEAgaW4gdXJsAEVtcHR5IENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhcmFjdGVyIGluIENvbnRlbnQtTGVuZ3RoAER1cGxpY2F0ZSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXIgaW4gdXJsIHBhdGgAQ29udGVudC1MZW5ndGggY2FuJ3QgYmUgcHJlc2VudCB3aXRoIFRyYW5zZmVyLUVuY29kaW5nAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHNpemUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfdmFsdWUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyB2YWx1ZQBNaXNzaW5nIGV4cGVjdGVkIExGIGFmdGVyIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AgaGVhZGVyIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGUgdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZWQgdmFsdWUAUGF1c2VkIGJ5IG9uX2hlYWRlcnNfY29tcGxldGUASW52YWxpZCBFT0Ygc3RhdGUAb25fcmVzZXQgcGF1c2UAb25fY2h1bmtfaGVhZGVyIHBhdXNlAG9uX21lc3NhZ2VfYmVnaW4gcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlIHBhdXNlAG9uX3N0YXR1c19jb21wbGV0ZSBwYXVzZQBvbl92ZXJzaW9uX2NvbXBsZXRlIHBhdXNlAG9uX3VybF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGUgcGF1c2UAb25fbWVzc2FnZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXRob2RfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lIHBhdXNlAFVuZXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgc3RhcnQgbGluZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgbmFtZQBQYXVzZSBvbiBDT05ORUNUL1VwZ3JhZGUAUGF1c2Ugb24gUFJJL1VwZ3JhZGUARXhwZWN0ZWQgSFRUUC8yIENvbm5lY3Rpb24gUHJlZmFjZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX21ldGhvZABFeHBlY3RlZCBzcGFjZSBhZnRlciBtZXRob2QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfZmllbGQAUGF1c2VkAEludmFsaWQgd29yZCBlbmNvdW50ZXJlZABJbnZhbGlkIG1ldGhvZCBlbmNvdW50ZXJlZABVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNjaGVtYQBSZXF1ZXN0IGhhcyBpbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AAU1dJVENIX1BST1hZAFVTRV9QUk9YWQBNS0FDVElWSVRZAFVOUFJPQ0VTU0FCTEVfRU5USVRZAENPUFkATU9WRURfUEVSTUFORU5UTFkAVE9PX0VBUkxZAE5PVElGWQBGQUlMRURfREVQRU5ERU5DWQBCQURfR0FURVdBWQBQTEFZAFBVVABDSEVDS09VVABHQVRFV0FZX1RJTUVPVVQAUkVRVUVTVF9USU1FT1VUAE5FVFdPUktfQ09OTkVDVF9USU1FT1VUAENPTk5FQ1RJT05fVElNRU9VVABMT0dJTl9USU1FT1VUAE5FVFdPUktfUkVBRF9USU1FT1VUAFBPU1QATUlTRElSRUNURURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9MT0FEX0JBTEFOQ0VEX1JFUVVFU1QAQkFEX1JFUVVFU1QASFRUUF9SRVFVRVNUX1NFTlRfVE9fSFRUUFNfUE9SVABSRVBPUlQASU1fQV9URUFQT1QAUkVTRVRfQ09OVEVOVABOT19DT05URU5UAFBBUlRJQUxfQ09OVEVOVABIUEVfSU5WQUxJRF9DT05TVEFOVABIUEVfQ0JfUkVTRVQAR0VUAEhQRV9TVFJJQ1QAQ09ORkxJQ1QAVEVNUE9SQVJZX1JFRElSRUNUAFBFUk1BTkVOVF9SRURJUkVDVABDT05ORUNUAE1VTFRJX1NUQVRVUwBIUEVfSU5WQUxJRF9TVEFUVVMAVE9PX01BTllfUkVRVUVTVFMARUFSTFlfSElOVFMAVU5BVkFJTEFCTEVfRk9SX0xFR0FMX1JFQVNPTlMAT1BUSU9OUwBTV0lUQ0hJTkdfUFJPVE9DT0xTAFZBUklBTlRfQUxTT19ORUdPVElBVEVTAE1VTFRJUExFX0NIT0lDRVMASU5URVJOQUxfU0VSVkVSX0VSUk9SAFdFQl9TRVJWRVJfVU5LTk9XTl9FUlJPUgBSQUlMR1VOX0VSUk9SAElERU5USVRZX1BST1ZJREVSX0FVVEhFTlRJQ0FUSU9OX0VSUk9SAFNTTF9DRVJUSUZJQ0FURV9FUlJPUgBJTlZBTElEX1hfRk9SV0FSREVEX0ZPUgBTRVRfUEFSQU1FVEVSAEdFVF9QQVJBTUVURVIASFBFX1VTRVIAU0VFX09USEVSAEhQRV9DQl9DSFVOS19IRUFERVIATUtDQUxFTkRBUgBTRVRVUABXRUJfU0VSVkVSX0lTX0RPV04AVEVBUkRPV04ASFBFX0NMT1NFRF9DT05ORUNUSU9OAEhFVVJJU1RJQ19FWFBJUkFUSU9OAERJU0NPTk5FQ1RFRF9PUEVSQVRJT04ATk9OX0FVVEhPUklUQVRJVkVfSU5GT1JNQVRJT04ASFBFX0lOVkFMSURfVkVSU0lPTgBIUEVfQ0JfTUVTU0FHRV9CRUdJTgBTSVRFX0lTX0ZST1pFTgBIUEVfSU5WQUxJRF9IRUFERVJfVE9LRU4ASU5WQUxJRF9UT0tFTgBGT1JCSURERU4ARU5IQU5DRV9ZT1VSX0NBTE0ASFBFX0lOVkFMSURfVVJMAEJMT0NLRURfQllfUEFSRU5UQUxfQ09OVFJPTABNS0NPTABBQ0wASFBFX0lOVEVSTkFMAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0VfVU5PRkZJQ0lBTABIUEVfT0sAVU5MSU5LAFVOTE9DSwBQUkkAUkVUUllfV0lUSABIUEVfSU5WQUxJRF9DT05URU5UX0xFTkdUSABIUEVfVU5FWFBFQ1RFRF9DT05URU5UX0xFTkdUSABGTFVTSABQUk9QUEFUQ0gATS1TRUFSQ0gAVVJJX1RPT19MT05HAFBST0NFU1NJTkcATUlTQ0VMTEFORU9VU19QRVJTSVNURU5UX1dBUk5JTkcATUlTQ0VMTEFORU9VU19XQVJOSU5HAEhQRV9JTlZBTElEX1RSQU5TRkVSX0VOQ09ESU5HAEV4cGVjdGVkIENSTEYASFBFX0lOVkFMSURfQ0hVTktfU0laRQBNT1ZFAENPTlRJTlVFAEhQRV9DQl9TVEFUVVNfQ09NUExFVEUASFBFX0NCX0hFQURFUlNfQ09NUExFVEUASFBFX0NCX1ZFUlNJT05fQ09NUExFVEUASFBFX0NCX1VSTF9DT01QTEVURQBIUEVfQ0JfQ0hVTktfQ09NUExFVEUASFBFX0NCX0hFQURFUl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fTkFNRV9DT01QTEVURQBIUEVfQ0JfTUVTU0FHRV9DT01QTEVURQBIUEVfQ0JfTUVUSE9EX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfRklFTERfQ09NUExFVEUAREVMRVRFAEhQRV9JTlZBTElEX0VPRl9TVEFURQBJTlZBTElEX1NTTF9DRVJUSUZJQ0FURQBQQVVTRQBOT19SRVNQT05TRQBVTlNVUFBPUlRFRF9NRURJQV9UWVBFAEdPTkUATk9UX0FDQ0VQVEFCTEUAU0VSVklDRV9VTkFWQUlMQUJMRQBSQU5HRV9OT1RfU0FUSVNGSUFCTEUAT1JJR0lOX0lTX1VOUkVBQ0hBQkxFAFJFU1BPTlNFX0lTX1NUQUxFAFBVUkdFAE1FUkdFAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0UAUkVRVUVTVF9IRUFERVJfVE9PX0xBUkdFAFBBWUxPQURfVE9PX0xBUkdFAElOU1VGRklDSUVOVF9TVE9SQUdFAEhQRV9QQVVTRURfVVBHUkFERQBIUEVfUEFVU0VEX0gyX1VQR1JBREUAU09VUkNFAEFOTk9VTkNFAFRSQUNFAEhQRV9VTkVYUEVDVEVEX1NQQUNFAERFU0NSSUJFAFVOU1VCU0NSSUJFAFJFQ09SRABIUEVfSU5WQUxJRF9NRVRIT0QATk9UX0ZPVU5EAFBST1BGSU5EAFVOQklORABSRUJJTkQAVU5BVVRIT1JJWkVEAE1FVEhPRF9OT1RfQUxMT1dFRABIVFRQX1ZFUlNJT05fTk9UX1NVUFBPUlRFRABBTFJFQURZX1JFUE9SVEVEAEFDQ0VQVEVEAE5PVF9JTVBMRU1FTlRFRABMT09QX0RFVEVDVEVEAEhQRV9DUl9FWFBFQ1RFRABIUEVfTEZfRVhQRUNURUQAQ1JFQVRFRABJTV9VU0VEAEhQRV9QQVVTRUQAVElNRU9VVF9PQ0NVUkVEAFBBWU1FTlRfUkVRVUlSRUQAUFJFQ09ORElUSU9OX1JFUVVJUkVEAFBST1hZX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAE5FVFdPUktfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATEVOR1RIX1JFUVVJUkVEAFNTTF9DRVJUSUZJQ0FURV9SRVFVSVJFRABVUEdSQURFX1JFUVVJUkVEAFBBR0VfRVhQSVJFRABQUkVDT05ESVRJT05fRkFJTEVEAEVYUEVDVEFUSU9OX0ZBSUxFRABSRVZBTElEQVRJT05fRkFJTEVEAFNTTF9IQU5EU0hBS0VfRkFJTEVEAExPQ0tFRABUUkFOU0ZPUk1BVElPTl9BUFBMSUVEAE5PVF9NT0RJRklFRABOT1RfRVhURU5ERUQAQkFORFdJRFRIX0xJTUlUX0VYQ0VFREVEAFNJVEVfSVNfT1ZFUkxPQURFRABIRUFEAEV4cGVjdGVkIEhUVFAvAABeEwAAJhMAADAQAADwFwAAnRMAABUSAAA5FwAA8BIAAAoQAAB1EgAArRIAAIITAABPFAAAfxAAAKAVAAAjFAAAiRIAAIsUAABNFQAA1BEAAM8UAAAQGAAAyRYAANwWAADBEQAA4BcAALsUAAB0FAAAfBUAAOUUAAAIFwAAHxAAAGUVAACjFAAAKBUAAAIVAACZFQAALBAAAIsZAABPDwAA1A4AAGoQAADOEAAAAhcAAIkOAABuEwAAHBMAAGYUAABWFwAAwRMAAM0TAABsEwAAaBcAAGYXAABfFwAAIhMAAM4PAABpDgAA2A4AAGMWAADLEwAAqg4AACgXAAAmFwAAxRMAAF0WAADoEQAAZxMAAGUTAADyFgAAcxMAAB0XAAD5FgAA8xEAAM8OAADOFQAADBIAALMRAAClEQAAYRAAADIXAAC7EwBB+TULAQEAQZA2C+ABAQECAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAQf03CwEBAEGROAteAgMCAgICAgAAAgIAAgIAAgICAgICAgICAgAEAAAAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAAIAAgBB/TkLAQEAQZE6C14CAAICAgICAAACAgACAgACAgICAgICAgICAAMABAAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgACAEHwOwsNbG9zZWVlcC1hbGl2ZQBBiTwLAQEAQaA8C+ABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAQYk+CwEBAEGgPgvnAQEBAQEBAQEBAQEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBY2h1bmtlZABBsMAAC18BAQABAQEBAQAAAQEAAQEAAQEBAQEBAQEBAQAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQBBkMIACyFlY3Rpb25lbnQtbGVuZ3Rob25yb3h5LWNvbm5lY3Rpb24AQcDCAAstcmFuc2Zlci1lbmNvZGluZ3BncmFkZQ0KDQoNClNNDQoNClRUUC9DRS9UU1AvAEH5wgALBQECAAEDAEGQwwAL4AEEAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBB+cQACwUBAgABAwBBkMUAC+ABBAEBBQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAQfnGAAsEAQAAAQBBkccAC98BAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBB+sgACwQBAAACAEGQyQALXwMEAAAEBAQEBAQEBAQEBAUEBAQEBAQEBAQEBAQABAAGBwQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEAEH6ygALBAEAAAEAQZDLAAsBAQBBqssAC0ECAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwBB+swACwQBAAABAEGQzQALAQEAQZrNAAsGAgAAAAACAEGxzQALOgMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAQfDOAAuWAU5PVU5DRUVDS09VVE5FQ1RFVEVDUklCRUxVU0hFVEVBRFNFQVJDSFJHRUNUSVZJVFlMRU5EQVJWRU9USUZZUFRJT05TQ0hTRUFZU1RBVENIR0VPUkRJUkVDVE9SVFJDSFBBUkFNRVRFUlVSQ0VCU0NSSUJFQVJET1dOQUNFSU5ETktDS1VCU0NSSUJFSFRUUC9BRFRQLw==", "base64");
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/fetch/constants.js
var require_constants3 = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/fetch/constants.js"(exports2, module2) {
    "use strict";
    var corsSafeListedMethods = (
      /** @type {const} */
      ["GET", "HEAD", "POST"]
    );
    var corsSafeListedMethodsSet = new Set(corsSafeListedMethods);
    var nullBodyStatus = (
      /** @type {const} */
      [101, 204, 205, 304]
    );
    var redirectStatus = (
      /** @type {const} */
      [301, 302, 303, 307, 308]
    );
    var redirectStatusSet = new Set(redirectStatus);
    var badPorts = (
      /** @type {const} */
      [
        "1",
        "7",
        "9",
        "11",
        "13",
        "15",
        "17",
        "19",
        "20",
        "21",
        "22",
        "23",
        "25",
        "37",
        "42",
        "43",
        "53",
        "69",
        "77",
        "79",
        "87",
        "95",
        "101",
        "102",
        "103",
        "104",
        "109",
        "110",
        "111",
        "113",
        "115",
        "117",
        "119",
        "123",
        "135",
        "137",
        "139",
        "143",
        "161",
        "179",
        "389",
        "427",
        "465",
        "512",
        "513",
        "514",
        "515",
        "526",
        "530",
        "531",
        "532",
        "540",
        "548",
        "554",
        "556",
        "563",
        "587",
        "601",
        "636",
        "989",
        "990",
        "993",
        "995",
        "1719",
        "1720",
        "1723",
        "2049",
        "3659",
        "4045",
        "4190",
        "5060",
        "5061",
        "6000",
        "6566",
        "6665",
        "6666",
        "6667",
        "6668",
        "6669",
        "6679",
        "6697",
        "10080"
      ]
    );
    var badPortsSet = new Set(badPorts);
    var referrerPolicy = (
      /** @type {const} */
      [
        "",
        "no-referrer",
        "no-referrer-when-downgrade",
        "same-origin",
        "origin",
        "strict-origin",
        "origin-when-cross-origin",
        "strict-origin-when-cross-origin",
        "unsafe-url"
      ]
    );
    var referrerPolicySet = new Set(referrerPolicy);
    var requestRedirect = (
      /** @type {const} */
      ["follow", "manual", "error"]
    );
    var safeMethods = (
      /** @type {const} */
      ["GET", "HEAD", "OPTIONS", "TRACE"]
    );
    var safeMethodsSet = new Set(safeMethods);
    var requestMode = (
      /** @type {const} */
      ["navigate", "same-origin", "no-cors", "cors"]
    );
    var requestCredentials = (
      /** @type {const} */
      ["omit", "same-origin", "include"]
    );
    var requestCache = (
      /** @type {const} */
      [
        "default",
        "no-store",
        "reload",
        "no-cache",
        "force-cache",
        "only-if-cached"
      ]
    );
    var requestBodyHeader = (
      /** @type {const} */
      [
        "content-encoding",
        "content-language",
        "content-location",
        "content-type",
        // See https://github.com/nodejs/undici/issues/2021
        // 'Content-Length' is a forbidden header name, which is typically
        // removed in the Headers implementation. However, undici doesn't
        // filter out headers, so we add it here.
        "content-length"
      ]
    );
    var requestDuplex = (
      /** @type {const} */
      [
        "half"
      ]
    );
    var forbiddenMethods = (
      /** @type {const} */
      ["CONNECT", "TRACE", "TRACK"]
    );
    var forbiddenMethodsSet = new Set(forbiddenMethods);
    var subresource = (
      /** @type {const} */
      [
        "audio",
        "audioworklet",
        "font",
        "image",
        "manifest",
        "paintworklet",
        "script",
        "style",
        "track",
        "video",
        "xslt",
        ""
      ]
    );
    var subresourceSet = new Set(subresource);
    module2.exports = {
      subresource,
      forbiddenMethods,
      requestBodyHeader,
      referrerPolicy,
      requestRedirect,
      requestMode,
      requestCredentials,
      requestCache,
      redirectStatus,
      corsSafeListedMethods,
      nullBodyStatus,
      safeMethods,
      badPorts,
      requestDuplex,
      subresourceSet,
      badPortsSet,
      redirectStatusSet,
      corsSafeListedMethodsSet,
      safeMethodsSet,
      forbiddenMethodsSet,
      referrerPolicySet
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/fetch/global.js
var require_global = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/fetch/global.js"(exports2, module2) {
    "use strict";
    var globalOrigin = Symbol.for("undici.globalOrigin.1");
    function getGlobalOrigin() {
      return globalThis[globalOrigin];
    }
    function setGlobalOrigin(newOrigin) {
      if (newOrigin === void 0) {
        Object.defineProperty(globalThis, globalOrigin, {
          value: void 0,
          writable: true,
          enumerable: false,
          configurable: false
        });
        return;
      }
      const parsedURL = new URL(newOrigin);
      if (parsedURL.protocol !== "http:" && parsedURL.protocol !== "https:") {
        throw new TypeError(`Only http & https urls are allowed, received ${parsedURL.protocol}`);
      }
      Object.defineProperty(globalThis, globalOrigin, {
        value: parsedURL,
        writable: true,
        enumerable: false,
        configurable: false
      });
    }
    module2.exports = {
      getGlobalOrigin,
      setGlobalOrigin
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/fetch/data-url.js
var require_data_url = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/fetch/data-url.js"(exports2, module2) {
    "use strict";
    var assert = require_node_assert();
    var encoder = new TextEncoder();
    var HTTP_TOKEN_CODEPOINTS = /^[!#$%&'*+\-.^_|~A-Za-z0-9]+$/;
    var HTTP_WHITESPACE_REGEX = /[\u000A\u000D\u0009\u0020]/;
    var ASCII_WHITESPACE_REPLACE_REGEX = /[\u0009\u000A\u000C\u000D\u0020]/g;
    var HTTP_QUOTED_STRING_TOKENS = /^[\u0009\u0020-\u007E\u0080-\u00FF]+$/;
    function dataURLProcessor(dataURL) {
      assert(dataURL.protocol === "data:");
      let input = URLSerializer(dataURL, true);
      input = input.slice(5);
      const position = { position: 0 };
      let mimeType = collectASequenceOfCodePointsFast(
        ",",
        input,
        position
      );
      const mimeTypeLength = mimeType.length;
      mimeType = removeASCIIWhitespace(mimeType, true, true);
      if (position.position >= input.length) {
        return "failure";
      }
      position.position++;
      const encodedBody = input.slice(mimeTypeLength + 1);
      let body = stringPercentDecode(encodedBody);
      if (/;(\u0020){0,}base64$/i.test(mimeType)) {
        const stringBody = isomorphicDecode(body);
        body = forgivingBase64(stringBody);
        if (body === "failure") {
          return "failure";
        }
        mimeType = mimeType.slice(0, -6);
        mimeType = mimeType.replace(/(\u0020)+$/, "");
        mimeType = mimeType.slice(0, -1);
      }
      if (mimeType.startsWith(";")) {
        mimeType = "text/plain" + mimeType;
      }
      let mimeTypeRecord = parseMIMEType(mimeType);
      if (mimeTypeRecord === "failure") {
        mimeTypeRecord = parseMIMEType("text/plain;charset=US-ASCII");
      }
      return { mimeType: mimeTypeRecord, body };
    }
    function URLSerializer(url, excludeFragment = false) {
      if (!excludeFragment) {
        return url.href;
      }
      const href = url.href;
      const hashLength = url.hash.length;
      const serialized = hashLength === 0 ? href : href.substring(0, href.length - hashLength);
      if (!hashLength && href.endsWith("#")) {
        return serialized.slice(0, -1);
      }
      return serialized;
    }
    function collectASequenceOfCodePoints(condition, input, position) {
      let result = "";
      while (position.position < input.length && condition(input[position.position])) {
        result += input[position.position];
        position.position++;
      }
      return result;
    }
    function collectASequenceOfCodePointsFast(char, input, position) {
      const idx = input.indexOf(char, position.position);
      const start = position.position;
      if (idx === -1) {
        position.position = input.length;
        return input.slice(start);
      }
      position.position = idx;
      return input.slice(start, position.position);
    }
    function stringPercentDecode(input) {
      const bytes = encoder.encode(input);
      return percentDecode(bytes);
    }
    function isHexCharByte(byte) {
      return byte >= 48 && byte <= 57 || byte >= 65 && byte <= 70 || byte >= 97 && byte <= 102;
    }
    function hexByteToNumber(byte) {
      return (
        // 0-9
        byte >= 48 && byte <= 57 ? byte - 48 : (byte & 223) - 55
      );
    }
    function percentDecode(input) {
      const length = input.length;
      const output = new Uint8Array(length);
      let j = 0;
      for (let i = 0; i < length; ++i) {
        const byte = input[i];
        if (byte !== 37) {
          output[j++] = byte;
        } else if (byte === 37 && !(isHexCharByte(input[i + 1]) && isHexCharByte(input[i + 2]))) {
          output[j++] = 37;
        } else {
          output[j++] = hexByteToNumber(input[i + 1]) << 4 | hexByteToNumber(input[i + 2]);
          i += 2;
        }
      }
      return length === j ? output : output.subarray(0, j);
    }
    function parseMIMEType(input) {
      input = removeHTTPWhitespace(input, true, true);
      const position = { position: 0 };
      const type = collectASequenceOfCodePointsFast(
        "/",
        input,
        position
      );
      if (type.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(type)) {
        return "failure";
      }
      if (position.position > input.length) {
        return "failure";
      }
      position.position++;
      let subtype = collectASequenceOfCodePointsFast(
        ";",
        input,
        position
      );
      subtype = removeHTTPWhitespace(subtype, false, true);
      if (subtype.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(subtype)) {
        return "failure";
      }
      const typeLowercase = type.toLowerCase();
      const subtypeLowercase = subtype.toLowerCase();
      const mimeType = {
        type: typeLowercase,
        subtype: subtypeLowercase,
        /** @type {Map<string, string>} */
        parameters: /* @__PURE__ */ new Map(),
        // https://mimesniff.spec.whatwg.org/#mime-type-essence
        essence: `${typeLowercase}/${subtypeLowercase}`
      };
      while (position.position < input.length) {
        position.position++;
        collectASequenceOfCodePoints(
          // https://fetch.spec.whatwg.org/#http-whitespace
          (char) => HTTP_WHITESPACE_REGEX.test(char),
          input,
          position
        );
        let parameterName = collectASequenceOfCodePoints(
          (char) => char !== ";" && char !== "=",
          input,
          position
        );
        parameterName = parameterName.toLowerCase();
        if (position.position < input.length) {
          if (input[position.position] === ";") {
            continue;
          }
          position.position++;
        }
        if (position.position > input.length) {
          break;
        }
        let parameterValue = null;
        if (input[position.position] === '"') {
          parameterValue = collectAnHTTPQuotedString(input, position, true);
          collectASequenceOfCodePointsFast(
            ";",
            input,
            position
          );
        } else {
          parameterValue = collectASequenceOfCodePointsFast(
            ";",
            input,
            position
          );
          parameterValue = removeHTTPWhitespace(parameterValue, false, true);
          if (parameterValue.length === 0) {
            continue;
          }
        }
        if (parameterName.length !== 0 && HTTP_TOKEN_CODEPOINTS.test(parameterName) && (parameterValue.length === 0 || HTTP_QUOTED_STRING_TOKENS.test(parameterValue)) && !mimeType.parameters.has(parameterName)) {
          mimeType.parameters.set(parameterName, parameterValue);
        }
      }
      return mimeType;
    }
    function forgivingBase64(data) {
      data = data.replace(ASCII_WHITESPACE_REPLACE_REGEX, "");
      let dataLength = data.length;
      if (dataLength % 4 === 0) {
        if (data.charCodeAt(dataLength - 1) === 61) {
          --dataLength;
          if (data.charCodeAt(dataLength - 1) === 61) {
            --dataLength;
          }
        }
      }
      if (dataLength % 4 === 1) {
        return "failure";
      }
      if (/[^+/0-9A-Za-z]/.test(data.length === dataLength ? data : data.substring(0, dataLength))) {
        return "failure";
      }
      const buffer = Buffer.from(data, "base64");
      return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
    }
    function collectAnHTTPQuotedString(input, position, extractValue) {
      const positionStart = position.position;
      let value = "";
      assert(input[position.position] === '"');
      position.position++;
      while (true) {
        value += collectASequenceOfCodePoints(
          (char) => char !== '"' && char !== "\\",
          input,
          position
        );
        if (position.position >= input.length) {
          break;
        }
        const quoteOrBackslash = input[position.position];
        position.position++;
        if (quoteOrBackslash === "\\") {
          if (position.position >= input.length) {
            value += "\\";
            break;
          }
          value += input[position.position];
          position.position++;
        } else {
          assert(quoteOrBackslash === '"');
          break;
        }
      }
      if (extractValue) {
        return value;
      }
      return input.slice(positionStart, position.position);
    }
    function serializeAMimeType(mimeType) {
      assert(mimeType !== "failure");
      const { parameters, essence } = mimeType;
      let serialization = essence;
      for (let [name, value] of parameters.entries()) {
        serialization += ";";
        serialization += name;
        serialization += "=";
        if (!HTTP_TOKEN_CODEPOINTS.test(value)) {
          value = value.replace(/(\\|")/g, "\\$1");
          value = '"' + value;
          value += '"';
        }
        serialization += value;
      }
      return serialization;
    }
    function isHTTPWhiteSpace(char) {
      return char === 13 || char === 10 || char === 9 || char === 32;
    }
    function removeHTTPWhitespace(str, leading = true, trailing = true) {
      return removeChars(str, leading, trailing, isHTTPWhiteSpace);
    }
    function isASCIIWhitespace(char) {
      return char === 13 || char === 10 || char === 9 || char === 12 || char === 32;
    }
    function removeASCIIWhitespace(str, leading = true, trailing = true) {
      return removeChars(str, leading, trailing, isASCIIWhitespace);
    }
    function removeChars(str, leading, trailing, predicate) {
      let lead = 0;
      let trail = str.length - 1;
      if (leading) {
        while (lead < str.length && predicate(str.charCodeAt(lead))) lead++;
      }
      if (trailing) {
        while (trail > 0 && predicate(str.charCodeAt(trail))) trail--;
      }
      return lead === 0 && trail === str.length - 1 ? str : str.slice(lead, trail + 1);
    }
    function isomorphicDecode(input) {
      const length = input.length;
      if ((2 << 15) - 1 > length) {
        return String.fromCharCode.apply(null, input);
      }
      let result = "";
      let i = 0;
      let addition = (2 << 15) - 1;
      while (i < length) {
        if (i + addition > length) {
          addition = length - i;
        }
        result += String.fromCharCode.apply(null, input.subarray(i, i += addition));
      }
      return result;
    }
    function minimizeSupportedMimeType(mimeType) {
      switch (mimeType.essence) {
        case "application/ecmascript":
        case "application/javascript":
        case "application/x-ecmascript":
        case "application/x-javascript":
        case "text/ecmascript":
        case "text/javascript":
        case "text/javascript1.0":
        case "text/javascript1.1":
        case "text/javascript1.2":
        case "text/javascript1.3":
        case "text/javascript1.4":
        case "text/javascript1.5":
        case "text/jscript":
        case "text/livescript":
        case "text/x-ecmascript":
        case "text/x-javascript":
          return "text/javascript";
        case "application/json":
        case "text/json":
          return "application/json";
        case "image/svg+xml":
          return "image/svg+xml";
        case "text/xml":
        case "application/xml":
          return "application/xml";
      }
      if (mimeType.subtype.endsWith("+json")) {
        return "application/json";
      }
      if (mimeType.subtype.endsWith("+xml")) {
        return "application/xml";
      }
      return "";
    }
    module2.exports = {
      dataURLProcessor,
      URLSerializer,
      collectASequenceOfCodePoints,
      collectASequenceOfCodePointsFast,
      stringPercentDecode,
      parseMIMEType,
      collectAnHTTPQuotedString,
      serializeAMimeType,
      removeChars,
      removeHTTPWhitespace,
      minimizeSupportedMimeType,
      HTTP_TOKEN_CODEPOINTS,
      isomorphicDecode
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/fetch/webidl.js
var require_webidl = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/fetch/webidl.js"(exports2, module2) {
    "use strict";
    var { types, inspect } = require_node_util();
    var { markAsUncloneable } = require_node_worker_threads();
    var { toUSVString } = require_util2();
    var webidl = {};
    webidl.converters = {};
    webidl.util = {};
    webidl.errors = {};
    webidl.errors.exception = function(message) {
      return new TypeError(`${message.header}: ${message.message}`);
    };
    webidl.errors.conversionFailed = function(context) {
      const plural = context.types.length === 1 ? "" : " one of";
      const message = `${context.argument} could not be converted to${plural}: ${context.types.join(", ")}.`;
      return webidl.errors.exception({
        header: context.prefix,
        message
      });
    };
    webidl.errors.invalidArgument = function(context) {
      return webidl.errors.exception({
        header: context.prefix,
        message: `"${context.value}" is an invalid ${context.type}.`
      });
    };
    webidl.brandCheck = function(V, I, opts) {
      if ((opts == null ? void 0 : opts.strict) !== false) {
        if (!(V instanceof I)) {
          const err = new TypeError("Illegal invocation");
          err.code = "ERR_INVALID_THIS";
          throw err;
        }
      } else {
        if ((V == null ? void 0 : V[Symbol.toStringTag]) !== I.prototype[Symbol.toStringTag]) {
          const err = new TypeError("Illegal invocation");
          err.code = "ERR_INVALID_THIS";
          throw err;
        }
      }
    };
    webidl.argumentLengthCheck = function({ length }, min, ctx) {
      if (length < min) {
        throw webidl.errors.exception({
          message: `${min} argument${min !== 1 ? "s" : ""} required, but${length ? " only" : ""} ${length} found.`,
          header: ctx
        });
      }
    };
    webidl.illegalConstructor = function() {
      throw webidl.errors.exception({
        header: "TypeError",
        message: "Illegal constructor"
      });
    };
    webidl.util.Type = function(V) {
      switch (typeof V) {
        case "undefined":
          return "Undefined";
        case "boolean":
          return "Boolean";
        case "string":
          return "String";
        case "symbol":
          return "Symbol";
        case "number":
          return "Number";
        case "bigint":
          return "BigInt";
        case "function":
        case "object": {
          if (V === null) {
            return "Null";
          }
          return "Object";
        }
      }
    };
    webidl.util.markAsUncloneable = markAsUncloneable || (() => {
    });
    webidl.util.ConvertToInt = function(V, bitLength, signedness, opts) {
      let upperBound;
      let lowerBound;
      if (bitLength === 64) {
        upperBound = Math.pow(2, 53) - 1;
        if (signedness === "unsigned") {
          lowerBound = 0;
        } else {
          lowerBound = Math.pow(-2, 53) + 1;
        }
      } else if (signedness === "unsigned") {
        lowerBound = 0;
        upperBound = Math.pow(2, bitLength) - 1;
      } else {
        lowerBound = Math.pow(-2, bitLength) - 1;
        upperBound = Math.pow(2, bitLength - 1) - 1;
      }
      let x = Number(V);
      if (x === 0) {
        x = 0;
      }
      if ((opts == null ? void 0 : opts.enforceRange) === true) {
        if (Number.isNaN(x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) {
          throw webidl.errors.exception({
            header: "Integer conversion",
            message: `Could not convert ${webidl.util.Stringify(V)} to an integer.`
          });
        }
        x = webidl.util.IntegerPart(x);
        if (x < lowerBound || x > upperBound) {
          throw webidl.errors.exception({
            header: "Integer conversion",
            message: `Value must be between ${lowerBound}-${upperBound}, got ${x}.`
          });
        }
        return x;
      }
      if (!Number.isNaN(x) && (opts == null ? void 0 : opts.clamp) === true) {
        x = Math.min(Math.max(x, lowerBound), upperBound);
        if (Math.floor(x) % 2 === 0) {
          x = Math.floor(x);
        } else {
          x = Math.ceil(x);
        }
        return x;
      }
      if (Number.isNaN(x) || x === 0 && Object.is(0, x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) {
        return 0;
      }
      x = webidl.util.IntegerPart(x);
      x = x % Math.pow(2, bitLength);
      if (signedness === "signed" && x >= Math.pow(2, bitLength) - 1) {
        return x - Math.pow(2, bitLength);
      }
      return x;
    };
    webidl.util.IntegerPart = function(n) {
      const r = Math.floor(Math.abs(n));
      if (n < 0) {
        return -1 * r;
      }
      return r;
    };
    webidl.util.Stringify = function(V) {
      const type = webidl.util.Type(V);
      switch (type) {
        case "Symbol":
          return `Symbol(${V.description})`;
        case "Object":
          return inspect(V);
        case "String":
          return `"${V}"`;
        default:
          return `${V}`;
      }
    };
    webidl.sequenceConverter = function(converter) {
      return (V, prefix, argument, Iterable) => {
        var _a;
        if (webidl.util.Type(V) !== "Object") {
          throw webidl.errors.exception({
            header: prefix,
            message: `${argument} (${webidl.util.Stringify(V)}) is not iterable.`
          });
        }
        const method = typeof Iterable === "function" ? Iterable() : (_a = V == null ? void 0 : V[Symbol.iterator]) == null ? void 0 : _a.call(V);
        const seq = [];
        let index = 0;
        if (method === void 0 || typeof method.next !== "function") {
          throw webidl.errors.exception({
            header: prefix,
            message: `${argument} is not iterable.`
          });
        }
        while (true) {
          const { done, value } = method.next();
          if (done) {
            break;
          }
          seq.push(converter(value, prefix, `${argument}[${index++}]`));
        }
        return seq;
      };
    };
    webidl.recordConverter = function(keyConverter, valueConverter) {
      return (O, prefix, argument) => {
        if (webidl.util.Type(O) !== "Object") {
          throw webidl.errors.exception({
            header: prefix,
            message: `${argument} ("${webidl.util.Type(O)}") is not an Object.`
          });
        }
        const result = {};
        if (!types.isProxy(O)) {
          const keys2 = [...Object.getOwnPropertyNames(O), ...Object.getOwnPropertySymbols(O)];
          for (const key of keys2) {
            const typedKey = keyConverter(key, prefix, argument);
            const typedValue = valueConverter(O[key], prefix, argument);
            result[typedKey] = typedValue;
          }
          return result;
        }
        const keys = Reflect.ownKeys(O);
        for (const key of keys) {
          const desc = Reflect.getOwnPropertyDescriptor(O, key);
          if (desc == null ? void 0 : desc.enumerable) {
            const typedKey = keyConverter(key, prefix, argument);
            const typedValue = valueConverter(O[key], prefix, argument);
            result[typedKey] = typedValue;
          }
        }
        return result;
      };
    };
    webidl.interfaceConverter = function(i) {
      return (V, prefix, argument, opts) => {
        if ((opts == null ? void 0 : opts.strict) !== false && !(V instanceof i)) {
          throw webidl.errors.exception({
            header: prefix,
            message: `Expected ${argument} ("${webidl.util.Stringify(V)}") to be an instance of ${i.name}.`
          });
        }
        return V;
      };
    };
    webidl.dictionaryConverter = function(converters) {
      return (dictionary, prefix, argument) => {
        const type = webidl.util.Type(dictionary);
        const dict = {};
        if (type === "Null" || type === "Undefined") {
          return dict;
        } else if (type !== "Object") {
          throw webidl.errors.exception({
            header: prefix,
            message: `Expected ${dictionary} to be one of: Null, Undefined, Object.`
          });
        }
        for (const options of converters) {
          const { key, defaultValue, required, converter } = options;
          if (required === true) {
            if (!Object.hasOwn(dictionary, key)) {
              throw webidl.errors.exception({
                header: prefix,
                message: `Missing required key "${key}".`
              });
            }
          }
          let value = dictionary[key];
          const hasDefault = Object.hasOwn(options, "defaultValue");
          if (hasDefault && value !== null) {
            value ?? (value = defaultValue());
          }
          if (required || hasDefault || value !== void 0) {
            value = converter(value, prefix, `${argument}.${key}`);
            if (options.allowedValues && !options.allowedValues.includes(value)) {
              throw webidl.errors.exception({
                header: prefix,
                message: `${value} is not an accepted type. Expected one of ${options.allowedValues.join(", ")}.`
              });
            }
            dict[key] = value;
          }
        }
        return dict;
      };
    };
    webidl.nullableConverter = function(converter) {
      return (V, prefix, argument) => {
        if (V === null) {
          return V;
        }
        return converter(V, prefix, argument);
      };
    };
    webidl.converters.DOMString = function(V, prefix, argument, opts) {
      if (V === null && (opts == null ? void 0 : opts.legacyNullToEmptyString)) {
        return "";
      }
      if (typeof V === "symbol") {
        throw webidl.errors.exception({
          header: prefix,
          message: `${argument} is a symbol, which cannot be converted to a DOMString.`
        });
      }
      return String(V);
    };
    webidl.converters.ByteString = function(V, prefix, argument) {
      const x = webidl.converters.DOMString(V, prefix, argument);
      for (let index = 0; index < x.length; index++) {
        if (x.charCodeAt(index) > 255) {
          throw new TypeError(
            `Cannot convert argument to a ByteString because the character at index ${index} has a value of ${x.charCodeAt(index)} which is greater than 255.`
          );
        }
      }
      return x;
    };
    webidl.converters.USVString = toUSVString;
    webidl.converters.boolean = function(V) {
      const x = Boolean(V);
      return x;
    };
    webidl.converters.any = function(V) {
      return V;
    };
    webidl.converters["long long"] = function(V, prefix, argument) {
      const x = webidl.util.ConvertToInt(V, 64, "signed", void 0, prefix, argument);
      return x;
    };
    webidl.converters["unsigned long long"] = function(V, prefix, argument) {
      const x = webidl.util.ConvertToInt(V, 64, "unsigned", void 0, prefix, argument);
      return x;
    };
    webidl.converters["unsigned long"] = function(V, prefix, argument) {
      const x = webidl.util.ConvertToInt(V, 32, "unsigned", void 0, prefix, argument);
      return x;
    };
    webidl.converters["unsigned short"] = function(V, prefix, argument, opts) {
      const x = webidl.util.ConvertToInt(V, 16, "unsigned", opts, prefix, argument);
      return x;
    };
    webidl.converters.ArrayBuffer = function(V, prefix, argument, opts) {
      if (webidl.util.Type(V) !== "Object" || !types.isAnyArrayBuffer(V)) {
        throw webidl.errors.conversionFailed({
          prefix,
          argument: `${argument} ("${webidl.util.Stringify(V)}")`,
          types: ["ArrayBuffer"]
        });
      }
      if ((opts == null ? void 0 : opts.allowShared) === false && types.isSharedArrayBuffer(V)) {
        throw webidl.errors.exception({
          header: "ArrayBuffer",
          message: "SharedArrayBuffer is not allowed."
        });
      }
      if (V.resizable || V.growable) {
        throw webidl.errors.exception({
          header: "ArrayBuffer",
          message: "Received a resizable ArrayBuffer."
        });
      }
      return V;
    };
    webidl.converters.TypedArray = function(V, T, prefix, name, opts) {
      if (webidl.util.Type(V) !== "Object" || !types.isTypedArray(V) || V.constructor.name !== T.name) {
        throw webidl.errors.conversionFailed({
          prefix,
          argument: `${name} ("${webidl.util.Stringify(V)}")`,
          types: [T.name]
        });
      }
      if ((opts == null ? void 0 : opts.allowShared) === false && types.isSharedArrayBuffer(V.buffer)) {
        throw webidl.errors.exception({
          header: "ArrayBuffer",
          message: "SharedArrayBuffer is not allowed."
        });
      }
      if (V.buffer.resizable || V.buffer.growable) {
        throw webidl.errors.exception({
          header: "ArrayBuffer",
          message: "Received a resizable ArrayBuffer."
        });
      }
      return V;
    };
    webidl.converters.DataView = function(V, prefix, name, opts) {
      if (webidl.util.Type(V) !== "Object" || !types.isDataView(V)) {
        throw webidl.errors.exception({
          header: prefix,
          message: `${name} is not a DataView.`
        });
      }
      if ((opts == null ? void 0 : opts.allowShared) === false && types.isSharedArrayBuffer(V.buffer)) {
        throw webidl.errors.exception({
          header: "ArrayBuffer",
          message: "SharedArrayBuffer is not allowed."
        });
      }
      if (V.buffer.resizable || V.buffer.growable) {
        throw webidl.errors.exception({
          header: "ArrayBuffer",
          message: "Received a resizable ArrayBuffer."
        });
      }
      return V;
    };
    webidl.converters.BufferSource = function(V, prefix, name, opts) {
      if (types.isAnyArrayBuffer(V)) {
        return webidl.converters.ArrayBuffer(V, prefix, name, { ...opts, allowShared: false });
      }
      if (types.isTypedArray(V)) {
        return webidl.converters.TypedArray(V, V.constructor, prefix, name, { ...opts, allowShared: false });
      }
      if (types.isDataView(V)) {
        return webidl.converters.DataView(V, prefix, name, { ...opts, allowShared: false });
      }
      throw webidl.errors.conversionFailed({
        prefix,
        argument: `${name} ("${webidl.util.Stringify(V)}")`,
        types: ["BufferSource"]
      });
    };
    webidl.converters["sequence<ByteString>"] = webidl.sequenceConverter(
      webidl.converters.ByteString
    );
    webidl.converters["sequence<sequence<ByteString>>"] = webidl.sequenceConverter(
      webidl.converters["sequence<ByteString>"]
    );
    webidl.converters["record<ByteString, ByteString>"] = webidl.recordConverter(
      webidl.converters.ByteString,
      webidl.converters.ByteString
    );
    module2.exports = {
      webidl
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/fetch/util.js
var require_util3 = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/fetch/util.js"(exports2, module2) {
    "use strict";
    var { Transform } = require_node_stream();
    var zlib = require_node_zlib();
    var { redirectStatusSet, referrerPolicySet: referrerPolicyTokens, badPortsSet } = require_constants3();
    var { getGlobalOrigin } = require_global();
    var { collectASequenceOfCodePoints, collectAnHTTPQuotedString, removeChars, parseMIMEType } = require_data_url();
    var { performance: performance2 } = require_node_perf_hooks();
    var { isBlobLike, ReadableStreamFrom, isValidHTTPToken, normalizedMethodRecordsBase } = require_util2();
    var assert = require_node_assert();
    var { isUint8Array } = require_types();
    var { webidl } = require_webidl();
    var supportedHashes = [];
    var crypto;
    try {
      crypto = require_node_crypto();
      const possibleRelevantHashes = ["sha256", "sha384", "sha512"];
      supportedHashes = crypto.getHashes().filter((hash) => possibleRelevantHashes.includes(hash));
    } catch {
    }
    function responseURL(response) {
      const urlList = response.urlList;
      const length = urlList.length;
      return length === 0 ? null : urlList[length - 1].toString();
    }
    function responseLocationURL(response, requestFragment) {
      if (!redirectStatusSet.has(response.status)) {
        return null;
      }
      let location = response.headersList.get("location", true);
      if (location !== null && isValidHeaderValue(location)) {
        if (!isValidEncodedURL(location)) {
          location = normalizeBinaryStringToUtf8(location);
        }
        location = new URL(location, responseURL(response));
      }
      if (location && !location.hash) {
        location.hash = requestFragment;
      }
      return location;
    }
    function isValidEncodedURL(url) {
      for (let i = 0; i < url.length; ++i) {
        const code = url.charCodeAt(i);
        if (code > 126 || // Non-US-ASCII + DEL
        code < 32) {
          return false;
        }
      }
      return true;
    }
    function normalizeBinaryStringToUtf8(value) {
      return Buffer.from(value, "binary").toString("utf8");
    }
    function requestCurrentURL(request) {
      return request.urlList[request.urlList.length - 1];
    }
    function requestBadPort(request) {
      const url = requestCurrentURL(request);
      if (urlIsHttpHttpsScheme(url) && badPortsSet.has(url.port)) {
        return "blocked";
      }
      return "allowed";
    }
    function isErrorLike(object) {
      var _a, _b;
      return object instanceof Error || (((_a = object == null ? void 0 : object.constructor) == null ? void 0 : _a.name) === "Error" || ((_b = object == null ? void 0 : object.constructor) == null ? void 0 : _b.name) === "DOMException");
    }
    function isValidReasonPhrase(statusText) {
      for (let i = 0; i < statusText.length; ++i) {
        const c = statusText.charCodeAt(i);
        if (!(c === 9 || // HTAB
        c >= 32 && c <= 126 || // SP / VCHAR
        c >= 128 && c <= 255)) {
          return false;
        }
      }
      return true;
    }
    var isValidHeaderName = isValidHTTPToken;
    function isValidHeaderValue(potentialValue) {
      return (potentialValue[0] === "	" || potentialValue[0] === " " || potentialValue[potentialValue.length - 1] === "	" || potentialValue[potentialValue.length - 1] === " " || potentialValue.includes("\n") || potentialValue.includes("\r") || potentialValue.includes("\0")) === false;
    }
    function setRequestReferrerPolicyOnRedirect(request, actualResponse) {
      const { headersList } = actualResponse;
      const policyHeader = (headersList.get("referrer-policy", true) ?? "").split(",");
      let policy = "";
      if (policyHeader.length > 0) {
        for (let i = policyHeader.length; i !== 0; i--) {
          const token = policyHeader[i - 1].trim();
          if (referrerPolicyTokens.has(token)) {
            policy = token;
            break;
          }
        }
      }
      if (policy !== "") {
        request.referrerPolicy = policy;
      }
    }
    function crossOriginResourcePolicyCheck() {
      return "allowed";
    }
    function corsCheck() {
      return "success";
    }
    function TAOCheck() {
      return "success";
    }
    function appendFetchMetadata(httpRequest) {
      let header = null;
      header = httpRequest.mode;
      httpRequest.headersList.set("sec-fetch-mode", header, true);
    }
    function appendRequestOriginHeader(request) {
      let serializedOrigin = request.origin;
      if (serializedOrigin === "client" || serializedOrigin === void 0) {
        return;
      }
      if (request.responseTainting === "cors" || request.mode === "websocket") {
        request.headersList.append("origin", serializedOrigin, true);
      } else if (request.method !== "GET" && request.method !== "HEAD") {
        switch (request.referrerPolicy) {
          case "no-referrer":
            serializedOrigin = null;
            break;
          case "no-referrer-when-downgrade":
          case "strict-origin":
          case "strict-origin-when-cross-origin":
            if (request.origin && urlHasHttpsScheme(request.origin) && !urlHasHttpsScheme(requestCurrentURL(request))) {
              serializedOrigin = null;
            }
            break;
          case "same-origin":
            if (!sameOrigin(request, requestCurrentURL(request))) {
              serializedOrigin = null;
            }
            break;
          default:
        }
        request.headersList.append("origin", serializedOrigin, true);
      }
    }
    function coarsenTime(timestamp, crossOriginIsolatedCapability) {
      return timestamp;
    }
    function clampAndCoarsenConnectionTimingInfo(connectionTimingInfo, defaultStartTime, crossOriginIsolatedCapability) {
      if (!(connectionTimingInfo == null ? void 0 : connectionTimingInfo.startTime) || connectionTimingInfo.startTime < defaultStartTime) {
        return {
          domainLookupStartTime: defaultStartTime,
          domainLookupEndTime: defaultStartTime,
          connectionStartTime: defaultStartTime,
          connectionEndTime: defaultStartTime,
          secureConnectionStartTime: defaultStartTime,
          ALPNNegotiatedProtocol: connectionTimingInfo == null ? void 0 : connectionTimingInfo.ALPNNegotiatedProtocol
        };
      }
      return {
        domainLookupStartTime: coarsenTime(connectionTimingInfo.domainLookupStartTime, crossOriginIsolatedCapability),
        domainLookupEndTime: coarsenTime(connectionTimingInfo.domainLookupEndTime, crossOriginIsolatedCapability),
        connectionStartTime: coarsenTime(connectionTimingInfo.connectionStartTime, crossOriginIsolatedCapability),
        connectionEndTime: coarsenTime(connectionTimingInfo.connectionEndTime, crossOriginIsolatedCapability),
        secureConnectionStartTime: coarsenTime(connectionTimingInfo.secureConnectionStartTime, crossOriginIsolatedCapability),
        ALPNNegotiatedProtocol: connectionTimingInfo.ALPNNegotiatedProtocol
      };
    }
    function coarsenedSharedCurrentTime(crossOriginIsolatedCapability) {
      return coarsenTime(performance2.now(), crossOriginIsolatedCapability);
    }
    function createOpaqueTimingInfo(timingInfo) {
      return {
        startTime: timingInfo.startTime ?? 0,
        redirectStartTime: 0,
        redirectEndTime: 0,
        postRedirectStartTime: timingInfo.startTime ?? 0,
        finalServiceWorkerStartTime: 0,
        finalNetworkResponseStartTime: 0,
        finalNetworkRequestStartTime: 0,
        endTime: 0,
        encodedBodySize: 0,
        decodedBodySize: 0,
        finalConnectionTimingInfo: null
      };
    }
    function makePolicyContainer() {
      return {
        referrerPolicy: "strict-origin-when-cross-origin"
      };
    }
    function clonePolicyContainer(policyContainer) {
      return {
        referrerPolicy: policyContainer.referrerPolicy
      };
    }
    function determineRequestsReferrer(request) {
      const policy = request.referrerPolicy;
      assert(policy);
      let referrerSource = null;
      if (request.referrer === "client") {
        const globalOrigin = getGlobalOrigin();
        if (!globalOrigin || globalOrigin.origin === "null") {
          return "no-referrer";
        }
        referrerSource = new URL(globalOrigin);
      } else if (request.referrer instanceof URL) {
        referrerSource = request.referrer;
      }
      let referrerURL = stripURLForReferrer(referrerSource);
      const referrerOrigin = stripURLForReferrer(referrerSource, true);
      if (referrerURL.toString().length > 4096) {
        referrerURL = referrerOrigin;
      }
      const areSameOrigin = sameOrigin(request, referrerURL);
      const isNonPotentiallyTrustWorthy = isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(request.url);
      switch (policy) {
        case "origin":
          return referrerOrigin != null ? referrerOrigin : stripURLForReferrer(referrerSource, true);
        case "unsafe-url":
          return referrerURL;
        case "same-origin":
          return areSameOrigin ? referrerOrigin : "no-referrer";
        case "origin-when-cross-origin":
          return areSameOrigin ? referrerURL : referrerOrigin;
        case "strict-origin-when-cross-origin": {
          const currentURL = requestCurrentURL(request);
          if (sameOrigin(referrerURL, currentURL)) {
            return referrerURL;
          }
          if (isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL)) {
            return "no-referrer";
          }
          return referrerOrigin;
        }
        case "strict-origin":
        case "no-referrer-when-downgrade":
        default:
          return isNonPotentiallyTrustWorthy ? "no-referrer" : referrerOrigin;
      }
    }
    function stripURLForReferrer(url, originOnly) {
      assert(url instanceof URL);
      url = new URL(url);
      if (url.protocol === "file:" || url.protocol === "about:" || url.protocol === "blank:") {
        return "no-referrer";
      }
      url.username = "";
      url.password = "";
      url.hash = "";
      if (originOnly) {
        url.pathname = "";
        url.search = "";
      }
      return url;
    }
    function isURLPotentiallyTrustworthy(url) {
      if (!(url instanceof URL)) {
        return false;
      }
      if (url.href === "about:blank" || url.href === "about:srcdoc") {
        return true;
      }
      if (url.protocol === "data:") return true;
      if (url.protocol === "file:") return true;
      return isOriginPotentiallyTrustworthy(url.origin);
      function isOriginPotentiallyTrustworthy(origin) {
        if (origin == null || origin === "null") return false;
        const originAsURL = new URL(origin);
        if (originAsURL.protocol === "https:" || originAsURL.protocol === "wss:") {
          return true;
        }
        if (/^127(?:\.[0-9]+){0,2}\.[0-9]+$|^\[(?:0*:)*?:?0*1\]$/.test(originAsURL.hostname) || (originAsURL.hostname === "localhost" || originAsURL.hostname.includes("localhost.")) || originAsURL.hostname.endsWith(".localhost")) {
          return true;
        }
        return false;
      }
    }
    function bytesMatch(bytes, metadataList) {
      if (crypto === void 0) {
        return true;
      }
      const parsedMetadata = parseMetadata(metadataList);
      if (parsedMetadata === "no metadata") {
        return true;
      }
      if (parsedMetadata.length === 0) {
        return true;
      }
      const strongest = getStrongestMetadata(parsedMetadata);
      const metadata = filterMetadataListByAlgorithm(parsedMetadata, strongest);
      for (const item of metadata) {
        const algorithm = item.algo;
        const expectedValue = item.hash;
        let actualValue = crypto.createHash(algorithm).update(bytes).digest("base64");
        if (actualValue[actualValue.length - 1] === "=") {
          if (actualValue[actualValue.length - 2] === "=") {
            actualValue = actualValue.slice(0, -2);
          } else {
            actualValue = actualValue.slice(0, -1);
          }
        }
        if (compareBase64Mixed(actualValue, expectedValue)) {
          return true;
        }
      }
      return false;
    }
    var parseHashWithOptions = /(?<algo>sha256|sha384|sha512)-((?<hash>[A-Za-z0-9+/]+|[A-Za-z0-9_-]+)={0,2}(?:\s|$)( +[!-~]*)?)?/i;
    function parseMetadata(metadata) {
      const result = [];
      let empty = true;
      for (const token of metadata.split(" ")) {
        empty = false;
        const parsedToken = parseHashWithOptions.exec(token);
        if (parsedToken === null || parsedToken.groups === void 0 || parsedToken.groups.algo === void 0) {
          continue;
        }
        const algorithm = parsedToken.groups.algo.toLowerCase();
        if (supportedHashes.includes(algorithm)) {
          result.push(parsedToken.groups);
        }
      }
      if (empty === true) {
        return "no metadata";
      }
      return result;
    }
    function getStrongestMetadata(metadataList) {
      let algorithm = metadataList[0].algo;
      if (algorithm[3] === "5") {
        return algorithm;
      }
      for (let i = 1; i < metadataList.length; ++i) {
        const metadata = metadataList[i];
        if (metadata.algo[3] === "5") {
          algorithm = "sha512";
          break;
        } else if (algorithm[3] === "3") {
          continue;
        } else if (metadata.algo[3] === "3") {
          algorithm = "sha384";
        }
      }
      return algorithm;
    }
    function filterMetadataListByAlgorithm(metadataList, algorithm) {
      if (metadataList.length === 1) {
        return metadataList;
      }
      let pos = 0;
      for (let i = 0; i < metadataList.length; ++i) {
        if (metadataList[i].algo === algorithm) {
          metadataList[pos++] = metadataList[i];
        }
      }
      metadataList.length = pos;
      return metadataList;
    }
    function compareBase64Mixed(actualValue, expectedValue) {
      if (actualValue.length !== expectedValue.length) {
        return false;
      }
      for (let i = 0; i < actualValue.length; ++i) {
        if (actualValue[i] !== expectedValue[i]) {
          if (actualValue[i] === "+" && expectedValue[i] === "-" || actualValue[i] === "/" && expectedValue[i] === "_") {
            continue;
          }
          return false;
        }
      }
      return true;
    }
    function tryUpgradeRequestToAPotentiallyTrustworthyURL(request) {
    }
    function sameOrigin(A, B) {
      if (A.origin === B.origin && A.origin === "null") {
        return true;
      }
      if (A.protocol === B.protocol && A.hostname === B.hostname && A.port === B.port) {
        return true;
      }
      return false;
    }
    function createDeferredPromise() {
      let res;
      let rej;
      const promise = new Promise((resolve, reject) => {
        res = resolve;
        rej = reject;
      });
      return { promise, resolve: res, reject: rej };
    }
    function isAborted(fetchParams) {
      return fetchParams.controller.state === "aborted";
    }
    function isCancelled(fetchParams) {
      return fetchParams.controller.state === "aborted" || fetchParams.controller.state === "terminated";
    }
    function normalizeMethod(method) {
      return normalizedMethodRecordsBase[method.toLowerCase()] ?? method;
    }
    function serializeJavascriptValueToJSONString(value) {
      const result = JSON.stringify(value);
      if (result === void 0) {
        throw new TypeError("Value is not JSON serializable");
      }
      assert(typeof result === "string");
      return result;
    }
    var esIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));
    function createIterator(name, kInternalIterator, keyIndex = 0, valueIndex = 1) {
      var _target, _kind, _index;
      class FastIterableIterator {
        /**
         * @see https://webidl.spec.whatwg.org/#dfn-default-iterator-object
         * @param {unknown} target
         * @param {'key' | 'value' | 'key+value'} kind
         */
        constructor(target, kind) {
          /** @type {any} */
          __privateAdd(this, _target);
          /** @type {'key' | 'value' | 'key+value'} */
          __privateAdd(this, _kind);
          /** @type {number} */
          __privateAdd(this, _index);
          __privateSet(this, _target, target);
          __privateSet(this, _kind, kind);
          __privateSet(this, _index, 0);
        }
        next() {
          if (typeof this !== "object" || this === null || !__privateIn(_target, this)) {
            throw new TypeError(
              `'next' called on an object that does not implement interface ${name} Iterator.`
            );
          }
          const index = __privateGet(this, _index);
          const values = __privateGet(this, _target)[kInternalIterator];
          const len = values.length;
          if (index >= len) {
            return {
              value: void 0,
              done: true
            };
          }
          const { [keyIndex]: key, [valueIndex]: value } = values[index];
          __privateSet(this, _index, index + 1);
          let result;
          switch (__privateGet(this, _kind)) {
            case "key":
              result = key;
              break;
            case "value":
              result = value;
              break;
            case "key+value":
              result = [key, value];
              break;
          }
          return {
            value: result,
            done: false
          };
        }
      }
      _target = new WeakMap();
      _kind = new WeakMap();
      _index = new WeakMap();
      delete FastIterableIterator.prototype.constructor;
      Object.setPrototypeOf(FastIterableIterator.prototype, esIteratorPrototype);
      Object.defineProperties(FastIterableIterator.prototype, {
        [Symbol.toStringTag]: {
          writable: false,
          enumerable: false,
          configurable: true,
          value: `${name} Iterator`
        },
        next: { writable: true, enumerable: true, configurable: true }
      });
      return function(target, kind) {
        return new FastIterableIterator(target, kind);
      };
    }
    function iteratorMixin(name, object, kInternalIterator, keyIndex = 0, valueIndex = 1) {
      const makeIterator = createIterator(name, kInternalIterator, keyIndex, valueIndex);
      const properties = {
        keys: {
          writable: true,
          enumerable: true,
          configurable: true,
          value: function keys() {
            webidl.brandCheck(this, object);
            return makeIterator(this, "key");
          }
        },
        values: {
          writable: true,
          enumerable: true,
          configurable: true,
          value: function values() {
            webidl.brandCheck(this, object);
            return makeIterator(this, "value");
          }
        },
        entries: {
          writable: true,
          enumerable: true,
          configurable: true,
          value: function entries() {
            webidl.brandCheck(this, object);
            return makeIterator(this, "key+value");
          }
        },
        forEach: {
          writable: true,
          enumerable: true,
          configurable: true,
          value: function forEach(callbackfn, thisArg = globalThis) {
            webidl.brandCheck(this, object);
            webidl.argumentLengthCheck(arguments, 1, `${name}.forEach`);
            if (typeof callbackfn !== "function") {
              throw new TypeError(
                `Failed to execute 'forEach' on '${name}': parameter 1 is not of type 'Function'.`
              );
            }
            for (const { 0: key, 1: value } of makeIterator(this, "key+value")) {
              callbackfn.call(thisArg, value, key, this);
            }
          }
        }
      };
      return Object.defineProperties(object.prototype, {
        ...properties,
        [Symbol.iterator]: {
          writable: true,
          enumerable: false,
          configurable: true,
          value: properties.entries.value
        }
      });
    }
    async function fullyReadBody(body, processBody, processBodyError) {
      const successSteps = processBody;
      const errorSteps = processBodyError;
      let reader;
      try {
        reader = body.stream.getReader();
      } catch (e) {
        errorSteps(e);
        return;
      }
      try {
        successSteps(await readAllBytes(reader));
      } catch (e) {
        errorSteps(e);
      }
    }
    function isReadableStreamLike(stream) {
      return stream instanceof ReadableStream || stream[Symbol.toStringTag] === "ReadableStream" && typeof stream.tee === "function";
    }
    function readableStreamClose(controller) {
      var _a;
      try {
        controller.close();
        (_a = controller.byobRequest) == null ? void 0 : _a.respond(0);
      } catch (err) {
        if (!err.message.includes("Controller is already closed") && !err.message.includes("ReadableStream is already closed")) {
          throw err;
        }
      }
    }
    var invalidIsomorphicEncodeValueRegex = /[^\x00-\xFF]/;
    function isomorphicEncode(input) {
      assert(!invalidIsomorphicEncodeValueRegex.test(input));
      return input;
    }
    async function readAllBytes(reader) {
      const bytes = [];
      let byteLength = 0;
      while (true) {
        const { done, value: chunk } = await reader.read();
        if (done) {
          return Buffer.concat(bytes, byteLength);
        }
        if (!isUint8Array(chunk)) {
          throw new TypeError("Received non-Uint8Array chunk");
        }
        bytes.push(chunk);
        byteLength += chunk.length;
      }
    }
    function urlIsLocal(url) {
      assert("protocol" in url);
      const protocol = url.protocol;
      return protocol === "about:" || protocol === "blob:" || protocol === "data:";
    }
    function urlHasHttpsScheme(url) {
      return typeof url === "string" && url[5] === ":" && url[0] === "h" && url[1] === "t" && url[2] === "t" && url[3] === "p" && url[4] === "s" || url.protocol === "https:";
    }
    function urlIsHttpHttpsScheme(url) {
      assert("protocol" in url);
      const protocol = url.protocol;
      return protocol === "http:" || protocol === "https:";
    }
    function simpleRangeHeaderValue(value, allowWhitespace) {
      const data = value;
      if (!data.startsWith("bytes")) {
        return "failure";
      }
      const position = { position: 5 };
      if (allowWhitespace) {
        collectASequenceOfCodePoints(
          (char) => char === "	" || char === " ",
          data,
          position
        );
      }
      if (data.charCodeAt(position.position) !== 61) {
        return "failure";
      }
      position.position++;
      if (allowWhitespace) {
        collectASequenceOfCodePoints(
          (char) => char === "	" || char === " ",
          data,
          position
        );
      }
      const rangeStart = collectASequenceOfCodePoints(
        (char) => {
          const code = char.charCodeAt(0);
          return code >= 48 && code <= 57;
        },
        data,
        position
      );
      const rangeStartValue = rangeStart.length ? Number(rangeStart) : null;
      if (allowWhitespace) {
        collectASequenceOfCodePoints(
          (char) => char === "	" || char === " ",
          data,
          position
        );
      }
      if (data.charCodeAt(position.position) !== 45) {
        return "failure";
      }
      position.position++;
      if (allowWhitespace) {
        collectASequenceOfCodePoints(
          (char) => char === "	" || char === " ",
          data,
          position
        );
      }
      const rangeEnd = collectASequenceOfCodePoints(
        (char) => {
          const code = char.charCodeAt(0);
          return code >= 48 && code <= 57;
        },
        data,
        position
      );
      const rangeEndValue = rangeEnd.length ? Number(rangeEnd) : null;
      if (position.position < data.length) {
        return "failure";
      }
      if (rangeEndValue === null && rangeStartValue === null) {
        return "failure";
      }
      if (rangeStartValue > rangeEndValue) {
        return "failure";
      }
      return { rangeStartValue, rangeEndValue };
    }
    function buildContentRange(rangeStart, rangeEnd, fullLength) {
      let contentRange = "bytes ";
      contentRange += isomorphicEncode(`${rangeStart}`);
      contentRange += "-";
      contentRange += isomorphicEncode(`${rangeEnd}`);
      contentRange += "/";
      contentRange += isomorphicEncode(`${fullLength}`);
      return contentRange;
    }
    var _zlibOptions;
    var InflateStream = class extends Transform {
      /** @param {zlib.ZlibOptions} [zlibOptions] */
      constructor(zlibOptions) {
        super();
        __privateAdd(this, _zlibOptions);
        __privateSet(this, _zlibOptions, zlibOptions);
      }
      _transform(chunk, encoding, callback) {
        if (!this._inflateStream) {
          if (chunk.length === 0) {
            callback();
            return;
          }
          this._inflateStream = (chunk[0] & 15) === 8 ? zlib.createInflate(__privateGet(this, _zlibOptions)) : zlib.createInflateRaw(__privateGet(this, _zlibOptions));
          this._inflateStream.on("data", this.push.bind(this));
          this._inflateStream.on("end", () => this.push(null));
          this._inflateStream.on("error", (err) => this.destroy(err));
        }
        this._inflateStream.write(chunk, encoding, callback);
      }
      _final(callback) {
        if (this._inflateStream) {
          this._inflateStream.end();
          this._inflateStream = null;
        }
        callback();
      }
    };
    _zlibOptions = new WeakMap();
    function createInflate(zlibOptions) {
      return new InflateStream(zlibOptions);
    }
    function extractMimeType(headers) {
      let charset = null;
      let essence = null;
      let mimeType = null;
      const values = getDecodeSplit("content-type", headers);
      if (values === null) {
        return "failure";
      }
      for (const value of values) {
        const temporaryMimeType = parseMIMEType(value);
        if (temporaryMimeType === "failure" || temporaryMimeType.essence === "*/*") {
          continue;
        }
        mimeType = temporaryMimeType;
        if (mimeType.essence !== essence) {
          charset = null;
          if (mimeType.parameters.has("charset")) {
            charset = mimeType.parameters.get("charset");
          }
          essence = mimeType.essence;
        } else if (!mimeType.parameters.has("charset") && charset !== null) {
          mimeType.parameters.set("charset", charset);
        }
      }
      if (mimeType == null) {
        return "failure";
      }
      return mimeType;
    }
    function gettingDecodingSplitting(value) {
      const input = value;
      const position = { position: 0 };
      const values = [];
      let temporaryValue = "";
      while (position.position < input.length) {
        temporaryValue += collectASequenceOfCodePoints(
          (char) => char !== '"' && char !== ",",
          input,
          position
        );
        if (position.position < input.length) {
          if (input.charCodeAt(position.position) === 34) {
            temporaryValue += collectAnHTTPQuotedString(
              input,
              position
            );
            if (position.position < input.length) {
              continue;
            }
          } else {
            assert(input.charCodeAt(position.position) === 44);
            position.position++;
          }
        }
        temporaryValue = removeChars(temporaryValue, true, true, (char) => char === 9 || char === 32);
        values.push(temporaryValue);
        temporaryValue = "";
      }
      return values;
    }
    function getDecodeSplit(name, list) {
      const value = list.get(name, true);
      if (value === null) {
        return null;
      }
      return gettingDecodingSplitting(value);
    }
    var textDecoder = new TextDecoder();
    function utf8DecodeBytes(buffer) {
      if (buffer.length === 0) {
        return "";
      }
      if (buffer[0] === 239 && buffer[1] === 187 && buffer[2] === 191) {
        buffer = buffer.subarray(3);
      }
      const output = textDecoder.decode(buffer);
      return output;
    }
    var EnvironmentSettingsObjectBase = class {
      constructor() {
        __publicField(this, "policyContainer", makePolicyContainer());
      }
      get baseUrl() {
        return getGlobalOrigin();
      }
      get origin() {
        var _a;
        return (_a = this.baseUrl) == null ? void 0 : _a.origin;
      }
    };
    var EnvironmentSettingsObject = class {
      constructor() {
        __publicField(this, "settingsObject", new EnvironmentSettingsObjectBase());
      }
    };
    var environmentSettingsObject = new EnvironmentSettingsObject();
    module2.exports = {
      isAborted,
      isCancelled,
      isValidEncodedURL,
      createDeferredPromise,
      ReadableStreamFrom,
      tryUpgradeRequestToAPotentiallyTrustworthyURL,
      clampAndCoarsenConnectionTimingInfo,
      coarsenedSharedCurrentTime,
      determineRequestsReferrer,
      makePolicyContainer,
      clonePolicyContainer,
      appendFetchMetadata,
      appendRequestOriginHeader,
      TAOCheck,
      corsCheck,
      crossOriginResourcePolicyCheck,
      createOpaqueTimingInfo,
      setRequestReferrerPolicyOnRedirect,
      isValidHTTPToken,
      requestBadPort,
      requestCurrentURL,
      responseURL,
      responseLocationURL,
      isBlobLike,
      isURLPotentiallyTrustworthy,
      isValidReasonPhrase,
      sameOrigin,
      normalizeMethod,
      serializeJavascriptValueToJSONString,
      iteratorMixin,
      createIterator,
      isValidHeaderName,
      isValidHeaderValue,
      isErrorLike,
      fullyReadBody,
      bytesMatch,
      isReadableStreamLike,
      readableStreamClose,
      isomorphicEncode,
      urlIsLocal,
      urlHasHttpsScheme,
      urlIsHttpHttpsScheme,
      readAllBytes,
      simpleRangeHeaderValue,
      buildContentRange,
      parseMetadata,
      createInflate,
      extractMimeType,
      getDecodeSplit,
      utf8DecodeBytes,
      environmentSettingsObject
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/fetch/symbols.js
var require_symbols2 = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/fetch/symbols.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      kUrl: Symbol("url"),
      kHeaders: Symbol("headers"),
      kSignal: Symbol("signal"),
      kState: Symbol("state"),
      kDispatcher: Symbol("dispatcher")
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/fetch/file.js
var require_file = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/fetch/file.js"(exports2, module2) {
    "use strict";
    var { Blob: Blob2, File } = require_node_buffer();
    var { kState } = require_symbols2();
    var { webidl } = require_webidl();
    var FileLike = class _FileLike {
      constructor(blobLike, fileName, options = {}) {
        const n = fileName;
        const t = options.type;
        const d = options.lastModified ?? Date.now();
        this[kState] = {
          blobLike,
          name: n,
          type: t,
          lastModified: d
        };
      }
      stream(...args) {
        webidl.brandCheck(this, _FileLike);
        return this[kState].blobLike.stream(...args);
      }
      arrayBuffer(...args) {
        webidl.brandCheck(this, _FileLike);
        return this[kState].blobLike.arrayBuffer(...args);
      }
      slice(...args) {
        webidl.brandCheck(this, _FileLike);
        return this[kState].blobLike.slice(...args);
      }
      text(...args) {
        webidl.brandCheck(this, _FileLike);
        return this[kState].blobLike.text(...args);
      }
      get size() {
        webidl.brandCheck(this, _FileLike);
        return this[kState].blobLike.size;
      }
      get type() {
        webidl.brandCheck(this, _FileLike);
        return this[kState].blobLike.type;
      }
      get name() {
        webidl.brandCheck(this, _FileLike);
        return this[kState].name;
      }
      get lastModified() {
        webidl.brandCheck(this, _FileLike);
        return this[kState].lastModified;
      }
      get [Symbol.toStringTag]() {
        return "File";
      }
    };
    webidl.converters.Blob = webidl.interfaceConverter(Blob2);
    function isFileLike(object) {
      return object instanceof File || object && (typeof object.stream === "function" || typeof object.arrayBuffer === "function") && object[Symbol.toStringTag] === "File";
    }
    module2.exports = { FileLike, isFileLike };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/fetch/formdata.js
var require_formdata = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/fetch/formdata.js"(exports2, module2) {
    "use strict";
    var { isBlobLike, iteratorMixin } = require_util3();
    var { kState } = require_symbols2();
    var { kEnumerableProperty } = require_util2();
    var { FileLike, isFileLike } = require_file();
    var { webidl } = require_webidl();
    var { File: NativeFile } = require_node_buffer();
    var nodeUtil = require_node_util();
    var File = globalThis.File ?? NativeFile;
    var FormData = class _FormData {
      constructor(form) {
        webidl.util.markAsUncloneable(this);
        if (form !== void 0) {
          throw webidl.errors.conversionFailed({
            prefix: "FormData constructor",
            argument: "Argument 1",
            types: ["undefined"]
          });
        }
        this[kState] = [];
      }
      append(name, value, filename = void 0) {
        webidl.brandCheck(this, _FormData);
        const prefix = "FormData.append";
        webidl.argumentLengthCheck(arguments, 2, prefix);
        if (arguments.length === 3 && !isBlobLike(value)) {
          throw new TypeError(
            "Failed to execute 'append' on 'FormData': parameter 2 is not of type 'Blob'"
          );
        }
        name = webidl.converters.USVString(name, prefix, "name");
        value = isBlobLike(value) ? webidl.converters.Blob(value, prefix, "value", { strict: false }) : webidl.converters.USVString(value, prefix, "value");
        filename = arguments.length === 3 ? webidl.converters.USVString(filename, prefix, "filename") : void 0;
        const entry = makeEntry(name, value, filename);
        this[kState].push(entry);
      }
      delete(name) {
        webidl.brandCheck(this, _FormData);
        const prefix = "FormData.delete";
        webidl.argumentLengthCheck(arguments, 1, prefix);
        name = webidl.converters.USVString(name, prefix, "name");
        this[kState] = this[kState].filter((entry) => entry.name !== name);
      }
      get(name) {
        webidl.brandCheck(this, _FormData);
        const prefix = "FormData.get";
        webidl.argumentLengthCheck(arguments, 1, prefix);
        name = webidl.converters.USVString(name, prefix, "name");
        const idx = this[kState].findIndex((entry) => entry.name === name);
        if (idx === -1) {
          return null;
        }
        return this[kState][idx].value;
      }
      getAll(name) {
        webidl.brandCheck(this, _FormData);
        const prefix = "FormData.getAll";
        webidl.argumentLengthCheck(arguments, 1, prefix);
        name = webidl.converters.USVString(name, prefix, "name");
        return this[kState].filter((entry) => entry.name === name).map((entry) => entry.value);
      }
      has(name) {
        webidl.brandCheck(this, _FormData);
        const prefix = "FormData.has";
        webidl.argumentLengthCheck(arguments, 1, prefix);
        name = webidl.converters.USVString(name, prefix, "name");
        return this[kState].findIndex((entry) => entry.name === name) !== -1;
      }
      set(name, value, filename = void 0) {
        webidl.brandCheck(this, _FormData);
        const prefix = "FormData.set";
        webidl.argumentLengthCheck(arguments, 2, prefix);
        if (arguments.length === 3 && !isBlobLike(value)) {
          throw new TypeError(
            "Failed to execute 'set' on 'FormData': parameter 2 is not of type 'Blob'"
          );
        }
        name = webidl.converters.USVString(name, prefix, "name");
        value = isBlobLike(value) ? webidl.converters.Blob(value, prefix, "name", { strict: false }) : webidl.converters.USVString(value, prefix, "name");
        filename = arguments.length === 3 ? webidl.converters.USVString(filename, prefix, "name") : void 0;
        const entry = makeEntry(name, value, filename);
        const idx = this[kState].findIndex((entry2) => entry2.name === name);
        if (idx !== -1) {
          this[kState] = [
            ...this[kState].slice(0, idx),
            entry,
            ...this[kState].slice(idx + 1).filter((entry2) => entry2.name !== name)
          ];
        } else {
          this[kState].push(entry);
        }
      }
      [nodeUtil.inspect.custom](depth, options) {
        const state = this[kState].reduce((a, b) => {
          if (a[b.name]) {
            if (Array.isArray(a[b.name])) {
              a[b.name].push(b.value);
            } else {
              a[b.name] = [a[b.name], b.value];
            }
          } else {
            a[b.name] = b.value;
          }
          return a;
        }, { __proto__: null });
        options.depth ?? (options.depth = depth);
        options.colors ?? (options.colors = true);
        const output = nodeUtil.formatWithOptions(options, state);
        return `FormData ${output.slice(output.indexOf("]") + 2)}`;
      }
    };
    iteratorMixin("FormData", FormData, kState, "name", "value");
    Object.defineProperties(FormData.prototype, {
      append: kEnumerableProperty,
      delete: kEnumerableProperty,
      get: kEnumerableProperty,
      getAll: kEnumerableProperty,
      has: kEnumerableProperty,
      set: kEnumerableProperty,
      [Symbol.toStringTag]: {
        value: "FormData",
        configurable: true
      }
    });
    function makeEntry(name, value, filename) {
      if (typeof value === "string") {
      } else {
        if (!isFileLike(value)) {
          value = value instanceof Blob ? new File([value], "blob", { type: value.type }) : new FileLike(value, "blob", { type: value.type });
        }
        if (filename !== void 0) {
          const options = {
            type: value.type,
            lastModified: value.lastModified
          };
          value = value instanceof NativeFile ? new File([value], filename, options) : new FileLike(value, filename, options);
        }
      }
      return { name, value };
    }
    module2.exports = { FormData, makeEntry };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/fetch/formdata-parser.js
var require_formdata_parser = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/fetch/formdata-parser.js"(exports2, module2) {
    "use strict";
    var { isUSVString, bufferToLowerCasedHeaderName } = require_util2();
    var { utf8DecodeBytes } = require_util3();
    var { HTTP_TOKEN_CODEPOINTS, isomorphicDecode } = require_data_url();
    var { isFileLike } = require_file();
    var { makeEntry } = require_formdata();
    var assert = require_node_assert();
    var { File: NodeFile } = require_node_buffer();
    var File = globalThis.File ?? NodeFile;
    var formDataNameBuffer = Buffer.from('form-data; name="');
    var filenameBuffer = Buffer.from("; filename");
    var dd = Buffer.from("--");
    var ddcrlf = Buffer.from("--\r\n");
    function isAsciiString(chars) {
      for (let i = 0; i < chars.length; ++i) {
        if ((chars.charCodeAt(i) & ~127) !== 0) {
          return false;
        }
      }
      return true;
    }
    function validateBoundary(boundary) {
      const length = boundary.length;
      if (length < 27 || length > 70) {
        return false;
      }
      for (let i = 0; i < length; ++i) {
        const cp = boundary.charCodeAt(i);
        if (!(cp >= 48 && cp <= 57 || cp >= 65 && cp <= 90 || cp >= 97 && cp <= 122 || cp === 39 || cp === 45 || cp === 95)) {
          return false;
        }
      }
      return true;
    }
    function multipartFormDataParser(input, mimeType) {
      assert(mimeType !== "failure" && mimeType.essence === "multipart/form-data");
      const boundaryString = mimeType.parameters.get("boundary");
      if (boundaryString === void 0) {
        return "failure";
      }
      const boundary = Buffer.from(`--${boundaryString}`, "utf8");
      const entryList = [];
      const position = { position: 0 };
      while (input[position.position] === 13 && input[position.position + 1] === 10) {
        position.position += 2;
      }
      let trailing = input.length;
      while (input[trailing - 1] === 10 && input[trailing - 2] === 13) {
        trailing -= 2;
      }
      if (trailing !== input.length) {
        input = input.subarray(0, trailing);
      }
      while (true) {
        if (input.subarray(position.position, position.position + boundary.length).equals(boundary)) {
          position.position += boundary.length;
        } else {
          return "failure";
        }
        if (position.position === input.length - 2 && bufferStartsWith(input, dd, position) || position.position === input.length - 4 && bufferStartsWith(input, ddcrlf, position)) {
          return entryList;
        }
        if (input[position.position] !== 13 || input[position.position + 1] !== 10) {
          return "failure";
        }
        position.position += 2;
        const result = parseMultipartFormDataHeaders(input, position);
        if (result === "failure") {
          return "failure";
        }
        let { name, filename, contentType, encoding } = result;
        position.position += 2;
        let body;
        {
          const boundaryIndex = input.indexOf(boundary.subarray(2), position.position);
          if (boundaryIndex === -1) {
            return "failure";
          }
          body = input.subarray(position.position, boundaryIndex - 4);
          position.position += body.length;
          if (encoding === "base64") {
            body = Buffer.from(body.toString(), "base64");
          }
        }
        if (input[position.position] !== 13 || input[position.position + 1] !== 10) {
          return "failure";
        } else {
          position.position += 2;
        }
        let value;
        if (filename !== null) {
          contentType ?? (contentType = "text/plain");
          if (!isAsciiString(contentType)) {
            contentType = "";
          }
          value = new File([body], filename, { type: contentType });
        } else {
          value = utf8DecodeBytes(Buffer.from(body));
        }
        assert(isUSVString(name));
        assert(typeof value === "string" && isUSVString(value) || isFileLike(value));
        entryList.push(makeEntry(name, value, filename));
      }
    }
    function parseMultipartFormDataHeaders(input, position) {
      let name = null;
      let filename = null;
      let contentType = null;
      let encoding = null;
      while (true) {
        if (input[position.position] === 13 && input[position.position + 1] === 10) {
          if (name === null) {
            return "failure";
          }
          return { name, filename, contentType, encoding };
        }
        let headerName = collectASequenceOfBytes(
          (char) => char !== 10 && char !== 13 && char !== 58,
          input,
          position
        );
        headerName = removeChars(headerName, true, true, (char) => char === 9 || char === 32);
        if (!HTTP_TOKEN_CODEPOINTS.test(headerName.toString())) {
          return "failure";
        }
        if (input[position.position] !== 58) {
          return "failure";
        }
        position.position++;
        collectASequenceOfBytes(
          (char) => char === 32 || char === 9,
          input,
          position
        );
        switch (bufferToLowerCasedHeaderName(headerName)) {
          case "content-disposition": {
            name = filename = null;
            if (!bufferStartsWith(input, formDataNameBuffer, position)) {
              return "failure";
            }
            position.position += 17;
            name = parseMultipartFormDataName(input, position);
            if (name === null) {
              return "failure";
            }
            if (bufferStartsWith(input, filenameBuffer, position)) {
              let check = position.position + filenameBuffer.length;
              if (input[check] === 42) {
                position.position += 1;
                check += 1;
              }
              if (input[check] !== 61 || input[check + 1] !== 34) {
                return "failure";
              }
              position.position += 12;
              filename = parseMultipartFormDataName(input, position);
              if (filename === null) {
                return "failure";
              }
            }
            break;
          }
          case "content-type": {
            let headerValue = collectASequenceOfBytes(
              (char) => char !== 10 && char !== 13,
              input,
              position
            );
            headerValue = removeChars(headerValue, false, true, (char) => char === 9 || char === 32);
            contentType = isomorphicDecode(headerValue);
            break;
          }
          case "content-transfer-encoding": {
            let headerValue = collectASequenceOfBytes(
              (char) => char !== 10 && char !== 13,
              input,
              position
            );
            headerValue = removeChars(headerValue, false, true, (char) => char === 9 || char === 32);
            encoding = isomorphicDecode(headerValue);
            break;
          }
          default: {
            collectASequenceOfBytes(
              (char) => char !== 10 && char !== 13,
              input,
              position
            );
          }
        }
        if (input[position.position] !== 13 && input[position.position + 1] !== 10) {
          return "failure";
        } else {
          position.position += 2;
        }
      }
    }
    function parseMultipartFormDataName(input, position) {
      assert(input[position.position - 1] === 34);
      let name = collectASequenceOfBytes(
        (char) => char !== 10 && char !== 13 && char !== 34,
        input,
        position
      );
      if (input[position.position] !== 34) {
        return null;
      } else {
        position.position++;
      }
      name = new TextDecoder().decode(name).replace(/%0A/ig, "\n").replace(/%0D/ig, "\r").replace(/%22/g, '"');
      return name;
    }
    function collectASequenceOfBytes(condition, input, position) {
      let start = position.position;
      while (start < input.length && condition(input[start])) {
        ++start;
      }
      return input.subarray(position.position, position.position = start);
    }
    function removeChars(buf, leading, trailing, predicate) {
      let lead = 0;
      let trail = buf.length - 1;
      if (leading) {
        while (lead < buf.length && predicate(buf[lead])) lead++;
      }
      if (trailing) {
        while (trail > 0 && predicate(buf[trail])) trail--;
      }
      return lead === 0 && trail === buf.length - 1 ? buf : buf.subarray(lead, trail + 1);
    }
    function bufferStartsWith(buffer, start, position) {
      if (buffer.length < start.length) {
        return false;
      }
      for (let i = 0; i < start.length; i++) {
        if (start[i] !== buffer[position.position + i]) {
          return false;
        }
      }
      return true;
    }
    module2.exports = {
      multipartFormDataParser,
      validateBoundary
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/fetch/body.js
var require_body = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/fetch/body.js"(exports2, module2) {
    "use strict";
    var util = require_util2();
    var {
      ReadableStreamFrom,
      isBlobLike,
      isReadableStreamLike,
      readableStreamClose,
      createDeferredPromise,
      fullyReadBody,
      extractMimeType,
      utf8DecodeBytes
    } = require_util3();
    var { FormData } = require_formdata();
    var { kState } = require_symbols2();
    var { webidl } = require_webidl();
    var { Blob: Blob2 } = require_node_buffer();
    var assert = require_node_assert();
    var { isErrored, isDisturbed } = require_node_stream();
    var { isArrayBuffer } = require_types();
    var { serializeAMimeType } = require_data_url();
    var { multipartFormDataParser } = require_formdata_parser();
    var textEncoder = new TextEncoder();
    function noop() {
    }
    var hasFinalizationRegistry = globalThis.FinalizationRegistry && process.version.indexOf("v18") !== 0;
    var streamRegistry;
    if (hasFinalizationRegistry) {
      streamRegistry = new FinalizationRegistry((weakRef) => {
        const stream = weakRef.deref();
        if (stream && !stream.locked && !isDisturbed(stream) && !isErrored(stream)) {
          stream.cancel("Response object has been garbage collected").catch(noop);
        }
      });
    }
    function extractBody(object, keepalive = false) {
      let stream = null;
      if (object instanceof ReadableStream) {
        stream = object;
      } else if (isBlobLike(object)) {
        stream = object.stream();
      } else {
        stream = new ReadableStream({
          async pull(controller) {
            const buffer = typeof source === "string" ? textEncoder.encode(source) : source;
            if (buffer.byteLength) {
              controller.enqueue(buffer);
            }
            queueMicrotask(() => readableStreamClose(controller));
          },
          start() {
          },
          type: "bytes"
        });
      }
      assert(isReadableStreamLike(stream));
      let action = null;
      let source = null;
      let length = null;
      let type = null;
      if (typeof object === "string") {
        source = object;
        type = "text/plain;charset=UTF-8";
      } else if (object instanceof URLSearchParams) {
        source = object.toString();
        type = "application/x-www-form-urlencoded;charset=UTF-8";
      } else if (isArrayBuffer(object)) {
        source = new Uint8Array(object.slice());
      } else if (ArrayBuffer.isView(object)) {
        source = new Uint8Array(object.buffer.slice(object.byteOffset, object.byteOffset + object.byteLength));
      } else if (util.isFormDataLike(object)) {
        const boundary = `----formdata-undici-0${`${Math.floor(Math.random() * 1e11)}`.padStart(11, "0")}`;
        const prefix = `--${boundary}\r
Content-Disposition: form-data`;
        const escape = (str) => str.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22");
        const normalizeLinefeeds = (value) => value.replace(/\r?\n|\r/g, "\r\n");
        const blobParts = [];
        const rn = new Uint8Array([13, 10]);
        length = 0;
        let hasUnknownSizeValue = false;
        for (const [name, value] of object) {
          if (typeof value === "string") {
            const chunk2 = textEncoder.encode(prefix + `; name="${escape(normalizeLinefeeds(name))}"\r
\r
${normalizeLinefeeds(value)}\r
`);
            blobParts.push(chunk2);
            length += chunk2.byteLength;
          } else {
            const chunk2 = textEncoder.encode(`${prefix}; name="${escape(normalizeLinefeeds(name))}"` + (value.name ? `; filename="${escape(value.name)}"` : "") + `\r
Content-Type: ${value.type || "application/octet-stream"}\r
\r
`);
            blobParts.push(chunk2, value, rn);
            if (typeof value.size === "number") {
              length += chunk2.byteLength + value.size + rn.byteLength;
            } else {
              hasUnknownSizeValue = true;
            }
          }
        }
        const chunk = textEncoder.encode(`--${boundary}--`);
        blobParts.push(chunk);
        length += chunk.byteLength;
        if (hasUnknownSizeValue) {
          length = null;
        }
        source = object;
        action = async function* () {
          for (const part of blobParts) {
            if (part.stream) {
              yield* part.stream();
            } else {
              yield part;
            }
          }
        };
        type = `multipart/form-data; boundary=${boundary}`;
      } else if (isBlobLike(object)) {
        source = object;
        length = object.size;
        if (object.type) {
          type = object.type;
        }
      } else if (typeof object[Symbol.asyncIterator] === "function") {
        if (keepalive) {
          throw new TypeError("keepalive");
        }
        if (util.isDisturbed(object) || object.locked) {
          throw new TypeError(
            "Response body object should not be disturbed or locked"
          );
        }
        stream = object instanceof ReadableStream ? object : ReadableStreamFrom(object);
      }
      if (typeof source === "string" || util.isBuffer(source)) {
        length = Buffer.byteLength(source);
      }
      if (action != null) {
        let iterator;
        stream = new ReadableStream({
          async start() {
            iterator = action(object)[Symbol.asyncIterator]();
          },
          async pull(controller) {
            const { value, done } = await iterator.next();
            if (done) {
              queueMicrotask(() => {
                var _a;
                controller.close();
                (_a = controller.byobRequest) == null ? void 0 : _a.respond(0);
              });
            } else {
              if (!isErrored(stream)) {
                const buffer = new Uint8Array(value);
                if (buffer.byteLength) {
                  controller.enqueue(buffer);
                }
              }
            }
            return controller.desiredSize > 0;
          },
          async cancel(reason) {
            await iterator.return();
          },
          type: "bytes"
        });
      }
      const body = { stream, source, length };
      return [body, type];
    }
    function safelyExtractBody(object, keepalive = false) {
      if (object instanceof ReadableStream) {
        assert(!util.isDisturbed(object), "The body has already been consumed.");
        assert(!object.locked, "The stream is locked.");
      }
      return extractBody(object, keepalive);
    }
    function cloneBody(instance, body) {
      const [out1, out2] = body.stream.tee();
      if (hasFinalizationRegistry) {
        streamRegistry.register(instance, new WeakRef(out1));
      }
      body.stream = out1;
      return {
        stream: out2,
        length: body.length,
        source: body.source
      };
    }
    function throwIfAborted(state) {
      if (state.aborted) {
        throw new DOMException("The operation was aborted.", "AbortError");
      }
    }
    function bodyMixinMethods(instance) {
      const methods = {
        blob() {
          return consumeBody(this, (bytes) => {
            let mimeType = bodyMimeType(this);
            if (mimeType === null) {
              mimeType = "";
            } else if (mimeType) {
              mimeType = serializeAMimeType(mimeType);
            }
            return new Blob2([bytes], { type: mimeType });
          }, instance);
        },
        arrayBuffer() {
          return consumeBody(this, (bytes) => {
            return new Uint8Array(bytes).buffer;
          }, instance);
        },
        text() {
          return consumeBody(this, utf8DecodeBytes, instance);
        },
        json() {
          return consumeBody(this, parseJSONFromBytes, instance);
        },
        formData() {
          return consumeBody(this, (value) => {
            const mimeType = bodyMimeType(this);
            if (mimeType !== null) {
              switch (mimeType.essence) {
                case "multipart/form-data": {
                  const parsed = multipartFormDataParser(value, mimeType);
                  if (parsed === "failure") {
                    throw new TypeError("Failed to parse body as FormData.");
                  }
                  const fd = new FormData();
                  fd[kState] = parsed;
                  return fd;
                }
                case "application/x-www-form-urlencoded": {
                  const entries = new URLSearchParams(value.toString());
                  const fd = new FormData();
                  for (const [name, value2] of entries) {
                    fd.append(name, value2);
                  }
                  return fd;
                }
              }
            }
            throw new TypeError(
              'Content-Type was not one of "multipart/form-data" or "application/x-www-form-urlencoded".'
            );
          }, instance);
        },
        bytes() {
          return consumeBody(this, (bytes) => {
            return new Uint8Array(bytes);
          }, instance);
        }
      };
      return methods;
    }
    function mixinBody(prototype) {
      Object.assign(prototype.prototype, bodyMixinMethods(prototype));
    }
    async function consumeBody(object, convertBytesToJSValue, instance) {
      webidl.brandCheck(object, instance);
      if (bodyUnusable(object)) {
        throw new TypeError("Body is unusable: Body has already been read");
      }
      throwIfAborted(object[kState]);
      const promise = createDeferredPromise();
      const errorSteps = (error2) => promise.reject(error2);
      const successSteps = (data) => {
        try {
          promise.resolve(convertBytesToJSValue(data));
        } catch (e) {
          errorSteps(e);
        }
      };
      if (object[kState].body == null) {
        successSteps(Buffer.allocUnsafe(0));
        return promise.promise;
      }
      await fullyReadBody(object[kState].body, successSteps, errorSteps);
      return promise.promise;
    }
    function bodyUnusable(object) {
      const body = object[kState].body;
      return body != null && (body.stream.locked || util.isDisturbed(body.stream));
    }
    function parseJSONFromBytes(bytes) {
      return JSON.parse(utf8DecodeBytes(bytes));
    }
    function bodyMimeType(requestOrResponse) {
      const headers = requestOrResponse[kState].headersList;
      const mimeType = extractMimeType(headers);
      if (mimeType === "failure") {
        return null;
      }
      return mimeType;
    }
    module2.exports = {
      extractBody,
      safelyExtractBody,
      cloneBody,
      mixinBody,
      streamRegistry,
      hasFinalizationRegistry,
      bodyUnusable
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/dispatcher/client-h1.js
var require_client_h1 = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/dispatcher/client-h1.js"(exports2, module2) {
    "use strict";
    var assert = require_node_assert();
    var util = require_util2();
    var { channels } = require_diagnostics();
    var timers = require_timers();
    var {
      RequestContentLengthMismatchError,
      ResponseContentLengthMismatchError,
      RequestAbortedError,
      HeadersTimeoutError,
      HeadersOverflowError,
      SocketError,
      InformationalError,
      BodyTimeoutError,
      HTTPParserError,
      ResponseExceededMaxSizeError
    } = require_errors();
    var {
      kUrl,
      kReset,
      kClient,
      kParser,
      kBlocking,
      kRunning,
      kPending,
      kSize,
      kWriting,
      kQueue,
      kNoRef,
      kKeepAliveDefaultTimeout,
      kHostHeader,
      kPendingIdx,
      kRunningIdx,
      kError,
      kPipelining,
      kSocket,
      kKeepAliveTimeoutValue,
      kMaxHeadersSize,
      kKeepAliveMaxTimeout,
      kKeepAliveTimeoutThreshold,
      kHeadersTimeout,
      kBodyTimeout,
      kStrictContentLength,
      kMaxRequests,
      kCounter,
      kMaxResponseSize,
      kOnError,
      kResume,
      kHTTPContext
    } = require_symbols();
    var constants = require_constants2();
    var EMPTY_BUF = Buffer.alloc(0);
    var FastBuffer = Buffer[Symbol.species];
    var addListener = util.addListener;
    var removeAllListeners = util.removeAllListeners;
    var extractBody;
    async function lazyllhttp() {
      const llhttpWasmData = process.env.JEST_WORKER_ID ? require_llhttp_wasm() : void 0;
      let mod;
      try {
        mod = await WebAssembly.compile(require_llhttp_simd_wasm());
      } catch (e) {
        mod = await WebAssembly.compile(llhttpWasmData || require_llhttp_wasm());
      }
      return await WebAssembly.instantiate(mod, {
        env: {
          /* eslint-disable camelcase */
          wasm_on_url: (p, at, len) => {
            return 0;
          },
          wasm_on_status: (p, at, len) => {
            assert(currentParser.ptr === p);
            const start = at - currentBufferPtr + currentBufferRef.byteOffset;
            return currentParser.onStatus(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
          },
          wasm_on_message_begin: (p) => {
            assert(currentParser.ptr === p);
            return currentParser.onMessageBegin() || 0;
          },
          wasm_on_header_field: (p, at, len) => {
            assert(currentParser.ptr === p);
            const start = at - currentBufferPtr + currentBufferRef.byteOffset;
            return currentParser.onHeaderField(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
          },
          wasm_on_header_value: (p, at, len) => {
            assert(currentParser.ptr === p);
            const start = at - currentBufferPtr + currentBufferRef.byteOffset;
            return currentParser.onHeaderValue(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
          },
          wasm_on_headers_complete: (p, statusCode, upgrade, shouldKeepAlive) => {
            assert(currentParser.ptr === p);
            return currentParser.onHeadersComplete(statusCode, Boolean(upgrade), Boolean(shouldKeepAlive)) || 0;
          },
          wasm_on_body: (p, at, len) => {
            assert(currentParser.ptr === p);
            const start = at - currentBufferPtr + currentBufferRef.byteOffset;
            return currentParser.onBody(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
          },
          wasm_on_message_complete: (p) => {
            assert(currentParser.ptr === p);
            return currentParser.onMessageComplete() || 0;
          }
          /* eslint-enable camelcase */
        }
      });
    }
    var llhttpInstance = null;
    var llhttpPromise = lazyllhttp();
    llhttpPromise.catch();
    var currentParser = null;
    var currentBufferRef = null;
    var currentBufferSize = 0;
    var currentBufferPtr = null;
    var USE_NATIVE_TIMER = 0;
    var USE_FAST_TIMER = 1;
    var TIMEOUT_HEADERS = 2 | USE_FAST_TIMER;
    var TIMEOUT_BODY = 4 | USE_FAST_TIMER;
    var TIMEOUT_KEEP_ALIVE = 8 | USE_NATIVE_TIMER;
    var Parser = class {
      constructor(client, socket, { exports: exports3 }) {
        assert(Number.isFinite(client[kMaxHeadersSize]) && client[kMaxHeadersSize] > 0);
        this.llhttp = exports3;
        this.ptr = this.llhttp.llhttp_alloc(constants.TYPE.RESPONSE);
        this.client = client;
        this.socket = socket;
        this.timeout = null;
        this.timeoutValue = null;
        this.timeoutType = null;
        this.statusCode = null;
        this.statusText = "";
        this.upgrade = false;
        this.headers = [];
        this.headersSize = 0;
        this.headersMaxSize = client[kMaxHeadersSize];
        this.shouldKeepAlive = false;
        this.paused = false;
        this.resume = this.resume.bind(this);
        this.bytesRead = 0;
        this.keepAlive = "";
        this.contentLength = "";
        this.connection = "";
        this.maxResponseSize = client[kMaxResponseSize];
      }
      setTimeout(delay, type) {
        if (delay !== this.timeoutValue || type & USE_FAST_TIMER ^ this.timeoutType & USE_FAST_TIMER) {
          if (this.timeout) {
            timers.clearTimeout(this.timeout);
            this.timeout = null;
          }
          if (delay) {
            if (type & USE_FAST_TIMER) {
              this.timeout = timers.setFastTimeout(onParserTimeout, delay, new WeakRef(this));
            } else {
              this.timeout = setTimeout(onParserTimeout, delay, new WeakRef(this));
              this.timeout.unref();
            }
          }
          this.timeoutValue = delay;
        } else if (this.timeout) {
          if (this.timeout.refresh) {
            this.timeout.refresh();
          }
        }
        this.timeoutType = type;
      }
      resume() {
        if (this.socket.destroyed || !this.paused) {
          return;
        }
        assert(this.ptr != null);
        assert(currentParser == null);
        this.llhttp.llhttp_resume(this.ptr);
        assert(this.timeoutType === TIMEOUT_BODY);
        if (this.timeout) {
          if (this.timeout.refresh) {
            this.timeout.refresh();
          }
        }
        this.paused = false;
        this.execute(this.socket.read() || EMPTY_BUF);
        this.readMore();
      }
      readMore() {
        while (!this.paused && this.ptr) {
          const chunk = this.socket.read();
          if (chunk === null) {
            break;
          }
          this.execute(chunk);
        }
      }
      execute(data) {
        assert(this.ptr != null);
        assert(currentParser == null);
        assert(!this.paused);
        const { socket, llhttp } = this;
        if (data.length > currentBufferSize) {
          if (currentBufferPtr) {
            llhttp.free(currentBufferPtr);
          }
          currentBufferSize = Math.ceil(data.length / 4096) * 4096;
          currentBufferPtr = llhttp.malloc(currentBufferSize);
        }
        new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(data);
        try {
          let ret;
          try {
            currentBufferRef = data;
            currentParser = this;
            ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, data.length);
          } catch (err) {
            throw err;
          } finally {
            currentParser = null;
            currentBufferRef = null;
          }
          const offset = llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr;
          if (ret === constants.ERROR.PAUSED_UPGRADE) {
            this.onUpgrade(data.slice(offset));
          } else if (ret === constants.ERROR.PAUSED) {
            this.paused = true;
            socket.unshift(data.slice(offset));
          } else if (ret !== constants.ERROR.OK) {
            const ptr = llhttp.llhttp_get_error_reason(this.ptr);
            let message = "";
            if (ptr) {
              const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0);
              message = "Response does not match the HTTP/1.1 protocol (" + Buffer.from(llhttp.memory.buffer, ptr, len).toString() + ")";
            }
            throw new HTTPParserError(message, constants.ERROR[ret], data.slice(offset));
          }
        } catch (err) {
          util.destroy(socket, err);
        }
      }
      destroy() {
        assert(this.ptr != null);
        assert(currentParser == null);
        this.llhttp.llhttp_free(this.ptr);
        this.ptr = null;
        this.timeout && timers.clearTimeout(this.timeout);
        this.timeout = null;
        this.timeoutValue = null;
        this.timeoutType = null;
        this.paused = false;
      }
      onStatus(buf) {
        this.statusText = buf.toString();
      }
      onMessageBegin() {
        const { socket, client } = this;
        if (socket.destroyed) {
          return -1;
        }
        const request = client[kQueue][client[kRunningIdx]];
        if (!request) {
          return -1;
        }
        request.onResponseStarted();
      }
      onHeaderField(buf) {
        const len = this.headers.length;
        if ((len & 1) === 0) {
          this.headers.push(buf);
        } else {
          this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
        }
        this.trackHeader(buf.length);
      }
      onHeaderValue(buf) {
        let len = this.headers.length;
        if ((len & 1) === 1) {
          this.headers.push(buf);
          len += 1;
        } else {
          this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
        }
        const key = this.headers[len - 2];
        if (key.length === 10) {
          const headerName = util.bufferToLowerCasedHeaderName(key);
          if (headerName === "keep-alive") {
            this.keepAlive += buf.toString();
          } else if (headerName === "connection") {
            this.connection += buf.toString();
          }
        } else if (key.length === 14 && util.bufferToLowerCasedHeaderName(key) === "content-length") {
          this.contentLength += buf.toString();
        }
        this.trackHeader(buf.length);
      }
      trackHeader(len) {
        this.headersSize += len;
        if (this.headersSize >= this.headersMaxSize) {
          util.destroy(this.socket, new HeadersOverflowError());
        }
      }
      onUpgrade(head) {
        const { upgrade, client, socket, headers, statusCode } = this;
        assert(upgrade);
        assert(client[kSocket] === socket);
        assert(!socket.destroyed);
        assert(!this.paused);
        assert((headers.length & 1) === 0);
        const request = client[kQueue][client[kRunningIdx]];
        assert(request);
        assert(request.upgrade || request.method === "CONNECT");
        this.statusCode = null;
        this.statusText = "";
        this.shouldKeepAlive = null;
        this.headers = [];
        this.headersSize = 0;
        socket.unshift(head);
        socket[kParser].destroy();
        socket[kParser] = null;
        socket[kClient] = null;
        socket[kError] = null;
        removeAllListeners(socket);
        client[kSocket] = null;
        client[kHTTPContext] = null;
        client[kQueue][client[kRunningIdx]++] = null;
        client.emit("disconnect", client[kUrl], [client], new InformationalError("upgrade"));
        try {
          request.onUpgrade(statusCode, headers, socket);
        } catch (err) {
          util.destroy(socket, err);
        }
        client[kResume]();
      }
      onHeadersComplete(statusCode, upgrade, shouldKeepAlive) {
        const { client, socket, headers, statusText } = this;
        if (socket.destroyed) {
          return -1;
        }
        const request = client[kQueue][client[kRunningIdx]];
        if (!request) {
          return -1;
        }
        assert(!this.upgrade);
        assert(this.statusCode < 200);
        if (statusCode === 100) {
          util.destroy(socket, new SocketError("bad response", util.getSocketInfo(socket)));
          return -1;
        }
        if (upgrade && !request.upgrade) {
          util.destroy(socket, new SocketError("bad upgrade", util.getSocketInfo(socket)));
          return -1;
        }
        assert(this.timeoutType === TIMEOUT_HEADERS);
        this.statusCode = statusCode;
        this.shouldKeepAlive = shouldKeepAlive || // Override llhttp value which does not allow keepAlive for HEAD.
        request.method === "HEAD" && !socket[kReset] && this.connection.toLowerCase() === "keep-alive";
        if (this.statusCode >= 200) {
          const bodyTimeout = request.bodyTimeout != null ? request.bodyTimeout : client[kBodyTimeout];
          this.setTimeout(bodyTimeout, TIMEOUT_BODY);
        } else if (this.timeout) {
          if (this.timeout.refresh) {
            this.timeout.refresh();
          }
        }
        if (request.method === "CONNECT") {
          assert(client[kRunning] === 1);
          this.upgrade = true;
          return 2;
        }
        if (upgrade) {
          assert(client[kRunning] === 1);
          this.upgrade = true;
          return 2;
        }
        assert((this.headers.length & 1) === 0);
        this.headers = [];
        this.headersSize = 0;
        if (this.shouldKeepAlive && client[kPipelining]) {
          const keepAliveTimeout = this.keepAlive ? util.parseKeepAliveTimeout(this.keepAlive) : null;
          if (keepAliveTimeout != null) {
            const timeout = Math.min(
              keepAliveTimeout - client[kKeepAliveTimeoutThreshold],
              client[kKeepAliveMaxTimeout]
            );
            if (timeout <= 0) {
              socket[kReset] = true;
            } else {
              client[kKeepAliveTimeoutValue] = timeout;
            }
          } else {
            client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout];
          }
        } else {
          socket[kReset] = true;
        }
        const pause = request.onHeaders(statusCode, headers, this.resume, statusText) === false;
        if (request.aborted) {
          return -1;
        }
        if (request.method === "HEAD") {
          return 1;
        }
        if (statusCode < 200) {
          return 1;
        }
        if (socket[kBlocking]) {
          socket[kBlocking] = false;
          client[kResume]();
        }
        return pause ? constants.ERROR.PAUSED : 0;
      }
      onBody(buf) {
        const { client, socket, statusCode, maxResponseSize } = this;
        if (socket.destroyed) {
          return -1;
        }
        const request = client[kQueue][client[kRunningIdx]];
        assert(request);
        assert(this.timeoutType === TIMEOUT_BODY);
        if (this.timeout) {
          if (this.timeout.refresh) {
            this.timeout.refresh();
          }
        }
        assert(statusCode >= 200);
        if (maxResponseSize > -1 && this.bytesRead + buf.length > maxResponseSize) {
          util.destroy(socket, new ResponseExceededMaxSizeError());
          return -1;
        }
        this.bytesRead += buf.length;
        if (request.onData(buf) === false) {
          return constants.ERROR.PAUSED;
        }
      }
      onMessageComplete() {
        const { client, socket, statusCode, upgrade, headers, contentLength, bytesRead, shouldKeepAlive } = this;
        if (socket.destroyed && (!statusCode || shouldKeepAlive)) {
          return -1;
        }
        if (upgrade) {
          return;
        }
        assert(statusCode >= 100);
        assert((this.headers.length & 1) === 0);
        const request = client[kQueue][client[kRunningIdx]];
        assert(request);
        this.statusCode = null;
        this.statusText = "";
        this.bytesRead = 0;
        this.contentLength = "";
        this.keepAlive = "";
        this.connection = "";
        this.headers = [];
        this.headersSize = 0;
        if (statusCode < 200) {
          return;
        }
        if (request.method !== "HEAD" && contentLength && bytesRead !== parseInt(contentLength, 10)) {
          util.destroy(socket, new ResponseContentLengthMismatchError());
          return -1;
        }
        request.onComplete(headers);
        client[kQueue][client[kRunningIdx]++] = null;
        if (socket[kWriting]) {
          assert(client[kRunning] === 0);
          util.destroy(socket, new InformationalError("reset"));
          return constants.ERROR.PAUSED;
        } else if (!shouldKeepAlive) {
          util.destroy(socket, new InformationalError("reset"));
          return constants.ERROR.PAUSED;
        } else if (socket[kReset] && client[kRunning] === 0) {
          util.destroy(socket, new InformationalError("reset"));
          return constants.ERROR.PAUSED;
        } else if (client[kPipelining] == null || client[kPipelining] === 1) {
          setImmediate(() => client[kResume]());
        } else {
          client[kResume]();
        }
      }
    };
    function onParserTimeout(parser) {
      const { socket, timeoutType, client, paused } = parser.deref();
      if (timeoutType === TIMEOUT_HEADERS) {
        if (!socket[kWriting] || socket.writableNeedDrain || client[kRunning] > 1) {
          assert(!paused, "cannot be paused while waiting for headers");
          util.destroy(socket, new HeadersTimeoutError());
        }
      } else if (timeoutType === TIMEOUT_BODY) {
        if (!paused) {
          util.destroy(socket, new BodyTimeoutError());
        }
      } else if (timeoutType === TIMEOUT_KEEP_ALIVE) {
        assert(client[kRunning] === 0 && client[kKeepAliveTimeoutValue]);
        util.destroy(socket, new InformationalError("socket idle timeout"));
      }
    }
    async function connectH1(client, socket) {
      client[kSocket] = socket;
      if (!llhttpInstance) {
        llhttpInstance = await llhttpPromise;
        llhttpPromise = null;
      }
      socket[kNoRef] = false;
      socket[kWriting] = false;
      socket[kReset] = false;
      socket[kBlocking] = false;
      socket[kParser] = new Parser(client, socket, llhttpInstance);
      addListener(socket, "error", function(err) {
        assert(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
        const parser = this[kParser];
        if (err.code === "ECONNRESET" && parser.statusCode && !parser.shouldKeepAlive) {
          parser.onMessageComplete();
          return;
        }
        this[kError] = err;
        this[kClient][kOnError](err);
      });
      addListener(socket, "readable", function() {
        const parser = this[kParser];
        if (parser) {
          parser.readMore();
        }
      });
      addListener(socket, "end", function() {
        const parser = this[kParser];
        if (parser.statusCode && !parser.shouldKeepAlive) {
          parser.onMessageComplete();
          return;
        }
        util.destroy(this, new SocketError("other side closed", util.getSocketInfo(this)));
      });
      addListener(socket, "close", function() {
        const client2 = this[kClient];
        const parser = this[kParser];
        if (parser) {
          if (!this[kError] && parser.statusCode && !parser.shouldKeepAlive) {
            parser.onMessageComplete();
          }
          this[kParser].destroy();
          this[kParser] = null;
        }
        const err = this[kError] || new SocketError("closed", util.getSocketInfo(this));
        client2[kSocket] = null;
        client2[kHTTPContext] = null;
        if (client2.destroyed) {
          assert(client2[kPending] === 0);
          const requests = client2[kQueue].splice(client2[kRunningIdx]);
          for (let i = 0; i < requests.length; i++) {
            const request = requests[i];
            util.errorRequest(client2, request, err);
          }
        } else if (client2[kRunning] > 0 && err.code !== "UND_ERR_INFO") {
          const request = client2[kQueue][client2[kRunningIdx]];
          client2[kQueue][client2[kRunningIdx]++] = null;
          util.errorRequest(client2, request, err);
        }
        client2[kPendingIdx] = client2[kRunningIdx];
        assert(client2[kRunning] === 0);
        client2.emit("disconnect", client2[kUrl], [client2], err);
        client2[kResume]();
      });
      let closed = false;
      socket.on("close", () => {
        closed = true;
      });
      return {
        version: "h1",
        defaultPipelining: 1,
        write(...args) {
          return writeH1(client, ...args);
        },
        resume() {
          resumeH1(client);
        },
        destroy(err, callback) {
          if (closed) {
            queueMicrotask(callback);
          } else {
            socket.destroy(err).on("close", callback);
          }
        },
        get destroyed() {
          return socket.destroyed;
        },
        busy(request) {
          if (socket[kWriting] || socket[kReset] || socket[kBlocking]) {
            return true;
          }
          if (request) {
            if (client[kRunning] > 0 && !request.idempotent) {
              return true;
            }
            if (client[kRunning] > 0 && (request.upgrade || request.method === "CONNECT")) {
              return true;
            }
            if (client[kRunning] > 0 && util.bodyLength(request.body) !== 0 && (util.isStream(request.body) || util.isAsyncIterable(request.body) || util.isFormDataLike(request.body))) {
              return true;
            }
          }
          return false;
        }
      };
    }
    function resumeH1(client) {
      const socket = client[kSocket];
      if (socket && !socket.destroyed) {
        if (client[kSize] === 0) {
          if (!socket[kNoRef] && socket.unref) {
            socket.unref();
            socket[kNoRef] = true;
          }
        } else if (socket[kNoRef] && socket.ref) {
          socket.ref();
          socket[kNoRef] = false;
        }
        if (client[kSize] === 0) {
          if (socket[kParser].timeoutType !== TIMEOUT_KEEP_ALIVE) {
            socket[kParser].setTimeout(client[kKeepAliveTimeoutValue], TIMEOUT_KEEP_ALIVE);
          }
        } else if (client[kRunning] > 0 && socket[kParser].statusCode < 200) {
          if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {
            const request = client[kQueue][client[kRunningIdx]];
            const headersTimeout = request.headersTimeout != null ? request.headersTimeout : client[kHeadersTimeout];
            socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS);
          }
        }
      }
    }
    function shouldSendContentLength(method) {
      return method !== "GET" && method !== "HEAD" && method !== "OPTIONS" && method !== "TRACE" && method !== "CONNECT";
    }
    function writeH1(client, request) {
      const { method, path, host, upgrade, blocking, reset } = request;
      let { body, headers, contentLength } = request;
      const expectsPayload = method === "PUT" || method === "POST" || method === "PATCH" || method === "QUERY" || method === "PROPFIND" || method === "PROPPATCH";
      if (util.isFormDataLike(body)) {
        if (!extractBody) {
          extractBody = require_body().extractBody;
        }
        const [bodyStream, contentType] = extractBody(body);
        if (request.contentType == null) {
          headers.push("content-type", contentType);
        }
        body = bodyStream.stream;
        contentLength = bodyStream.length;
      } else if (util.isBlobLike(body) && request.contentType == null && body.type) {
        headers.push("content-type", body.type);
      }
      if (body && typeof body.read === "function") {
        body.read(0);
      }
      const bodyLength = util.bodyLength(body);
      contentLength = bodyLength ?? contentLength;
      if (contentLength === null) {
        contentLength = request.contentLength;
      }
      if (contentLength === 0 && !expectsPayload) {
        contentLength = null;
      }
      if (shouldSendContentLength(method) && contentLength > 0 && request.contentLength !== null && request.contentLength !== contentLength) {
        if (client[kStrictContentLength]) {
          util.errorRequest(client, request, new RequestContentLengthMismatchError());
          return false;
        }
        process.emitWarning(new RequestContentLengthMismatchError());
      }
      const socket = client[kSocket];
      const abort = (err) => {
        if (request.aborted || request.completed) {
          return;
        }
        util.errorRequest(client, request, err || new RequestAbortedError());
        util.destroy(body);
        util.destroy(socket, new InformationalError("aborted"));
      };
      try {
        request.onConnect(abort);
      } catch (err) {
        util.errorRequest(client, request, err);
      }
      if (request.aborted) {
        return false;
      }
      if (method === "HEAD") {
        socket[kReset] = true;
      }
      if (upgrade || method === "CONNECT") {
        socket[kReset] = true;
      }
      if (reset != null) {
        socket[kReset] = reset;
      }
      if (client[kMaxRequests] && socket[kCounter]++ >= client[kMaxRequests]) {
        socket[kReset] = true;
      }
      if (blocking) {
        socket[kBlocking] = true;
      }
      let header = `${method} ${path} HTTP/1.1\r
`;
      if (typeof host === "string") {
        header += `host: ${host}\r
`;
      } else {
        header += client[kHostHeader];
      }
      if (upgrade) {
        header += `connection: upgrade\r
upgrade: ${upgrade}\r
`;
      } else if (client[kPipelining] && !socket[kReset]) {
        header += "connection: keep-alive\r\n";
      } else {
        header += "connection: close\r\n";
      }
      if (Array.isArray(headers)) {
        for (let n = 0; n < headers.length; n += 2) {
          const key = headers[n + 0];
          const val = headers[n + 1];
          if (Array.isArray(val)) {
            for (let i = 0; i < val.length; i++) {
              header += `${key}: ${val[i]}\r
`;
            }
          } else {
            header += `${key}: ${val}\r
`;
          }
        }
      }
      if (channels.sendHeaders.hasSubscribers) {
        channels.sendHeaders.publish({ request, headers: header, socket });
      }
      if (!body || bodyLength === 0) {
        writeBuffer(abort, null, client, request, socket, contentLength, header, expectsPayload);
      } else if (util.isBuffer(body)) {
        writeBuffer(abort, body, client, request, socket, contentLength, header, expectsPayload);
      } else if (util.isBlobLike(body)) {
        if (typeof body.stream === "function") {
          writeIterable(abort, body.stream(), client, request, socket, contentLength, header, expectsPayload);
        } else {
          writeBlob(abort, body, client, request, socket, contentLength, header, expectsPayload);
        }
      } else if (util.isStream(body)) {
        writeStream(abort, body, client, request, socket, contentLength, header, expectsPayload);
      } else if (util.isIterable(body)) {
        writeIterable(abort, body, client, request, socket, contentLength, header, expectsPayload);
      } else {
        assert(false);
      }
      return true;
    }
    function writeStream(abort, body, client, request, socket, contentLength, header, expectsPayload) {
      assert(contentLength !== 0 || client[kRunning] === 0, "stream body cannot be pipelined");
      let finished = false;
      const writer = new AsyncWriter({ abort, socket, request, contentLength, client, expectsPayload, header });
      const onData = function(chunk) {
        if (finished) {
          return;
        }
        try {
          if (!writer.write(chunk) && this.pause) {
            this.pause();
          }
        } catch (err) {
          util.destroy(this, err);
        }
      };
      const onDrain = function() {
        if (finished) {
          return;
        }
        if (body.resume) {
          body.resume();
        }
      };
      const onClose = function() {
        queueMicrotask(() => {
          body.removeListener("error", onFinished);
        });
        if (!finished) {
          const err = new RequestAbortedError();
          queueMicrotask(() => onFinished(err));
        }
      };
      const onFinished = function(err) {
        if (finished) {
          return;
        }
        finished = true;
        assert(socket.destroyed || socket[kWriting] && client[kRunning] <= 1);
        socket.off("drain", onDrain).off("error", onFinished);
        body.removeListener("data", onData).removeListener("end", onFinished).removeListener("close", onClose);
        if (!err) {
          try {
            writer.end();
          } catch (er) {
            err = er;
          }
        }
        writer.destroy(err);
        if (err && (err.code !== "UND_ERR_INFO" || err.message !== "reset")) {
          util.destroy(body, err);
        } else {
          util.destroy(body);
        }
      };
      body.on("data", onData).on("end", onFinished).on("error", onFinished).on("close", onClose);
      if (body.resume) {
        body.resume();
      }
      socket.on("drain", onDrain).on("error", onFinished);
      if (body.errorEmitted ?? body.errored) {
        setImmediate(() => onFinished(body.errored));
      } else if (body.endEmitted ?? body.readableEnded) {
        setImmediate(() => onFinished(null));
      }
      if (body.closeEmitted ?? body.closed) {
        setImmediate(onClose);
      }
    }
    function writeBuffer(abort, body, client, request, socket, contentLength, header, expectsPayload) {
      try {
        if (!body) {
          if (contentLength === 0) {
            socket.write(`${header}content-length: 0\r
\r
`, "latin1");
          } else {
            assert(contentLength === null, "no body must not have content length");
            socket.write(`${header}\r
`, "latin1");
          }
        } else if (util.isBuffer(body)) {
          assert(contentLength === body.byteLength, "buffer body must have content length");
          socket.cork();
          socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1");
          socket.write(body);
          socket.uncork();
          request.onBodySent(body);
          if (!expectsPayload && request.reset !== false) {
            socket[kReset] = true;
          }
        }
        request.onRequestSent();
        client[kResume]();
      } catch (err) {
        abort(err);
      }
    }
    async function writeBlob(abort, body, client, request, socket, contentLength, header, expectsPayload) {
      assert(contentLength === body.size, "blob body must have content length");
      try {
        if (contentLength != null && contentLength !== body.size) {
          throw new RequestContentLengthMismatchError();
        }
        const buffer = Buffer.from(await body.arrayBuffer());
        socket.cork();
        socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1");
        socket.write(buffer);
        socket.uncork();
        request.onBodySent(buffer);
        request.onRequestSent();
        if (!expectsPayload && request.reset !== false) {
          socket[kReset] = true;
        }
        client[kResume]();
      } catch (err) {
        abort(err);
      }
    }
    async function writeIterable(abort, body, client, request, socket, contentLength, header, expectsPayload) {
      assert(contentLength !== 0 || client[kRunning] === 0, "iterator body cannot be pipelined");
      let callback = null;
      function onDrain() {
        if (callback) {
          const cb = callback;
          callback = null;
          cb();
        }
      }
      const waitForDrain = () => new Promise((resolve, reject) => {
        assert(callback === null);
        if (socket[kError]) {
          reject(socket[kError]);
        } else {
          callback = resolve;
        }
      });
      socket.on("close", onDrain).on("drain", onDrain);
      const writer = new AsyncWriter({ abort, socket, request, contentLength, client, expectsPayload, header });
      try {
        for await (const chunk of body) {
          if (socket[kError]) {
            throw socket[kError];
          }
          if (!writer.write(chunk)) {
            await waitForDrain();
          }
        }
        writer.end();
      } catch (err) {
        writer.destroy(err);
      } finally {
        socket.off("close", onDrain).off("drain", onDrain);
      }
    }
    var AsyncWriter = class {
      constructor({ abort, socket, request, contentLength, client, expectsPayload, header }) {
        this.socket = socket;
        this.request = request;
        this.contentLength = contentLength;
        this.client = client;
        this.bytesWritten = 0;
        this.expectsPayload = expectsPayload;
        this.header = header;
        this.abort = abort;
        socket[kWriting] = true;
      }
      write(chunk) {
        const { socket, request, contentLength, client, bytesWritten, expectsPayload, header } = this;
        if (socket[kError]) {
          throw socket[kError];
        }
        if (socket.destroyed) {
          return false;
        }
        const len = Buffer.byteLength(chunk);
        if (!len) {
          return true;
        }
        if (contentLength !== null && bytesWritten + len > contentLength) {
          if (client[kStrictContentLength]) {
            throw new RequestContentLengthMismatchError();
          }
          process.emitWarning(new RequestContentLengthMismatchError());
        }
        socket.cork();
        if (bytesWritten === 0) {
          if (!expectsPayload && request.reset !== false) {
            socket[kReset] = true;
          }
          if (contentLength === null) {
            socket.write(`${header}transfer-encoding: chunked\r
`, "latin1");
          } else {
            socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1");
          }
        }
        if (contentLength === null) {
          socket.write(`\r
${len.toString(16)}\r
`, "latin1");
        }
        this.bytesWritten += len;
        const ret = socket.write(chunk);
        socket.uncork();
        request.onBodySent(chunk);
        if (!ret) {
          if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
            if (socket[kParser].timeout.refresh) {
              socket[kParser].timeout.refresh();
            }
          }
        }
        return ret;
      }
      end() {
        const { socket, contentLength, client, bytesWritten, expectsPayload, header, request } = this;
        request.onRequestSent();
        socket[kWriting] = false;
        if (socket[kError]) {
          throw socket[kError];
        }
        if (socket.destroyed) {
          return;
        }
        if (bytesWritten === 0) {
          if (expectsPayload) {
            socket.write(`${header}content-length: 0\r
\r
`, "latin1");
          } else {
            socket.write(`${header}\r
`, "latin1");
          }
        } else if (contentLength === null) {
          socket.write("\r\n0\r\n\r\n", "latin1");
        }
        if (contentLength !== null && bytesWritten !== contentLength) {
          if (client[kStrictContentLength]) {
            throw new RequestContentLengthMismatchError();
          } else {
            process.emitWarning(new RequestContentLengthMismatchError());
          }
        }
        if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
          if (socket[kParser].timeout.refresh) {
            socket[kParser].timeout.refresh();
          }
        }
        client[kResume]();
      }
      destroy(err) {
        const { socket, client, abort } = this;
        socket[kWriting] = false;
        if (err) {
          assert(client[kRunning] <= 1, "pipeline should only contain this request");
          abort(err);
        }
      }
    };
    module2.exports = connectH1;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/dispatcher/client-h2.js
var require_client_h2 = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/dispatcher/client-h2.js"(exports2, module2) {
    "use strict";
    var assert = require_node_assert();
    var { pipeline } = require_node_stream();
    var util = require_util2();
    var {
      RequestContentLengthMismatchError,
      RequestAbortedError,
      SocketError,
      InformationalError
    } = require_errors();
    var {
      kUrl,
      kReset,
      kClient,
      kRunning,
      kPending,
      kQueue,
      kPendingIdx,
      kRunningIdx,
      kError,
      kSocket,
      kStrictContentLength,
      kOnError,
      kMaxConcurrentStreams,
      kHTTP2Session,
      kResume,
      kSize,
      kHTTPContext
    } = require_symbols();
    var kOpenStreams = Symbol("open streams");
    var h2ExperimentalWarned = false;
    var http2;
    try {
      http2 = require_node_http2();
    } catch {
      http2 = { constants: {} };
    }
    var {
      constants: {
        HTTP2_HEADER_AUTHORITY,
        HTTP2_HEADER_METHOD,
        HTTP2_HEADER_PATH,
        HTTP2_HEADER_SCHEME,
        HTTP2_HEADER_CONTENT_LENGTH,
        HTTP2_HEADER_EXPECT,
        HTTP2_HEADER_STATUS
      }
    } = http2;
    function parseH2Headers(headers) {
      const result = [];
      for (const [name, value] of Object.entries(headers)) {
        if (Array.isArray(value)) {
          for (const subvalue of value) {
            result.push(Buffer.from(name), Buffer.from(subvalue));
          }
        } else {
          result.push(Buffer.from(name), Buffer.from(value));
        }
      }
      return result;
    }
    async function connectH2(client, socket) {
      client[kSocket] = socket;
      if (!h2ExperimentalWarned) {
        h2ExperimentalWarned = true;
        process.emitWarning("H2 support is experimental, expect them to change at any time.", {
          code: "UNDICI-H2"
        });
      }
      const session = http2.connect(client[kUrl], {
        createConnection: () => socket,
        peerMaxConcurrentStreams: client[kMaxConcurrentStreams]
      });
      session[kOpenStreams] = 0;
      session[kClient] = client;
      session[kSocket] = socket;
      util.addListener(session, "error", onHttp2SessionError);
      util.addListener(session, "frameError", onHttp2FrameError);
      util.addListener(session, "end", onHttp2SessionEnd);
      util.addListener(session, "goaway", onHTTP2GoAway);
      util.addListener(session, "close", function() {
        const { [kClient]: client2 } = this;
        const { [kSocket]: socket2 } = client2;
        const err = this[kSocket][kError] || this[kError] || new SocketError("closed", util.getSocketInfo(socket2));
        client2[kHTTP2Session] = null;
        if (client2.destroyed) {
          assert(client2[kPending] === 0);
          const requests = client2[kQueue].splice(client2[kRunningIdx]);
          for (let i = 0; i < requests.length; i++) {
            const request = requests[i];
            util.errorRequest(client2, request, err);
          }
        }
      });
      session.unref();
      client[kHTTP2Session] = session;
      socket[kHTTP2Session] = session;
      util.addListener(socket, "error", function(err) {
        assert(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
        this[kError] = err;
        this[kClient][kOnError](err);
      });
      util.addListener(socket, "end", function() {
        util.destroy(this, new SocketError("other side closed", util.getSocketInfo(this)));
      });
      util.addListener(socket, "close", function() {
        const err = this[kError] || new SocketError("closed", util.getSocketInfo(this));
        client[kSocket] = null;
        if (this[kHTTP2Session] != null) {
          this[kHTTP2Session].destroy(err);
        }
        client[kPendingIdx] = client[kRunningIdx];
        assert(client[kRunning] === 0);
        client.emit("disconnect", client[kUrl], [client], err);
        client[kResume]();
      });
      let closed = false;
      socket.on("close", () => {
        closed = true;
      });
      return {
        version: "h2",
        defaultPipelining: Infinity,
        write(...args) {
          return writeH2(client, ...args);
        },
        resume() {
          resumeH2(client);
        },
        destroy(err, callback) {
          if (closed) {
            queueMicrotask(callback);
          } else {
            socket.destroy(err).on("close", callback);
          }
        },
        get destroyed() {
          return socket.destroyed;
        },
        busy() {
          return false;
        }
      };
    }
    function resumeH2(client) {
      const socket = client[kSocket];
      if ((socket == null ? void 0 : socket.destroyed) === false) {
        if (client[kSize] === 0 && client[kMaxConcurrentStreams] === 0) {
          socket.unref();
          client[kHTTP2Session].unref();
        } else {
          socket.ref();
          client[kHTTP2Session].ref();
        }
      }
    }
    function onHttp2SessionError(err) {
      assert(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
      this[kSocket][kError] = err;
      this[kClient][kOnError](err);
    }
    function onHttp2FrameError(type, code, id) {
      if (id === 0) {
        const err = new InformationalError(`HTTP/2: "frameError" received - type ${type}, code ${code}`);
        this[kSocket][kError] = err;
        this[kClient][kOnError](err);
      }
    }
    function onHttp2SessionEnd() {
      const err = new SocketError("other side closed", util.getSocketInfo(this[kSocket]));
      this.destroy(err);
      util.destroy(this[kSocket], err);
    }
    function onHTTP2GoAway(code) {
      const err = this[kError] || new SocketError(`HTTP/2: "GOAWAY" frame received with code ${code}`, util.getSocketInfo(this));
      const client = this[kClient];
      client[kSocket] = null;
      client[kHTTPContext] = null;
      if (this[kHTTP2Session] != null) {
        this[kHTTP2Session].destroy(err);
        this[kHTTP2Session] = null;
      }
      util.destroy(this[kSocket], err);
      const request = client[kQueue][client[kRunningIdx]];
      client[kQueue][client[kRunningIdx]++] = null;
      util.errorRequest(client, request, err);
      client[kPendingIdx] = client[kRunningIdx];
      assert(client[kRunning] === 0);
      client.emit("disconnect", client[kUrl], [client], err);
      client[kResume]();
    }
    function shouldSendContentLength(method) {
      return method !== "GET" && method !== "HEAD" && method !== "OPTIONS" && method !== "TRACE" && method !== "CONNECT";
    }
    function writeH2(client, request) {
      const session = client[kHTTP2Session];
      const { body, method, path, host, upgrade, expectContinue, signal, headers: reqHeaders } = request;
      if (upgrade) {
        util.errorRequest(client, request, new Error("Upgrade not supported for H2"));
        return false;
      }
      const headers = {};
      for (let n = 0; n < reqHeaders.length; n += 2) {
        const key = reqHeaders[n + 0];
        const val = reqHeaders[n + 1];
        if (Array.isArray(val)) {
          for (let i = 0; i < val.length; i++) {
            if (headers[key]) {
              headers[key] += `,${val[i]}`;
            } else {
              headers[key] = val[i];
            }
          }
        } else {
          headers[key] = val;
        }
      }
      let stream;
      const { hostname, port } = client[kUrl];
      headers[HTTP2_HEADER_AUTHORITY] = host || `${hostname}${port ? `:${port}` : ""}`;
      headers[HTTP2_HEADER_METHOD] = method;
      const abort = (err) => {
        if (request.aborted || request.completed) {
          return;
        }
        err = err || new RequestAbortedError();
        util.errorRequest(client, request, err);
        if (stream != null) {
          util.destroy(stream, err);
        }
        util.destroy(body, err);
        client[kQueue][client[kRunningIdx]++] = null;
        client[kResume]();
      };
      try {
        request.onConnect(abort);
      } catch (err) {
        util.errorRequest(client, request, err);
      }
      if (request.aborted) {
        return false;
      }
      if (method === "CONNECT") {
        session.ref();
        stream = session.request(headers, { endStream: false, signal });
        if (stream.id && !stream.pending) {
          request.onUpgrade(null, null, stream);
          ++session[kOpenStreams];
          client[kQueue][client[kRunningIdx]++] = null;
        } else {
          stream.once("ready", () => {
            request.onUpgrade(null, null, stream);
            ++session[kOpenStreams];
            client[kQueue][client[kRunningIdx]++] = null;
          });
        }
        stream.once("close", () => {
          session[kOpenStreams] -= 1;
          if (session[kOpenStreams] === 0) session.unref();
        });
        return true;
      }
      headers[HTTP2_HEADER_PATH] = path;
      headers[HTTP2_HEADER_SCHEME] = "https";
      const expectsPayload = method === "PUT" || method === "POST" || method === "PATCH";
      if (body && typeof body.read === "function") {
        body.read(0);
      }
      let contentLength = util.bodyLength(body);
      if (contentLength == null) {
        contentLength = request.contentLength;
      }
      if (contentLength === 0 || !expectsPayload) {
        contentLength = null;
      }
      if (shouldSendContentLength(method) && contentLength > 0 && request.contentLength != null && request.contentLength !== contentLength) {
        if (client[kStrictContentLength]) {
          util.errorRequest(client, request, new RequestContentLengthMismatchError());
          return false;
        }
        process.emitWarning(new RequestContentLengthMismatchError());
      }
      if (contentLength != null) {
        assert(body, "no body must not have content length");
        headers[HTTP2_HEADER_CONTENT_LENGTH] = `${contentLength}`;
      }
      session.ref();
      const shouldEndStream = method === "GET" || method === "HEAD" || body === null;
      if (expectContinue) {
        headers[HTTP2_HEADER_EXPECT] = "100-continue";
        stream = session.request(headers, { endStream: shouldEndStream, signal });
        stream.once("continue", writeBodyH2);
      } else {
        stream = session.request(headers, {
          endStream: shouldEndStream,
          signal
        });
        writeBodyH2();
      }
      ++session[kOpenStreams];
      stream.once("response", (headers2) => {
        const { [HTTP2_HEADER_STATUS]: statusCode, ...realHeaders } = headers2;
        request.onResponseStarted();
        if (request.aborted) {
          const err = new RequestAbortedError();
          util.errorRequest(client, request, err);
          util.destroy(stream, err);
          return;
        }
        if (request.onHeaders(Number(statusCode), parseH2Headers(realHeaders), stream.resume.bind(stream), "") === false) {
          stream.pause();
        }
        stream.on("data", (chunk) => {
          if (request.onData(chunk) === false) {
            stream.pause();
          }
        });
      });
      stream.once("end", () => {
        var _a;
        if (((_a = stream.state) == null ? void 0 : _a.state) == null || stream.state.state < 6) {
          request.onComplete([]);
        }
        if (session[kOpenStreams] === 0) {
          session.unref();
        }
        abort(new InformationalError("HTTP/2: stream half-closed (remote)"));
        client[kQueue][client[kRunningIdx]++] = null;
        client[kPendingIdx] = client[kRunningIdx];
        client[kResume]();
      });
      stream.once("close", () => {
        session[kOpenStreams] -= 1;
        if (session[kOpenStreams] === 0) {
          session.unref();
        }
      });
      stream.once("error", function(err) {
        abort(err);
      });
      stream.once("frameError", (type, code) => {
        abort(new InformationalError(`HTTP/2: "frameError" received - type ${type}, code ${code}`));
      });
      return true;
      function writeBodyH2() {
        if (!body || contentLength === 0) {
          writeBuffer(
            abort,
            stream,
            null,
            client,
            request,
            client[kSocket],
            contentLength,
            expectsPayload
          );
        } else if (util.isBuffer(body)) {
          writeBuffer(
            abort,
            stream,
            body,
            client,
            request,
            client[kSocket],
            contentLength,
            expectsPayload
          );
        } else if (util.isBlobLike(body)) {
          if (typeof body.stream === "function") {
            writeIterable(
              abort,
              stream,
              body.stream(),
              client,
              request,
              client[kSocket],
              contentLength,
              expectsPayload
            );
          } else {
            writeBlob(
              abort,
              stream,
              body,
              client,
              request,
              client[kSocket],
              contentLength,
              expectsPayload
            );
          }
        } else if (util.isStream(body)) {
          writeStream(
            abort,
            client[kSocket],
            expectsPayload,
            stream,
            body,
            client,
            request,
            contentLength
          );
        } else if (util.isIterable(body)) {
          writeIterable(
            abort,
            stream,
            body,
            client,
            request,
            client[kSocket],
            contentLength,
            expectsPayload
          );
        } else {
          assert(false);
        }
      }
    }
    function writeBuffer(abort, h2stream, body, client, request, socket, contentLength, expectsPayload) {
      try {
        if (body != null && util.isBuffer(body)) {
          assert(contentLength === body.byteLength, "buffer body must have content length");
          h2stream.cork();
          h2stream.write(body);
          h2stream.uncork();
          h2stream.end();
          request.onBodySent(body);
        }
        if (!expectsPayload) {
          socket[kReset] = true;
        }
        request.onRequestSent();
        client[kResume]();
      } catch (error2) {
        abort(error2);
      }
    }
    function writeStream(abort, socket, expectsPayload, h2stream, body, client, request, contentLength) {
      assert(contentLength !== 0 || client[kRunning] === 0, "stream body cannot be pipelined");
      const pipe = pipeline(
        body,
        h2stream,
        (err) => {
          if (err) {
            util.destroy(pipe, err);
            abort(err);
          } else {
            util.removeAllListeners(pipe);
            request.onRequestSent();
            if (!expectsPayload) {
              socket[kReset] = true;
            }
            client[kResume]();
          }
        }
      );
      util.addListener(pipe, "data", onPipeData);
      function onPipeData(chunk) {
        request.onBodySent(chunk);
      }
    }
    async function writeBlob(abort, h2stream, body, client, request, socket, contentLength, expectsPayload) {
      assert(contentLength === body.size, "blob body must have content length");
      try {
        if (contentLength != null && contentLength !== body.size) {
          throw new RequestContentLengthMismatchError();
        }
        const buffer = Buffer.from(await body.arrayBuffer());
        h2stream.cork();
        h2stream.write(buffer);
        h2stream.uncork();
        h2stream.end();
        request.onBodySent(buffer);
        request.onRequestSent();
        if (!expectsPayload) {
          socket[kReset] = true;
        }
        client[kResume]();
      } catch (err) {
        abort(err);
      }
    }
    async function writeIterable(abort, h2stream, body, client, request, socket, contentLength, expectsPayload) {
      assert(contentLength !== 0 || client[kRunning] === 0, "iterator body cannot be pipelined");
      let callback = null;
      function onDrain() {
        if (callback) {
          const cb = callback;
          callback = null;
          cb();
        }
      }
      const waitForDrain = () => new Promise((resolve, reject) => {
        assert(callback === null);
        if (socket[kError]) {
          reject(socket[kError]);
        } else {
          callback = resolve;
        }
      });
      h2stream.on("close", onDrain).on("drain", onDrain);
      try {
        for await (const chunk of body) {
          if (socket[kError]) {
            throw socket[kError];
          }
          const res = h2stream.write(chunk);
          request.onBodySent(chunk);
          if (!res) {
            await waitForDrain();
          }
        }
        h2stream.end();
        request.onRequestSent();
        if (!expectsPayload) {
          socket[kReset] = true;
        }
        client[kResume]();
      } catch (err) {
        abort(err);
      } finally {
        h2stream.off("close", onDrain).off("drain", onDrain);
      }
    }
    module2.exports = connectH2;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/handler/redirect-handler.js
var require_redirect_handler = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/handler/redirect-handler.js"(exports2, module2) {
    "use strict";
    var util = require_util2();
    var { kBodyUsed } = require_symbols();
    var assert = require_node_assert();
    var { InvalidArgumentError } = require_errors();
    var EE = require_node_events();
    var redirectableStatusCodes = [300, 301, 302, 303, 307, 308];
    var kBody = Symbol("body");
    var BodyAsyncIterable = class {
      constructor(body) {
        this[kBody] = body;
        this[kBodyUsed] = false;
      }
      async *[Symbol.asyncIterator]() {
        assert(!this[kBodyUsed], "disturbed");
        this[kBodyUsed] = true;
        yield* this[kBody];
      }
    };
    var RedirectHandler = class {
      constructor(dispatch, maxRedirections, opts, handler) {
        if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {
          throw new InvalidArgumentError("maxRedirections must be a positive number");
        }
        util.validateHandler(handler, opts.method, opts.upgrade);
        this.dispatch = dispatch;
        this.location = null;
        this.abort = null;
        this.opts = { ...opts, maxRedirections: 0 };
        this.maxRedirections = maxRedirections;
        this.handler = handler;
        this.history = [];
        this.redirectionLimitReached = false;
        if (util.isStream(this.opts.body)) {
          if (util.bodyLength(this.opts.body) === 0) {
            this.opts.body.on("data", function() {
              assert(false);
            });
          }
          if (typeof this.opts.body.readableDidRead !== "boolean") {
            this.opts.body[kBodyUsed] = false;
            EE.prototype.on.call(this.opts.body, "data", function() {
              this[kBodyUsed] = true;
            });
          }
        } else if (this.opts.body && typeof this.opts.body.pipeTo === "function") {
          this.opts.body = new BodyAsyncIterable(this.opts.body);
        } else if (this.opts.body && typeof this.opts.body !== "string" && !ArrayBuffer.isView(this.opts.body) && util.isIterable(this.opts.body)) {
          this.opts.body = new BodyAsyncIterable(this.opts.body);
        }
      }
      onConnect(abort) {
        this.abort = abort;
        this.handler.onConnect(abort, { history: this.history });
      }
      onUpgrade(statusCode, headers, socket) {
        this.handler.onUpgrade(statusCode, headers, socket);
      }
      onError(error2) {
        this.handler.onError(error2);
      }
      onHeaders(statusCode, headers, resume, statusText) {
        this.location = this.history.length >= this.maxRedirections || util.isDisturbed(this.opts.body) ? null : parseLocation(statusCode, headers);
        if (this.opts.throwOnMaxRedirect && this.history.length >= this.maxRedirections) {
          if (this.request) {
            this.request.abort(new Error("max redirects"));
          }
          this.redirectionLimitReached = true;
          this.abort(new Error("max redirects"));
          return;
        }
        if (this.opts.origin) {
          this.history.push(new URL(this.opts.path, this.opts.origin));
        }
        if (!this.location) {
          return this.handler.onHeaders(statusCode, headers, resume, statusText);
        }
        const { origin, pathname, search } = util.parseURL(new URL(this.location, this.opts.origin && new URL(this.opts.path, this.opts.origin)));
        const path = search ? `${pathname}${search}` : pathname;
        this.opts.headers = cleanRequestHeaders(this.opts.headers, statusCode === 303, this.opts.origin !== origin);
        this.opts.path = path;
        this.opts.origin = origin;
        this.opts.maxRedirections = 0;
        this.opts.query = null;
        if (statusCode === 303 && this.opts.method !== "HEAD") {
          this.opts.method = "GET";
          this.opts.body = null;
        }
      }
      onData(chunk) {
        if (this.location) {
        } else {
          return this.handler.onData(chunk);
        }
      }
      onComplete(trailers) {
        if (this.location) {
          this.location = null;
          this.abort = null;
          this.dispatch(this.opts, this);
        } else {
          this.handler.onComplete(trailers);
        }
      }
      onBodySent(chunk) {
        if (this.handler.onBodySent) {
          this.handler.onBodySent(chunk);
        }
      }
    };
    function parseLocation(statusCode, headers) {
      if (redirectableStatusCodes.indexOf(statusCode) === -1) {
        return null;
      }
      for (let i = 0; i < headers.length; i += 2) {
        if (headers[i].length === 8 && util.headerNameToString(headers[i]) === "location") {
          return headers[i + 1];
        }
      }
    }
    function shouldRemoveHeader(header, removeContent, unknownOrigin) {
      if (header.length === 4) {
        return util.headerNameToString(header) === "host";
      }
      if (removeContent && util.headerNameToString(header).startsWith("content-")) {
        return true;
      }
      if (unknownOrigin && (header.length === 13 || header.length === 6 || header.length === 19)) {
        const name = util.headerNameToString(header);
        return name === "authorization" || name === "cookie" || name === "proxy-authorization";
      }
      return false;
    }
    function cleanRequestHeaders(headers, removeContent, unknownOrigin) {
      const ret = [];
      if (Array.isArray(headers)) {
        for (let i = 0; i < headers.length; i += 2) {
          if (!shouldRemoveHeader(headers[i], removeContent, unknownOrigin)) {
            ret.push(headers[i], headers[i + 1]);
          }
        }
      } else if (headers && typeof headers === "object") {
        for (const key of Object.keys(headers)) {
          if (!shouldRemoveHeader(key, removeContent, unknownOrigin)) {
            ret.push(key, headers[key]);
          }
        }
      } else {
        assert(headers == null, "headers must be an object or an array");
      }
      return ret;
    }
    module2.exports = RedirectHandler;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/interceptor/redirect-interceptor.js
var require_redirect_interceptor = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/interceptor/redirect-interceptor.js"(exports2, module2) {
    "use strict";
    var RedirectHandler = require_redirect_handler();
    function createRedirectInterceptor({ maxRedirections: defaultMaxRedirections }) {
      return (dispatch) => {
        return function Intercept(opts, handler) {
          const { maxRedirections = defaultMaxRedirections } = opts;
          if (!maxRedirections) {
            return dispatch(opts, handler);
          }
          const redirectHandler = new RedirectHandler(dispatch, maxRedirections, opts, handler);
          opts = { ...opts, maxRedirections: 0 };
          return dispatch(opts, redirectHandler);
        };
      };
    }
    module2.exports = createRedirectInterceptor;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/dispatcher/client.js
var require_client = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/dispatcher/client.js"(exports2, module2) {
    "use strict";
    var assert = require_node_assert();
    var net = require_node_net();
    var http = require_node_http();
    var util = require_util2();
    var { channels } = require_diagnostics();
    var Request = require_request();
    var DispatcherBase = require_dispatcher_base();
    var {
      InvalidArgumentError,
      InformationalError,
      ClientDestroyedError
    } = require_errors();
    var buildConnector = require_connect();
    var {
      kUrl,
      kServerName,
      kClient,
      kBusy,
      kConnect,
      kResuming,
      kRunning,
      kPending,
      kSize,
      kQueue,
      kConnected,
      kConnecting,
      kNeedDrain,
      kKeepAliveDefaultTimeout,
      kHostHeader,
      kPendingIdx,
      kRunningIdx,
      kError,
      kPipelining,
      kKeepAliveTimeoutValue,
      kMaxHeadersSize,
      kKeepAliveMaxTimeout,
      kKeepAliveTimeoutThreshold,
      kHeadersTimeout,
      kBodyTimeout,
      kStrictContentLength,
      kConnector,
      kMaxRedirections,
      kMaxRequests,
      kCounter,
      kClose,
      kDestroy,
      kDispatch,
      kInterceptors,
      kLocalAddress,
      kMaxResponseSize,
      kOnError,
      kHTTPContext,
      kMaxConcurrentStreams,
      kResume
    } = require_symbols();
    var connectH1 = require_client_h1();
    var connectH2 = require_client_h2();
    var deprecatedInterceptorWarned = false;
    var kClosedResolve = Symbol("kClosedResolve");
    var noop = () => {
    };
    function getPipelining(client) {
      var _a;
      return client[kPipelining] ?? ((_a = client[kHTTPContext]) == null ? void 0 : _a.defaultPipelining) ?? 1;
    }
    var Client2 = class extends DispatcherBase {
      /**
       *
       * @param {string|URL} url
       * @param {import('../../types/client.js').Client.Options} options
       */
      constructor(url, {
        interceptors,
        maxHeaderSize,
        headersTimeout,
        socketTimeout,
        requestTimeout,
        connectTimeout,
        bodyTimeout,
        idleTimeout,
        keepAlive,
        keepAliveTimeout,
        maxKeepAliveTimeout,
        keepAliveMaxTimeout,
        keepAliveTimeoutThreshold,
        socketPath,
        pipelining,
        tls,
        strictContentLength,
        maxCachedSessions,
        maxRedirections,
        connect: connect2,
        maxRequestsPerClient,
        localAddress,
        maxResponseSize,
        autoSelectFamily,
        autoSelectFamilyAttemptTimeout,
        // h2
        maxConcurrentStreams,
        allowH2
      } = {}) {
        super();
        if (keepAlive !== void 0) {
          throw new InvalidArgumentError("unsupported keepAlive, use pipelining=0 instead");
        }
        if (socketTimeout !== void 0) {
          throw new InvalidArgumentError("unsupported socketTimeout, use headersTimeout & bodyTimeout instead");
        }
        if (requestTimeout !== void 0) {
          throw new InvalidArgumentError("unsupported requestTimeout, use headersTimeout & bodyTimeout instead");
        }
        if (idleTimeout !== void 0) {
          throw new InvalidArgumentError("unsupported idleTimeout, use keepAliveTimeout instead");
        }
        if (maxKeepAliveTimeout !== void 0) {
          throw new InvalidArgumentError("unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead");
        }
        if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize)) {
          throw new InvalidArgumentError("invalid maxHeaderSize");
        }
        if (socketPath != null && typeof socketPath !== "string") {
          throw new InvalidArgumentError("invalid socketPath");
        }
        if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) {
          throw new InvalidArgumentError("invalid connectTimeout");
        }
        if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) {
          throw new InvalidArgumentError("invalid keepAliveTimeout");
        }
        if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) {
          throw new InvalidArgumentError("invalid keepAliveMaxTimeout");
        }
        if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) {
          throw new InvalidArgumentError("invalid keepAliveTimeoutThreshold");
        }
        if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) {
          throw new InvalidArgumentError("headersTimeout must be a positive integer or zero");
        }
        if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) {
          throw new InvalidArgumentError("bodyTimeout must be a positive integer or zero");
        }
        if (connect2 != null && typeof connect2 !== "function" && typeof connect2 !== "object") {
          throw new InvalidArgumentError("connect must be a function or an object");
        }
        if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {
          throw new InvalidArgumentError("maxRedirections must be a positive number");
        }
        if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)) {
          throw new InvalidArgumentError("maxRequestsPerClient must be a positive number");
        }
        if (localAddress != null && (typeof localAddress !== "string" || net.isIP(localAddress) === 0)) {
          throw new InvalidArgumentError("localAddress must be valid string IP address");
        }
        if (maxResponseSize != null && (!Number.isInteger(maxResponseSize) || maxResponseSize < -1)) {
          throw new InvalidArgumentError("maxResponseSize must be a positive number");
        }
        if (autoSelectFamilyAttemptTimeout != null && (!Number.isInteger(autoSelectFamilyAttemptTimeout) || autoSelectFamilyAttemptTimeout < -1)) {
          throw new InvalidArgumentError("autoSelectFamilyAttemptTimeout must be a positive number");
        }
        if (allowH2 != null && typeof allowH2 !== "boolean") {
          throw new InvalidArgumentError("allowH2 must be a valid boolean value");
        }
        if (maxConcurrentStreams != null && (typeof maxConcurrentStreams !== "number" || maxConcurrentStreams < 1)) {
          throw new InvalidArgumentError("maxConcurrentStreams must be a positive integer, greater than 0");
        }
        if (typeof connect2 !== "function") {
          connect2 = buildConnector({
            ...tls,
            maxCachedSessions,
            allowH2,
            socketPath,
            timeout: connectTimeout,
            ...autoSelectFamily ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : void 0,
            ...connect2
          });
        }
        if ((interceptors == null ? void 0 : interceptors.Client) && Array.isArray(interceptors.Client)) {
          this[kInterceptors] = interceptors.Client;
          if (!deprecatedInterceptorWarned) {
            deprecatedInterceptorWarned = true;
            process.emitWarning("Client.Options#interceptor is deprecated. Use Dispatcher#compose instead.", {
              code: "UNDICI-CLIENT-INTERCEPTOR-DEPRECATED"
            });
          }
        } else {
          this[kInterceptors] = [createRedirectInterceptor({ maxRedirections })];
        }
        this[kUrl] = util.parseOrigin(url);
        this[kConnector] = connect2;
        this[kPipelining] = pipelining != null ? pipelining : 1;
        this[kMaxHeadersSize] = maxHeaderSize || http.maxHeaderSize;
        this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4e3 : keepAliveTimeout;
        this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 6e5 : keepAliveMaxTimeout;
        this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 2e3 : keepAliveTimeoutThreshold;
        this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout];
        this[kServerName] = null;
        this[kLocalAddress] = localAddress != null ? localAddress : null;
        this[kResuming] = 0;
        this[kNeedDrain] = 0;
        this[kHostHeader] = `host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ""}\r
`;
        this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 3e5;
        this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 3e5;
        this[kStrictContentLength] = strictContentLength == null ? true : strictContentLength;
        this[kMaxRedirections] = maxRedirections;
        this[kMaxRequests] = maxRequestsPerClient;
        this[kClosedResolve] = null;
        this[kMaxResponseSize] = maxResponseSize > -1 ? maxResponseSize : -1;
        this[kMaxConcurrentStreams] = maxConcurrentStreams != null ? maxConcurrentStreams : 100;
        this[kHTTPContext] = null;
        this[kQueue] = [];
        this[kRunningIdx] = 0;
        this[kPendingIdx] = 0;
        this[kResume] = (sync) => resume(this, sync);
        this[kOnError] = (err) => onError(this, err);
      }
      get pipelining() {
        return this[kPipelining];
      }
      set pipelining(value) {
        this[kPipelining] = value;
        this[kResume](true);
      }
      get [kPending]() {
        return this[kQueue].length - this[kPendingIdx];
      }
      get [kRunning]() {
        return this[kPendingIdx] - this[kRunningIdx];
      }
      get [kSize]() {
        return this[kQueue].length - this[kRunningIdx];
      }
      get [kConnected]() {
        return !!this[kHTTPContext] && !this[kConnecting] && !this[kHTTPContext].destroyed;
      }
      get [kBusy]() {
        var _a;
        return Boolean(
          ((_a = this[kHTTPContext]) == null ? void 0 : _a.busy(null)) || this[kSize] >= (getPipelining(this) || 1) || this[kPending] > 0
        );
      }
      /* istanbul ignore: only used for test */
      [kConnect](cb) {
        connect(this);
        this.once("connect", cb);
      }
      [kDispatch](opts, handler) {
        const origin = opts.origin || this[kUrl].origin;
        const request = new Request(origin, opts, handler);
        this[kQueue].push(request);
        if (this[kResuming]) {
        } else if (util.bodyLength(request.body) == null && util.isIterable(request.body)) {
          this[kResuming] = 1;
          queueMicrotask(() => resume(this));
        } else {
          this[kResume](true);
        }
        if (this[kResuming] && this[kNeedDrain] !== 2 && this[kBusy]) {
          this[kNeedDrain] = 2;
        }
        return this[kNeedDrain] < 2;
      }
      async [kClose]() {
        return new Promise((resolve) => {
          if (this[kSize]) {
            this[kClosedResolve] = resolve;
          } else {
            resolve(null);
          }
        });
      }
      async [kDestroy](err) {
        return new Promise((resolve) => {
          const requests = this[kQueue].splice(this[kPendingIdx]);
          for (let i = 0; i < requests.length; i++) {
            const request = requests[i];
            util.errorRequest(this, request, err);
          }
          const callback = () => {
            if (this[kClosedResolve]) {
              this[kClosedResolve]();
              this[kClosedResolve] = null;
            }
            resolve(null);
          };
          if (this[kHTTPContext]) {
            this[kHTTPContext].destroy(err, callback);
            this[kHTTPContext] = null;
          } else {
            queueMicrotask(callback);
          }
          this[kResume]();
        });
      }
    };
    var createRedirectInterceptor = require_redirect_interceptor();
    function onError(client, err) {
      if (client[kRunning] === 0 && err.code !== "UND_ERR_INFO" && err.code !== "UND_ERR_SOCKET") {
        assert(client[kPendingIdx] === client[kRunningIdx]);
        const requests = client[kQueue].splice(client[kRunningIdx]);
        for (let i = 0; i < requests.length; i++) {
          const request = requests[i];
          util.errorRequest(client, request, err);
        }
        assert(client[kSize] === 0);
      }
    }
    async function connect(client) {
      var _a, _b, _c;
      assert(!client[kConnecting]);
      assert(!client[kHTTPContext]);
      let { host, hostname, protocol, port } = client[kUrl];
      if (hostname[0] === "[") {
        const idx = hostname.indexOf("]");
        assert(idx !== -1);
        const ip = hostname.substring(1, idx);
        assert(net.isIP(ip));
        hostname = ip;
      }
      client[kConnecting] = true;
      if (channels.beforeConnect.hasSubscribers) {
        channels.beforeConnect.publish({
          connectParams: {
            host,
            hostname,
            protocol,
            port,
            version: (_a = client[kHTTPContext]) == null ? void 0 : _a.version,
            servername: client[kServerName],
            localAddress: client[kLocalAddress]
          },
          connector: client[kConnector]
        });
      }
      try {
        const socket = await new Promise((resolve, reject) => {
          client[kConnector]({
            host,
            hostname,
            protocol,
            port,
            servername: client[kServerName],
            localAddress: client[kLocalAddress]
          }, (err, socket2) => {
            if (err) {
              reject(err);
            } else {
              resolve(socket2);
            }
          });
        });
        if (client.destroyed) {
          util.destroy(socket.on("error", noop), new ClientDestroyedError());
          return;
        }
        assert(socket);
        try {
          client[kHTTPContext] = socket.alpnProtocol === "h2" ? await connectH2(client, socket) : await connectH1(client, socket);
        } catch (err) {
          socket.destroy().on("error", noop);
          throw err;
        }
        client[kConnecting] = false;
        socket[kCounter] = 0;
        socket[kMaxRequests] = client[kMaxRequests];
        socket[kClient] = client;
        socket[kError] = null;
        if (channels.connected.hasSubscribers) {
          channels.connected.publish({
            connectParams: {
              host,
              hostname,
              protocol,
              port,
              version: (_b = client[kHTTPContext]) == null ? void 0 : _b.version,
              servername: client[kServerName],
              localAddress: client[kLocalAddress]
            },
            connector: client[kConnector],
            socket
          });
        }
        client.emit("connect", client[kUrl], [client]);
      } catch (err) {
        if (client.destroyed) {
          return;
        }
        client[kConnecting] = false;
        if (channels.connectError.hasSubscribers) {
          channels.connectError.publish({
            connectParams: {
              host,
              hostname,
              protocol,
              port,
              version: (_c = client[kHTTPContext]) == null ? void 0 : _c.version,
              servername: client[kServerName],
              localAddress: client[kLocalAddress]
            },
            connector: client[kConnector],
            error: err
          });
        }
        if (err.code === "ERR_TLS_CERT_ALTNAME_INVALID") {
          assert(client[kRunning] === 0);
          while (client[kPending] > 0 && client[kQueue][client[kPendingIdx]].servername === client[kServerName]) {
            const request = client[kQueue][client[kPendingIdx]++];
            util.errorRequest(client, request, err);
          }
        } else {
          onError(client, err);
        }
        client.emit("connectionError", client[kUrl], [client], err);
      }
      client[kResume]();
    }
    function emitDrain(client) {
      client[kNeedDrain] = 0;
      client.emit("drain", client[kUrl], [client]);
    }
    function resume(client, sync) {
      if (client[kResuming] === 2) {
        return;
      }
      client[kResuming] = 2;
      _resume(client, sync);
      client[kResuming] = 0;
      if (client[kRunningIdx] > 256) {
        client[kQueue].splice(0, client[kRunningIdx]);
        client[kPendingIdx] -= client[kRunningIdx];
        client[kRunningIdx] = 0;
      }
    }
    function _resume(client, sync) {
      var _a;
      while (true) {
        if (client.destroyed) {
          assert(client[kPending] === 0);
          return;
        }
        if (client[kClosedResolve] && !client[kSize]) {
          client[kClosedResolve]();
          client[kClosedResolve] = null;
          return;
        }
        if (client[kHTTPContext]) {
          client[kHTTPContext].resume();
        }
        if (client[kBusy]) {
          client[kNeedDrain] = 2;
        } else if (client[kNeedDrain] === 2) {
          if (sync) {
            client[kNeedDrain] = 1;
            queueMicrotask(() => emitDrain(client));
          } else {
            emitDrain(client);
          }
          continue;
        }
        if (client[kPending] === 0) {
          return;
        }
        if (client[kRunning] >= (getPipelining(client) || 1)) {
          return;
        }
        const request = client[kQueue][client[kPendingIdx]];
        if (client[kUrl].protocol === "https:" && client[kServerName] !== request.servername) {
          if (client[kRunning] > 0) {
            return;
          }
          client[kServerName] = request.servername;
          (_a = client[kHTTPContext]) == null ? void 0 : _a.destroy(new InformationalError("servername changed"), () => {
            client[kHTTPContext] = null;
            resume(client);
          });
        }
        if (client[kConnecting]) {
          return;
        }
        if (!client[kHTTPContext]) {
          connect(client);
          return;
        }
        if (client[kHTTPContext].destroyed) {
          return;
        }
        if (client[kHTTPContext].busy(request)) {
          return;
        }
        if (!request.aborted && client[kHTTPContext].write(request)) {
          client[kPendingIdx]++;
        } else {
          client[kQueue].splice(client[kPendingIdx], 1);
        }
      }
    }
    module2.exports = Client2;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/dispatcher/fixed-queue.js
var require_fixed_queue = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/dispatcher/fixed-queue.js"(exports2, module2) {
    "use strict";
    var kSize = 2048;
    var kMask = kSize - 1;
    var FixedCircularBuffer = class {
      constructor() {
        this.bottom = 0;
        this.top = 0;
        this.list = new Array(kSize);
        this.next = null;
      }
      isEmpty() {
        return this.top === this.bottom;
      }
      isFull() {
        return (this.top + 1 & kMask) === this.bottom;
      }
      push(data) {
        this.list[this.top] = data;
        this.top = this.top + 1 & kMask;
      }
      shift() {
        const nextItem = this.list[this.bottom];
        if (nextItem === void 0)
          return null;
        this.list[this.bottom] = void 0;
        this.bottom = this.bottom + 1 & kMask;
        return nextItem;
      }
    };
    module2.exports = class FixedQueue {
      constructor() {
        this.head = this.tail = new FixedCircularBuffer();
      }
      isEmpty() {
        return this.head.isEmpty();
      }
      push(data) {
        if (this.head.isFull()) {
          this.head = this.head.next = new FixedCircularBuffer();
        }
        this.head.push(data);
      }
      shift() {
        const tail = this.tail;
        const next = tail.shift();
        if (tail.isEmpty() && tail.next !== null) {
          this.tail = tail.next;
        }
        return next;
      }
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/dispatcher/pool-stats.js
var require_pool_stats = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/dispatcher/pool-stats.js"(exports2, module2) {
    var { kFree, kConnected, kPending, kQueued, kRunning, kSize } = require_symbols();
    var kPool = Symbol("pool");
    var PoolStats = class {
      constructor(pool) {
        this[kPool] = pool;
      }
      get connected() {
        return this[kPool][kConnected];
      }
      get free() {
        return this[kPool][kFree];
      }
      get pending() {
        return this[kPool][kPending];
      }
      get queued() {
        return this[kPool][kQueued];
      }
      get running() {
        return this[kPool][kRunning];
      }
      get size() {
        return this[kPool][kSize];
      }
    };
    module2.exports = PoolStats;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/dispatcher/pool-base.js
var require_pool_base = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/dispatcher/pool-base.js"(exports2, module2) {
    "use strict";
    var DispatcherBase = require_dispatcher_base();
    var FixedQueue = require_fixed_queue();
    var { kConnected, kSize, kRunning, kPending, kQueued, kBusy, kFree, kUrl, kClose, kDestroy, kDispatch } = require_symbols();
    var PoolStats = require_pool_stats();
    var kClients = Symbol("clients");
    var kNeedDrain = Symbol("needDrain");
    var kQueue = Symbol("queue");
    var kClosedResolve = Symbol("closed resolve");
    var kOnDrain = Symbol("onDrain");
    var kOnConnect = Symbol("onConnect");
    var kOnDisconnect = Symbol("onDisconnect");
    var kOnConnectionError = Symbol("onConnectionError");
    var kGetDispatcher = Symbol("get dispatcher");
    var kAddClient = Symbol("add client");
    var kRemoveClient = Symbol("remove client");
    var kStats = Symbol("stats");
    var PoolBase = class extends DispatcherBase {
      constructor() {
        super();
        this[kQueue] = new FixedQueue();
        this[kClients] = [];
        this[kQueued] = 0;
        const pool = this;
        this[kOnDrain] = function onDrain(origin, targets) {
          const queue = pool[kQueue];
          let needDrain = false;
          while (!needDrain) {
            const item = queue.shift();
            if (!item) {
              break;
            }
            pool[kQueued]--;
            needDrain = !this.dispatch(item.opts, item.handler);
          }
          this[kNeedDrain] = needDrain;
          if (!this[kNeedDrain] && pool[kNeedDrain]) {
            pool[kNeedDrain] = false;
            pool.emit("drain", origin, [pool, ...targets]);
          }
          if (pool[kClosedResolve] && queue.isEmpty()) {
            Promise.all(pool[kClients].map((c) => c.close())).then(pool[kClosedResolve]);
          }
        };
        this[kOnConnect] = (origin, targets) => {
          pool.emit("connect", origin, [pool, ...targets]);
        };
        this[kOnDisconnect] = (origin, targets, err) => {
          pool.emit("disconnect", origin, [pool, ...targets], err);
        };
        this[kOnConnectionError] = (origin, targets, err) => {
          pool.emit("connectionError", origin, [pool, ...targets], err);
        };
        this[kStats] = new PoolStats(this);
      }
      get [kBusy]() {
        return this[kNeedDrain];
      }
      get [kConnected]() {
        return this[kClients].filter((client) => client[kConnected]).length;
      }
      get [kFree]() {
        return this[kClients].filter((client) => client[kConnected] && !client[kNeedDrain]).length;
      }
      get [kPending]() {
        let ret = this[kQueued];
        for (const { [kPending]: pending } of this[kClients]) {
          ret += pending;
        }
        return ret;
      }
      get [kRunning]() {
        let ret = 0;
        for (const { [kRunning]: running } of this[kClients]) {
          ret += running;
        }
        return ret;
      }
      get [kSize]() {
        let ret = this[kQueued];
        for (const { [kSize]: size } of this[kClients]) {
          ret += size;
        }
        return ret;
      }
      get stats() {
        return this[kStats];
      }
      async [kClose]() {
        if (this[kQueue].isEmpty()) {
          await Promise.all(this[kClients].map((c) => c.close()));
        } else {
          await new Promise((resolve) => {
            this[kClosedResolve] = resolve;
          });
        }
      }
      async [kDestroy](err) {
        while (true) {
          const item = this[kQueue].shift();
          if (!item) {
            break;
          }
          item.handler.onError(err);
        }
        await Promise.all(this[kClients].map((c) => c.destroy(err)));
      }
      [kDispatch](opts, handler) {
        const dispatcher = this[kGetDispatcher]();
        if (!dispatcher) {
          this[kNeedDrain] = true;
          this[kQueue].push({ opts, handler });
          this[kQueued]++;
        } else if (!dispatcher.dispatch(opts, handler)) {
          dispatcher[kNeedDrain] = true;
          this[kNeedDrain] = !this[kGetDispatcher]();
        }
        return !this[kNeedDrain];
      }
      [kAddClient](client) {
        client.on("drain", this[kOnDrain]).on("connect", this[kOnConnect]).on("disconnect", this[kOnDisconnect]).on("connectionError", this[kOnConnectionError]);
        this[kClients].push(client);
        if (this[kNeedDrain]) {
          queueMicrotask(() => {
            if (this[kNeedDrain]) {
              this[kOnDrain](client[kUrl], [this, client]);
            }
          });
        }
        return this;
      }
      [kRemoveClient](client) {
        client.close(() => {
          const idx = this[kClients].indexOf(client);
          if (idx !== -1) {
            this[kClients].splice(idx, 1);
          }
        });
        this[kNeedDrain] = this[kClients].some((dispatcher) => !dispatcher[kNeedDrain] && dispatcher.closed !== true && dispatcher.destroyed !== true);
      }
    };
    module2.exports = {
      PoolBase,
      kClients,
      kNeedDrain,
      kAddClient,
      kRemoveClient,
      kGetDispatcher
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/dispatcher/pool.js
var require_pool = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/dispatcher/pool.js"(exports2, module2) {
    "use strict";
    var {
      PoolBase,
      kClients,
      kNeedDrain,
      kAddClient,
      kGetDispatcher
    } = require_pool_base();
    var Client2 = require_client();
    var {
      InvalidArgumentError
    } = require_errors();
    var util = require_util2();
    var { kUrl, kInterceptors } = require_symbols();
    var buildConnector = require_connect();
    var kOptions = Symbol("options");
    var kConnections = Symbol("connections");
    var kFactory = Symbol("factory");
    function defaultFactory(origin, opts) {
      return new Client2(origin, opts);
    }
    var Pool = class extends PoolBase {
      constructor(origin, {
        connections,
        factory = defaultFactory,
        connect,
        connectTimeout,
        tls,
        maxCachedSessions,
        socketPath,
        autoSelectFamily,
        autoSelectFamilyAttemptTimeout,
        allowH2,
        ...options
      } = {}) {
        var _a;
        super();
        if (connections != null && (!Number.isFinite(connections) || connections < 0)) {
          throw new InvalidArgumentError("invalid connections");
        }
        if (typeof factory !== "function") {
          throw new InvalidArgumentError("factory must be a function.");
        }
        if (connect != null && typeof connect !== "function" && typeof connect !== "object") {
          throw new InvalidArgumentError("connect must be a function or an object");
        }
        if (typeof connect !== "function") {
          connect = buildConnector({
            ...tls,
            maxCachedSessions,
            allowH2,
            socketPath,
            timeout: connectTimeout,
            ...autoSelectFamily ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : void 0,
            ...connect
          });
        }
        this[kInterceptors] = ((_a = options.interceptors) == null ? void 0 : _a.Pool) && Array.isArray(options.interceptors.Pool) ? options.interceptors.Pool : [];
        this[kConnections] = connections || null;
        this[kUrl] = util.parseOrigin(origin);
        this[kOptions] = { ...util.deepClone(options), connect, allowH2 };
        this[kOptions].interceptors = options.interceptors ? { ...options.interceptors } : void 0;
        this[kFactory] = factory;
      }
      [kGetDispatcher]() {
        for (const client of this[kClients]) {
          if (!client[kNeedDrain]) {
            return client;
          }
        }
        if (!this[kConnections] || this[kClients].length < this[kConnections]) {
          const dispatcher = this[kFactory](this[kUrl], this[kOptions]);
          this[kAddClient](dispatcher);
          return dispatcher;
        }
      }
    };
    module2.exports = Pool;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/dispatcher/balanced-pool.js
var require_balanced_pool = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/dispatcher/balanced-pool.js"(exports2, module2) {
    "use strict";
    var {
      BalancedPoolMissingUpstreamError,
      InvalidArgumentError
    } = require_errors();
    var {
      PoolBase,
      kClients,
      kNeedDrain,
      kAddClient,
      kRemoveClient,
      kGetDispatcher
    } = require_pool_base();
    var Pool = require_pool();
    var { kUrl, kInterceptors } = require_symbols();
    var { parseOrigin } = require_util2();
    var kFactory = Symbol("factory");
    var kOptions = Symbol("options");
    var kGreatestCommonDivisor = Symbol("kGreatestCommonDivisor");
    var kCurrentWeight = Symbol("kCurrentWeight");
    var kIndex = Symbol("kIndex");
    var kWeight = Symbol("kWeight");
    var kMaxWeightPerServer = Symbol("kMaxWeightPerServer");
    var kErrorPenalty = Symbol("kErrorPenalty");
    function getGreatestCommonDivisor(a, b) {
      if (a === 0) return b;
      while (b !== 0) {
        const t = b;
        b = a % b;
        a = t;
      }
      return a;
    }
    function defaultFactory(origin, opts) {
      return new Pool(origin, opts);
    }
    var BalancedPool = class extends PoolBase {
      constructor(upstreams = [], { factory = defaultFactory, ...opts } = {}) {
        var _a;
        super();
        this[kOptions] = opts;
        this[kIndex] = -1;
        this[kCurrentWeight] = 0;
        this[kMaxWeightPerServer] = this[kOptions].maxWeightPerServer || 100;
        this[kErrorPenalty] = this[kOptions].errorPenalty || 15;
        if (!Array.isArray(upstreams)) {
          upstreams = [upstreams];
        }
        if (typeof factory !== "function") {
          throw new InvalidArgumentError("factory must be a function.");
        }
        this[kInterceptors] = ((_a = opts.interceptors) == null ? void 0 : _a.BalancedPool) && Array.isArray(opts.interceptors.BalancedPool) ? opts.interceptors.BalancedPool : [];
        this[kFactory] = factory;
        for (const upstream of upstreams) {
          this.addUpstream(upstream);
        }
        this._updateBalancedPoolStats();
      }
      addUpstream(upstream) {
        const upstreamOrigin = parseOrigin(upstream).origin;
        if (this[kClients].find((pool2) => pool2[kUrl].origin === upstreamOrigin && pool2.closed !== true && pool2.destroyed !== true)) {
          return this;
        }
        const pool = this[kFactory](upstreamOrigin, Object.assign({}, this[kOptions]));
        this[kAddClient](pool);
        pool.on("connect", () => {
          pool[kWeight] = Math.min(this[kMaxWeightPerServer], pool[kWeight] + this[kErrorPenalty]);
        });
        pool.on("connectionError", () => {
          pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);
          this._updateBalancedPoolStats();
        });
        pool.on("disconnect", (...args) => {
          const err = args[2];
          if (err && err.code === "UND_ERR_SOCKET") {
            pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);
            this._updateBalancedPoolStats();
          }
        });
        for (const client of this[kClients]) {
          client[kWeight] = this[kMaxWeightPerServer];
        }
        this._updateBalancedPoolStats();
        return this;
      }
      _updateBalancedPoolStats() {
        let result = 0;
        for (let i = 0; i < this[kClients].length; i++) {
          result = getGreatestCommonDivisor(this[kClients][i][kWeight], result);
        }
        this[kGreatestCommonDivisor] = result;
      }
      removeUpstream(upstream) {
        const upstreamOrigin = parseOrigin(upstream).origin;
        const pool = this[kClients].find((pool2) => pool2[kUrl].origin === upstreamOrigin && pool2.closed !== true && pool2.destroyed !== true);
        if (pool) {
          this[kRemoveClient](pool);
        }
        return this;
      }
      get upstreams() {
        return this[kClients].filter((dispatcher) => dispatcher.closed !== true && dispatcher.destroyed !== true).map((p) => p[kUrl].origin);
      }
      [kGetDispatcher]() {
        if (this[kClients].length === 0) {
          throw new BalancedPoolMissingUpstreamError();
        }
        const dispatcher = this[kClients].find((dispatcher2) => !dispatcher2[kNeedDrain] && dispatcher2.closed !== true && dispatcher2.destroyed !== true);
        if (!dispatcher) {
          return;
        }
        const allClientsBusy = this[kClients].map((pool) => pool[kNeedDrain]).reduce((a, b) => a && b, true);
        if (allClientsBusy) {
          return;
        }
        let counter = 0;
        let maxWeightIndex = this[kClients].findIndex((pool) => !pool[kNeedDrain]);
        while (counter++ < this[kClients].length) {
          this[kIndex] = (this[kIndex] + 1) % this[kClients].length;
          const pool = this[kClients][this[kIndex]];
          if (pool[kWeight] > this[kClients][maxWeightIndex][kWeight] && !pool[kNeedDrain]) {
            maxWeightIndex = this[kIndex];
          }
          if (this[kIndex] === 0) {
            this[kCurrentWeight] = this[kCurrentWeight] - this[kGreatestCommonDivisor];
            if (this[kCurrentWeight] <= 0) {
              this[kCurrentWeight] = this[kMaxWeightPerServer];
            }
          }
          if (pool[kWeight] >= this[kCurrentWeight] && !pool[kNeedDrain]) {
            return pool;
          }
        }
        this[kCurrentWeight] = this[kClients][maxWeightIndex][kWeight];
        this[kIndex] = maxWeightIndex;
        return this[kClients][maxWeightIndex];
      }
    };
    module2.exports = BalancedPool;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/dispatcher/agent.js
var require_agent = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/dispatcher/agent.js"(exports2, module2) {
    "use strict";
    var { InvalidArgumentError } = require_errors();
    var { kClients, kRunning, kClose, kDestroy, kDispatch, kInterceptors } = require_symbols();
    var DispatcherBase = require_dispatcher_base();
    var Pool = require_pool();
    var Client2 = require_client();
    var util = require_util2();
    var createRedirectInterceptor = require_redirect_interceptor();
    var kOnConnect = Symbol("onConnect");
    var kOnDisconnect = Symbol("onDisconnect");
    var kOnConnectionError = Symbol("onConnectionError");
    var kMaxRedirections = Symbol("maxRedirections");
    var kOnDrain = Symbol("onDrain");
    var kFactory = Symbol("factory");
    var kOptions = Symbol("options");
    function defaultFactory(origin, opts) {
      return opts && opts.connections === 1 ? new Client2(origin, opts) : new Pool(origin, opts);
    }
    var Agent = class extends DispatcherBase {
      constructor({ factory = defaultFactory, maxRedirections = 0, connect, ...options } = {}) {
        var _a;
        super();
        if (typeof factory !== "function") {
          throw new InvalidArgumentError("factory must be a function.");
        }
        if (connect != null && typeof connect !== "function" && typeof connect !== "object") {
          throw new InvalidArgumentError("connect must be a function or an object");
        }
        if (!Number.isInteger(maxRedirections) || maxRedirections < 0) {
          throw new InvalidArgumentError("maxRedirections must be a positive number");
        }
        if (connect && typeof connect !== "function") {
          connect = { ...connect };
        }
        this[kInterceptors] = ((_a = options.interceptors) == null ? void 0 : _a.Agent) && Array.isArray(options.interceptors.Agent) ? options.interceptors.Agent : [createRedirectInterceptor({ maxRedirections })];
        this[kOptions] = { ...util.deepClone(options), connect };
        this[kOptions].interceptors = options.interceptors ? { ...options.interceptors } : void 0;
        this[kMaxRedirections] = maxRedirections;
        this[kFactory] = factory;
        this[kClients] = /* @__PURE__ */ new Map();
        this[kOnDrain] = (origin, targets) => {
          this.emit("drain", origin, [this, ...targets]);
        };
        this[kOnConnect] = (origin, targets) => {
          this.emit("connect", origin, [this, ...targets]);
        };
        this[kOnDisconnect] = (origin, targets, err) => {
          this.emit("disconnect", origin, [this, ...targets], err);
        };
        this[kOnConnectionError] = (origin, targets, err) => {
          this.emit("connectionError", origin, [this, ...targets], err);
        };
      }
      get [kRunning]() {
        let ret = 0;
        for (const client of this[kClients].values()) {
          ret += client[kRunning];
        }
        return ret;
      }
      [kDispatch](opts, handler) {
        let key;
        if (opts.origin && (typeof opts.origin === "string" || opts.origin instanceof URL)) {
          key = String(opts.origin);
        } else {
          throw new InvalidArgumentError("opts.origin must be a non-empty string or URL.");
        }
        let dispatcher = this[kClients].get(key);
        if (!dispatcher) {
          dispatcher = this[kFactory](opts.origin, this[kOptions]).on("drain", this[kOnDrain]).on("connect", this[kOnConnect]).on("disconnect", this[kOnDisconnect]).on("connectionError", this[kOnConnectionError]);
          this[kClients].set(key, dispatcher);
        }
        return dispatcher.dispatch(opts, handler);
      }
      async [kClose]() {
        const closePromises = [];
        for (const client of this[kClients].values()) {
          closePromises.push(client.close());
        }
        this[kClients].clear();
        await Promise.all(closePromises);
      }
      async [kDestroy](err) {
        const destroyPromises = [];
        for (const client of this[kClients].values()) {
          destroyPromises.push(client.destroy(err));
        }
        this[kClients].clear();
        await Promise.all(destroyPromises);
      }
    };
    module2.exports = Agent;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/dispatcher/proxy-agent.js
var require_proxy_agent = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/dispatcher/proxy-agent.js"(exports2, module2) {
    "use strict";
    var { kProxy, kClose, kDestroy, kInterceptors } = require_symbols();
    var { URL: URL2 } = require_node_url();
    var Agent = require_agent();
    var Pool = require_pool();
    var DispatcherBase = require_dispatcher_base();
    var { InvalidArgumentError, RequestAbortedError, SecureProxyConnectionError } = require_errors();
    var buildConnector = require_connect();
    var kAgent = Symbol("proxy agent");
    var kClient = Symbol("proxy client");
    var kProxyHeaders = Symbol("proxy headers");
    var kRequestTls = Symbol("request tls settings");
    var kProxyTls = Symbol("proxy tls settings");
    var kConnectEndpoint = Symbol("connect endpoint function");
    function defaultProtocolPort(protocol) {
      return protocol === "https:" ? 443 : 80;
    }
    function defaultFactory(origin, opts) {
      return new Pool(origin, opts);
    }
    var noop = () => {
    };
    var _ProxyAgent_instances, getUrl_fn;
    var ProxyAgent = class extends DispatcherBase {
      constructor(opts) {
        var _a;
        super();
        __privateAdd(this, _ProxyAgent_instances);
        if (!opts || typeof opts === "object" && !(opts instanceof URL2) && !opts.uri) {
          throw new InvalidArgumentError("Proxy uri is mandatory");
        }
        const { clientFactory = defaultFactory } = opts;
        if (typeof clientFactory !== "function") {
          throw new InvalidArgumentError("Proxy opts.clientFactory must be a function.");
        }
        const url = __privateMethod(this, _ProxyAgent_instances, getUrl_fn).call(this, opts);
        const { href, origin, port, protocol, username, password, hostname: proxyHostname } = url;
        this[kProxy] = { uri: href, protocol };
        this[kInterceptors] = ((_a = opts.interceptors) == null ? void 0 : _a.ProxyAgent) && Array.isArray(opts.interceptors.ProxyAgent) ? opts.interceptors.ProxyAgent : [];
        this[kRequestTls] = opts.requestTls;
        this[kProxyTls] = opts.proxyTls;
        this[kProxyHeaders] = opts.headers || {};
        if (opts.auth && opts.token) {
          throw new InvalidArgumentError("opts.auth cannot be used in combination with opts.token");
        } else if (opts.auth) {
          this[kProxyHeaders]["proxy-authorization"] = `Basic ${opts.auth}`;
        } else if (opts.token) {
          this[kProxyHeaders]["proxy-authorization"] = opts.token;
        } else if (username && password) {
          this[kProxyHeaders]["proxy-authorization"] = `Basic ${Buffer.from(`${decodeURIComponent(username)}:${decodeURIComponent(password)}`).toString("base64")}`;
        }
        const connect = buildConnector({ ...opts.proxyTls });
        this[kConnectEndpoint] = buildConnector({ ...opts.requestTls });
        this[kClient] = clientFactory(url, { connect });
        this[kAgent] = new Agent({
          ...opts,
          connect: async (opts2, callback) => {
            var _a2;
            let requestedPath = opts2.host;
            if (!opts2.port) {
              requestedPath += `:${defaultProtocolPort(opts2.protocol)}`;
            }
            try {
              const { socket, statusCode } = await this[kClient].connect({
                origin,
                port,
                path: requestedPath,
                signal: opts2.signal,
                headers: {
                  ...this[kProxyHeaders],
                  host: opts2.host
                },
                servername: ((_a2 = this[kProxyTls]) == null ? void 0 : _a2.servername) || proxyHostname
              });
              if (statusCode !== 200) {
                socket.on("error", noop).destroy();
                callback(new RequestAbortedError(`Proxy response (${statusCode}) !== 200 when HTTP Tunneling`));
              }
              if (opts2.protocol !== "https:") {
                callback(null, socket);
                return;
              }
              let servername;
              if (this[kRequestTls]) {
                servername = this[kRequestTls].servername;
              } else {
                servername = opts2.servername;
              }
              this[kConnectEndpoint]({ ...opts2, servername, httpSocket: socket }, callback);
            } catch (err) {
              if (err.code === "ERR_TLS_CERT_ALTNAME_INVALID") {
                callback(new SecureProxyConnectionError(err));
              } else {
                callback(err);
              }
            }
          }
        });
      }
      dispatch(opts, handler) {
        const headers = buildHeaders(opts.headers);
        throwIfProxyAuthIsSent(headers);
        if (headers && !("host" in headers) && !("Host" in headers)) {
          const { host } = new URL2(opts.origin);
          headers.host = host;
        }
        return this[kAgent].dispatch(
          {
            ...opts,
            headers
          },
          handler
        );
      }
      async [kClose]() {
        await this[kAgent].close();
        await this[kClient].close();
      }
      async [kDestroy]() {
        await this[kAgent].destroy();
        await this[kClient].destroy();
      }
    };
    _ProxyAgent_instances = new WeakSet();
    /**
     * @param {import('../types/proxy-agent').ProxyAgent.Options | string | URL} opts
     * @returns {URL}
     */
    getUrl_fn = function(opts) {
      if (typeof opts === "string") {
        return new URL2(opts);
      } else if (opts instanceof URL2) {
        return opts;
      } else {
        return new URL2(opts.uri);
      }
    };
    function buildHeaders(headers) {
      if (Array.isArray(headers)) {
        const headersPair = {};
        for (let i = 0; i < headers.length; i += 2) {
          headersPair[headers[i]] = headers[i + 1];
        }
        return headersPair;
      }
      return headers;
    }
    function throwIfProxyAuthIsSent(headers) {
      const existProxyAuth = headers && Object.keys(headers).find((key) => key.toLowerCase() === "proxy-authorization");
      if (existProxyAuth) {
        throw new InvalidArgumentError("Proxy-Authorization should be sent in ProxyAgent constructor");
      }
    }
    module2.exports = ProxyAgent;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/dispatcher/env-http-proxy-agent.js
var require_env_http_proxy_agent = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/dispatcher/env-http-proxy-agent.js"(exports2, module2) {
    "use strict";
    var DispatcherBase = require_dispatcher_base();
    var { kClose, kDestroy, kClosed, kDestroyed, kDispatch, kNoProxyAgent, kHttpProxyAgent, kHttpsProxyAgent } = require_symbols();
    var ProxyAgent = require_proxy_agent();
    var Agent = require_agent();
    var DEFAULT_PORTS = {
      "http:": 80,
      "https:": 443
    };
    var experimentalWarned = false;
    var _noProxyValue, _noProxyEntries, _opts, _EnvHttpProxyAgent_instances, getProxyAgentForUrl_fn, shouldProxy_fn, parseNoProxy_fn, noProxyChanged_get, noProxyEnv_get;
    var EnvHttpProxyAgent = class extends DispatcherBase {
      constructor(opts = {}) {
        super();
        __privateAdd(this, _EnvHttpProxyAgent_instances);
        __privateAdd(this, _noProxyValue, null);
        __privateAdd(this, _noProxyEntries, null);
        __privateAdd(this, _opts, null);
        __privateSet(this, _opts, opts);
        if (!experimentalWarned) {
          experimentalWarned = true;
          process.emitWarning("EnvHttpProxyAgent is experimental, expect them to change at any time.", {
            code: "UNDICI-EHPA"
          });
        }
        const { httpProxy, httpsProxy, noProxy, ...agentOpts } = opts;
        this[kNoProxyAgent] = new Agent(agentOpts);
        const HTTP_PROXY = httpProxy ?? process.env.http_proxy ?? process.env.HTTP_PROXY;
        if (HTTP_PROXY) {
          this[kHttpProxyAgent] = new ProxyAgent({ ...agentOpts, uri: HTTP_PROXY });
        } else {
          this[kHttpProxyAgent] = this[kNoProxyAgent];
        }
        const HTTPS_PROXY = httpsProxy ?? process.env.https_proxy ?? process.env.HTTPS_PROXY;
        if (HTTPS_PROXY) {
          this[kHttpsProxyAgent] = new ProxyAgent({ ...agentOpts, uri: HTTPS_PROXY });
        } else {
          this[kHttpsProxyAgent] = this[kHttpProxyAgent];
        }
        __privateMethod(this, _EnvHttpProxyAgent_instances, parseNoProxy_fn).call(this);
      }
      [kDispatch](opts, handler) {
        const url = new URL(opts.origin);
        const agent = __privateMethod(this, _EnvHttpProxyAgent_instances, getProxyAgentForUrl_fn).call(this, url);
        return agent.dispatch(opts, handler);
      }
      async [kClose]() {
        await this[kNoProxyAgent].close();
        if (!this[kHttpProxyAgent][kClosed]) {
          await this[kHttpProxyAgent].close();
        }
        if (!this[kHttpsProxyAgent][kClosed]) {
          await this[kHttpsProxyAgent].close();
        }
      }
      async [kDestroy](err) {
        await this[kNoProxyAgent].destroy(err);
        if (!this[kHttpProxyAgent][kDestroyed]) {
          await this[kHttpProxyAgent].destroy(err);
        }
        if (!this[kHttpsProxyAgent][kDestroyed]) {
          await this[kHttpsProxyAgent].destroy(err);
        }
      }
    };
    _noProxyValue = new WeakMap();
    _noProxyEntries = new WeakMap();
    _opts = new WeakMap();
    _EnvHttpProxyAgent_instances = new WeakSet();
    getProxyAgentForUrl_fn = function(url) {
      let { protocol, host: hostname, port } = url;
      hostname = hostname.replace(/:\d*$/, "").toLowerCase();
      port = Number.parseInt(port, 10) || DEFAULT_PORTS[protocol] || 0;
      if (!__privateMethod(this, _EnvHttpProxyAgent_instances, shouldProxy_fn).call(this, hostname, port)) {
        return this[kNoProxyAgent];
      }
      if (protocol === "https:") {
        return this[kHttpsProxyAgent];
      }
      return this[kHttpProxyAgent];
    };
    shouldProxy_fn = function(hostname, port) {
      if (__privateGet(this, _EnvHttpProxyAgent_instances, noProxyChanged_get)) {
        __privateMethod(this, _EnvHttpProxyAgent_instances, parseNoProxy_fn).call(this);
      }
      if (__privateGet(this, _noProxyEntries).length === 0) {
        return true;
      }
      if (__privateGet(this, _noProxyValue) === "*") {
        return false;
      }
      for (let i = 0; i < __privateGet(this, _noProxyEntries).length; i++) {
        const entry = __privateGet(this, _noProxyEntries)[i];
        if (entry.port && entry.port !== port) {
          continue;
        }
        if (!/^[.*]/.test(entry.hostname)) {
          if (hostname === entry.hostname) {
            return false;
          }
        } else {
          if (hostname.endsWith(entry.hostname.replace(/^\*/, ""))) {
            return false;
          }
        }
      }
      return true;
    };
    parseNoProxy_fn = function() {
      const noProxyValue = __privateGet(this, _opts).noProxy ?? __privateGet(this, _EnvHttpProxyAgent_instances, noProxyEnv_get);
      const noProxySplit = noProxyValue.split(/[,\s]/);
      const noProxyEntries = [];
      for (let i = 0; i < noProxySplit.length; i++) {
        const entry = noProxySplit[i];
        if (!entry) {
          continue;
        }
        const parsed = entry.match(/^(.+):(\d+)$/);
        noProxyEntries.push({
          hostname: (parsed ? parsed[1] : entry).toLowerCase(),
          port: parsed ? Number.parseInt(parsed[2], 10) : 0
        });
      }
      __privateSet(this, _noProxyValue, noProxyValue);
      __privateSet(this, _noProxyEntries, noProxyEntries);
    };
    noProxyChanged_get = function() {
      if (__privateGet(this, _opts).noProxy !== void 0) {
        return false;
      }
      return __privateGet(this, _noProxyValue) !== __privateGet(this, _EnvHttpProxyAgent_instances, noProxyEnv_get);
    };
    noProxyEnv_get = function() {
      return process.env.no_proxy ?? process.env.NO_PROXY ?? "";
    };
    module2.exports = EnvHttpProxyAgent;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/handler/retry-handler.js
var require_retry_handler = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/handler/retry-handler.js"(exports2, module2) {
    "use strict";
    var assert = require_node_assert();
    var { kRetryHandlerDefaultRetry } = require_symbols();
    var { RequestRetryError } = require_errors();
    var {
      isDisturbed,
      parseHeaders,
      parseRangeHeader,
      wrapRequestBody
    } = require_util2();
    function calculateRetryAfterHeader(retryAfter) {
      const current = Date.now();
      return new Date(retryAfter).getTime() - current;
    }
    var RetryHandler = class _RetryHandler {
      constructor(opts, handlers) {
        const { retryOptions, ...dispatchOpts } = opts;
        const {
          // Retry scoped
          retry: retryFn,
          maxRetries,
          maxTimeout,
          minTimeout,
          timeoutFactor,
          // Response scoped
          methods,
          errorCodes,
          retryAfter,
          statusCodes
        } = retryOptions ?? {};
        this.dispatch = handlers.dispatch;
        this.handler = handlers.handler;
        this.opts = { ...dispatchOpts, body: wrapRequestBody(opts.body) };
        this.abort = null;
        this.aborted = false;
        this.retryOpts = {
          retry: retryFn ?? _RetryHandler[kRetryHandlerDefaultRetry],
          retryAfter: retryAfter ?? true,
          maxTimeout: maxTimeout ?? 30 * 1e3,
          // 30s,
          minTimeout: minTimeout ?? 500,
          // .5s
          timeoutFactor: timeoutFactor ?? 2,
          maxRetries: maxRetries ?? 5,
          // What errors we should retry
          methods: methods ?? ["GET", "HEAD", "OPTIONS", "PUT", "DELETE", "TRACE"],
          // Indicates which errors to retry
          statusCodes: statusCodes ?? [500, 502, 503, 504, 429],
          // List of errors to retry
          errorCodes: errorCodes ?? [
            "ECONNRESET",
            "ECONNREFUSED",
            "ENOTFOUND",
            "ENETDOWN",
            "ENETUNREACH",
            "EHOSTDOWN",
            "EHOSTUNREACH",
            "EPIPE",
            "UND_ERR_SOCKET"
          ]
        };
        this.retryCount = 0;
        this.retryCountCheckpoint = 0;
        this.start = 0;
        this.end = null;
        this.etag = null;
        this.resume = null;
        this.handler.onConnect((reason) => {
          this.aborted = true;
          if (this.abort) {
            this.abort(reason);
          } else {
            this.reason = reason;
          }
        });
      }
      onRequestSent() {
        if (this.handler.onRequestSent) {
          this.handler.onRequestSent();
        }
      }
      onUpgrade(statusCode, headers, socket) {
        if (this.handler.onUpgrade) {
          this.handler.onUpgrade(statusCode, headers, socket);
        }
      }
      onConnect(abort) {
        if (this.aborted) {
          abort(this.reason);
        } else {
          this.abort = abort;
        }
      }
      onBodySent(chunk) {
        if (this.handler.onBodySent) return this.handler.onBodySent(chunk);
      }
      static [kRetryHandlerDefaultRetry](err, { state, opts }, cb) {
        const { statusCode, code, headers } = err;
        const { method, retryOptions } = opts;
        const {
          maxRetries,
          minTimeout,
          maxTimeout,
          timeoutFactor,
          statusCodes,
          errorCodes,
          methods
        } = retryOptions;
        const { counter } = state;
        if (code && code !== "UND_ERR_REQ_RETRY" && !errorCodes.includes(code)) {
          cb(err);
          return;
        }
        if (Array.isArray(methods) && !methods.includes(method)) {
          cb(err);
          return;
        }
        if (statusCode != null && Array.isArray(statusCodes) && !statusCodes.includes(statusCode)) {
          cb(err);
          return;
        }
        if (counter > maxRetries) {
          cb(err);
          return;
        }
        let retryAfterHeader = headers == null ? void 0 : headers["retry-after"];
        if (retryAfterHeader) {
          retryAfterHeader = Number(retryAfterHeader);
          retryAfterHeader = Number.isNaN(retryAfterHeader) ? calculateRetryAfterHeader(retryAfterHeader) : retryAfterHeader * 1e3;
        }
        const retryTimeout = retryAfterHeader > 0 ? Math.min(retryAfterHeader, maxTimeout) : Math.min(minTimeout * timeoutFactor ** (counter - 1), maxTimeout);
        setTimeout(() => cb(null), retryTimeout);
      }
      onHeaders(statusCode, rawHeaders, resume, statusMessage) {
        const headers = parseHeaders(rawHeaders);
        this.retryCount += 1;
        if (statusCode >= 300) {
          if (this.retryOpts.statusCodes.includes(statusCode) === false) {
            return this.handler.onHeaders(
              statusCode,
              rawHeaders,
              resume,
              statusMessage
            );
          } else {
            this.abort(
              new RequestRetryError("Request failed", statusCode, {
                headers,
                data: {
                  count: this.retryCount
                }
              })
            );
            return false;
          }
        }
        if (this.resume != null) {
          this.resume = null;
          if (statusCode !== 206 && (this.start > 0 || statusCode !== 200)) {
            this.abort(
              new RequestRetryError("server does not support the range header and the payload was partially consumed", statusCode, {
                headers,
                data: { count: this.retryCount }
              })
            );
            return false;
          }
          const contentRange = parseRangeHeader(headers["content-range"]);
          if (!contentRange) {
            this.abort(
              new RequestRetryError("Content-Range mismatch", statusCode, {
                headers,
                data: { count: this.retryCount }
              })
            );
            return false;
          }
          if (this.etag != null && this.etag !== headers.etag) {
            this.abort(
              new RequestRetryError("ETag mismatch", statusCode, {
                headers,
                data: { count: this.retryCount }
              })
            );
            return false;
          }
          const { start, size, end = size - 1 } = contentRange;
          assert(this.start === start, "content-range mismatch");
          assert(this.end == null || this.end === end, "content-range mismatch");
          this.resume = resume;
          return true;
        }
        if (this.end == null) {
          if (statusCode === 206) {
            const range = parseRangeHeader(headers["content-range"]);
            if (range == null) {
              return this.handler.onHeaders(
                statusCode,
                rawHeaders,
                resume,
                statusMessage
              );
            }
            const { start, size, end = size - 1 } = range;
            assert(
              start != null && Number.isFinite(start),
              "content-range mismatch"
            );
            assert(end != null && Number.isFinite(end), "invalid content-length");
            this.start = start;
            this.end = end;
          }
          if (this.end == null) {
            const contentLength = headers["content-length"];
            this.end = contentLength != null ? Number(contentLength) - 1 : null;
          }
          assert(Number.isFinite(this.start));
          assert(
            this.end == null || Number.isFinite(this.end),
            "invalid content-length"
          );
          this.resume = resume;
          this.etag = headers.etag != null ? headers.etag : null;
          if (this.etag != null && this.etag.startsWith("W/")) {
            this.etag = null;
          }
          return this.handler.onHeaders(
            statusCode,
            rawHeaders,
            resume,
            statusMessage
          );
        }
        const err = new RequestRetryError("Request failed", statusCode, {
          headers,
          data: { count: this.retryCount }
        });
        this.abort(err);
        return false;
      }
      onData(chunk) {
        this.start += chunk.length;
        return this.handler.onData(chunk);
      }
      onComplete(rawTrailers) {
        this.retryCount = 0;
        return this.handler.onComplete(rawTrailers);
      }
      onError(err) {
        if (this.aborted || isDisturbed(this.opts.body)) {
          return this.handler.onError(err);
        }
        if (this.retryCount - this.retryCountCheckpoint > 0) {
          this.retryCount = this.retryCountCheckpoint + (this.retryCount - this.retryCountCheckpoint);
        } else {
          this.retryCount += 1;
        }
        this.retryOpts.retry(
          err,
          {
            state: { counter: this.retryCount },
            opts: { retryOptions: this.retryOpts, ...this.opts }
          },
          onRetry.bind(this)
        );
        function onRetry(err2) {
          if (err2 != null || this.aborted || isDisturbed(this.opts.body)) {
            return this.handler.onError(err2);
          }
          if (this.start !== 0) {
            const headers = { range: `bytes=${this.start}-${this.end ?? ""}` };
            if (this.etag != null) {
              headers["if-match"] = this.etag;
            }
            this.opts = {
              ...this.opts,
              headers: {
                ...this.opts.headers,
                ...headers
              }
            };
          }
          try {
            this.retryCountCheckpoint = this.retryCount;
            this.dispatch(this.opts, this);
          } catch (err3) {
            this.handler.onError(err3);
          }
        }
      }
    };
    module2.exports = RetryHandler;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/dispatcher/retry-agent.js
var require_retry_agent = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/dispatcher/retry-agent.js"(exports2, module2) {
    "use strict";
    var Dispatcher = require_dispatcher();
    var RetryHandler = require_retry_handler();
    var _agent, _options;
    var RetryAgent = class extends Dispatcher {
      constructor(agent, options = {}) {
        super(options);
        __privateAdd(this, _agent, null);
        __privateAdd(this, _options, null);
        __privateSet(this, _agent, agent);
        __privateSet(this, _options, options);
      }
      dispatch(opts, handler) {
        const retry = new RetryHandler({
          ...opts,
          retryOptions: __privateGet(this, _options)
        }, {
          dispatch: __privateGet(this, _agent).dispatch.bind(__privateGet(this, _agent)),
          handler
        });
        return __privateGet(this, _agent).dispatch(opts, retry);
      }
      close() {
        return __privateGet(this, _agent).close();
      }
      destroy() {
        return __privateGet(this, _agent).destroy();
      }
    };
    _agent = new WeakMap();
    _options = new WeakMap();
    module2.exports = RetryAgent;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/api/readable.js
var require_readable = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/api/readable.js"(exports2, module2) {
    "use strict";
    var assert = require_node_assert();
    var { Readable } = require_node_stream();
    var { RequestAbortedError, NotSupportedError, InvalidArgumentError, AbortError } = require_errors();
    var util = require_util2();
    var { ReadableStreamFrom } = require_util2();
    var kConsume = Symbol("kConsume");
    var kReading = Symbol("kReading");
    var kBody = Symbol("kBody");
    var kAbort = Symbol("kAbort");
    var kContentType = Symbol("kContentType");
    var kContentLength = Symbol("kContentLength");
    var noop = () => {
    };
    var BodyReadable = class extends Readable {
      constructor({
        resume,
        abort,
        contentType = "",
        contentLength,
        highWaterMark = 64 * 1024
        // Same as nodejs fs streams.
      }) {
        super({
          autoDestroy: true,
          read: resume,
          highWaterMark
        });
        this._readableState.dataEmitted = false;
        this[kAbort] = abort;
        this[kConsume] = null;
        this[kBody] = null;
        this[kContentType] = contentType;
        this[kContentLength] = contentLength;
        this[kReading] = false;
      }
      destroy(err) {
        if (!err && !this._readableState.endEmitted) {
          err = new RequestAbortedError();
        }
        if (err) {
          this[kAbort]();
        }
        return super.destroy(err);
      }
      _destroy(err, callback) {
        if (!this[kReading]) {
          setImmediate(() => {
            callback(err);
          });
        } else {
          callback(err);
        }
      }
      on(ev, ...args) {
        if (ev === "data" || ev === "readable") {
          this[kReading] = true;
        }
        return super.on(ev, ...args);
      }
      addListener(ev, ...args) {
        return this.on(ev, ...args);
      }
      off(ev, ...args) {
        const ret = super.off(ev, ...args);
        if (ev === "data" || ev === "readable") {
          this[kReading] = this.listenerCount("data") > 0 || this.listenerCount("readable") > 0;
        }
        return ret;
      }
      removeListener(ev, ...args) {
        return this.off(ev, ...args);
      }
      push(chunk) {
        if (this[kConsume] && chunk !== null) {
          consumePush(this[kConsume], chunk);
          return this[kReading] ? super.push(chunk) : true;
        }
        return super.push(chunk);
      }
      // https://fetch.spec.whatwg.org/#dom-body-text
      async text() {
        return consume(this, "text");
      }
      // https://fetch.spec.whatwg.org/#dom-body-json
      async json() {
        return consume(this, "json");
      }
      // https://fetch.spec.whatwg.org/#dom-body-blob
      async blob() {
        return consume(this, "blob");
      }
      // https://fetch.spec.whatwg.org/#dom-body-bytes
      async bytes() {
        return consume(this, "bytes");
      }
      // https://fetch.spec.whatwg.org/#dom-body-arraybuffer
      async arrayBuffer() {
        return consume(this, "arrayBuffer");
      }
      // https://fetch.spec.whatwg.org/#dom-body-formdata
      async formData() {
        throw new NotSupportedError();
      }
      // https://fetch.spec.whatwg.org/#dom-body-bodyused
      get bodyUsed() {
        return util.isDisturbed(this);
      }
      // https://fetch.spec.whatwg.org/#dom-body-body
      get body() {
        if (!this[kBody]) {
          this[kBody] = ReadableStreamFrom(this);
          if (this[kConsume]) {
            this[kBody].getReader();
            assert(this[kBody].locked);
          }
        }
        return this[kBody];
      }
      async dump(opts) {
        let limit = Number.isFinite(opts == null ? void 0 : opts.limit) ? opts.limit : 128 * 1024;
        const signal = opts == null ? void 0 : opts.signal;
        if (signal != null && (typeof signal !== "object" || !("aborted" in signal))) {
          throw new InvalidArgumentError("signal must be an AbortSignal");
        }
        signal == null ? void 0 : signal.throwIfAborted();
        if (this._readableState.closeEmitted) {
          return null;
        }
        return await new Promise((resolve, reject) => {
          if (this[kContentLength] > limit) {
            this.destroy(new AbortError());
          }
          const onAbort = () => {
            this.destroy(signal.reason ?? new AbortError());
          };
          signal == null ? void 0 : signal.addEventListener("abort", onAbort);
          this.on("close", function() {
            signal == null ? void 0 : signal.removeEventListener("abort", onAbort);
            if (signal == null ? void 0 : signal.aborted) {
              reject(signal.reason ?? new AbortError());
            } else {
              resolve(null);
            }
          }).on("error", noop).on("data", function(chunk) {
            limit -= chunk.length;
            if (limit <= 0) {
              this.destroy();
            }
          }).resume();
        });
      }
    };
    function isLocked(self2) {
      return self2[kBody] && self2[kBody].locked === true || self2[kConsume];
    }
    function isUnusable(self2) {
      return util.isDisturbed(self2) || isLocked(self2);
    }
    async function consume(stream, type) {
      assert(!stream[kConsume]);
      return new Promise((resolve, reject) => {
        if (isUnusable(stream)) {
          const rState = stream._readableState;
          if (rState.destroyed && rState.closeEmitted === false) {
            stream.on("error", (err) => {
              reject(err);
            }).on("close", () => {
              reject(new TypeError("unusable"));
            });
          } else {
            reject(rState.errored ?? new TypeError("unusable"));
          }
        } else {
          queueMicrotask(() => {
            stream[kConsume] = {
              type,
              stream,
              resolve,
              reject,
              length: 0,
              body: []
            };
            stream.on("error", function(err) {
              consumeFinish(this[kConsume], err);
            }).on("close", function() {
              if (this[kConsume].body !== null) {
                consumeFinish(this[kConsume], new RequestAbortedError());
              }
            });
            consumeStart(stream[kConsume]);
          });
        }
      });
    }
    function consumeStart(consume2) {
      if (consume2.body === null) {
        return;
      }
      const { _readableState: state } = consume2.stream;
      if (state.bufferIndex) {
        const start = state.bufferIndex;
        const end = state.buffer.length;
        for (let n = start; n < end; n++) {
          consumePush(consume2, state.buffer[n]);
        }
      } else {
        for (const chunk of state.buffer) {
          consumePush(consume2, chunk);
        }
      }
      if (state.endEmitted) {
        consumeEnd(this[kConsume]);
      } else {
        consume2.stream.on("end", function() {
          consumeEnd(this[kConsume]);
        });
      }
      consume2.stream.resume();
      while (consume2.stream.read() != null) {
      }
    }
    function chunksDecode(chunks, length) {
      if (chunks.length === 0 || length === 0) {
        return "";
      }
      const buffer = chunks.length === 1 ? chunks[0] : Buffer.concat(chunks, length);
      const bufferLength = buffer.length;
      const start = bufferLength > 2 && buffer[0] === 239 && buffer[1] === 187 && buffer[2] === 191 ? 3 : 0;
      return buffer.utf8Slice(start, bufferLength);
    }
    function chunksConcat(chunks, length) {
      if (chunks.length === 0 || length === 0) {
        return new Uint8Array(0);
      }
      if (chunks.length === 1) {
        return new Uint8Array(chunks[0]);
      }
      const buffer = new Uint8Array(Buffer.allocUnsafeSlow(length).buffer);
      let offset = 0;
      for (let i = 0; i < chunks.length; ++i) {
        const chunk = chunks[i];
        buffer.set(chunk, offset);
        offset += chunk.length;
      }
      return buffer;
    }
    function consumeEnd(consume2) {
      const { type, body, resolve, stream, length } = consume2;
      try {
        if (type === "text") {
          resolve(chunksDecode(body, length));
        } else if (type === "json") {
          resolve(JSON.parse(chunksDecode(body, length)));
        } else if (type === "arrayBuffer") {
          resolve(chunksConcat(body, length).buffer);
        } else if (type === "blob") {
          resolve(new Blob(body, { type: stream[kContentType] }));
        } else if (type === "bytes") {
          resolve(chunksConcat(body, length));
        }
        consumeFinish(consume2);
      } catch (err) {
        stream.destroy(err);
      }
    }
    function consumePush(consume2, chunk) {
      consume2.length += chunk.length;
      consume2.body.push(chunk);
    }
    function consumeFinish(consume2, err) {
      if (consume2.body === null) {
        return;
      }
      if (err) {
        consume2.reject(err);
      } else {
        consume2.resolve();
      }
      consume2.type = null;
      consume2.stream = null;
      consume2.resolve = null;
      consume2.reject = null;
      consume2.length = 0;
      consume2.body = null;
    }
    module2.exports = { Readable: BodyReadable, chunksDecode };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/api/util.js
var require_util4 = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/api/util.js"(exports2, module2) {
    var assert = require_node_assert();
    var {
      ResponseStatusCodeError
    } = require_errors();
    var { chunksDecode } = require_readable();
    var CHUNK_LIMIT = 128 * 1024;
    async function getResolveErrorBodyCallback({ callback, body, contentType, statusCode, statusMessage, headers }) {
      assert(body);
      let chunks = [];
      let length = 0;
      try {
        for await (const chunk of body) {
          chunks.push(chunk);
          length += chunk.length;
          if (length > CHUNK_LIMIT) {
            chunks = [];
            length = 0;
            break;
          }
        }
      } catch {
        chunks = [];
        length = 0;
      }
      const message = `Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`;
      if (statusCode === 204 || !contentType || !length) {
        queueMicrotask(() => callback(new ResponseStatusCodeError(message, statusCode, headers)));
        return;
      }
      const stackTraceLimit = Error.stackTraceLimit;
      Error.stackTraceLimit = 0;
      let payload;
      try {
        if (isContentTypeApplicationJson(contentType)) {
          payload = JSON.parse(chunksDecode(chunks, length));
        } else if (isContentTypeText(contentType)) {
          payload = chunksDecode(chunks, length);
        }
      } catch {
      } finally {
        Error.stackTraceLimit = stackTraceLimit;
      }
      queueMicrotask(() => callback(new ResponseStatusCodeError(message, statusCode, headers, payload)));
    }
    var isContentTypeApplicationJson = (contentType) => {
      return contentType.length > 15 && contentType[11] === "/" && contentType[0] === "a" && contentType[1] === "p" && contentType[2] === "p" && contentType[3] === "l" && contentType[4] === "i" && contentType[5] === "c" && contentType[6] === "a" && contentType[7] === "t" && contentType[8] === "i" && contentType[9] === "o" && contentType[10] === "n" && contentType[12] === "j" && contentType[13] === "s" && contentType[14] === "o" && contentType[15] === "n";
    };
    var isContentTypeText = (contentType) => {
      return contentType.length > 4 && contentType[4] === "/" && contentType[0] === "t" && contentType[1] === "e" && contentType[2] === "x" && contentType[3] === "t";
    };
    module2.exports = {
      getResolveErrorBodyCallback,
      isContentTypeApplicationJson,
      isContentTypeText
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/api/api-request.js
var require_api_request = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/api/api-request.js"(exports2, module2) {
    "use strict";
    var assert = require_node_assert();
    var { Readable } = require_readable();
    var { InvalidArgumentError, RequestAbortedError } = require_errors();
    var util = require_util2();
    var { getResolveErrorBodyCallback } = require_util4();
    var { AsyncResource } = require_node_async_hooks();
    var RequestHandler = class extends AsyncResource {
      constructor(opts, callback) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError, highWaterMark } = opts;
        try {
          if (typeof callback !== "function") {
            throw new InvalidArgumentError("invalid callback");
          }
          if (highWaterMark && (typeof highWaterMark !== "number" || highWaterMark < 0)) {
            throw new InvalidArgumentError("invalid highWaterMark");
          }
          if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
            throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
          }
          if (method === "CONNECT") {
            throw new InvalidArgumentError("invalid method");
          }
          if (onInfo && typeof onInfo !== "function") {
            throw new InvalidArgumentError("invalid onInfo callback");
          }
          super("UNDICI_REQUEST");
        } catch (err) {
          if (util.isStream(body)) {
            util.destroy(body.on("error", util.nop), err);
          }
          throw err;
        }
        this.method = method;
        this.responseHeaders = responseHeaders || null;
        this.opaque = opaque || null;
        this.callback = callback;
        this.res = null;
        this.abort = null;
        this.body = body;
        this.trailers = {};
        this.context = null;
        this.onInfo = onInfo || null;
        this.throwOnError = throwOnError;
        this.highWaterMark = highWaterMark;
        this.signal = signal;
        this.reason = null;
        this.removeAbortListener = null;
        if (util.isStream(body)) {
          body.on("error", (err) => {
            this.onError(err);
          });
        }
        if (this.signal) {
          if (this.signal.aborted) {
            this.reason = this.signal.reason ?? new RequestAbortedError();
          } else {
            this.removeAbortListener = util.addAbortListener(this.signal, () => {
              var _a;
              this.reason = this.signal.reason ?? new RequestAbortedError();
              if (this.res) {
                util.destroy(this.res, this.reason);
              } else if (this.abort) {
                this.abort(this.reason);
              }
              if (this.removeAbortListener) {
                (_a = this.res) == null ? void 0 : _a.off("close", this.removeAbortListener);
                this.removeAbortListener();
                this.removeAbortListener = null;
              }
            });
          }
        }
      }
      onConnect(abort, context) {
        if (this.reason) {
          abort(this.reason);
          return;
        }
        assert(this.callback);
        this.abort = abort;
        this.context = context;
      }
      onHeaders(statusCode, rawHeaders, resume, statusMessage) {
        const { callback, opaque, abort, context, responseHeaders, highWaterMark } = this;
        const headers = responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
        if (statusCode < 200) {
          if (this.onInfo) {
            this.onInfo({ statusCode, headers });
          }
          return;
        }
        const parsedHeaders = responseHeaders === "raw" ? util.parseHeaders(rawHeaders) : headers;
        const contentType = parsedHeaders["content-type"];
        const contentLength = parsedHeaders["content-length"];
        const res = new Readable({
          resume,
          abort,
          contentType,
          contentLength: this.method !== "HEAD" && contentLength ? Number(contentLength) : null,
          highWaterMark
        });
        if (this.removeAbortListener) {
          res.on("close", this.removeAbortListener);
        }
        this.callback = null;
        this.res = res;
        if (callback !== null) {
          if (this.throwOnError && statusCode >= 400) {
            this.runInAsyncScope(
              getResolveErrorBodyCallback,
              null,
              { callback, body: res, contentType, statusCode, statusMessage, headers }
            );
          } else {
            this.runInAsyncScope(callback, null, null, {
              statusCode,
              headers,
              trailers: this.trailers,
              opaque,
              body: res,
              context
            });
          }
        }
      }
      onData(chunk) {
        return this.res.push(chunk);
      }
      onComplete(trailers) {
        util.parseHeaders(trailers, this.trailers);
        this.res.push(null);
      }
      onError(err) {
        const { res, callback, body, opaque } = this;
        if (callback) {
          this.callback = null;
          queueMicrotask(() => {
            this.runInAsyncScope(callback, null, err, { opaque });
          });
        }
        if (res) {
          this.res = null;
          queueMicrotask(() => {
            util.destroy(res, err);
          });
        }
        if (body) {
          this.body = null;
          util.destroy(body, err);
        }
        if (this.removeAbortListener) {
          res == null ? void 0 : res.off("close", this.removeAbortListener);
          this.removeAbortListener();
          this.removeAbortListener = null;
        }
      }
    };
    function request(opts, callback) {
      if (callback === void 0) {
        return new Promise((resolve, reject) => {
          request.call(this, opts, (err, data) => {
            return err ? reject(err) : resolve(data);
          });
        });
      }
      try {
        this.dispatch(opts, new RequestHandler(opts, callback));
      } catch (err) {
        if (typeof callback !== "function") {
          throw err;
        }
        const opaque = opts == null ? void 0 : opts.opaque;
        queueMicrotask(() => callback(err, { opaque }));
      }
    }
    module2.exports = request;
    module2.exports.RequestHandler = RequestHandler;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/api/abort-signal.js
var require_abort_signal = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/api/abort-signal.js"(exports2, module2) {
    var { addAbortListener } = require_util2();
    var { RequestAbortedError } = require_errors();
    var kListener = Symbol("kListener");
    var kSignal = Symbol("kSignal");
    function abort(self2) {
      var _a, _b;
      if (self2.abort) {
        self2.abort((_a = self2[kSignal]) == null ? void 0 : _a.reason);
      } else {
        self2.reason = ((_b = self2[kSignal]) == null ? void 0 : _b.reason) ?? new RequestAbortedError();
      }
      removeSignal(self2);
    }
    function addSignal(self2, signal) {
      self2.reason = null;
      self2[kSignal] = null;
      self2[kListener] = null;
      if (!signal) {
        return;
      }
      if (signal.aborted) {
        abort(self2);
        return;
      }
      self2[kSignal] = signal;
      self2[kListener] = () => {
        abort(self2);
      };
      addAbortListener(self2[kSignal], self2[kListener]);
    }
    function removeSignal(self2) {
      if (!self2[kSignal]) {
        return;
      }
      if ("removeEventListener" in self2[kSignal]) {
        self2[kSignal].removeEventListener("abort", self2[kListener]);
      } else {
        self2[kSignal].removeListener("abort", self2[kListener]);
      }
      self2[kSignal] = null;
      self2[kListener] = null;
    }
    module2.exports = {
      addSignal,
      removeSignal
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/api/api-stream.js
var require_api_stream = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/api/api-stream.js"(exports2, module2) {
    "use strict";
    var assert = require_node_assert();
    var { finished, PassThrough } = require_node_stream();
    var { InvalidArgumentError, InvalidReturnValueError } = require_errors();
    var util = require_util2();
    var { getResolveErrorBodyCallback } = require_util4();
    var { AsyncResource } = require_node_async_hooks();
    var { addSignal, removeSignal } = require_abort_signal();
    var StreamHandler = class extends AsyncResource {
      constructor(opts, factory, callback) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError } = opts;
        try {
          if (typeof callback !== "function") {
            throw new InvalidArgumentError("invalid callback");
          }
          if (typeof factory !== "function") {
            throw new InvalidArgumentError("invalid factory");
          }
          if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
            throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
          }
          if (method === "CONNECT") {
            throw new InvalidArgumentError("invalid method");
          }
          if (onInfo && typeof onInfo !== "function") {
            throw new InvalidArgumentError("invalid onInfo callback");
          }
          super("UNDICI_STREAM");
        } catch (err) {
          if (util.isStream(body)) {
            util.destroy(body.on("error", util.nop), err);
          }
          throw err;
        }
        this.responseHeaders = responseHeaders || null;
        this.opaque = opaque || null;
        this.factory = factory;
        this.callback = callback;
        this.res = null;
        this.abort = null;
        this.context = null;
        this.trailers = null;
        this.body = body;
        this.onInfo = onInfo || null;
        this.throwOnError = throwOnError || false;
        if (util.isStream(body)) {
          body.on("error", (err) => {
            this.onError(err);
          });
        }
        addSignal(this, signal);
      }
      onConnect(abort, context) {
        if (this.reason) {
          abort(this.reason);
          return;
        }
        assert(this.callback);
        this.abort = abort;
        this.context = context;
      }
      onHeaders(statusCode, rawHeaders, resume, statusMessage) {
        var _a;
        const { factory, opaque, context, callback, responseHeaders } = this;
        const headers = responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
        if (statusCode < 200) {
          if (this.onInfo) {
            this.onInfo({ statusCode, headers });
          }
          return;
        }
        this.factory = null;
        let res;
        if (this.throwOnError && statusCode >= 400) {
          const parsedHeaders = responseHeaders === "raw" ? util.parseHeaders(rawHeaders) : headers;
          const contentType = parsedHeaders["content-type"];
          res = new PassThrough();
          this.callback = null;
          this.runInAsyncScope(
            getResolveErrorBodyCallback,
            null,
            { callback, body: res, contentType, statusCode, statusMessage, headers }
          );
        } else {
          if (factory === null) {
            return;
          }
          res = this.runInAsyncScope(factory, null, {
            statusCode,
            headers,
            opaque,
            context
          });
          if (!res || typeof res.write !== "function" || typeof res.end !== "function" || typeof res.on !== "function") {
            throw new InvalidReturnValueError("expected Writable");
          }
          finished(res, { readable: false }, (err) => {
            const { callback: callback2, res: res2, opaque: opaque2, trailers, abort } = this;
            this.res = null;
            if (err || !res2.readable) {
              util.destroy(res2, err);
            }
            this.callback = null;
            this.runInAsyncScope(callback2, null, err || null, { opaque: opaque2, trailers });
            if (err) {
              abort();
            }
          });
        }
        res.on("drain", resume);
        this.res = res;
        const needDrain = res.writableNeedDrain !== void 0 ? res.writableNeedDrain : (_a = res._writableState) == null ? void 0 : _a.needDrain;
        return needDrain !== true;
      }
      onData(chunk) {
        const { res } = this;
        return res ? res.write(chunk) : true;
      }
      onComplete(trailers) {
        const { res } = this;
        removeSignal(this);
        if (!res) {
          return;
        }
        this.trailers = util.parseHeaders(trailers);
        res.end();
      }
      onError(err) {
        const { res, callback, opaque, body } = this;
        removeSignal(this);
        this.factory = null;
        if (res) {
          this.res = null;
          util.destroy(res, err);
        } else if (callback) {
          this.callback = null;
          queueMicrotask(() => {
            this.runInAsyncScope(callback, null, err, { opaque });
          });
        }
        if (body) {
          this.body = null;
          util.destroy(body, err);
        }
      }
    };
    function stream(opts, factory, callback) {
      if (callback === void 0) {
        return new Promise((resolve, reject) => {
          stream.call(this, opts, factory, (err, data) => {
            return err ? reject(err) : resolve(data);
          });
        });
      }
      try {
        this.dispatch(opts, new StreamHandler(opts, factory, callback));
      } catch (err) {
        if (typeof callback !== "function") {
          throw err;
        }
        const opaque = opts == null ? void 0 : opts.opaque;
        queueMicrotask(() => callback(err, { opaque }));
      }
    }
    module2.exports = stream;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/api/api-pipeline.js
var require_api_pipeline = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/api/api-pipeline.js"(exports2, module2) {
    "use strict";
    var {
      Readable,
      Duplex,
      PassThrough
    } = require_node_stream();
    var {
      InvalidArgumentError,
      InvalidReturnValueError,
      RequestAbortedError
    } = require_errors();
    var util = require_util2();
    var { AsyncResource } = require_node_async_hooks();
    var { addSignal, removeSignal } = require_abort_signal();
    var assert = require_node_assert();
    var kResume = Symbol("resume");
    var PipelineRequest = class extends Readable {
      constructor() {
        super({ autoDestroy: true });
        this[kResume] = null;
      }
      _read() {
        const { [kResume]: resume } = this;
        if (resume) {
          this[kResume] = null;
          resume();
        }
      }
      _destroy(err, callback) {
        this._read();
        callback(err);
      }
    };
    var PipelineResponse = class extends Readable {
      constructor(resume) {
        super({ autoDestroy: true });
        this[kResume] = resume;
      }
      _read() {
        this[kResume]();
      }
      _destroy(err, callback) {
        if (!err && !this._readableState.endEmitted) {
          err = new RequestAbortedError();
        }
        callback(err);
      }
    };
    var PipelineHandler = class extends AsyncResource {
      constructor(opts, handler) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        if (typeof handler !== "function") {
          throw new InvalidArgumentError("invalid handler");
        }
        const { signal, method, opaque, onInfo, responseHeaders } = opts;
        if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        }
        if (method === "CONNECT") {
          throw new InvalidArgumentError("invalid method");
        }
        if (onInfo && typeof onInfo !== "function") {
          throw new InvalidArgumentError("invalid onInfo callback");
        }
        super("UNDICI_PIPELINE");
        this.opaque = opaque || null;
        this.responseHeaders = responseHeaders || null;
        this.handler = handler;
        this.abort = null;
        this.context = null;
        this.onInfo = onInfo || null;
        this.req = new PipelineRequest().on("error", util.nop);
        this.ret = new Duplex({
          readableObjectMode: opts.objectMode,
          autoDestroy: true,
          read: () => {
            const { body } = this;
            if (body == null ? void 0 : body.resume) {
              body.resume();
            }
          },
          write: (chunk, encoding, callback) => {
            const { req } = this;
            if (req.push(chunk, encoding) || req._readableState.destroyed) {
              callback();
            } else {
              req[kResume] = callback;
            }
          },
          destroy: (err, callback) => {
            const { body, req, res, ret, abort } = this;
            if (!err && !ret._readableState.endEmitted) {
              err = new RequestAbortedError();
            }
            if (abort && err) {
              abort();
            }
            util.destroy(body, err);
            util.destroy(req, err);
            util.destroy(res, err);
            removeSignal(this);
            callback(err);
          }
        }).on("prefinish", () => {
          const { req } = this;
          req.push(null);
        });
        this.res = null;
        addSignal(this, signal);
      }
      onConnect(abort, context) {
        const { ret, res } = this;
        if (this.reason) {
          abort(this.reason);
          return;
        }
        assert(!res, "pipeline cannot be retried");
        assert(!ret.destroyed);
        this.abort = abort;
        this.context = context;
      }
      onHeaders(statusCode, rawHeaders, resume) {
        const { opaque, handler, context } = this;
        if (statusCode < 200) {
          if (this.onInfo) {
            const headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
            this.onInfo({ statusCode, headers });
          }
          return;
        }
        this.res = new PipelineResponse(resume);
        let body;
        try {
          this.handler = null;
          const headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
          body = this.runInAsyncScope(handler, null, {
            statusCode,
            headers,
            opaque,
            body: this.res,
            context
          });
        } catch (err) {
          this.res.on("error", util.nop);
          throw err;
        }
        if (!body || typeof body.on !== "function") {
          throw new InvalidReturnValueError("expected Readable");
        }
        body.on("data", (chunk) => {
          const { ret, body: body2 } = this;
          if (!ret.push(chunk) && body2.pause) {
            body2.pause();
          }
        }).on("error", (err) => {
          const { ret } = this;
          util.destroy(ret, err);
        }).on("end", () => {
          const { ret } = this;
          ret.push(null);
        }).on("close", () => {
          const { ret } = this;
          if (!ret._readableState.ended) {
            util.destroy(ret, new RequestAbortedError());
          }
        });
        this.body = body;
      }
      onData(chunk) {
        const { res } = this;
        return res.push(chunk);
      }
      onComplete(trailers) {
        const { res } = this;
        res.push(null);
      }
      onError(err) {
        const { ret } = this;
        this.handler = null;
        util.destroy(ret, err);
      }
    };
    function pipeline(opts, handler) {
      try {
        const pipelineHandler = new PipelineHandler(opts, handler);
        this.dispatch({ ...opts, body: pipelineHandler.req }, pipelineHandler);
        return pipelineHandler.ret;
      } catch (err) {
        return new PassThrough().destroy(err);
      }
    }
    module2.exports = pipeline;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/api/api-upgrade.js
var require_api_upgrade = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/api/api-upgrade.js"(exports2, module2) {
    "use strict";
    var { InvalidArgumentError, SocketError } = require_errors();
    var { AsyncResource } = require_node_async_hooks();
    var util = require_util2();
    var { addSignal, removeSignal } = require_abort_signal();
    var assert = require_node_assert();
    var UpgradeHandler = class extends AsyncResource {
      constructor(opts, callback) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        const { signal, opaque, responseHeaders } = opts;
        if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        }
        super("UNDICI_UPGRADE");
        this.responseHeaders = responseHeaders || null;
        this.opaque = opaque || null;
        this.callback = callback;
        this.abort = null;
        this.context = null;
        addSignal(this, signal);
      }
      onConnect(abort, context) {
        if (this.reason) {
          abort(this.reason);
          return;
        }
        assert(this.callback);
        this.abort = abort;
        this.context = null;
      }
      onHeaders() {
        throw new SocketError("bad upgrade", null);
      }
      onUpgrade(statusCode, rawHeaders, socket) {
        assert(statusCode === 101);
        const { callback, opaque, context } = this;
        removeSignal(this);
        this.callback = null;
        const headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
        this.runInAsyncScope(callback, null, null, {
          headers,
          socket,
          opaque,
          context
        });
      }
      onError(err) {
        const { callback, opaque } = this;
        removeSignal(this);
        if (callback) {
          this.callback = null;
          queueMicrotask(() => {
            this.runInAsyncScope(callback, null, err, { opaque });
          });
        }
      }
    };
    function upgrade(opts, callback) {
      if (callback === void 0) {
        return new Promise((resolve, reject) => {
          upgrade.call(this, opts, (err, data) => {
            return err ? reject(err) : resolve(data);
          });
        });
      }
      try {
        const upgradeHandler = new UpgradeHandler(opts, callback);
        this.dispatch({
          ...opts,
          method: opts.method || "GET",
          upgrade: opts.protocol || "Websocket"
        }, upgradeHandler);
      } catch (err) {
        if (typeof callback !== "function") {
          throw err;
        }
        const opaque = opts == null ? void 0 : opts.opaque;
        queueMicrotask(() => callback(err, { opaque }));
      }
    }
    module2.exports = upgrade;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/api/api-connect.js
var require_api_connect = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/api/api-connect.js"(exports2, module2) {
    "use strict";
    var assert = require_node_assert();
    var { AsyncResource } = require_node_async_hooks();
    var { InvalidArgumentError, SocketError } = require_errors();
    var util = require_util2();
    var { addSignal, removeSignal } = require_abort_signal();
    var ConnectHandler = class extends AsyncResource {
      constructor(opts, callback) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        const { signal, opaque, responseHeaders } = opts;
        if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        }
        super("UNDICI_CONNECT");
        this.opaque = opaque || null;
        this.responseHeaders = responseHeaders || null;
        this.callback = callback;
        this.abort = null;
        addSignal(this, signal);
      }
      onConnect(abort, context) {
        if (this.reason) {
          abort(this.reason);
          return;
        }
        assert(this.callback);
        this.abort = abort;
        this.context = context;
      }
      onHeaders() {
        throw new SocketError("bad connect", null);
      }
      onUpgrade(statusCode, rawHeaders, socket) {
        const { callback, opaque, context } = this;
        removeSignal(this);
        this.callback = null;
        let headers = rawHeaders;
        if (headers != null) {
          headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
        }
        this.runInAsyncScope(callback, null, null, {
          statusCode,
          headers,
          socket,
          opaque,
          context
        });
      }
      onError(err) {
        const { callback, opaque } = this;
        removeSignal(this);
        if (callback) {
          this.callback = null;
          queueMicrotask(() => {
            this.runInAsyncScope(callback, null, err, { opaque });
          });
        }
      }
    };
    function connect(opts, callback) {
      if (callback === void 0) {
        return new Promise((resolve, reject) => {
          connect.call(this, opts, (err, data) => {
            return err ? reject(err) : resolve(data);
          });
        });
      }
      try {
        const connectHandler = new ConnectHandler(opts, callback);
        this.dispatch({ ...opts, method: "CONNECT" }, connectHandler);
      } catch (err) {
        if (typeof callback !== "function") {
          throw err;
        }
        const opaque = opts == null ? void 0 : opts.opaque;
        queueMicrotask(() => callback(err, { opaque }));
      }
    }
    module2.exports = connect;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/api/index.js
var require_api = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/api/index.js"(exports2, module2) {
    "use strict";
    module2.exports.request = require_api_request();
    module2.exports.stream = require_api_stream();
    module2.exports.pipeline = require_api_pipeline();
    module2.exports.upgrade = require_api_upgrade();
    module2.exports.connect = require_api_connect();
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/mock/mock-errors.js
var require_mock_errors = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/mock/mock-errors.js"(exports2, module2) {
    "use strict";
    var { UndiciError } = require_errors();
    var MockNotMatchedError = class _MockNotMatchedError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _MockNotMatchedError);
        this.name = "MockNotMatchedError";
        this.message = message || "The request does not match any registered mock dispatches";
        this.code = "UND_MOCK_ERR_MOCK_NOT_MATCHED";
      }
    };
    module2.exports = {
      MockNotMatchedError
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/mock/mock-symbols.js
var require_mock_symbols = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/mock/mock-symbols.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      kAgent: Symbol("agent"),
      kOptions: Symbol("options"),
      kFactory: Symbol("factory"),
      kDispatches: Symbol("dispatches"),
      kDispatchKey: Symbol("dispatch key"),
      kDefaultHeaders: Symbol("default headers"),
      kDefaultTrailers: Symbol("default trailers"),
      kContentLength: Symbol("content length"),
      kMockAgent: Symbol("mock agent"),
      kMockAgentSet: Symbol("mock agent set"),
      kMockAgentGet: Symbol("mock agent get"),
      kMockDispatch: Symbol("mock dispatch"),
      kClose: Symbol("close"),
      kOriginalClose: Symbol("original agent close"),
      kOrigin: Symbol("origin"),
      kIsMockActive: Symbol("is mock active"),
      kNetConnect: Symbol("net connect"),
      kGetNetConnect: Symbol("get net connect"),
      kConnected: Symbol("connected")
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/mock/mock-utils.js
var require_mock_utils = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/mock/mock-utils.js"(exports2, module2) {
    "use strict";
    var { MockNotMatchedError } = require_mock_errors();
    var {
      kDispatches,
      kMockAgent,
      kOriginalDispatch,
      kOrigin,
      kGetNetConnect
    } = require_mock_symbols();
    var { buildURL } = require_util2();
    var { STATUS_CODES } = require_node_http();
    var {
      types: {
        isPromise
      }
    } = require_node_util();
    function matchValue(match, value) {
      if (typeof match === "string") {
        return match === value;
      }
      if (match instanceof RegExp) {
        return match.test(value);
      }
      if (typeof match === "function") {
        return match(value) === true;
      }
      return false;
    }
    function lowerCaseEntries(headers) {
      return Object.fromEntries(
        Object.entries(headers).map(([headerName, headerValue]) => {
          return [headerName.toLocaleLowerCase(), headerValue];
        })
      );
    }
    function getHeaderByName(headers, key) {
      if (Array.isArray(headers)) {
        for (let i = 0; i < headers.length; i += 2) {
          if (headers[i].toLocaleLowerCase() === key.toLocaleLowerCase()) {
            return headers[i + 1];
          }
        }
        return void 0;
      } else if (typeof headers.get === "function") {
        return headers.get(key);
      } else {
        return lowerCaseEntries(headers)[key.toLocaleLowerCase()];
      }
    }
    function buildHeadersFromArray(headers) {
      const clone = headers.slice();
      const entries = [];
      for (let index = 0; index < clone.length; index += 2) {
        entries.push([clone[index], clone[index + 1]]);
      }
      return Object.fromEntries(entries);
    }
    function matchHeaders(mockDispatch2, headers) {
      if (typeof mockDispatch2.headers === "function") {
        if (Array.isArray(headers)) {
          headers = buildHeadersFromArray(headers);
        }
        return mockDispatch2.headers(headers ? lowerCaseEntries(headers) : {});
      }
      if (typeof mockDispatch2.headers === "undefined") {
        return true;
      }
      if (typeof headers !== "object" || typeof mockDispatch2.headers !== "object") {
        return false;
      }
      for (const [matchHeaderName, matchHeaderValue] of Object.entries(mockDispatch2.headers)) {
        const headerValue = getHeaderByName(headers, matchHeaderName);
        if (!matchValue(matchHeaderValue, headerValue)) {
          return false;
        }
      }
      return true;
    }
    function safeUrl(path) {
      if (typeof path !== "string") {
        return path;
      }
      const pathSegments = path.split("?");
      if (pathSegments.length !== 2) {
        return path;
      }
      const qp = new URLSearchParams(pathSegments.pop());
      qp.sort();
      return [...pathSegments, qp.toString()].join("?");
    }
    function matchKey(mockDispatch2, { path, method, body, headers }) {
      const pathMatch = matchValue(mockDispatch2.path, path);
      const methodMatch = matchValue(mockDispatch2.method, method);
      const bodyMatch = typeof mockDispatch2.body !== "undefined" ? matchValue(mockDispatch2.body, body) : true;
      const headersMatch = matchHeaders(mockDispatch2, headers);
      return pathMatch && methodMatch && bodyMatch && headersMatch;
    }
    function getResponseData(data) {
      if (Buffer.isBuffer(data)) {
        return data;
      } else if (data instanceof Uint8Array) {
        return data;
      } else if (data instanceof ArrayBuffer) {
        return data;
      } else if (typeof data === "object") {
        return JSON.stringify(data);
      } else {
        return data.toString();
      }
    }
    function getMockDispatch(mockDispatches, key) {
      const basePath = key.query ? buildURL(key.path, key.query) : key.path;
      const resolvedPath = typeof basePath === "string" ? safeUrl(basePath) : basePath;
      let matchedMockDispatches = mockDispatches.filter(({ consumed }) => !consumed).filter(({ path }) => matchValue(safeUrl(path), resolvedPath));
      if (matchedMockDispatches.length === 0) {
        throw new MockNotMatchedError(`Mock dispatch not matched for path '${resolvedPath}'`);
      }
      matchedMockDispatches = matchedMockDispatches.filter(({ method }) => matchValue(method, key.method));
      if (matchedMockDispatches.length === 0) {
        throw new MockNotMatchedError(`Mock dispatch not matched for method '${key.method}' on path '${resolvedPath}'`);
      }
      matchedMockDispatches = matchedMockDispatches.filter(({ body }) => typeof body !== "undefined" ? matchValue(body, key.body) : true);
      if (matchedMockDispatches.length === 0) {
        throw new MockNotMatchedError(`Mock dispatch not matched for body '${key.body}' on path '${resolvedPath}'`);
      }
      matchedMockDispatches = matchedMockDispatches.filter((mockDispatch2) => matchHeaders(mockDispatch2, key.headers));
      if (matchedMockDispatches.length === 0) {
        const headers = typeof key.headers === "object" ? JSON.stringify(key.headers) : key.headers;
        throw new MockNotMatchedError(`Mock dispatch not matched for headers '${headers}' on path '${resolvedPath}'`);
      }
      return matchedMockDispatches[0];
    }
    function addMockDispatch(mockDispatches, key, data) {
      const baseData = { timesInvoked: 0, times: 1, persist: false, consumed: false };
      const replyData = typeof data === "function" ? { callback: data } : { ...data };
      const newMockDispatch = { ...baseData, ...key, pending: true, data: { error: null, ...replyData } };
      mockDispatches.push(newMockDispatch);
      return newMockDispatch;
    }
    function deleteMockDispatch(mockDispatches, key) {
      const index = mockDispatches.findIndex((dispatch) => {
        if (!dispatch.consumed) {
          return false;
        }
        return matchKey(dispatch, key);
      });
      if (index !== -1) {
        mockDispatches.splice(index, 1);
      }
    }
    function buildKey(opts) {
      const { path, method, body, headers, query } = opts;
      return {
        path,
        method,
        body,
        headers,
        query
      };
    }
    function generateKeyValues(data) {
      const keys = Object.keys(data);
      const result = [];
      for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        const value = data[key];
        const name = Buffer.from(`${key}`);
        if (Array.isArray(value)) {
          for (let j = 0; j < value.length; ++j) {
            result.push(name, Buffer.from(`${value[j]}`));
          }
        } else {
          result.push(name, Buffer.from(`${value}`));
        }
      }
      return result;
    }
    function getStatusText(statusCode) {
      return STATUS_CODES[statusCode] || "unknown";
    }
    async function getResponse(body) {
      const buffers = [];
      for await (const data of body) {
        buffers.push(data);
      }
      return Buffer.concat(buffers).toString("utf8");
    }
    function mockDispatch(opts, handler) {
      const key = buildKey(opts);
      const mockDispatch2 = getMockDispatch(this[kDispatches], key);
      mockDispatch2.timesInvoked++;
      if (mockDispatch2.data.callback) {
        mockDispatch2.data = { ...mockDispatch2.data, ...mockDispatch2.data.callback(opts) };
      }
      const { data: { statusCode, data, headers, trailers, error: error2 }, delay, persist } = mockDispatch2;
      const { timesInvoked, times } = mockDispatch2;
      mockDispatch2.consumed = !persist && timesInvoked >= times;
      mockDispatch2.pending = timesInvoked < times;
      if (error2 !== null) {
        deleteMockDispatch(this[kDispatches], key);
        handler.onError(error2);
        return true;
      }
      if (typeof delay === "number" && delay > 0) {
        setTimeout(() => {
          handleReply(this[kDispatches]);
        }, delay);
      } else {
        handleReply(this[kDispatches]);
      }
      function handleReply(mockDispatches, _data = data) {
        var _a, _b, _c, _d;
        const optsHeaders = Array.isArray(opts.headers) ? buildHeadersFromArray(opts.headers) : opts.headers;
        const body = typeof _data === "function" ? _data({ ...opts, headers: optsHeaders }) : _data;
        if (isPromise(body)) {
          body.then((newData) => handleReply(mockDispatches, newData));
          return;
        }
        const responseData = getResponseData(body);
        const responseHeaders = generateKeyValues(headers);
        const responseTrailers = generateKeyValues(trailers);
        (_a = handler.onConnect) == null ? void 0 : _a.call(handler, (err) => handler.onError(err), null);
        (_b = handler.onHeaders) == null ? void 0 : _b.call(handler, statusCode, responseHeaders, resume, getStatusText(statusCode));
        (_c = handler.onData) == null ? void 0 : _c.call(handler, Buffer.from(responseData));
        (_d = handler.onComplete) == null ? void 0 : _d.call(handler, responseTrailers);
        deleteMockDispatch(mockDispatches, key);
      }
      function resume() {
      }
      return true;
    }
    function buildMockDispatch() {
      const agent = this[kMockAgent];
      const origin = this[kOrigin];
      const originalDispatch = this[kOriginalDispatch];
      return function dispatch(opts, handler) {
        if (agent.isMockActive) {
          try {
            mockDispatch.call(this, opts, handler);
          } catch (error2) {
            if (error2 instanceof MockNotMatchedError) {
              const netConnect = agent[kGetNetConnect]();
              if (netConnect === false) {
                throw new MockNotMatchedError(`${error2.message}: subsequent request to origin ${origin} was not allowed (net.connect disabled)`);
              }
              if (checkNetConnect(netConnect, origin)) {
                originalDispatch.call(this, opts, handler);
              } else {
                throw new MockNotMatchedError(`${error2.message}: subsequent request to origin ${origin} was not allowed (net.connect is not enabled for this origin)`);
              }
            } else {
              throw error2;
            }
          }
        } else {
          originalDispatch.call(this, opts, handler);
        }
      };
    }
    function checkNetConnect(netConnect, origin) {
      const url = new URL(origin);
      if (netConnect === true) {
        return true;
      } else if (Array.isArray(netConnect) && netConnect.some((matcher) => matchValue(matcher, url.host))) {
        return true;
      }
      return false;
    }
    function buildMockOptions(opts) {
      if (opts) {
        const { agent, ...mockOptions } = opts;
        return mockOptions;
      }
    }
    module2.exports = {
      getResponseData,
      getMockDispatch,
      addMockDispatch,
      deleteMockDispatch,
      buildKey,
      generateKeyValues,
      matchValue,
      getResponse,
      getStatusText,
      mockDispatch,
      buildMockDispatch,
      checkNetConnect,
      buildMockOptions,
      getHeaderByName,
      buildHeadersFromArray
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/mock/mock-interceptor.js
var require_mock_interceptor = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/mock/mock-interceptor.js"(exports2, module2) {
    "use strict";
    var { getResponseData, buildKey, addMockDispatch } = require_mock_utils();
    var {
      kDispatches,
      kDispatchKey,
      kDefaultHeaders,
      kDefaultTrailers,
      kContentLength,
      kMockDispatch
    } = require_mock_symbols();
    var { InvalidArgumentError } = require_errors();
    var { buildURL } = require_util2();
    var MockScope = class {
      constructor(mockDispatch) {
        this[kMockDispatch] = mockDispatch;
      }
      /**
       * Delay a reply by a set amount in ms.
       */
      delay(waitInMs) {
        if (typeof waitInMs !== "number" || !Number.isInteger(waitInMs) || waitInMs <= 0) {
          throw new InvalidArgumentError("waitInMs must be a valid integer > 0");
        }
        this[kMockDispatch].delay = waitInMs;
        return this;
      }
      /**
       * For a defined reply, never mark as consumed.
       */
      persist() {
        this[kMockDispatch].persist = true;
        return this;
      }
      /**
       * Allow one to define a reply for a set amount of matching requests.
       */
      times(repeatTimes) {
        if (typeof repeatTimes !== "number" || !Number.isInteger(repeatTimes) || repeatTimes <= 0) {
          throw new InvalidArgumentError("repeatTimes must be a valid integer > 0");
        }
        this[kMockDispatch].times = repeatTimes;
        return this;
      }
    };
    var MockInterceptor = class {
      constructor(opts, mockDispatches) {
        if (typeof opts !== "object") {
          throw new InvalidArgumentError("opts must be an object");
        }
        if (typeof opts.path === "undefined") {
          throw new InvalidArgumentError("opts.path must be defined");
        }
        if (typeof opts.method === "undefined") {
          opts.method = "GET";
        }
        if (typeof opts.path === "string") {
          if (opts.query) {
            opts.path = buildURL(opts.path, opts.query);
          } else {
            const parsedURL = new URL(opts.path, "data://");
            opts.path = parsedURL.pathname + parsedURL.search;
          }
        }
        if (typeof opts.method === "string") {
          opts.method = opts.method.toUpperCase();
        }
        this[kDispatchKey] = buildKey(opts);
        this[kDispatches] = mockDispatches;
        this[kDefaultHeaders] = {};
        this[kDefaultTrailers] = {};
        this[kContentLength] = false;
      }
      createMockScopeDispatchData({ statusCode, data, responseOptions }) {
        const responseData = getResponseData(data);
        const contentLength = this[kContentLength] ? { "content-length": responseData.length } : {};
        const headers = { ...this[kDefaultHeaders], ...contentLength, ...responseOptions.headers };
        const trailers = { ...this[kDefaultTrailers], ...responseOptions.trailers };
        return { statusCode, data, headers, trailers };
      }
      validateReplyParameters(replyParameters) {
        if (typeof replyParameters.statusCode === "undefined") {
          throw new InvalidArgumentError("statusCode must be defined");
        }
        if (typeof replyParameters.responseOptions !== "object" || replyParameters.responseOptions === null) {
          throw new InvalidArgumentError("responseOptions must be an object");
        }
      }
      /**
       * Mock an undici request with a defined reply.
       */
      reply(replyOptionsCallbackOrStatusCode) {
        if (typeof replyOptionsCallbackOrStatusCode === "function") {
          const wrappedDefaultsCallback = (opts) => {
            const resolvedData = replyOptionsCallbackOrStatusCode(opts);
            if (typeof resolvedData !== "object" || resolvedData === null) {
              throw new InvalidArgumentError("reply options callback must return an object");
            }
            const replyParameters2 = { data: "", responseOptions: {}, ...resolvedData };
            this.validateReplyParameters(replyParameters2);
            return {
              ...this.createMockScopeDispatchData(replyParameters2)
            };
          };
          const newMockDispatch2 = addMockDispatch(this[kDispatches], this[kDispatchKey], wrappedDefaultsCallback);
          return new MockScope(newMockDispatch2);
        }
        const replyParameters = {
          statusCode: replyOptionsCallbackOrStatusCode,
          data: arguments[1] === void 0 ? "" : arguments[1],
          responseOptions: arguments[2] === void 0 ? {} : arguments[2]
        };
        this.validateReplyParameters(replyParameters);
        const dispatchData = this.createMockScopeDispatchData(replyParameters);
        const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], dispatchData);
        return new MockScope(newMockDispatch);
      }
      /**
       * Mock an undici request with a defined error.
       */
      replyWithError(error2) {
        if (typeof error2 === "undefined") {
          throw new InvalidArgumentError("error must be defined");
        }
        const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], { error: error2 });
        return new MockScope(newMockDispatch);
      }
      /**
       * Set default reply headers on the interceptor for subsequent replies
       */
      defaultReplyHeaders(headers) {
        if (typeof headers === "undefined") {
          throw new InvalidArgumentError("headers must be defined");
        }
        this[kDefaultHeaders] = headers;
        return this;
      }
      /**
       * Set default reply trailers on the interceptor for subsequent replies
       */
      defaultReplyTrailers(trailers) {
        if (typeof trailers === "undefined") {
          throw new InvalidArgumentError("trailers must be defined");
        }
        this[kDefaultTrailers] = trailers;
        return this;
      }
      /**
       * Set reply content length header for replies on the interceptor
       */
      replyContentLength() {
        this[kContentLength] = true;
        return this;
      }
    };
    module2.exports.MockInterceptor = MockInterceptor;
    module2.exports.MockScope = MockScope;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/mock/mock-client.js
var require_mock_client = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/mock/mock-client.js"(exports2, module2) {
    "use strict";
    var { promisify } = require_node_util();
    var Client2 = require_client();
    var { buildMockDispatch } = require_mock_utils();
    var {
      kDispatches,
      kMockAgent,
      kClose,
      kOriginalClose,
      kOrigin,
      kOriginalDispatch,
      kConnected
    } = require_mock_symbols();
    var { MockInterceptor } = require_mock_interceptor();
    var Symbols = require_symbols();
    var { InvalidArgumentError } = require_errors();
    var MockClient = class extends Client2 {
      constructor(origin, opts) {
        super(origin, opts);
        if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function") {
          throw new InvalidArgumentError("Argument opts.agent must implement Agent");
        }
        this[kMockAgent] = opts.agent;
        this[kOrigin] = origin;
        this[kDispatches] = [];
        this[kConnected] = 1;
        this[kOriginalDispatch] = this.dispatch;
        this[kOriginalClose] = this.close.bind(this);
        this.dispatch = buildMockDispatch.call(this);
        this.close = this[kClose];
      }
      get [Symbols.kConnected]() {
        return this[kConnected];
      }
      /**
       * Sets up the base interceptor for mocking replies from undici.
       */
      intercept(opts) {
        return new MockInterceptor(opts, this[kDispatches]);
      }
      async [kClose]() {
        await promisify(this[kOriginalClose])();
        this[kConnected] = 0;
        this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
      }
    };
    module2.exports = MockClient;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/mock/mock-pool.js
var require_mock_pool = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/mock/mock-pool.js"(exports2, module2) {
    "use strict";
    var { promisify } = require_node_util();
    var Pool = require_pool();
    var { buildMockDispatch } = require_mock_utils();
    var {
      kDispatches,
      kMockAgent,
      kClose,
      kOriginalClose,
      kOrigin,
      kOriginalDispatch,
      kConnected
    } = require_mock_symbols();
    var { MockInterceptor } = require_mock_interceptor();
    var Symbols = require_symbols();
    var { InvalidArgumentError } = require_errors();
    var MockPool = class extends Pool {
      constructor(origin, opts) {
        super(origin, opts);
        if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function") {
          throw new InvalidArgumentError("Argument opts.agent must implement Agent");
        }
        this[kMockAgent] = opts.agent;
        this[kOrigin] = origin;
        this[kDispatches] = [];
        this[kConnected] = 1;
        this[kOriginalDispatch] = this.dispatch;
        this[kOriginalClose] = this.close.bind(this);
        this.dispatch = buildMockDispatch.call(this);
        this.close = this[kClose];
      }
      get [Symbols.kConnected]() {
        return this[kConnected];
      }
      /**
       * Sets up the base interceptor for mocking replies from undici.
       */
      intercept(opts) {
        return new MockInterceptor(opts, this[kDispatches]);
      }
      async [kClose]() {
        await promisify(this[kOriginalClose])();
        this[kConnected] = 0;
        this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
      }
    };
    module2.exports = MockPool;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/mock/pluralizer.js
var require_pluralizer = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/mock/pluralizer.js"(exports2, module2) {
    "use strict";
    var singulars = {
      pronoun: "it",
      is: "is",
      was: "was",
      this: "this"
    };
    var plurals = {
      pronoun: "they",
      is: "are",
      was: "were",
      this: "these"
    };
    module2.exports = class Pluralizer {
      constructor(singular, plural) {
        this.singular = singular;
        this.plural = plural;
      }
      pluralize(count) {
        const one = count === 1;
        const keys = one ? singulars : plurals;
        const noun = one ? this.singular : this.plural;
        return { ...keys, count, noun };
      }
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/mock/pending-interceptors-formatter.js
var require_pending_interceptors_formatter = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/mock/pending-interceptors-formatter.js"(exports2, module2) {
    "use strict";
    var { Transform } = require_node_stream();
    var { Console } = require_node_console();
    var PERSISTENT = process.versions.icu ? "✅" : "Y ";
    var NOT_PERSISTENT = process.versions.icu ? "❌" : "N ";
    module2.exports = class PendingInterceptorsFormatter {
      constructor({ disableColors } = {}) {
        this.transform = new Transform({
          transform(chunk, _enc, cb) {
            cb(null, chunk);
          }
        });
        this.logger = new Console({
          stdout: this.transform,
          inspectOptions: {
            colors: !disableColors && !process.env.CI
          }
        });
      }
      format(pendingInterceptors) {
        const withPrettyHeaders = pendingInterceptors.map(
          ({ method, path, data: { statusCode }, persist, times, timesInvoked, origin }) => ({
            Method: method,
            Origin: origin,
            Path: path,
            "Status code": statusCode,
            Persistent: persist ? PERSISTENT : NOT_PERSISTENT,
            Invocations: timesInvoked,
            Remaining: persist ? Infinity : times - timesInvoked
          })
        );
        this.logger.table(withPrettyHeaders);
        return this.transform.read().toString();
      }
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/mock/mock-agent.js
var require_mock_agent = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/mock/mock-agent.js"(exports2, module2) {
    "use strict";
    var { kClients } = require_symbols();
    var Agent = require_agent();
    var {
      kAgent,
      kMockAgentSet,
      kMockAgentGet,
      kDispatches,
      kIsMockActive,
      kNetConnect,
      kGetNetConnect,
      kOptions,
      kFactory
    } = require_mock_symbols();
    var MockClient = require_mock_client();
    var MockPool = require_mock_pool();
    var { matchValue, buildMockOptions } = require_mock_utils();
    var { InvalidArgumentError, UndiciError } = require_errors();
    var Dispatcher = require_dispatcher();
    var Pluralizer = require_pluralizer();
    var PendingInterceptorsFormatter = require_pending_interceptors_formatter();
    var MockAgent = class extends Dispatcher {
      constructor(opts) {
        super(opts);
        this[kNetConnect] = true;
        this[kIsMockActive] = true;
        if ((opts == null ? void 0 : opts.agent) && typeof opts.agent.dispatch !== "function") {
          throw new InvalidArgumentError("Argument opts.agent must implement Agent");
        }
        const agent = (opts == null ? void 0 : opts.agent) ? opts.agent : new Agent(opts);
        this[kAgent] = agent;
        this[kClients] = agent[kClients];
        this[kOptions] = buildMockOptions(opts);
      }
      get(origin) {
        let dispatcher = this[kMockAgentGet](origin);
        if (!dispatcher) {
          dispatcher = this[kFactory](origin);
          this[kMockAgentSet](origin, dispatcher);
        }
        return dispatcher;
      }
      dispatch(opts, handler) {
        this.get(opts.origin);
        return this[kAgent].dispatch(opts, handler);
      }
      async close() {
        await this[kAgent].close();
        this[kClients].clear();
      }
      deactivate() {
        this[kIsMockActive] = false;
      }
      activate() {
        this[kIsMockActive] = true;
      }
      enableNetConnect(matcher) {
        if (typeof matcher === "string" || typeof matcher === "function" || matcher instanceof RegExp) {
          if (Array.isArray(this[kNetConnect])) {
            this[kNetConnect].push(matcher);
          } else {
            this[kNetConnect] = [matcher];
          }
        } else if (typeof matcher === "undefined") {
          this[kNetConnect] = true;
        } else {
          throw new InvalidArgumentError("Unsupported matcher. Must be one of String|Function|RegExp.");
        }
      }
      disableNetConnect() {
        this[kNetConnect] = false;
      }
      // This is required to bypass issues caused by using global symbols - see:
      // https://github.com/nodejs/undici/issues/1447
      get isMockActive() {
        return this[kIsMockActive];
      }
      [kMockAgentSet](origin, dispatcher) {
        this[kClients].set(origin, dispatcher);
      }
      [kFactory](origin) {
        const mockOptions = Object.assign({ agent: this }, this[kOptions]);
        return this[kOptions] && this[kOptions].connections === 1 ? new MockClient(origin, mockOptions) : new MockPool(origin, mockOptions);
      }
      [kMockAgentGet](origin) {
        const client = this[kClients].get(origin);
        if (client) {
          return client;
        }
        if (typeof origin !== "string") {
          const dispatcher = this[kFactory]("http://localhost:9999");
          this[kMockAgentSet](origin, dispatcher);
          return dispatcher;
        }
        for (const [keyMatcher, nonExplicitDispatcher] of Array.from(this[kClients])) {
          if (nonExplicitDispatcher && typeof keyMatcher !== "string" && matchValue(keyMatcher, origin)) {
            const dispatcher = this[kFactory](origin);
            this[kMockAgentSet](origin, dispatcher);
            dispatcher[kDispatches] = nonExplicitDispatcher[kDispatches];
            return dispatcher;
          }
        }
      }
      [kGetNetConnect]() {
        return this[kNetConnect];
      }
      pendingInterceptors() {
        const mockAgentClients = this[kClients];
        return Array.from(mockAgentClients.entries()).flatMap(([origin, scope]) => scope[kDispatches].map((dispatch) => ({ ...dispatch, origin }))).filter(({ pending }) => pending);
      }
      assertNoPendingInterceptors({ pendingInterceptorsFormatter = new PendingInterceptorsFormatter() } = {}) {
        const pending = this.pendingInterceptors();
        if (pending.length === 0) {
          return;
        }
        const pluralizer = new Pluralizer("interceptor", "interceptors").pluralize(pending.length);
        throw new UndiciError(`
${pluralizer.count} ${pluralizer.noun} ${pluralizer.is} pending:

${pendingInterceptorsFormatter.format(pending)}
`.trim());
      }
    };
    module2.exports = MockAgent;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/global.js
var require_global2 = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/global.js"(exports2, module2) {
    "use strict";
    var globalDispatcher = Symbol.for("undici.globalDispatcher.1");
    var { InvalidArgumentError } = require_errors();
    var Agent = require_agent();
    if (getGlobalDispatcher() === void 0) {
      setGlobalDispatcher(new Agent());
    }
    function setGlobalDispatcher(agent) {
      if (!agent || typeof agent.dispatch !== "function") {
        throw new InvalidArgumentError("Argument agent must implement Agent");
      }
      Object.defineProperty(globalThis, globalDispatcher, {
        value: agent,
        writable: true,
        enumerable: false,
        configurable: false
      });
    }
    function getGlobalDispatcher() {
      return globalThis[globalDispatcher];
    }
    module2.exports = {
      setGlobalDispatcher,
      getGlobalDispatcher
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/handler/decorator-handler.js
var require_decorator_handler = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/handler/decorator-handler.js"(exports2, module2) {
    "use strict";
    var _handler, _a;
    module2.exports = (_a = class {
      constructor(handler) {
        __privateAdd(this, _handler);
        if (typeof handler !== "object" || handler === null) {
          throw new TypeError("handler must be an object");
        }
        __privateSet(this, _handler, handler);
      }
      onConnect(...args) {
        var _a2, _b;
        return (_b = (_a2 = __privateGet(this, _handler)).onConnect) == null ? void 0 : _b.call(_a2, ...args);
      }
      onError(...args) {
        var _a2, _b;
        return (_b = (_a2 = __privateGet(this, _handler)).onError) == null ? void 0 : _b.call(_a2, ...args);
      }
      onUpgrade(...args) {
        var _a2, _b;
        return (_b = (_a2 = __privateGet(this, _handler)).onUpgrade) == null ? void 0 : _b.call(_a2, ...args);
      }
      onResponseStarted(...args) {
        var _a2, _b;
        return (_b = (_a2 = __privateGet(this, _handler)).onResponseStarted) == null ? void 0 : _b.call(_a2, ...args);
      }
      onHeaders(...args) {
        var _a2, _b;
        return (_b = (_a2 = __privateGet(this, _handler)).onHeaders) == null ? void 0 : _b.call(_a2, ...args);
      }
      onData(...args) {
        var _a2, _b;
        return (_b = (_a2 = __privateGet(this, _handler)).onData) == null ? void 0 : _b.call(_a2, ...args);
      }
      onComplete(...args) {
        var _a2, _b;
        return (_b = (_a2 = __privateGet(this, _handler)).onComplete) == null ? void 0 : _b.call(_a2, ...args);
      }
      onBodySent(...args) {
        var _a2, _b;
        return (_b = (_a2 = __privateGet(this, _handler)).onBodySent) == null ? void 0 : _b.call(_a2, ...args);
      }
    }, _handler = new WeakMap(), _a);
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/interceptor/redirect.js
var require_redirect = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/interceptor/redirect.js"(exports2, module2) {
    "use strict";
    var RedirectHandler = require_redirect_handler();
    module2.exports = (opts) => {
      const globalMaxRedirections = opts == null ? void 0 : opts.maxRedirections;
      return (dispatch) => {
        return function redirectInterceptor(opts2, handler) {
          const { maxRedirections = globalMaxRedirections, ...baseOpts } = opts2;
          if (!maxRedirections) {
            return dispatch(opts2, handler);
          }
          const redirectHandler = new RedirectHandler(
            dispatch,
            maxRedirections,
            opts2,
            handler
          );
          return dispatch(baseOpts, redirectHandler);
        };
      };
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/interceptor/retry.js
var require_retry = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/interceptor/retry.js"(exports2, module2) {
    "use strict";
    var RetryHandler = require_retry_handler();
    module2.exports = (globalOpts) => {
      return (dispatch) => {
        return function retryInterceptor(opts, handler) {
          return dispatch(
            opts,
            new RetryHandler(
              { ...opts, retryOptions: { ...globalOpts, ...opts.retryOptions } },
              {
                handler,
                dispatch
              }
            )
          );
        };
      };
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/interceptor/dump.js
var require_dump = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/interceptor/dump.js"(exports2, module2) {
    "use strict";
    var util = require_util2();
    var { InvalidArgumentError, RequestAbortedError } = require_errors();
    var DecoratorHandler = require_decorator_handler();
    var _maxSize, _abort, _dumped, _aborted, _size, _reason, _handler, _DumpHandler_instances, customAbort_fn;
    var DumpHandler = class extends DecoratorHandler {
      constructor({ maxSize }, handler) {
        super(handler);
        __privateAdd(this, _DumpHandler_instances);
        __privateAdd(this, _maxSize, 1024 * 1024);
        __privateAdd(this, _abort, null);
        __privateAdd(this, _dumped, false);
        __privateAdd(this, _aborted, false);
        __privateAdd(this, _size, 0);
        __privateAdd(this, _reason, null);
        __privateAdd(this, _handler, null);
        if (maxSize != null && (!Number.isFinite(maxSize) || maxSize < 1)) {
          throw new InvalidArgumentError("maxSize must be a number greater than 0");
        }
        __privateSet(this, _maxSize, maxSize ?? __privateGet(this, _maxSize));
        __privateSet(this, _handler, handler);
      }
      onConnect(abort) {
        __privateSet(this, _abort, abort);
        __privateGet(this, _handler).onConnect(__privateMethod(this, _DumpHandler_instances, customAbort_fn).bind(this));
      }
      // TODO: will require adjustment after new hooks are out
      onHeaders(statusCode, rawHeaders, resume, statusMessage) {
        const headers = util.parseHeaders(rawHeaders);
        const contentLength = headers["content-length"];
        if (contentLength != null && contentLength > __privateGet(this, _maxSize)) {
          throw new RequestAbortedError(
            `Response size (${contentLength}) larger than maxSize (${__privateGet(this, _maxSize)})`
          );
        }
        if (__privateGet(this, _aborted)) {
          return true;
        }
        return __privateGet(this, _handler).onHeaders(
          statusCode,
          rawHeaders,
          resume,
          statusMessage
        );
      }
      onError(err) {
        if (__privateGet(this, _dumped)) {
          return;
        }
        err = __privateGet(this, _reason) ?? err;
        __privateGet(this, _handler).onError(err);
      }
      onData(chunk) {
        __privateSet(this, _size, __privateGet(this, _size) + chunk.length);
        if (__privateGet(this, _size) >= __privateGet(this, _maxSize)) {
          __privateSet(this, _dumped, true);
          if (__privateGet(this, _aborted)) {
            __privateGet(this, _handler).onError(__privateGet(this, _reason));
          } else {
            __privateGet(this, _handler).onComplete([]);
          }
        }
        return true;
      }
      onComplete(trailers) {
        if (__privateGet(this, _dumped)) {
          return;
        }
        if (__privateGet(this, _aborted)) {
          __privateGet(this, _handler).onError(this.reason);
          return;
        }
        __privateGet(this, _handler).onComplete(trailers);
      }
    };
    _maxSize = new WeakMap();
    _abort = new WeakMap();
    _dumped = new WeakMap();
    _aborted = new WeakMap();
    _size = new WeakMap();
    _reason = new WeakMap();
    _handler = new WeakMap();
    _DumpHandler_instances = new WeakSet();
    customAbort_fn = function(reason) {
      __privateSet(this, _aborted, true);
      __privateSet(this, _reason, reason);
    };
    function createDumpInterceptor({ maxSize: defaultMaxSize } = {
      maxSize: 1024 * 1024
    }) {
      return (dispatch) => {
        return function Intercept(opts, handler) {
          const { dumpMaxSize = defaultMaxSize } = opts;
          const dumpHandler = new DumpHandler(
            { maxSize: dumpMaxSize },
            handler
          );
          return dispatch(opts, dumpHandler);
        };
      };
    }
    module2.exports = createDumpInterceptor;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/fetch/headers.js
var require_headers = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/fetch/headers.js"(exports2, module2) {
    "use strict";
    var { kConstruct } = require_symbols();
    var { kEnumerableProperty } = require_util2();
    var {
      iteratorMixin,
      isValidHeaderName,
      isValidHeaderValue
    } = require_util3();
    var { webidl } = require_webidl();
    var assert = require_node_assert();
    var util = require_node_util();
    var kHeadersMap = Symbol("headers map");
    var kHeadersSortedMap = Symbol("headers map sorted");
    function isHTTPWhiteSpaceCharCode(code) {
      return code === 10 || code === 13 || code === 9 || code === 32;
    }
    function headerValueNormalize(potentialValue) {
      let i = 0;
      let j = potentialValue.length;
      while (j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(j - 1))) --j;
      while (j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(i))) ++i;
      return i === 0 && j === potentialValue.length ? potentialValue : potentialValue.substring(i, j);
    }
    function fill(headers, object) {
      if (Array.isArray(object)) {
        for (let i = 0; i < object.length; ++i) {
          const header = object[i];
          if (header.length !== 2) {
            throw webidl.errors.exception({
              header: "Headers constructor",
              message: `expected name/value pair to be length 2, found ${header.length}.`
            });
          }
          appendHeader(headers, header[0], header[1]);
        }
      } else if (typeof object === "object" && object !== null) {
        const keys = Object.keys(object);
        for (let i = 0; i < keys.length; ++i) {
          appendHeader(headers, keys[i], object[keys[i]]);
        }
      } else {
        throw webidl.errors.conversionFailed({
          prefix: "Headers constructor",
          argument: "Argument 1",
          types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
        });
      }
    }
    function appendHeader(headers, name, value) {
      value = headerValueNormalize(value);
      if (!isValidHeaderName(name)) {
        throw webidl.errors.invalidArgument({
          prefix: "Headers.append",
          value: name,
          type: "header name"
        });
      } else if (!isValidHeaderValue(value)) {
        throw webidl.errors.invalidArgument({
          prefix: "Headers.append",
          value,
          type: "header value"
        });
      }
      if (getHeadersGuard(headers) === "immutable") {
        throw new TypeError("immutable");
      }
      return getHeadersList(headers).append(name, value, false);
    }
    function compareHeaderName(a, b) {
      return a[0] < b[0] ? -1 : 1;
    }
    var HeadersList = class _HeadersList {
      constructor(init) {
        /** @type {[string, string][]|null} */
        __publicField(this, "cookies", null);
        if (init instanceof _HeadersList) {
          this[kHeadersMap] = new Map(init[kHeadersMap]);
          this[kHeadersSortedMap] = init[kHeadersSortedMap];
          this.cookies = init.cookies === null ? null : [...init.cookies];
        } else {
          this[kHeadersMap] = new Map(init);
          this[kHeadersSortedMap] = null;
        }
      }
      /**
       * @see https://fetch.spec.whatwg.org/#header-list-contains
       * @param {string} name
       * @param {boolean} isLowerCase
       */
      contains(name, isLowerCase) {
        return this[kHeadersMap].has(isLowerCase ? name : name.toLowerCase());
      }
      clear() {
        this[kHeadersMap].clear();
        this[kHeadersSortedMap] = null;
        this.cookies = null;
      }
      /**
       * @see https://fetch.spec.whatwg.org/#concept-header-list-append
       * @param {string} name
       * @param {string} value
       * @param {boolean} isLowerCase
       */
      append(name, value, isLowerCase) {
        this[kHeadersSortedMap] = null;
        const lowercaseName = isLowerCase ? name : name.toLowerCase();
        const exists = this[kHeadersMap].get(lowercaseName);
        if (exists) {
          const delimiter2 = lowercaseName === "cookie" ? "; " : ", ";
          this[kHeadersMap].set(lowercaseName, {
            name: exists.name,
            value: `${exists.value}${delimiter2}${value}`
          });
        } else {
          this[kHeadersMap].set(lowercaseName, { name, value });
        }
        if (lowercaseName === "set-cookie") {
          (this.cookies ?? (this.cookies = [])).push(value);
        }
      }
      /**
       * @see https://fetch.spec.whatwg.org/#concept-header-list-set
       * @param {string} name
       * @param {string} value
       * @param {boolean} isLowerCase
       */
      set(name, value, isLowerCase) {
        this[kHeadersSortedMap] = null;
        const lowercaseName = isLowerCase ? name : name.toLowerCase();
        if (lowercaseName === "set-cookie") {
          this.cookies = [value];
        }
        this[kHeadersMap].set(lowercaseName, { name, value });
      }
      /**
       * @see https://fetch.spec.whatwg.org/#concept-header-list-delete
       * @param {string} name
       * @param {boolean} isLowerCase
       */
      delete(name, isLowerCase) {
        this[kHeadersSortedMap] = null;
        if (!isLowerCase) name = name.toLowerCase();
        if (name === "set-cookie") {
          this.cookies = null;
        }
        this[kHeadersMap].delete(name);
      }
      /**
       * @see https://fetch.spec.whatwg.org/#concept-header-list-get
       * @param {string} name
       * @param {boolean} isLowerCase
       * @returns {string | null}
       */
      get(name, isLowerCase) {
        var _a;
        return ((_a = this[kHeadersMap].get(isLowerCase ? name : name.toLowerCase())) == null ? void 0 : _a.value) ?? null;
      }
      *[Symbol.iterator]() {
        for (const { 0: name, 1: { value } } of this[kHeadersMap]) {
          yield [name, value];
        }
      }
      get entries() {
        const headers = {};
        if (this[kHeadersMap].size !== 0) {
          for (const { name, value } of this[kHeadersMap].values()) {
            headers[name] = value;
          }
        }
        return headers;
      }
      rawValues() {
        return this[kHeadersMap].values();
      }
      get entriesList() {
        const headers = [];
        if (this[kHeadersMap].size !== 0) {
          for (const { 0: lowerName, 1: { name, value } } of this[kHeadersMap]) {
            if (lowerName === "set-cookie") {
              for (const cookie of this.cookies) {
                headers.push([name, cookie]);
              }
            } else {
              headers.push([name, value]);
            }
          }
        }
        return headers;
      }
      // https://fetch.spec.whatwg.org/#convert-header-names-to-a-sorted-lowercase-set
      toSortedArray() {
        const size = this[kHeadersMap].size;
        const array = new Array(size);
        if (size <= 32) {
          if (size === 0) {
            return array;
          }
          const iterator = this[kHeadersMap][Symbol.iterator]();
          const firstValue = iterator.next().value;
          array[0] = [firstValue[0], firstValue[1].value];
          assert(firstValue[1].value !== null);
          for (let i = 1, j = 0, right = 0, left = 0, pivot = 0, x, value; i < size; ++i) {
            value = iterator.next().value;
            x = array[i] = [value[0], value[1].value];
            assert(x[1] !== null);
            left = 0;
            right = i;
            while (left < right) {
              pivot = left + (right - left >> 1);
              if (array[pivot][0] <= x[0]) {
                left = pivot + 1;
              } else {
                right = pivot;
              }
            }
            if (i !== pivot) {
              j = i;
              while (j > left) {
                array[j] = array[--j];
              }
              array[left] = x;
            }
          }
          if (!iterator.next().done) {
            throw new TypeError("Unreachable");
          }
          return array;
        } else {
          let i = 0;
          for (const { 0: name, 1: { value } } of this[kHeadersMap]) {
            array[i++] = [name, value];
            assert(value !== null);
          }
          return array.sort(compareHeaderName);
        }
      }
    };
    var _guard, _headersList;
    var _Headers = class _Headers {
      constructor(init = void 0) {
        __privateAdd(this, _guard);
        __privateAdd(this, _headersList);
        webidl.util.markAsUncloneable(this);
        if (init === kConstruct) {
          return;
        }
        __privateSet(this, _headersList, new HeadersList());
        __privateSet(this, _guard, "none");
        if (init !== void 0) {
          init = webidl.converters.HeadersInit(init, "Headers contructor", "init");
          fill(this, init);
        }
      }
      // https://fetch.spec.whatwg.org/#dom-headers-append
      append(name, value) {
        webidl.brandCheck(this, _Headers);
        webidl.argumentLengthCheck(arguments, 2, "Headers.append");
        const prefix = "Headers.append";
        name = webidl.converters.ByteString(name, prefix, "name");
        value = webidl.converters.ByteString(value, prefix, "value");
        return appendHeader(this, name, value);
      }
      // https://fetch.spec.whatwg.org/#dom-headers-delete
      delete(name) {
        webidl.brandCheck(this, _Headers);
        webidl.argumentLengthCheck(arguments, 1, "Headers.delete");
        const prefix = "Headers.delete";
        name = webidl.converters.ByteString(name, prefix, "name");
        if (!isValidHeaderName(name)) {
          throw webidl.errors.invalidArgument({
            prefix: "Headers.delete",
            value: name,
            type: "header name"
          });
        }
        if (__privateGet(this, _guard) === "immutable") {
          throw new TypeError("immutable");
        }
        if (!__privateGet(this, _headersList).contains(name, false)) {
          return;
        }
        __privateGet(this, _headersList).delete(name, false);
      }
      // https://fetch.spec.whatwg.org/#dom-headers-get
      get(name) {
        webidl.brandCheck(this, _Headers);
        webidl.argumentLengthCheck(arguments, 1, "Headers.get");
        const prefix = "Headers.get";
        name = webidl.converters.ByteString(name, prefix, "name");
        if (!isValidHeaderName(name)) {
          throw webidl.errors.invalidArgument({
            prefix,
            value: name,
            type: "header name"
          });
        }
        return __privateGet(this, _headersList).get(name, false);
      }
      // https://fetch.spec.whatwg.org/#dom-headers-has
      has(name) {
        webidl.brandCheck(this, _Headers);
        webidl.argumentLengthCheck(arguments, 1, "Headers.has");
        const prefix = "Headers.has";
        name = webidl.converters.ByteString(name, prefix, "name");
        if (!isValidHeaderName(name)) {
          throw webidl.errors.invalidArgument({
            prefix,
            value: name,
            type: "header name"
          });
        }
        return __privateGet(this, _headersList).contains(name, false);
      }
      // https://fetch.spec.whatwg.org/#dom-headers-set
      set(name, value) {
        webidl.brandCheck(this, _Headers);
        webidl.argumentLengthCheck(arguments, 2, "Headers.set");
        const prefix = "Headers.set";
        name = webidl.converters.ByteString(name, prefix, "name");
        value = webidl.converters.ByteString(value, prefix, "value");
        value = headerValueNormalize(value);
        if (!isValidHeaderName(name)) {
          throw webidl.errors.invalidArgument({
            prefix,
            value: name,
            type: "header name"
          });
        } else if (!isValidHeaderValue(value)) {
          throw webidl.errors.invalidArgument({
            prefix,
            value,
            type: "header value"
          });
        }
        if (__privateGet(this, _guard) === "immutable") {
          throw new TypeError("immutable");
        }
        __privateGet(this, _headersList).set(name, value, false);
      }
      // https://fetch.spec.whatwg.org/#dom-headers-getsetcookie
      getSetCookie() {
        webidl.brandCheck(this, _Headers);
        const list = __privateGet(this, _headersList).cookies;
        if (list) {
          return [...list];
        }
        return [];
      }
      // https://fetch.spec.whatwg.org/#concept-header-list-sort-and-combine
      get [kHeadersSortedMap]() {
        if (__privateGet(this, _headersList)[kHeadersSortedMap]) {
          return __privateGet(this, _headersList)[kHeadersSortedMap];
        }
        const headers = [];
        const names = __privateGet(this, _headersList).toSortedArray();
        const cookies = __privateGet(this, _headersList).cookies;
        if (cookies === null || cookies.length === 1) {
          return __privateGet(this, _headersList)[kHeadersSortedMap] = names;
        }
        for (let i = 0; i < names.length; ++i) {
          const { 0: name, 1: value } = names[i];
          if (name === "set-cookie") {
            for (let j = 0; j < cookies.length; ++j) {
              headers.push([name, cookies[j]]);
            }
          } else {
            headers.push([name, value]);
          }
        }
        return __privateGet(this, _headersList)[kHeadersSortedMap] = headers;
      }
      [util.inspect.custom](depth, options) {
        options.depth ?? (options.depth = depth);
        return `Headers ${util.formatWithOptions(options, __privateGet(this, _headersList).entries)}`;
      }
      static getHeadersGuard(o) {
        return __privateGet(o, _guard);
      }
      static setHeadersGuard(o, guard) {
        __privateSet(o, _guard, guard);
      }
      static getHeadersList(o) {
        return __privateGet(o, _headersList);
      }
      static setHeadersList(o, list) {
        __privateSet(o, _headersList, list);
      }
    };
    _guard = new WeakMap();
    _headersList = new WeakMap();
    var Headers = _Headers;
    var { getHeadersGuard, setHeadersGuard, getHeadersList, setHeadersList } = Headers;
    Reflect.deleteProperty(Headers, "getHeadersGuard");
    Reflect.deleteProperty(Headers, "setHeadersGuard");
    Reflect.deleteProperty(Headers, "getHeadersList");
    Reflect.deleteProperty(Headers, "setHeadersList");
    iteratorMixin("Headers", Headers, kHeadersSortedMap, 0, 1);
    Object.defineProperties(Headers.prototype, {
      append: kEnumerableProperty,
      delete: kEnumerableProperty,
      get: kEnumerableProperty,
      has: kEnumerableProperty,
      set: kEnumerableProperty,
      getSetCookie: kEnumerableProperty,
      [Symbol.toStringTag]: {
        value: "Headers",
        configurable: true
      },
      [util.inspect.custom]: {
        enumerable: false
      }
    });
    webidl.converters.HeadersInit = function(V, prefix, argument) {
      if (webidl.util.Type(V) === "Object") {
        const iterator = Reflect.get(V, Symbol.iterator);
        if (!util.types.isProxy(V) && iterator === Headers.prototype.entries) {
          try {
            return getHeadersList(V).entriesList;
          } catch {
          }
        }
        if (typeof iterator === "function") {
          return webidl.converters["sequence<sequence<ByteString>>"](V, prefix, argument, iterator.bind(V));
        }
        return webidl.converters["record<ByteString, ByteString>"](V, prefix, argument);
      }
      throw webidl.errors.conversionFailed({
        prefix: "Headers constructor",
        argument: "Argument 1",
        types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
      });
    };
    module2.exports = {
      fill,
      // for test.
      compareHeaderName,
      Headers,
      HeadersList,
      getHeadersGuard,
      setHeadersGuard,
      setHeadersList,
      getHeadersList
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/fetch/response.js
var require_response = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/fetch/response.js"(exports2, module2) {
    "use strict";
    var { Headers, HeadersList, fill, getHeadersGuard, setHeadersGuard, setHeadersList } = require_headers();
    var { extractBody, cloneBody, mixinBody, hasFinalizationRegistry, streamRegistry, bodyUnusable } = require_body();
    var util = require_util2();
    var nodeUtil = require_node_util();
    var { kEnumerableProperty } = util;
    var {
      isValidReasonPhrase,
      isCancelled,
      isAborted,
      isBlobLike,
      serializeJavascriptValueToJSONString,
      isErrorLike,
      isomorphicEncode,
      environmentSettingsObject: relevantRealm
    } = require_util3();
    var {
      redirectStatusSet,
      nullBodyStatus
    } = require_constants3();
    var { kState, kHeaders } = require_symbols2();
    var { webidl } = require_webidl();
    var { FormData } = require_formdata();
    var { URLSerializer } = require_data_url();
    var { kConstruct } = require_symbols();
    var assert = require_node_assert();
    var { types } = require_node_util();
    var textEncoder = new TextEncoder("utf-8");
    var Response = class _Response {
      // Creates network error Response.
      static error() {
        const responseObject = fromInnerResponse(makeNetworkError(), "immutable");
        return responseObject;
      }
      // https://fetch.spec.whatwg.org/#dom-response-json
      static json(data, init = {}) {
        webidl.argumentLengthCheck(arguments, 1, "Response.json");
        if (init !== null) {
          init = webidl.converters.ResponseInit(init);
        }
        const bytes = textEncoder.encode(
          serializeJavascriptValueToJSONString(data)
        );
        const body = extractBody(bytes);
        const responseObject = fromInnerResponse(makeResponse({}), "response");
        initializeResponse(responseObject, init, { body: body[0], type: "application/json" });
        return responseObject;
      }
      // Creates a redirect Response that redirects to url with status status.
      static redirect(url, status = 302) {
        webidl.argumentLengthCheck(arguments, 1, "Response.redirect");
        url = webidl.converters.USVString(url);
        status = webidl.converters["unsigned short"](status);
        let parsedURL;
        try {
          parsedURL = new URL(url, relevantRealm.settingsObject.baseUrl);
        } catch (err) {
          throw new TypeError(`Failed to parse URL from ${url}`, { cause: err });
        }
        if (!redirectStatusSet.has(status)) {
          throw new RangeError(`Invalid status code ${status}`);
        }
        const responseObject = fromInnerResponse(makeResponse({}), "immutable");
        responseObject[kState].status = status;
        const value = isomorphicEncode(URLSerializer(parsedURL));
        responseObject[kState].headersList.append("location", value, true);
        return responseObject;
      }
      // https://fetch.spec.whatwg.org/#dom-response
      constructor(body = null, init = {}) {
        webidl.util.markAsUncloneable(this);
        if (body === kConstruct) {
          return;
        }
        if (body !== null) {
          body = webidl.converters.BodyInit(body);
        }
        init = webidl.converters.ResponseInit(init);
        this[kState] = makeResponse({});
        this[kHeaders] = new Headers(kConstruct);
        setHeadersGuard(this[kHeaders], "response");
        setHeadersList(this[kHeaders], this[kState].headersList);
        let bodyWithType = null;
        if (body != null) {
          const [extractedBody, type] = extractBody(body);
          bodyWithType = { body: extractedBody, type };
        }
        initializeResponse(this, init, bodyWithType);
      }
      // Returns response’s type, e.g., "cors".
      get type() {
        webidl.brandCheck(this, _Response);
        return this[kState].type;
      }
      // Returns response’s URL, if it has one; otherwise the empty string.
      get url() {
        webidl.brandCheck(this, _Response);
        const urlList = this[kState].urlList;
        const url = urlList[urlList.length - 1] ?? null;
        if (url === null) {
          return "";
        }
        return URLSerializer(url, true);
      }
      // Returns whether response was obtained through a redirect.
      get redirected() {
        webidl.brandCheck(this, _Response);
        return this[kState].urlList.length > 1;
      }
      // Returns response’s status.
      get status() {
        webidl.brandCheck(this, _Response);
        return this[kState].status;
      }
      // Returns whether response’s status is an ok status.
      get ok() {
        webidl.brandCheck(this, _Response);
        return this[kState].status >= 200 && this[kState].status <= 299;
      }
      // Returns response’s status message.
      get statusText() {
        webidl.brandCheck(this, _Response);
        return this[kState].statusText;
      }
      // Returns response’s headers as Headers.
      get headers() {
        webidl.brandCheck(this, _Response);
        return this[kHeaders];
      }
      get body() {
        webidl.brandCheck(this, _Response);
        return this[kState].body ? this[kState].body.stream : null;
      }
      get bodyUsed() {
        webidl.brandCheck(this, _Response);
        return !!this[kState].body && util.isDisturbed(this[kState].body.stream);
      }
      // Returns a clone of response.
      clone() {
        webidl.brandCheck(this, _Response);
        if (bodyUnusable(this)) {
          throw webidl.errors.exception({
            header: "Response.clone",
            message: "Body has already been consumed."
          });
        }
        const clonedResponse = cloneResponse(this[kState]);
        return fromInnerResponse(clonedResponse, getHeadersGuard(this[kHeaders]));
      }
      [nodeUtil.inspect.custom](depth, options) {
        if (options.depth === null) {
          options.depth = 2;
        }
        options.colors ?? (options.colors = true);
        const properties = {
          status: this.status,
          statusText: this.statusText,
          headers: this.headers,
          body: this.body,
          bodyUsed: this.bodyUsed,
          ok: this.ok,
          redirected: this.redirected,
          type: this.type,
          url: this.url
        };
        return `Response ${nodeUtil.formatWithOptions(options, properties)}`;
      }
    };
    mixinBody(Response);
    Object.defineProperties(Response.prototype, {
      type: kEnumerableProperty,
      url: kEnumerableProperty,
      status: kEnumerableProperty,
      ok: kEnumerableProperty,
      redirected: kEnumerableProperty,
      statusText: kEnumerableProperty,
      headers: kEnumerableProperty,
      clone: kEnumerableProperty,
      body: kEnumerableProperty,
      bodyUsed: kEnumerableProperty,
      [Symbol.toStringTag]: {
        value: "Response",
        configurable: true
      }
    });
    Object.defineProperties(Response, {
      json: kEnumerableProperty,
      redirect: kEnumerableProperty,
      error: kEnumerableProperty
    });
    function cloneResponse(response) {
      if (response.internalResponse) {
        return filterResponse(
          cloneResponse(response.internalResponse),
          response.type
        );
      }
      const newResponse = makeResponse({ ...response, body: null });
      if (response.body != null) {
        newResponse.body = cloneBody(newResponse, response.body);
      }
      return newResponse;
    }
    function makeResponse(init) {
      return {
        aborted: false,
        rangeRequested: false,
        timingAllowPassed: false,
        requestIncludesCredentials: false,
        type: "default",
        status: 200,
        timingInfo: null,
        cacheState: "",
        statusText: "",
        ...init,
        headersList: (init == null ? void 0 : init.headersList) ? new HeadersList(init == null ? void 0 : init.headersList) : new HeadersList(),
        urlList: (init == null ? void 0 : init.urlList) ? [...init.urlList] : []
      };
    }
    function makeNetworkError(reason) {
      const isError = isErrorLike(reason);
      return makeResponse({
        type: "error",
        status: 0,
        error: isError ? reason : new Error(reason ? String(reason) : reason),
        aborted: reason && reason.name === "AbortError"
      });
    }
    function isNetworkError(response) {
      return (
        // A network error is a response whose type is "error",
        response.type === "error" && // status is 0
        response.status === 0
      );
    }
    function makeFilteredResponse(response, state) {
      state = {
        internalResponse: response,
        ...state
      };
      return new Proxy(response, {
        get(target, p) {
          return p in state ? state[p] : target[p];
        },
        set(target, p, value) {
          assert(!(p in state));
          target[p] = value;
          return true;
        }
      });
    }
    function filterResponse(response, type) {
      if (type === "basic") {
        return makeFilteredResponse(response, {
          type: "basic",
          headersList: response.headersList
        });
      } else if (type === "cors") {
        return makeFilteredResponse(response, {
          type: "cors",
          headersList: response.headersList
        });
      } else if (type === "opaque") {
        return makeFilteredResponse(response, {
          type: "opaque",
          urlList: Object.freeze([]),
          status: 0,
          statusText: "",
          body: null
        });
      } else if (type === "opaqueredirect") {
        return makeFilteredResponse(response, {
          type: "opaqueredirect",
          status: 0,
          statusText: "",
          headersList: [],
          body: null
        });
      } else {
        assert(false);
      }
    }
    function makeAppropriateNetworkError(fetchParams, err = null) {
      assert(isCancelled(fetchParams));
      return isAborted(fetchParams) ? makeNetworkError(Object.assign(new DOMException("The operation was aborted.", "AbortError"), { cause: err })) : makeNetworkError(Object.assign(new DOMException("Request was cancelled."), { cause: err }));
    }
    function initializeResponse(response, init, body) {
      if (init.status !== null && (init.status < 200 || init.status > 599)) {
        throw new RangeError('init["status"] must be in the range of 200 to 599, inclusive.');
      }
      if ("statusText" in init && init.statusText != null) {
        if (!isValidReasonPhrase(String(init.statusText))) {
          throw new TypeError("Invalid statusText");
        }
      }
      if ("status" in init && init.status != null) {
        response[kState].status = init.status;
      }
      if ("statusText" in init && init.statusText != null) {
        response[kState].statusText = init.statusText;
      }
      if ("headers" in init && init.headers != null) {
        fill(response[kHeaders], init.headers);
      }
      if (body) {
        if (nullBodyStatus.includes(response.status)) {
          throw webidl.errors.exception({
            header: "Response constructor",
            message: `Invalid response status code ${response.status}`
          });
        }
        response[kState].body = body.body;
        if (body.type != null && !response[kState].headersList.contains("content-type", true)) {
          response[kState].headersList.append("content-type", body.type, true);
        }
      }
    }
    function fromInnerResponse(innerResponse, guard) {
      var _a;
      const response = new Response(kConstruct);
      response[kState] = innerResponse;
      response[kHeaders] = new Headers(kConstruct);
      setHeadersList(response[kHeaders], innerResponse.headersList);
      setHeadersGuard(response[kHeaders], guard);
      if (hasFinalizationRegistry && ((_a = innerResponse.body) == null ? void 0 : _a.stream)) {
        streamRegistry.register(response, new WeakRef(innerResponse.body.stream));
      }
      return response;
    }
    webidl.converters.ReadableStream = webidl.interfaceConverter(
      ReadableStream
    );
    webidl.converters.FormData = webidl.interfaceConverter(
      FormData
    );
    webidl.converters.URLSearchParams = webidl.interfaceConverter(
      URLSearchParams
    );
    webidl.converters.XMLHttpRequestBodyInit = function(V, prefix, name) {
      if (typeof V === "string") {
        return webidl.converters.USVString(V, prefix, name);
      }
      if (isBlobLike(V)) {
        return webidl.converters.Blob(V, prefix, name, { strict: false });
      }
      if (ArrayBuffer.isView(V) || types.isArrayBuffer(V)) {
        return webidl.converters.BufferSource(V, prefix, name);
      }
      if (util.isFormDataLike(V)) {
        return webidl.converters.FormData(V, prefix, name, { strict: false });
      }
      if (V instanceof URLSearchParams) {
        return webidl.converters.URLSearchParams(V, prefix, name);
      }
      return webidl.converters.DOMString(V, prefix, name);
    };
    webidl.converters.BodyInit = function(V, prefix, argument) {
      if (V instanceof ReadableStream) {
        return webidl.converters.ReadableStream(V, prefix, argument);
      }
      if (V == null ? void 0 : V[Symbol.asyncIterator]) {
        return V;
      }
      return webidl.converters.XMLHttpRequestBodyInit(V, prefix, argument);
    };
    webidl.converters.ResponseInit = webidl.dictionaryConverter([
      {
        key: "status",
        converter: webidl.converters["unsigned short"],
        defaultValue: () => 200
      },
      {
        key: "statusText",
        converter: webidl.converters.ByteString,
        defaultValue: () => ""
      },
      {
        key: "headers",
        converter: webidl.converters.HeadersInit
      }
    ]);
    module2.exports = {
      isNetworkError,
      makeNetworkError,
      makeResponse,
      makeAppropriateNetworkError,
      filterResponse,
      Response,
      cloneResponse,
      fromInnerResponse
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/fetch/dispatcher-weakref.js
var require_dispatcher_weakref = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/fetch/dispatcher-weakref.js"(exports2, module2) {
    "use strict";
    var { kConnected, kSize } = require_symbols();
    var CompatWeakRef = class {
      constructor(value) {
        this.value = value;
      }
      deref() {
        return this.value[kConnected] === 0 && this.value[kSize] === 0 ? void 0 : this.value;
      }
    };
    var CompatFinalizer = class {
      constructor(finalizer) {
        this.finalizer = finalizer;
      }
      register(dispatcher, key) {
        if (dispatcher.on) {
          dispatcher.on("disconnect", () => {
            if (dispatcher[kConnected] === 0 && dispatcher[kSize] === 0) {
              this.finalizer(key);
            }
          });
        }
      }
      unregister(key) {
      }
    };
    module2.exports = function() {
      if (process.env.NODE_V8_COVERAGE && process.version.startsWith("v18")) {
        process._rawDebug("Using compatibility WeakRef and FinalizationRegistry");
        return {
          WeakRef: CompatWeakRef,
          FinalizationRegistry: CompatFinalizer
        };
      }
      return { WeakRef, FinalizationRegistry };
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/fetch/request.js
var require_request2 = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/fetch/request.js"(exports2, module2) {
    "use strict";
    var { extractBody, mixinBody, cloneBody, bodyUnusable } = require_body();
    var { Headers, fill: fillHeaders, HeadersList, setHeadersGuard, getHeadersGuard, setHeadersList, getHeadersList } = require_headers();
    var { FinalizationRegistry: FinalizationRegistry2 } = require_dispatcher_weakref()();
    var util = require_util2();
    var nodeUtil = require_node_util();
    var {
      isValidHTTPToken,
      sameOrigin,
      environmentSettingsObject
    } = require_util3();
    var {
      forbiddenMethodsSet,
      corsSafeListedMethodsSet,
      referrerPolicy,
      requestRedirect,
      requestMode,
      requestCredentials,
      requestCache,
      requestDuplex
    } = require_constants3();
    var { kEnumerableProperty, normalizedMethodRecordsBase, normalizedMethodRecords } = util;
    var { kHeaders, kSignal, kState, kDispatcher } = require_symbols2();
    var { webidl } = require_webidl();
    var { URLSerializer } = require_data_url();
    var { kConstruct } = require_symbols();
    var assert = require_node_assert();
    var { getMaxListeners, setMaxListeners, getEventListeners, defaultMaxListeners } = require_node_events();
    var kAbortController = Symbol("abortController");
    var requestFinalizer = new FinalizationRegistry2(({ signal, abort }) => {
      signal.removeEventListener("abort", abort);
    });
    var dependentControllerMap = /* @__PURE__ */ new WeakMap();
    function buildAbort(acRef) {
      return abort;
      function abort() {
        const ac = acRef.deref();
        if (ac !== void 0) {
          requestFinalizer.unregister(abort);
          this.removeEventListener("abort", abort);
          ac.abort(this.reason);
          const controllerList = dependentControllerMap.get(ac.signal);
          if (controllerList !== void 0) {
            if (controllerList.size !== 0) {
              for (const ref of controllerList) {
                const ctrl = ref.deref();
                if (ctrl !== void 0) {
                  ctrl.abort(this.reason);
                }
              }
              controllerList.clear();
            }
            dependentControllerMap.delete(ac.signal);
          }
        }
      }
    }
    var patchMethodWarning = false;
    var Request = class _Request {
      // https://fetch.spec.whatwg.org/#dom-request
      constructor(input, init = {}) {
        var _a, _b;
        webidl.util.markAsUncloneable(this);
        if (input === kConstruct) {
          return;
        }
        const prefix = "Request constructor";
        webidl.argumentLengthCheck(arguments, 1, prefix);
        input = webidl.converters.RequestInfo(input, prefix, "input");
        init = webidl.converters.RequestInit(init, prefix, "init");
        let request = null;
        let fallbackMode = null;
        const baseUrl = environmentSettingsObject.settingsObject.baseUrl;
        let signal = null;
        if (typeof input === "string") {
          this[kDispatcher] = init.dispatcher;
          let parsedURL;
          try {
            parsedURL = new URL(input, baseUrl);
          } catch (err) {
            throw new TypeError("Failed to parse URL from " + input, { cause: err });
          }
          if (parsedURL.username || parsedURL.password) {
            throw new TypeError(
              "Request cannot be constructed from a URL that includes credentials: " + input
            );
          }
          request = makeRequest({ urlList: [parsedURL] });
          fallbackMode = "cors";
        } else {
          this[kDispatcher] = init.dispatcher || input[kDispatcher];
          assert(input instanceof _Request);
          request = input[kState];
          signal = input[kSignal];
        }
        const origin = environmentSettingsObject.settingsObject.origin;
        let window2 = "client";
        if (((_b = (_a = request.window) == null ? void 0 : _a.constructor) == null ? void 0 : _b.name) === "EnvironmentSettingsObject" && sameOrigin(request.window, origin)) {
          window2 = request.window;
        }
        if (init.window != null) {
          throw new TypeError(`'window' option '${window2}' must be null`);
        }
        if ("window" in init) {
          window2 = "no-window";
        }
        request = makeRequest({
          // URL request’s URL.
          // undici implementation note: this is set as the first item in request's urlList in makeRequest
          // method request’s method.
          method: request.method,
          // header list A copy of request’s header list.
          // undici implementation note: headersList is cloned in makeRequest
          headersList: request.headersList,
          // unsafe-request flag Set.
          unsafeRequest: request.unsafeRequest,
          // client This’s relevant settings object.
          client: environmentSettingsObject.settingsObject,
          // window window.
          window: window2,
          // priority request’s priority.
          priority: request.priority,
          // origin request’s origin. The propagation of the origin is only significant for navigation requests
          // being handled by a service worker. In this scenario a request can have an origin that is different
          // from the current client.
          origin: request.origin,
          // referrer request’s referrer.
          referrer: request.referrer,
          // referrer policy request’s referrer policy.
          referrerPolicy: request.referrerPolicy,
          // mode request’s mode.
          mode: request.mode,
          // credentials mode request’s credentials mode.
          credentials: request.credentials,
          // cache mode request’s cache mode.
          cache: request.cache,
          // redirect mode request’s redirect mode.
          redirect: request.redirect,
          // integrity metadata request’s integrity metadata.
          integrity: request.integrity,
          // keepalive request’s keepalive.
          keepalive: request.keepalive,
          // reload-navigation flag request’s reload-navigation flag.
          reloadNavigation: request.reloadNavigation,
          // history-navigation flag request’s history-navigation flag.
          historyNavigation: request.historyNavigation,
          // URL list A clone of request’s URL list.
          urlList: [...request.urlList]
        });
        const initHasKey = Object.keys(init).length !== 0;
        if (initHasKey) {
          if (request.mode === "navigate") {
            request.mode = "same-origin";
          }
          request.reloadNavigation = false;
          request.historyNavigation = false;
          request.origin = "client";
          request.referrer = "client";
          request.referrerPolicy = "";
          request.url = request.urlList[request.urlList.length - 1];
          request.urlList = [request.url];
        }
        if (init.referrer !== void 0) {
          const referrer = init.referrer;
          if (referrer === "") {
            request.referrer = "no-referrer";
          } else {
            let parsedReferrer;
            try {
              parsedReferrer = new URL(referrer, baseUrl);
            } catch (err) {
              throw new TypeError(`Referrer "${referrer}" is not a valid URL.`, { cause: err });
            }
            if (parsedReferrer.protocol === "about:" && parsedReferrer.hostname === "client" || origin && !sameOrigin(parsedReferrer, environmentSettingsObject.settingsObject.baseUrl)) {
              request.referrer = "client";
            } else {
              request.referrer = parsedReferrer;
            }
          }
        }
        if (init.referrerPolicy !== void 0) {
          request.referrerPolicy = init.referrerPolicy;
        }
        let mode;
        if (init.mode !== void 0) {
          mode = init.mode;
        } else {
          mode = fallbackMode;
        }
        if (mode === "navigate") {
          throw webidl.errors.exception({
            header: "Request constructor",
            message: "invalid request mode navigate."
          });
        }
        if (mode != null) {
          request.mode = mode;
        }
        if (init.credentials !== void 0) {
          request.credentials = init.credentials;
        }
        if (init.cache !== void 0) {
          request.cache = init.cache;
        }
        if (request.cache === "only-if-cached" && request.mode !== "same-origin") {
          throw new TypeError(
            "'only-if-cached' can be set only with 'same-origin' mode"
          );
        }
        if (init.redirect !== void 0) {
          request.redirect = init.redirect;
        }
        if (init.integrity != null) {
          request.integrity = String(init.integrity);
        }
        if (init.keepalive !== void 0) {
          request.keepalive = Boolean(init.keepalive);
        }
        if (init.method !== void 0) {
          let method = init.method;
          const mayBeNormalized = normalizedMethodRecords[method];
          if (mayBeNormalized !== void 0) {
            request.method = mayBeNormalized;
          } else {
            if (!isValidHTTPToken(method)) {
              throw new TypeError(`'${method}' is not a valid HTTP method.`);
            }
            const upperCase = method.toUpperCase();
            if (forbiddenMethodsSet.has(upperCase)) {
              throw new TypeError(`'${method}' HTTP method is unsupported.`);
            }
            method = normalizedMethodRecordsBase[upperCase] ?? method;
            request.method = method;
          }
          if (!patchMethodWarning && request.method === "patch") {
            process.emitWarning("Using `patch` is highly likely to result in a `405 Method Not Allowed`. `PATCH` is much more likely to succeed.", {
              code: "UNDICI-FETCH-patch"
            });
            patchMethodWarning = true;
          }
        }
        if (init.signal !== void 0) {
          signal = init.signal;
        }
        this[kState] = request;
        const ac = new AbortController();
        this[kSignal] = ac.signal;
        if (signal != null) {
          if (!signal || typeof signal.aborted !== "boolean" || typeof signal.addEventListener !== "function") {
            throw new TypeError(
              "Failed to construct 'Request': member signal is not of type AbortSignal."
            );
          }
          if (signal.aborted) {
            ac.abort(signal.reason);
          } else {
            this[kAbortController] = ac;
            const acRef = new WeakRef(ac);
            const abort = buildAbort(acRef);
            try {
              if (typeof getMaxListeners === "function" && getMaxListeners(signal) === defaultMaxListeners) {
                setMaxListeners(1500, signal);
              } else if (getEventListeners(signal, "abort").length >= defaultMaxListeners) {
                setMaxListeners(1500, signal);
              }
            } catch {
            }
            util.addAbortListener(signal, abort);
            requestFinalizer.register(ac, { signal, abort }, abort);
          }
        }
        this[kHeaders] = new Headers(kConstruct);
        setHeadersList(this[kHeaders], request.headersList);
        setHeadersGuard(this[kHeaders], "request");
        if (mode === "no-cors") {
          if (!corsSafeListedMethodsSet.has(request.method)) {
            throw new TypeError(
              `'${request.method} is unsupported in no-cors mode.`
            );
          }
          setHeadersGuard(this[kHeaders], "request-no-cors");
        }
        if (initHasKey) {
          const headersList = getHeadersList(this[kHeaders]);
          const headers = init.headers !== void 0 ? init.headers : new HeadersList(headersList);
          headersList.clear();
          if (headers instanceof HeadersList) {
            for (const { name, value } of headers.rawValues()) {
              headersList.append(name, value, false);
            }
            headersList.cookies = headers.cookies;
          } else {
            fillHeaders(this[kHeaders], headers);
          }
        }
        const inputBody = input instanceof _Request ? input[kState].body : null;
        if ((init.body != null || inputBody != null) && (request.method === "GET" || request.method === "HEAD")) {
          throw new TypeError("Request with GET/HEAD method cannot have body.");
        }
        let initBody = null;
        if (init.body != null) {
          const [extractedBody, contentType] = extractBody(
            init.body,
            request.keepalive
          );
          initBody = extractedBody;
          if (contentType && !getHeadersList(this[kHeaders]).contains("content-type", true)) {
            this[kHeaders].append("content-type", contentType);
          }
        }
        const inputOrInitBody = initBody ?? inputBody;
        if (inputOrInitBody != null && inputOrInitBody.source == null) {
          if (initBody != null && init.duplex == null) {
            throw new TypeError("RequestInit: duplex option is required when sending a body.");
          }
          if (request.mode !== "same-origin" && request.mode !== "cors") {
            throw new TypeError(
              'If request is made from ReadableStream, mode should be "same-origin" or "cors"'
            );
          }
          request.useCORSPreflightFlag = true;
        }
        let finalBody = inputOrInitBody;
        if (initBody == null && inputBody != null) {
          if (bodyUnusable(input)) {
            throw new TypeError(
              "Cannot construct a Request with a Request object that has already been used."
            );
          }
          const identityTransform = new TransformStream();
          inputBody.stream.pipeThrough(identityTransform);
          finalBody = {
            source: inputBody.source,
            length: inputBody.length,
            stream: identityTransform.readable
          };
        }
        this[kState].body = finalBody;
      }
      // Returns request’s HTTP method, which is "GET" by default.
      get method() {
        webidl.brandCheck(this, _Request);
        return this[kState].method;
      }
      // Returns the URL of request as a string.
      get url() {
        webidl.brandCheck(this, _Request);
        return URLSerializer(this[kState].url);
      }
      // Returns a Headers object consisting of the headers associated with request.
      // Note that headers added in the network layer by the user agent will not
      // be accounted for in this object, e.g., the "Host" header.
      get headers() {
        webidl.brandCheck(this, _Request);
        return this[kHeaders];
      }
      // Returns the kind of resource requested by request, e.g., "document"
      // or "script".
      get destination() {
        webidl.brandCheck(this, _Request);
        return this[kState].destination;
      }
      // Returns the referrer of request. Its value can be a same-origin URL if
      // explicitly set in init, the empty string to indicate no referrer, and
      // "about:client" when defaulting to the global’s default. This is used
      // during fetching to determine the value of the `Referer` header of the
      // request being made.
      get referrer() {
        webidl.brandCheck(this, _Request);
        if (this[kState].referrer === "no-referrer") {
          return "";
        }
        if (this[kState].referrer === "client") {
          return "about:client";
        }
        return this[kState].referrer.toString();
      }
      // Returns the referrer policy associated with request.
      // This is used during fetching to compute the value of the request’s
      // referrer.
      get referrerPolicy() {
        webidl.brandCheck(this, _Request);
        return this[kState].referrerPolicy;
      }
      // Returns the mode associated with request, which is a string indicating
      // whether the request will use CORS, or will be restricted to same-origin
      // URLs.
      get mode() {
        webidl.brandCheck(this, _Request);
        return this[kState].mode;
      }
      // Returns the credentials mode associated with request,
      // which is a string indicating whether credentials will be sent with the
      // request always, never, or only when sent to a same-origin URL.
      get credentials() {
        return this[kState].credentials;
      }
      // Returns the cache mode associated with request,
      // which is a string indicating how the request will
      // interact with the browser’s cache when fetching.
      get cache() {
        webidl.brandCheck(this, _Request);
        return this[kState].cache;
      }
      // Returns the redirect mode associated with request,
      // which is a string indicating how redirects for the
      // request will be handled during fetching. A request
      // will follow redirects by default.
      get redirect() {
        webidl.brandCheck(this, _Request);
        return this[kState].redirect;
      }
      // Returns request’s subresource integrity metadata, which is a
      // cryptographic hash of the resource being fetched. Its value
      // consists of multiple hashes separated by whitespace. [SRI]
      get integrity() {
        webidl.brandCheck(this, _Request);
        return this[kState].integrity;
      }
      // Returns a boolean indicating whether or not request can outlive the
      // global in which it was created.
      get keepalive() {
        webidl.brandCheck(this, _Request);
        return this[kState].keepalive;
      }
      // Returns a boolean indicating whether or not request is for a reload
      // navigation.
      get isReloadNavigation() {
        webidl.brandCheck(this, _Request);
        return this[kState].reloadNavigation;
      }
      // Returns a boolean indicating whether or not request is for a history
      // navigation (a.k.a. back-forward navigation).
      get isHistoryNavigation() {
        webidl.brandCheck(this, _Request);
        return this[kState].historyNavigation;
      }
      // Returns the signal associated with request, which is an AbortSignal
      // object indicating whether or not request has been aborted, and its
      // abort event handler.
      get signal() {
        webidl.brandCheck(this, _Request);
        return this[kSignal];
      }
      get body() {
        webidl.brandCheck(this, _Request);
        return this[kState].body ? this[kState].body.stream : null;
      }
      get bodyUsed() {
        webidl.brandCheck(this, _Request);
        return !!this[kState].body && util.isDisturbed(this[kState].body.stream);
      }
      get duplex() {
        webidl.brandCheck(this, _Request);
        return "half";
      }
      // Returns a clone of request.
      clone() {
        webidl.brandCheck(this, _Request);
        if (bodyUnusable(this)) {
          throw new TypeError("unusable");
        }
        const clonedRequest = cloneRequest(this[kState]);
        const ac = new AbortController();
        if (this.signal.aborted) {
          ac.abort(this.signal.reason);
        } else {
          let list = dependentControllerMap.get(this.signal);
          if (list === void 0) {
            list = /* @__PURE__ */ new Set();
            dependentControllerMap.set(this.signal, list);
          }
          const acRef = new WeakRef(ac);
          list.add(acRef);
          util.addAbortListener(
            ac.signal,
            buildAbort(acRef)
          );
        }
        return fromInnerRequest(clonedRequest, ac.signal, getHeadersGuard(this[kHeaders]));
      }
      [nodeUtil.inspect.custom](depth, options) {
        if (options.depth === null) {
          options.depth = 2;
        }
        options.colors ?? (options.colors = true);
        const properties = {
          method: this.method,
          url: this.url,
          headers: this.headers,
          destination: this.destination,
          referrer: this.referrer,
          referrerPolicy: this.referrerPolicy,
          mode: this.mode,
          credentials: this.credentials,
          cache: this.cache,
          redirect: this.redirect,
          integrity: this.integrity,
          keepalive: this.keepalive,
          isReloadNavigation: this.isReloadNavigation,
          isHistoryNavigation: this.isHistoryNavigation,
          signal: this.signal
        };
        return `Request ${nodeUtil.formatWithOptions(options, properties)}`;
      }
    };
    mixinBody(Request);
    function makeRequest(init) {
      return {
        method: init.method ?? "GET",
        localURLsOnly: init.localURLsOnly ?? false,
        unsafeRequest: init.unsafeRequest ?? false,
        body: init.body ?? null,
        client: init.client ?? null,
        reservedClient: init.reservedClient ?? null,
        replacesClientId: init.replacesClientId ?? "",
        window: init.window ?? "client",
        keepalive: init.keepalive ?? false,
        serviceWorkers: init.serviceWorkers ?? "all",
        initiator: init.initiator ?? "",
        destination: init.destination ?? "",
        priority: init.priority ?? null,
        origin: init.origin ?? "client",
        policyContainer: init.policyContainer ?? "client",
        referrer: init.referrer ?? "client",
        referrerPolicy: init.referrerPolicy ?? "",
        mode: init.mode ?? "no-cors",
        useCORSPreflightFlag: init.useCORSPreflightFlag ?? false,
        credentials: init.credentials ?? "same-origin",
        useCredentials: init.useCredentials ?? false,
        cache: init.cache ?? "default",
        redirect: init.redirect ?? "follow",
        integrity: init.integrity ?? "",
        cryptoGraphicsNonceMetadata: init.cryptoGraphicsNonceMetadata ?? "",
        parserMetadata: init.parserMetadata ?? "",
        reloadNavigation: init.reloadNavigation ?? false,
        historyNavigation: init.historyNavigation ?? false,
        userActivation: init.userActivation ?? false,
        taintedOrigin: init.taintedOrigin ?? false,
        redirectCount: init.redirectCount ?? 0,
        responseTainting: init.responseTainting ?? "basic",
        preventNoCacheCacheControlHeaderModification: init.preventNoCacheCacheControlHeaderModification ?? false,
        done: init.done ?? false,
        timingAllowFailed: init.timingAllowFailed ?? false,
        urlList: init.urlList,
        url: init.urlList[0],
        headersList: init.headersList ? new HeadersList(init.headersList) : new HeadersList()
      };
    }
    function cloneRequest(request) {
      const newRequest = makeRequest({ ...request, body: null });
      if (request.body != null) {
        newRequest.body = cloneBody(newRequest, request.body);
      }
      return newRequest;
    }
    function fromInnerRequest(innerRequest, signal, guard) {
      const request = new Request(kConstruct);
      request[kState] = innerRequest;
      request[kSignal] = signal;
      request[kHeaders] = new Headers(kConstruct);
      setHeadersList(request[kHeaders], innerRequest.headersList);
      setHeadersGuard(request[kHeaders], guard);
      return request;
    }
    Object.defineProperties(Request.prototype, {
      method: kEnumerableProperty,
      url: kEnumerableProperty,
      headers: kEnumerableProperty,
      redirect: kEnumerableProperty,
      clone: kEnumerableProperty,
      signal: kEnumerableProperty,
      duplex: kEnumerableProperty,
      destination: kEnumerableProperty,
      body: kEnumerableProperty,
      bodyUsed: kEnumerableProperty,
      isHistoryNavigation: kEnumerableProperty,
      isReloadNavigation: kEnumerableProperty,
      keepalive: kEnumerableProperty,
      integrity: kEnumerableProperty,
      cache: kEnumerableProperty,
      credentials: kEnumerableProperty,
      attribute: kEnumerableProperty,
      referrerPolicy: kEnumerableProperty,
      referrer: kEnumerableProperty,
      mode: kEnumerableProperty,
      [Symbol.toStringTag]: {
        value: "Request",
        configurable: true
      }
    });
    webidl.converters.Request = webidl.interfaceConverter(
      Request
    );
    webidl.converters.RequestInfo = function(V, prefix, argument) {
      if (typeof V === "string") {
        return webidl.converters.USVString(V, prefix, argument);
      }
      if (V instanceof Request) {
        return webidl.converters.Request(V, prefix, argument);
      }
      return webidl.converters.USVString(V, prefix, argument);
    };
    webidl.converters.AbortSignal = webidl.interfaceConverter(
      AbortSignal
    );
    webidl.converters.RequestInit = webidl.dictionaryConverter([
      {
        key: "method",
        converter: webidl.converters.ByteString
      },
      {
        key: "headers",
        converter: webidl.converters.HeadersInit
      },
      {
        key: "body",
        converter: webidl.nullableConverter(
          webidl.converters.BodyInit
        )
      },
      {
        key: "referrer",
        converter: webidl.converters.USVString
      },
      {
        key: "referrerPolicy",
        converter: webidl.converters.DOMString,
        // https://w3c.github.io/webappsec-referrer-policy/#referrer-policy
        allowedValues: referrerPolicy
      },
      {
        key: "mode",
        converter: webidl.converters.DOMString,
        // https://fetch.spec.whatwg.org/#concept-request-mode
        allowedValues: requestMode
      },
      {
        key: "credentials",
        converter: webidl.converters.DOMString,
        // https://fetch.spec.whatwg.org/#requestcredentials
        allowedValues: requestCredentials
      },
      {
        key: "cache",
        converter: webidl.converters.DOMString,
        // https://fetch.spec.whatwg.org/#requestcache
        allowedValues: requestCache
      },
      {
        key: "redirect",
        converter: webidl.converters.DOMString,
        // https://fetch.spec.whatwg.org/#requestredirect
        allowedValues: requestRedirect
      },
      {
        key: "integrity",
        converter: webidl.converters.DOMString
      },
      {
        key: "keepalive",
        converter: webidl.converters.boolean
      },
      {
        key: "signal",
        converter: webidl.nullableConverter(
          (signal) => webidl.converters.AbortSignal(
            signal,
            "RequestInit",
            "signal",
            { strict: false }
          )
        )
      },
      {
        key: "window",
        converter: webidl.converters.any
      },
      {
        key: "duplex",
        converter: webidl.converters.DOMString,
        allowedValues: requestDuplex
      },
      {
        key: "dispatcher",
        // undici specific option
        converter: webidl.converters.any
      }
    ]);
    module2.exports = { Request, makeRequest, fromInnerRequest, cloneRequest };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/fetch/index.js
var require_fetch = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/fetch/index.js"(exports2, module2) {
    "use strict";
    var {
      makeNetworkError,
      makeAppropriateNetworkError,
      filterResponse,
      makeResponse,
      fromInnerResponse
    } = require_response();
    var { HeadersList } = require_headers();
    var { Request, cloneRequest } = require_request2();
    var zlib = require_node_zlib();
    var {
      bytesMatch,
      makePolicyContainer,
      clonePolicyContainer,
      requestBadPort,
      TAOCheck,
      appendRequestOriginHeader,
      responseLocationURL,
      requestCurrentURL,
      setRequestReferrerPolicyOnRedirect,
      tryUpgradeRequestToAPotentiallyTrustworthyURL,
      createOpaqueTimingInfo,
      appendFetchMetadata,
      corsCheck,
      crossOriginResourcePolicyCheck,
      determineRequestsReferrer,
      coarsenedSharedCurrentTime,
      createDeferredPromise,
      isBlobLike,
      sameOrigin,
      isCancelled,
      isAborted,
      isErrorLike,
      fullyReadBody,
      readableStreamClose,
      isomorphicEncode,
      urlIsLocal,
      urlIsHttpHttpsScheme,
      urlHasHttpsScheme,
      clampAndCoarsenConnectionTimingInfo,
      simpleRangeHeaderValue,
      buildContentRange,
      createInflate,
      extractMimeType
    } = require_util3();
    var { kState, kDispatcher } = require_symbols2();
    var assert = require_node_assert();
    var { safelyExtractBody, extractBody } = require_body();
    var {
      redirectStatusSet,
      nullBodyStatus,
      safeMethodsSet,
      requestBodyHeader,
      subresourceSet
    } = require_constants3();
    var EE = require_node_events();
    var { Readable, pipeline, finished } = require_node_stream();
    var { addAbortListener, isErrored, isReadable, bufferToLowerCasedHeaderName } = require_util2();
    var { dataURLProcessor, serializeAMimeType, minimizeSupportedMimeType } = require_data_url();
    var { getGlobalDispatcher } = require_global2();
    var { webidl } = require_webidl();
    var { STATUS_CODES } = require_node_http();
    var GET_OR_HEAD = ["GET", "HEAD"];
    var defaultUserAgent = typeof __UNDICI_IS_NODE__ !== "undefined" || typeof esbuildDetection !== "undefined" ? "node" : "undici";
    var resolveObjectURL;
    var Fetch = class extends EE {
      constructor(dispatcher) {
        super();
        this.dispatcher = dispatcher;
        this.connection = null;
        this.dump = false;
        this.state = "ongoing";
      }
      terminate(reason) {
        var _a;
        if (this.state !== "ongoing") {
          return;
        }
        this.state = "terminated";
        (_a = this.connection) == null ? void 0 : _a.destroy(reason);
        this.emit("terminated", reason);
      }
      // https://fetch.spec.whatwg.org/#fetch-controller-abort
      abort(error2) {
        var _a;
        if (this.state !== "ongoing") {
          return;
        }
        this.state = "aborted";
        if (!error2) {
          error2 = new DOMException("The operation was aborted.", "AbortError");
        }
        this.serializedAbortReason = error2;
        (_a = this.connection) == null ? void 0 : _a.destroy(error2);
        this.emit("terminated", error2);
      }
    };
    function handleFetchDone(response) {
      finalizeAndReportTiming(response, "fetch");
    }
    function fetch(input, init = void 0) {
      var _a;
      webidl.argumentLengthCheck(arguments, 1, "globalThis.fetch");
      let p = createDeferredPromise();
      let requestObject;
      try {
        requestObject = new Request(input, init);
      } catch (e) {
        p.reject(e);
        return p.promise;
      }
      const request = requestObject[kState];
      if (requestObject.signal.aborted) {
        abortFetch(p, request, null, requestObject.signal.reason);
        return p.promise;
      }
      const globalObject = request.client.globalObject;
      if (((_a = globalObject == null ? void 0 : globalObject.constructor) == null ? void 0 : _a.name) === "ServiceWorkerGlobalScope") {
        request.serviceWorkers = "none";
      }
      let responseObject = null;
      let locallyAborted = false;
      let controller = null;
      addAbortListener(
        requestObject.signal,
        () => {
          locallyAborted = true;
          assert(controller != null);
          controller.abort(requestObject.signal.reason);
          const realResponse = responseObject == null ? void 0 : responseObject.deref();
          abortFetch(p, request, realResponse, requestObject.signal.reason);
        }
      );
      const processResponse = (response) => {
        if (locallyAborted) {
          return;
        }
        if (response.aborted) {
          abortFetch(p, request, responseObject, controller.serializedAbortReason);
          return;
        }
        if (response.type === "error") {
          p.reject(new TypeError("fetch failed", { cause: response.error }));
          return;
        }
        responseObject = new WeakRef(fromInnerResponse(response, "immutable"));
        p.resolve(responseObject.deref());
        p = null;
      };
      controller = fetching({
        request,
        processResponseEndOfBody: handleFetchDone,
        processResponse,
        dispatcher: requestObject[kDispatcher]
        // undici
      });
      return p.promise;
    }
    function finalizeAndReportTiming(response, initiatorType = "other") {
      var _a;
      if (response.type === "error" && response.aborted) {
        return;
      }
      if (!((_a = response.urlList) == null ? void 0 : _a.length)) {
        return;
      }
      const originalURL = response.urlList[0];
      let timingInfo = response.timingInfo;
      let cacheState = response.cacheState;
      if (!urlIsHttpHttpsScheme(originalURL)) {
        return;
      }
      if (timingInfo === null) {
        return;
      }
      if (!response.timingAllowPassed) {
        timingInfo = createOpaqueTimingInfo({
          startTime: timingInfo.startTime
        });
        cacheState = "";
      }
      timingInfo.endTime = coarsenedSharedCurrentTime();
      response.timingInfo = timingInfo;
      markResourceTiming(
        timingInfo,
        originalURL.href,
        initiatorType,
        globalThis,
        cacheState
      );
    }
    var markResourceTiming = performance.markResourceTiming;
    function abortFetch(p, request, responseObject, error2) {
      var _a, _b;
      if (p) {
        p.reject(error2);
      }
      if (request.body != null && isReadable((_a = request.body) == null ? void 0 : _a.stream)) {
        request.body.stream.cancel(error2).catch((err) => {
          if (err.code === "ERR_INVALID_STATE") {
            return;
          }
          throw err;
        });
      }
      if (responseObject == null) {
        return;
      }
      const response = responseObject[kState];
      if (response.body != null && isReadable((_b = response.body) == null ? void 0 : _b.stream)) {
        response.body.stream.cancel(error2).catch((err) => {
          if (err.code === "ERR_INVALID_STATE") {
            return;
          }
          throw err;
        });
      }
    }
    function fetching({
      request,
      processRequestBodyChunkLength,
      processRequestEndOfBody,
      processResponse,
      processResponseEndOfBody,
      processResponseConsumeBody,
      useParallelQueue = false,
      dispatcher = getGlobalDispatcher()
      // undici
    }) {
      var _a, _b, _c;
      assert(dispatcher);
      let taskDestination = null;
      let crossOriginIsolatedCapability = false;
      if (request.client != null) {
        taskDestination = request.client.globalObject;
        crossOriginIsolatedCapability = request.client.crossOriginIsolatedCapability;
      }
      const currentTime = coarsenedSharedCurrentTime(crossOriginIsolatedCapability);
      const timingInfo = createOpaqueTimingInfo({
        startTime: currentTime
      });
      const fetchParams = {
        controller: new Fetch(dispatcher),
        request,
        timingInfo,
        processRequestBodyChunkLength,
        processRequestEndOfBody,
        processResponse,
        processResponseConsumeBody,
        processResponseEndOfBody,
        taskDestination,
        crossOriginIsolatedCapability
      };
      assert(!request.body || request.body.stream);
      if (request.window === "client") {
        request.window = ((_c = (_b = (_a = request.client) == null ? void 0 : _a.globalObject) == null ? void 0 : _b.constructor) == null ? void 0 : _c.name) === "Window" ? request.client : "no-window";
      }
      if (request.origin === "client") {
        request.origin = request.client.origin;
      }
      if (request.policyContainer === "client") {
        if (request.client != null) {
          request.policyContainer = clonePolicyContainer(
            request.client.policyContainer
          );
        } else {
          request.policyContainer = makePolicyContainer();
        }
      }
      if (!request.headersList.contains("accept", true)) {
        const value = "*/*";
        request.headersList.append("accept", value, true);
      }
      if (!request.headersList.contains("accept-language", true)) {
        request.headersList.append("accept-language", "*", true);
      }
      if (request.priority === null) {
      }
      if (subresourceSet.has(request.destination)) {
      }
      mainFetch(fetchParams).catch((err) => {
        fetchParams.controller.terminate(err);
      });
      return fetchParams.controller;
    }
    async function mainFetch(fetchParams, recursive = false) {
      const request = fetchParams.request;
      let response = null;
      if (request.localURLsOnly && !urlIsLocal(requestCurrentURL(request))) {
        response = makeNetworkError("local URLs only");
      }
      tryUpgradeRequestToAPotentiallyTrustworthyURL(request);
      if (requestBadPort(request) === "blocked") {
        response = makeNetworkError("bad port");
      }
      if (request.referrerPolicy === "") {
        request.referrerPolicy = request.policyContainer.referrerPolicy;
      }
      if (request.referrer !== "no-referrer") {
        request.referrer = determineRequestsReferrer(request);
      }
      if (response === null) {
        response = await (async () => {
          const currentURL = requestCurrentURL(request);
          if (
            // - request’s current URL’s origin is same origin with request’s origin,
            //   and request’s response tainting is "basic"
            sameOrigin(currentURL, request.url) && request.responseTainting === "basic" || // request’s current URL’s scheme is "data"
            currentURL.protocol === "data:" || // - request’s mode is "navigate" or "websocket"
            (request.mode === "navigate" || request.mode === "websocket")
          ) {
            request.responseTainting = "basic";
            return await schemeFetch(fetchParams);
          }
          if (request.mode === "same-origin") {
            return makeNetworkError('request mode cannot be "same-origin"');
          }
          if (request.mode === "no-cors") {
            if (request.redirect !== "follow") {
              return makeNetworkError(
                'redirect mode cannot be "follow" for "no-cors" request'
              );
            }
            request.responseTainting = "opaque";
            return await schemeFetch(fetchParams);
          }
          if (!urlIsHttpHttpsScheme(requestCurrentURL(request))) {
            return makeNetworkError("URL scheme must be a HTTP(S) scheme");
          }
          request.responseTainting = "cors";
          return await httpFetch(fetchParams);
        })();
      }
      if (recursive) {
        return response;
      }
      if (response.status !== 0 && !response.internalResponse) {
        if (request.responseTainting === "cors") {
        }
        if (request.responseTainting === "basic") {
          response = filterResponse(response, "basic");
        } else if (request.responseTainting === "cors") {
          response = filterResponse(response, "cors");
        } else if (request.responseTainting === "opaque") {
          response = filterResponse(response, "opaque");
        } else {
          assert(false);
        }
      }
      let internalResponse = response.status === 0 ? response : response.internalResponse;
      if (internalResponse.urlList.length === 0) {
        internalResponse.urlList.push(...request.urlList);
      }
      if (!request.timingAllowFailed) {
        response.timingAllowPassed = true;
      }
      if (response.type === "opaque" && internalResponse.status === 206 && internalResponse.rangeRequested && !request.headers.contains("range", true)) {
        response = internalResponse = makeNetworkError();
      }
      if (response.status !== 0 && (request.method === "HEAD" || request.method === "CONNECT" || nullBodyStatus.includes(internalResponse.status))) {
        internalResponse.body = null;
        fetchParams.controller.dump = true;
      }
      if (request.integrity) {
        const processBodyError = (reason) => fetchFinale(fetchParams, makeNetworkError(reason));
        if (request.responseTainting === "opaque" || response.body == null) {
          processBodyError(response.error);
          return;
        }
        const processBody = (bytes) => {
          if (!bytesMatch(bytes, request.integrity)) {
            processBodyError("integrity mismatch");
            return;
          }
          response.body = safelyExtractBody(bytes)[0];
          fetchFinale(fetchParams, response);
        };
        await fullyReadBody(response.body, processBody, processBodyError);
      } else {
        fetchFinale(fetchParams, response);
      }
    }
    function schemeFetch(fetchParams) {
      if (isCancelled(fetchParams) && fetchParams.request.redirectCount === 0) {
        return Promise.resolve(makeAppropriateNetworkError(fetchParams));
      }
      const { request } = fetchParams;
      const { protocol: scheme } = requestCurrentURL(request);
      switch (scheme) {
        case "about:": {
          return Promise.resolve(makeNetworkError("about scheme is not supported"));
        }
        case "blob:": {
          if (!resolveObjectURL) {
            resolveObjectURL = require_node_buffer().resolveObjectURL;
          }
          const blobURLEntry = requestCurrentURL(request);
          if (blobURLEntry.search.length !== 0) {
            return Promise.resolve(makeNetworkError("NetworkError when attempting to fetch resource."));
          }
          const blob = resolveObjectURL(blobURLEntry.toString());
          if (request.method !== "GET" || !isBlobLike(blob)) {
            return Promise.resolve(makeNetworkError("invalid method"));
          }
          const response = makeResponse();
          const fullLength = blob.size;
          const serializedFullLength = isomorphicEncode(`${fullLength}`);
          const type = blob.type;
          if (!request.headersList.contains("range", true)) {
            const bodyWithType = extractBody(blob);
            response.statusText = "OK";
            response.body = bodyWithType[0];
            response.headersList.set("content-length", serializedFullLength, true);
            response.headersList.set("content-type", type, true);
          } else {
            response.rangeRequested = true;
            const rangeHeader = request.headersList.get("range", true);
            const rangeValue = simpleRangeHeaderValue(rangeHeader, true);
            if (rangeValue === "failure") {
              return Promise.resolve(makeNetworkError("failed to fetch the data URL"));
            }
            let { rangeStartValue: rangeStart, rangeEndValue: rangeEnd } = rangeValue;
            if (rangeStart === null) {
              rangeStart = fullLength - rangeEnd;
              rangeEnd = rangeStart + rangeEnd - 1;
            } else {
              if (rangeStart >= fullLength) {
                return Promise.resolve(makeNetworkError("Range start is greater than the blob's size."));
              }
              if (rangeEnd === null || rangeEnd >= fullLength) {
                rangeEnd = fullLength - 1;
              }
            }
            const slicedBlob = blob.slice(rangeStart, rangeEnd, type);
            const slicedBodyWithType = extractBody(slicedBlob);
            response.body = slicedBodyWithType[0];
            const serializedSlicedLength = isomorphicEncode(`${slicedBlob.size}`);
            const contentRange = buildContentRange(rangeStart, rangeEnd, fullLength);
            response.status = 206;
            response.statusText = "Partial Content";
            response.headersList.set("content-length", serializedSlicedLength, true);
            response.headersList.set("content-type", type, true);
            response.headersList.set("content-range", contentRange, true);
          }
          return Promise.resolve(response);
        }
        case "data:": {
          const currentURL = requestCurrentURL(request);
          const dataURLStruct = dataURLProcessor(currentURL);
          if (dataURLStruct === "failure") {
            return Promise.resolve(makeNetworkError("failed to fetch the data URL"));
          }
          const mimeType = serializeAMimeType(dataURLStruct.mimeType);
          return Promise.resolve(makeResponse({
            statusText: "OK",
            headersList: [
              ["content-type", { name: "Content-Type", value: mimeType }]
            ],
            body: safelyExtractBody(dataURLStruct.body)[0]
          }));
        }
        case "file:": {
          return Promise.resolve(makeNetworkError("not implemented... yet..."));
        }
        case "http:":
        case "https:": {
          return httpFetch(fetchParams).catch((err) => makeNetworkError(err));
        }
        default: {
          return Promise.resolve(makeNetworkError("unknown scheme"));
        }
      }
    }
    function finalizeResponse(fetchParams, response) {
      fetchParams.request.done = true;
      if (fetchParams.processResponseDone != null) {
        queueMicrotask(() => fetchParams.processResponseDone(response));
      }
    }
    function fetchFinale(fetchParams, response) {
      let timingInfo = fetchParams.timingInfo;
      const processResponseEndOfBody = () => {
        const unsafeEndTime = Date.now();
        if (fetchParams.request.destination === "document") {
          fetchParams.controller.fullTimingInfo = timingInfo;
        }
        fetchParams.controller.reportTimingSteps = () => {
          if (fetchParams.request.url.protocol !== "https:") {
            return;
          }
          timingInfo.endTime = unsafeEndTime;
          let cacheState = response.cacheState;
          const bodyInfo = response.bodyInfo;
          if (!response.timingAllowPassed) {
            timingInfo = createOpaqueTimingInfo(timingInfo);
            cacheState = "";
          }
          let responseStatus = 0;
          if (fetchParams.request.mode !== "navigator" || !response.hasCrossOriginRedirects) {
            responseStatus = response.status;
            const mimeType = extractMimeType(response.headersList);
            if (mimeType !== "failure") {
              bodyInfo.contentType = minimizeSupportedMimeType(mimeType);
            }
          }
          if (fetchParams.request.initiatorType != null) {
            markResourceTiming(timingInfo, fetchParams.request.url.href, fetchParams.request.initiatorType, globalThis, cacheState, bodyInfo, responseStatus);
          }
        };
        const processResponseEndOfBodyTask = () => {
          fetchParams.request.done = true;
          if (fetchParams.processResponseEndOfBody != null) {
            queueMicrotask(() => fetchParams.processResponseEndOfBody(response));
          }
          if (fetchParams.request.initiatorType != null) {
            fetchParams.controller.reportTimingSteps();
          }
        };
        queueMicrotask(() => processResponseEndOfBodyTask());
      };
      if (fetchParams.processResponse != null) {
        queueMicrotask(() => {
          fetchParams.processResponse(response);
          fetchParams.processResponse = null;
        });
      }
      const internalResponse = response.type === "error" ? response : response.internalResponse ?? response;
      if (internalResponse.body == null) {
        processResponseEndOfBody();
      } else {
        finished(internalResponse.body.stream, () => {
          processResponseEndOfBody();
        });
      }
    }
    async function httpFetch(fetchParams) {
      const request = fetchParams.request;
      let response = null;
      let actualResponse = null;
      const timingInfo = fetchParams.timingInfo;
      if (request.serviceWorkers === "all") {
      }
      if (response === null) {
        if (request.redirect === "follow") {
          request.serviceWorkers = "none";
        }
        actualResponse = response = await httpNetworkOrCacheFetch(fetchParams);
        if (request.responseTainting === "cors" && corsCheck(request, response) === "failure") {
          return makeNetworkError("cors failure");
        }
        if (TAOCheck(request, response) === "failure") {
          request.timingAllowFailed = true;
        }
      }
      if ((request.responseTainting === "opaque" || response.type === "opaque") && crossOriginResourcePolicyCheck(
        request.origin,
        request.client,
        request.destination,
        actualResponse
      ) === "blocked") {
        return makeNetworkError("blocked");
      }
      if (redirectStatusSet.has(actualResponse.status)) {
        if (request.redirect !== "manual") {
          fetchParams.controller.connection.destroy(void 0, false);
        }
        if (request.redirect === "error") {
          response = makeNetworkError("unexpected redirect");
        } else if (request.redirect === "manual") {
          response = actualResponse;
        } else if (request.redirect === "follow") {
          response = await httpRedirectFetch(fetchParams, response);
        } else {
          assert(false);
        }
      }
      response.timingInfo = timingInfo;
      return response;
    }
    function httpRedirectFetch(fetchParams, response) {
      const request = fetchParams.request;
      const actualResponse = response.internalResponse ? response.internalResponse : response;
      let locationURL;
      try {
        locationURL = responseLocationURL(
          actualResponse,
          requestCurrentURL(request).hash
        );
        if (locationURL == null) {
          return response;
        }
      } catch (err) {
        return Promise.resolve(makeNetworkError(err));
      }
      if (!urlIsHttpHttpsScheme(locationURL)) {
        return Promise.resolve(makeNetworkError("URL scheme must be a HTTP(S) scheme"));
      }
      if (request.redirectCount === 20) {
        return Promise.resolve(makeNetworkError("redirect count exceeded"));
      }
      request.redirectCount += 1;
      if (request.mode === "cors" && (locationURL.username || locationURL.password) && !sameOrigin(request, locationURL)) {
        return Promise.resolve(makeNetworkError('cross origin not allowed for request mode "cors"'));
      }
      if (request.responseTainting === "cors" && (locationURL.username || locationURL.password)) {
        return Promise.resolve(makeNetworkError(
          'URL cannot contain credentials for request mode "cors"'
        ));
      }
      if (actualResponse.status !== 303 && request.body != null && request.body.source == null) {
        return Promise.resolve(makeNetworkError());
      }
      if ([301, 302].includes(actualResponse.status) && request.method === "POST" || actualResponse.status === 303 && !GET_OR_HEAD.includes(request.method)) {
        request.method = "GET";
        request.body = null;
        for (const headerName of requestBodyHeader) {
          request.headersList.delete(headerName);
        }
      }
      if (!sameOrigin(requestCurrentURL(request), locationURL)) {
        request.headersList.delete("authorization", true);
        request.headersList.delete("proxy-authorization", true);
        request.headersList.delete("cookie", true);
        request.headersList.delete("host", true);
      }
      if (request.body != null) {
        assert(request.body.source != null);
        request.body = safelyExtractBody(request.body.source)[0];
      }
      const timingInfo = fetchParams.timingInfo;
      timingInfo.redirectEndTime = timingInfo.postRedirectStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);
      if (timingInfo.redirectStartTime === 0) {
        timingInfo.redirectStartTime = timingInfo.startTime;
      }
      request.urlList.push(locationURL);
      setRequestReferrerPolicyOnRedirect(request, actualResponse);
      return mainFetch(fetchParams, true);
    }
    async function httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch = false, isNewConnectionFetch = false) {
      const request = fetchParams.request;
      let httpFetchParams = null;
      let httpRequest = null;
      let response = null;
      const httpCache = null;
      const revalidatingFlag = false;
      if (request.window === "no-window" && request.redirect === "error") {
        httpFetchParams = fetchParams;
        httpRequest = request;
      } else {
        httpRequest = cloneRequest(request);
        httpFetchParams = { ...fetchParams };
        httpFetchParams.request = httpRequest;
      }
      const includeCredentials = request.credentials === "include" || request.credentials === "same-origin" && request.responseTainting === "basic";
      const contentLength = httpRequest.body ? httpRequest.body.length : null;
      let contentLengthHeaderValue = null;
      if (httpRequest.body == null && ["POST", "PUT"].includes(httpRequest.method)) {
        contentLengthHeaderValue = "0";
      }
      if (contentLength != null) {
        contentLengthHeaderValue = isomorphicEncode(`${contentLength}`);
      }
      if (contentLengthHeaderValue != null) {
        httpRequest.headersList.append("content-length", contentLengthHeaderValue, true);
      }
      if (contentLength != null && httpRequest.keepalive) {
      }
      if (httpRequest.referrer instanceof URL) {
        httpRequest.headersList.append("referer", isomorphicEncode(httpRequest.referrer.href), true);
      }
      appendRequestOriginHeader(httpRequest);
      appendFetchMetadata(httpRequest);
      if (!httpRequest.headersList.contains("user-agent", true)) {
        httpRequest.headersList.append("user-agent", defaultUserAgent);
      }
      if (httpRequest.cache === "default" && (httpRequest.headersList.contains("if-modified-since", true) || httpRequest.headersList.contains("if-none-match", true) || httpRequest.headersList.contains("if-unmodified-since", true) || httpRequest.headersList.contains("if-match", true) || httpRequest.headersList.contains("if-range", true))) {
        httpRequest.cache = "no-store";
      }
      if (httpRequest.cache === "no-cache" && !httpRequest.preventNoCacheCacheControlHeaderModification && !httpRequest.headersList.contains("cache-control", true)) {
        httpRequest.headersList.append("cache-control", "max-age=0", true);
      }
      if (httpRequest.cache === "no-store" || httpRequest.cache === "reload") {
        if (!httpRequest.headersList.contains("pragma", true)) {
          httpRequest.headersList.append("pragma", "no-cache", true);
        }
        if (!httpRequest.headersList.contains("cache-control", true)) {
          httpRequest.headersList.append("cache-control", "no-cache", true);
        }
      }
      if (httpRequest.headersList.contains("range", true)) {
        httpRequest.headersList.append("accept-encoding", "identity", true);
      }
      if (!httpRequest.headersList.contains("accept-encoding", true)) {
        if (urlHasHttpsScheme(requestCurrentURL(httpRequest))) {
          httpRequest.headersList.append("accept-encoding", "br, gzip, deflate", true);
        } else {
          httpRequest.headersList.append("accept-encoding", "gzip, deflate", true);
        }
      }
      httpRequest.headersList.delete("host", true);
      if (includeCredentials) {
      }
      if (httpCache == null) {
        httpRequest.cache = "no-store";
      }
      if (httpRequest.cache !== "no-store" && httpRequest.cache !== "reload") {
      }
      if (response == null) {
        if (httpRequest.cache === "only-if-cached") {
          return makeNetworkError("only if cached");
        }
        const forwardResponse = await httpNetworkFetch(
          httpFetchParams,
          includeCredentials,
          isNewConnectionFetch
        );
        if (!safeMethodsSet.has(httpRequest.method) && forwardResponse.status >= 200 && forwardResponse.status <= 399) {
        }
        if (revalidatingFlag && forwardResponse.status === 304) {
        }
        if (response == null) {
          response = forwardResponse;
        }
      }
      response.urlList = [...httpRequest.urlList];
      if (httpRequest.headersList.contains("range", true)) {
        response.rangeRequested = true;
      }
      response.requestIncludesCredentials = includeCredentials;
      if (response.status === 407) {
        if (request.window === "no-window") {
          return makeNetworkError();
        }
        if (isCancelled(fetchParams)) {
          return makeAppropriateNetworkError(fetchParams);
        }
        return makeNetworkError("proxy authentication required");
      }
      if (
        // response’s status is 421
        response.status === 421 && // isNewConnectionFetch is false
        !isNewConnectionFetch && // request’s body is null, or request’s body is non-null and request’s body’s source is non-null
        (request.body == null || request.body.source != null)
      ) {
        if (isCancelled(fetchParams)) {
          return makeAppropriateNetworkError(fetchParams);
        }
        fetchParams.controller.connection.destroy();
        response = await httpNetworkOrCacheFetch(
          fetchParams,
          isAuthenticationFetch,
          true
        );
      }
      if (isAuthenticationFetch) {
      }
      return response;
    }
    async function httpNetworkFetch(fetchParams, includeCredentials = false, forceNewConnection = false) {
      assert(!fetchParams.controller.connection || fetchParams.controller.connection.destroyed);
      fetchParams.controller.connection = {
        abort: null,
        destroyed: false,
        destroy(err, abort = true) {
          var _a;
          if (!this.destroyed) {
            this.destroyed = true;
            if (abort) {
              (_a = this.abort) == null ? void 0 : _a.call(this, err ?? new DOMException("The operation was aborted.", "AbortError"));
            }
          }
        }
      };
      const request = fetchParams.request;
      let response = null;
      const timingInfo = fetchParams.timingInfo;
      const httpCache = null;
      if (httpCache == null) {
        request.cache = "no-store";
      }
      const newConnection = forceNewConnection ? "yes" : "no";
      if (request.mode === "websocket") {
      } else {
      }
      let requestBody = null;
      if (request.body == null && fetchParams.processRequestEndOfBody) {
        queueMicrotask(() => fetchParams.processRequestEndOfBody());
      } else if (request.body != null) {
        const processBodyChunk = async function* (bytes) {
          var _a;
          if (isCancelled(fetchParams)) {
            return;
          }
          yield bytes;
          (_a = fetchParams.processRequestBodyChunkLength) == null ? void 0 : _a.call(fetchParams, bytes.byteLength);
        };
        const processEndOfBody = () => {
          if (isCancelled(fetchParams)) {
            return;
          }
          if (fetchParams.processRequestEndOfBody) {
            fetchParams.processRequestEndOfBody();
          }
        };
        const processBodyError = (e) => {
          if (isCancelled(fetchParams)) {
            return;
          }
          if (e.name === "AbortError") {
            fetchParams.controller.abort();
          } else {
            fetchParams.controller.terminate(e);
          }
        };
        requestBody = async function* () {
          try {
            for await (const bytes of request.body.stream) {
              yield* processBodyChunk(bytes);
            }
            processEndOfBody();
          } catch (err) {
            processBodyError(err);
          }
        }();
      }
      try {
        const { body, status, statusText, headersList, socket } = await dispatch({ body: requestBody });
        if (socket) {
          response = makeResponse({ status, statusText, headersList, socket });
        } else {
          const iterator = body[Symbol.asyncIterator]();
          fetchParams.controller.next = () => iterator.next();
          response = makeResponse({ status, statusText, headersList });
        }
      } catch (err) {
        if (err.name === "AbortError") {
          fetchParams.controller.connection.destroy();
          return makeAppropriateNetworkError(fetchParams, err);
        }
        return makeNetworkError(err);
      }
      const pullAlgorithm = async () => {
        await fetchParams.controller.resume();
      };
      const cancelAlgorithm = (reason) => {
        if (!isCancelled(fetchParams)) {
          fetchParams.controller.abort(reason);
        }
      };
      const stream = new ReadableStream(
        {
          async start(controller) {
            fetchParams.controller.controller = controller;
          },
          async pull(controller) {
            await pullAlgorithm(controller);
          },
          async cancel(reason) {
            await cancelAlgorithm(reason);
          },
          type: "bytes"
        }
      );
      response.body = { stream, source: null, length: null };
      fetchParams.controller.onAborted = onAborted;
      fetchParams.controller.on("terminated", onAborted);
      fetchParams.controller.resume = async () => {
        while (true) {
          let bytes;
          let isFailure;
          try {
            const { done, value } = await fetchParams.controller.next();
            if (isAborted(fetchParams)) {
              break;
            }
            bytes = done ? void 0 : value;
          } catch (err) {
            if (fetchParams.controller.ended && !timingInfo.encodedBodySize) {
              bytes = void 0;
            } else {
              bytes = err;
              isFailure = true;
            }
          }
          if (bytes === void 0) {
            readableStreamClose(fetchParams.controller.controller);
            finalizeResponse(fetchParams, response);
            return;
          }
          timingInfo.decodedBodySize += (bytes == null ? void 0 : bytes.byteLength) ?? 0;
          if (isFailure) {
            fetchParams.controller.terminate(bytes);
            return;
          }
          const buffer = new Uint8Array(bytes);
          if (buffer.byteLength) {
            fetchParams.controller.controller.enqueue(buffer);
          }
          if (isErrored(stream)) {
            fetchParams.controller.terminate();
            return;
          }
          if (fetchParams.controller.controller.desiredSize <= 0) {
            return;
          }
        }
      };
      function onAborted(reason) {
        if (isAborted(fetchParams)) {
          response.aborted = true;
          if (isReadable(stream)) {
            fetchParams.controller.controller.error(
              fetchParams.controller.serializedAbortReason
            );
          }
        } else {
          if (isReadable(stream)) {
            fetchParams.controller.controller.error(new TypeError("terminated", {
              cause: isErrorLike(reason) ? reason : void 0
            }));
          }
        }
        fetchParams.controller.connection.destroy();
      }
      return response;
      function dispatch({ body }) {
        const url = requestCurrentURL(request);
        const agent = fetchParams.controller.dispatcher;
        return new Promise((resolve, reject) => agent.dispatch(
          {
            path: url.pathname + url.search,
            origin: url.origin,
            method: request.method,
            body: agent.isMockActive ? request.body && (request.body.source || request.body.stream) : body,
            headers: request.headersList.entries,
            maxRedirections: 0,
            upgrade: request.mode === "websocket" ? "websocket" : void 0
          },
          {
            body: null,
            abort: null,
            onConnect(abort) {
              const { connection } = fetchParams.controller;
              timingInfo.finalConnectionTimingInfo = clampAndCoarsenConnectionTimingInfo(void 0, timingInfo.postRedirectStartTime, fetchParams.crossOriginIsolatedCapability);
              if (connection.destroyed) {
                abort(new DOMException("The operation was aborted.", "AbortError"));
              } else {
                fetchParams.controller.on("terminated", abort);
                this.abort = connection.abort = abort;
              }
              timingInfo.finalNetworkRequestStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);
            },
            onResponseStarted() {
              timingInfo.finalNetworkResponseStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);
            },
            onHeaders(status, rawHeaders, resume, statusText) {
              if (status < 200) {
                return;
              }
              let codings = [];
              let location = "";
              const headersList = new HeadersList();
              for (let i = 0; i < rawHeaders.length; i += 2) {
                headersList.append(bufferToLowerCasedHeaderName(rawHeaders[i]), rawHeaders[i + 1].toString("latin1"), true);
              }
              const contentEncoding = headersList.get("content-encoding", true);
              if (contentEncoding) {
                codings = contentEncoding.toLowerCase().split(",").map((x) => x.trim());
              }
              location = headersList.get("location", true);
              this.body = new Readable({ read: resume });
              const decoders = [];
              const willFollow = location && request.redirect === "follow" && redirectStatusSet.has(status);
              if (codings.length !== 0 && request.method !== "HEAD" && request.method !== "CONNECT" && !nullBodyStatus.includes(status) && !willFollow) {
                for (let i = codings.length - 1; i >= 0; --i) {
                  const coding = codings[i];
                  if (coding === "x-gzip" || coding === "gzip") {
                    decoders.push(zlib.createGunzip({
                      // Be less strict when decoding compressed responses, since sometimes
                      // servers send slightly invalid responses that are still accepted
                      // by common browsers.
                      // Always using Z_SYNC_FLUSH is what cURL does.
                      flush: zlib.constants.Z_SYNC_FLUSH,
                      finishFlush: zlib.constants.Z_SYNC_FLUSH
                    }));
                  } else if (coding === "deflate") {
                    decoders.push(createInflate({
                      flush: zlib.constants.Z_SYNC_FLUSH,
                      finishFlush: zlib.constants.Z_SYNC_FLUSH
                    }));
                  } else if (coding === "br") {
                    decoders.push(zlib.createBrotliDecompress({
                      flush: zlib.constants.BROTLI_OPERATION_FLUSH,
                      finishFlush: zlib.constants.BROTLI_OPERATION_FLUSH
                    }));
                  } else {
                    decoders.length = 0;
                    break;
                  }
                }
              }
              const onError = this.onError.bind(this);
              resolve({
                status,
                statusText,
                headersList,
                body: decoders.length ? pipeline(this.body, ...decoders, (err) => {
                  if (err) {
                    this.onError(err);
                  }
                }).on("error", onError) : this.body.on("error", onError)
              });
              return true;
            },
            onData(chunk) {
              if (fetchParams.controller.dump) {
                return;
              }
              const bytes = chunk;
              timingInfo.encodedBodySize += bytes.byteLength;
              return this.body.push(bytes);
            },
            onComplete() {
              if (this.abort) {
                fetchParams.controller.off("terminated", this.abort);
              }
              if (fetchParams.controller.onAborted) {
                fetchParams.controller.off("terminated", fetchParams.controller.onAborted);
              }
              fetchParams.controller.ended = true;
              this.body.push(null);
            },
            onError(error2) {
              var _a;
              if (this.abort) {
                fetchParams.controller.off("terminated", this.abort);
              }
              (_a = this.body) == null ? void 0 : _a.destroy(error2);
              fetchParams.controller.terminate(error2);
              reject(error2);
            },
            onUpgrade(status, rawHeaders, socket) {
              if (status !== 101) {
                return;
              }
              const headersList = new HeadersList();
              for (let i = 0; i < rawHeaders.length; i += 2) {
                headersList.append(bufferToLowerCasedHeaderName(rawHeaders[i]), rawHeaders[i + 1].toString("latin1"), true);
              }
              resolve({
                status,
                statusText: STATUS_CODES[status],
                headersList,
                socket
              });
              return true;
            }
          }
        ));
      }
    }
    module2.exports = {
      fetch,
      Fetch,
      fetching,
      finalizeAndReportTiming
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/fileapi/symbols.js
var require_symbols3 = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/fileapi/symbols.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      kState: Symbol("FileReader state"),
      kResult: Symbol("FileReader result"),
      kError: Symbol("FileReader error"),
      kLastProgressEventFired: Symbol("FileReader last progress event fired timestamp"),
      kEvents: Symbol("FileReader events"),
      kAborted: Symbol("FileReader aborted")
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/fileapi/progressevent.js
var require_progressevent = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/fileapi/progressevent.js"(exports2, module2) {
    "use strict";
    var { webidl } = require_webidl();
    var kState = Symbol("ProgressEvent state");
    var ProgressEvent = class _ProgressEvent extends Event {
      constructor(type, eventInitDict = {}) {
        type = webidl.converters.DOMString(type, "ProgressEvent constructor", "type");
        eventInitDict = webidl.converters.ProgressEventInit(eventInitDict ?? {});
        super(type, eventInitDict);
        this[kState] = {
          lengthComputable: eventInitDict.lengthComputable,
          loaded: eventInitDict.loaded,
          total: eventInitDict.total
        };
      }
      get lengthComputable() {
        webidl.brandCheck(this, _ProgressEvent);
        return this[kState].lengthComputable;
      }
      get loaded() {
        webidl.brandCheck(this, _ProgressEvent);
        return this[kState].loaded;
      }
      get total() {
        webidl.brandCheck(this, _ProgressEvent);
        return this[kState].total;
      }
    };
    webidl.converters.ProgressEventInit = webidl.dictionaryConverter([
      {
        key: "lengthComputable",
        converter: webidl.converters.boolean,
        defaultValue: () => false
      },
      {
        key: "loaded",
        converter: webidl.converters["unsigned long long"],
        defaultValue: () => 0
      },
      {
        key: "total",
        converter: webidl.converters["unsigned long long"],
        defaultValue: () => 0
      },
      {
        key: "bubbles",
        converter: webidl.converters.boolean,
        defaultValue: () => false
      },
      {
        key: "cancelable",
        converter: webidl.converters.boolean,
        defaultValue: () => false
      },
      {
        key: "composed",
        converter: webidl.converters.boolean,
        defaultValue: () => false
      }
    ]);
    module2.exports = {
      ProgressEvent
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/fileapi/encoding.js
var require_encoding = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/fileapi/encoding.js"(exports2, module2) {
    "use strict";
    function getEncoding(label) {
      if (!label) {
        return "failure";
      }
      switch (label.trim().toLowerCase()) {
        case "unicode-1-1-utf-8":
        case "unicode11utf8":
        case "unicode20utf8":
        case "utf-8":
        case "utf8":
        case "x-unicode20utf8":
          return "UTF-8";
        case "866":
        case "cp866":
        case "csibm866":
        case "ibm866":
          return "IBM866";
        case "csisolatin2":
        case "iso-8859-2":
        case "iso-ir-101":
        case "iso8859-2":
        case "iso88592":
        case "iso_8859-2":
        case "iso_8859-2:1987":
        case "l2":
        case "latin2":
          return "ISO-8859-2";
        case "csisolatin3":
        case "iso-8859-3":
        case "iso-ir-109":
        case "iso8859-3":
        case "iso88593":
        case "iso_8859-3":
        case "iso_8859-3:1988":
        case "l3":
        case "latin3":
          return "ISO-8859-3";
        case "csisolatin4":
        case "iso-8859-4":
        case "iso-ir-110":
        case "iso8859-4":
        case "iso88594":
        case "iso_8859-4":
        case "iso_8859-4:1988":
        case "l4":
        case "latin4":
          return "ISO-8859-4";
        case "csisolatincyrillic":
        case "cyrillic":
        case "iso-8859-5":
        case "iso-ir-144":
        case "iso8859-5":
        case "iso88595":
        case "iso_8859-5":
        case "iso_8859-5:1988":
          return "ISO-8859-5";
        case "arabic":
        case "asmo-708":
        case "csiso88596e":
        case "csiso88596i":
        case "csisolatinarabic":
        case "ecma-114":
        case "iso-8859-6":
        case "iso-8859-6-e":
        case "iso-8859-6-i":
        case "iso-ir-127":
        case "iso8859-6":
        case "iso88596":
        case "iso_8859-6":
        case "iso_8859-6:1987":
          return "ISO-8859-6";
        case "csisolatingreek":
        case "ecma-118":
        case "elot_928":
        case "greek":
        case "greek8":
        case "iso-8859-7":
        case "iso-ir-126":
        case "iso8859-7":
        case "iso88597":
        case "iso_8859-7":
        case "iso_8859-7:1987":
        case "sun_eu_greek":
          return "ISO-8859-7";
        case "csiso88598e":
        case "csisolatinhebrew":
        case "hebrew":
        case "iso-8859-8":
        case "iso-8859-8-e":
        case "iso-ir-138":
        case "iso8859-8":
        case "iso88598":
        case "iso_8859-8":
        case "iso_8859-8:1988":
        case "visual":
          return "ISO-8859-8";
        case "csiso88598i":
        case "iso-8859-8-i":
        case "logical":
          return "ISO-8859-8-I";
        case "csisolatin6":
        case "iso-8859-10":
        case "iso-ir-157":
        case "iso8859-10":
        case "iso885910":
        case "l6":
        case "latin6":
          return "ISO-8859-10";
        case "iso-8859-13":
        case "iso8859-13":
        case "iso885913":
          return "ISO-8859-13";
        case "iso-8859-14":
        case "iso8859-14":
        case "iso885914":
          return "ISO-8859-14";
        case "csisolatin9":
        case "iso-8859-15":
        case "iso8859-15":
        case "iso885915":
        case "iso_8859-15":
        case "l9":
          return "ISO-8859-15";
        case "iso-8859-16":
          return "ISO-8859-16";
        case "cskoi8r":
        case "koi":
        case "koi8":
        case "koi8-r":
        case "koi8_r":
          return "KOI8-R";
        case "koi8-ru":
        case "koi8-u":
          return "KOI8-U";
        case "csmacintosh":
        case "mac":
        case "macintosh":
        case "x-mac-roman":
          return "macintosh";
        case "iso-8859-11":
        case "iso8859-11":
        case "iso885911":
        case "tis-620":
        case "windows-874":
          return "windows-874";
        case "cp1250":
        case "windows-1250":
        case "x-cp1250":
          return "windows-1250";
        case "cp1251":
        case "windows-1251":
        case "x-cp1251":
          return "windows-1251";
        case "ansi_x3.4-1968":
        case "ascii":
        case "cp1252":
        case "cp819":
        case "csisolatin1":
        case "ibm819":
        case "iso-8859-1":
        case "iso-ir-100":
        case "iso8859-1":
        case "iso88591":
        case "iso_8859-1":
        case "iso_8859-1:1987":
        case "l1":
        case "latin1":
        case "us-ascii":
        case "windows-1252":
        case "x-cp1252":
          return "windows-1252";
        case "cp1253":
        case "windows-1253":
        case "x-cp1253":
          return "windows-1253";
        case "cp1254":
        case "csisolatin5":
        case "iso-8859-9":
        case "iso-ir-148":
        case "iso8859-9":
        case "iso88599":
        case "iso_8859-9":
        case "iso_8859-9:1989":
        case "l5":
        case "latin5":
        case "windows-1254":
        case "x-cp1254":
          return "windows-1254";
        case "cp1255":
        case "windows-1255":
        case "x-cp1255":
          return "windows-1255";
        case "cp1256":
        case "windows-1256":
        case "x-cp1256":
          return "windows-1256";
        case "cp1257":
        case "windows-1257":
        case "x-cp1257":
          return "windows-1257";
        case "cp1258":
        case "windows-1258":
        case "x-cp1258":
          return "windows-1258";
        case "x-mac-cyrillic":
        case "x-mac-ukrainian":
          return "x-mac-cyrillic";
        case "chinese":
        case "csgb2312":
        case "csiso58gb231280":
        case "gb2312":
        case "gb_2312":
        case "gb_2312-80":
        case "gbk":
        case "iso-ir-58":
        case "x-gbk":
          return "GBK";
        case "gb18030":
          return "gb18030";
        case "big5":
        case "big5-hkscs":
        case "cn-big5":
        case "csbig5":
        case "x-x-big5":
          return "Big5";
        case "cseucpkdfmtjapanese":
        case "euc-jp":
        case "x-euc-jp":
          return "EUC-JP";
        case "csiso2022jp":
        case "iso-2022-jp":
          return "ISO-2022-JP";
        case "csshiftjis":
        case "ms932":
        case "ms_kanji":
        case "shift-jis":
        case "shift_jis":
        case "sjis":
        case "windows-31j":
        case "x-sjis":
          return "Shift_JIS";
        case "cseuckr":
        case "csksc56011987":
        case "euc-kr":
        case "iso-ir-149":
        case "korean":
        case "ks_c_5601-1987":
        case "ks_c_5601-1989":
        case "ksc5601":
        case "ksc_5601":
        case "windows-949":
          return "EUC-KR";
        case "csiso2022kr":
        case "hz-gb-2312":
        case "iso-2022-cn":
        case "iso-2022-cn-ext":
        case "iso-2022-kr":
        case "replacement":
          return "replacement";
        case "unicodefffe":
        case "utf-16be":
          return "UTF-16BE";
        case "csunicode":
        case "iso-10646-ucs-2":
        case "ucs-2":
        case "unicode":
        case "unicodefeff":
        case "utf-16":
        case "utf-16le":
          return "UTF-16LE";
        case "x-user-defined":
          return "x-user-defined";
        default:
          return "failure";
      }
    }
    module2.exports = {
      getEncoding
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/fileapi/util.js
var require_util5 = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/fileapi/util.js"(exports2, module2) {
    "use strict";
    var {
      kState,
      kError,
      kResult,
      kAborted,
      kLastProgressEventFired
    } = require_symbols3();
    var { ProgressEvent } = require_progressevent();
    var { getEncoding } = require_encoding();
    var { serializeAMimeType, parseMIMEType } = require_data_url();
    var { types } = require_node_util();
    var { StringDecoder } = require_string_decoder();
    var { btoa } = require_node_buffer();
    var staticPropertyDescriptors = {
      enumerable: true,
      writable: false,
      configurable: false
    };
    function readOperation(fr, blob, type, encodingName) {
      if (fr[kState] === "loading") {
        throw new DOMException("Invalid state", "InvalidStateError");
      }
      fr[kState] = "loading";
      fr[kResult] = null;
      fr[kError] = null;
      const stream = blob.stream();
      const reader = stream.getReader();
      const bytes = [];
      let chunkPromise = reader.read();
      let isFirstChunk = true;
      (async () => {
        while (!fr[kAborted]) {
          try {
            const { done, value } = await chunkPromise;
            if (isFirstChunk && !fr[kAborted]) {
              queueMicrotask(() => {
                fireAProgressEvent("loadstart", fr);
              });
            }
            isFirstChunk = false;
            if (!done && types.isUint8Array(value)) {
              bytes.push(value);
              if ((fr[kLastProgressEventFired] === void 0 || Date.now() - fr[kLastProgressEventFired] >= 50) && !fr[kAborted]) {
                fr[kLastProgressEventFired] = Date.now();
                queueMicrotask(() => {
                  fireAProgressEvent("progress", fr);
                });
              }
              chunkPromise = reader.read();
            } else if (done) {
              queueMicrotask(() => {
                fr[kState] = "done";
                try {
                  const result = packageData(bytes, type, blob.type, encodingName);
                  if (fr[kAborted]) {
                    return;
                  }
                  fr[kResult] = result;
                  fireAProgressEvent("load", fr);
                } catch (error2) {
                  fr[kError] = error2;
                  fireAProgressEvent("error", fr);
                }
                if (fr[kState] !== "loading") {
                  fireAProgressEvent("loadend", fr);
                }
              });
              break;
            }
          } catch (error2) {
            if (fr[kAborted]) {
              return;
            }
            queueMicrotask(() => {
              fr[kState] = "done";
              fr[kError] = error2;
              fireAProgressEvent("error", fr);
              if (fr[kState] !== "loading") {
                fireAProgressEvent("loadend", fr);
              }
            });
            break;
          }
        }
      })();
    }
    function fireAProgressEvent(e, reader) {
      const event = new ProgressEvent(e, {
        bubbles: false,
        cancelable: false
      });
      reader.dispatchEvent(event);
    }
    function packageData(bytes, type, mimeType, encodingName) {
      switch (type) {
        case "DataURL": {
          let dataURL = "data:";
          const parsed = parseMIMEType(mimeType || "application/octet-stream");
          if (parsed !== "failure") {
            dataURL += serializeAMimeType(parsed);
          }
          dataURL += ";base64,";
          const decoder = new StringDecoder("latin1");
          for (const chunk of bytes) {
            dataURL += btoa(decoder.write(chunk));
          }
          dataURL += btoa(decoder.end());
          return dataURL;
        }
        case "Text": {
          let encoding = "failure";
          if (encodingName) {
            encoding = getEncoding(encodingName);
          }
          if (encoding === "failure" && mimeType) {
            const type2 = parseMIMEType(mimeType);
            if (type2 !== "failure") {
              encoding = getEncoding(type2.parameters.get("charset"));
            }
          }
          if (encoding === "failure") {
            encoding = "UTF-8";
          }
          return decode2(bytes, encoding);
        }
        case "ArrayBuffer": {
          const sequence = combineByteSequences(bytes);
          return sequence.buffer;
        }
        case "BinaryString": {
          let binaryString = "";
          const decoder = new StringDecoder("latin1");
          for (const chunk of bytes) {
            binaryString += decoder.write(chunk);
          }
          binaryString += decoder.end();
          return binaryString;
        }
      }
    }
    function decode2(ioQueue, encoding) {
      const bytes = combineByteSequences(ioQueue);
      const BOMEncoding = BOMSniffing(bytes);
      let slice = 0;
      if (BOMEncoding !== null) {
        encoding = BOMEncoding;
        slice = BOMEncoding === "UTF-8" ? 3 : 2;
      }
      const sliced = bytes.slice(slice);
      return new TextDecoder(encoding).decode(sliced);
    }
    function BOMSniffing(ioQueue) {
      const [a, b, c] = ioQueue;
      if (a === 239 && b === 187 && c === 191) {
        return "UTF-8";
      } else if (a === 254 && b === 255) {
        return "UTF-16BE";
      } else if (a === 255 && b === 254) {
        return "UTF-16LE";
      }
      return null;
    }
    function combineByteSequences(sequences) {
      const size = sequences.reduce((a, b) => {
        return a + b.byteLength;
      }, 0);
      let offset = 0;
      return sequences.reduce((a, b) => {
        a.set(b, offset);
        offset += b.byteLength;
        return a;
      }, new Uint8Array(size));
    }
    module2.exports = {
      staticPropertyDescriptors,
      readOperation,
      fireAProgressEvent
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/fileapi/filereader.js
var require_filereader = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/fileapi/filereader.js"(exports2, module2) {
    "use strict";
    var {
      staticPropertyDescriptors,
      readOperation,
      fireAProgressEvent
    } = require_util5();
    var {
      kState,
      kError,
      kResult,
      kEvents,
      kAborted
    } = require_symbols3();
    var { webidl } = require_webidl();
    var { kEnumerableProperty } = require_util2();
    var FileReader = class _FileReader extends EventTarget {
      constructor() {
        super();
        this[kState] = "empty";
        this[kResult] = null;
        this[kError] = null;
        this[kEvents] = {
          loadend: null,
          error: null,
          abort: null,
          load: null,
          progress: null,
          loadstart: null
        };
      }
      /**
       * @see https://w3c.github.io/FileAPI/#dfn-readAsArrayBuffer
       * @param {import('buffer').Blob} blob
       */
      readAsArrayBuffer(blob) {
        webidl.brandCheck(this, _FileReader);
        webidl.argumentLengthCheck(arguments, 1, "FileReader.readAsArrayBuffer");
        blob = webidl.converters.Blob(blob, { strict: false });
        readOperation(this, blob, "ArrayBuffer");
      }
      /**
       * @see https://w3c.github.io/FileAPI/#readAsBinaryString
       * @param {import('buffer').Blob} blob
       */
      readAsBinaryString(blob) {
        webidl.brandCheck(this, _FileReader);
        webidl.argumentLengthCheck(arguments, 1, "FileReader.readAsBinaryString");
        blob = webidl.converters.Blob(blob, { strict: false });
        readOperation(this, blob, "BinaryString");
      }
      /**
       * @see https://w3c.github.io/FileAPI/#readAsDataText
       * @param {import('buffer').Blob} blob
       * @param {string?} encoding
       */
      readAsText(blob, encoding = void 0) {
        webidl.brandCheck(this, _FileReader);
        webidl.argumentLengthCheck(arguments, 1, "FileReader.readAsText");
        blob = webidl.converters.Blob(blob, { strict: false });
        if (encoding !== void 0) {
          encoding = webidl.converters.DOMString(encoding, "FileReader.readAsText", "encoding");
        }
        readOperation(this, blob, "Text", encoding);
      }
      /**
       * @see https://w3c.github.io/FileAPI/#dfn-readAsDataURL
       * @param {import('buffer').Blob} blob
       */
      readAsDataURL(blob) {
        webidl.brandCheck(this, _FileReader);
        webidl.argumentLengthCheck(arguments, 1, "FileReader.readAsDataURL");
        blob = webidl.converters.Blob(blob, { strict: false });
        readOperation(this, blob, "DataURL");
      }
      /**
       * @see https://w3c.github.io/FileAPI/#dfn-abort
       */
      abort() {
        if (this[kState] === "empty" || this[kState] === "done") {
          this[kResult] = null;
          return;
        }
        if (this[kState] === "loading") {
          this[kState] = "done";
          this[kResult] = null;
        }
        this[kAborted] = true;
        fireAProgressEvent("abort", this);
        if (this[kState] !== "loading") {
          fireAProgressEvent("loadend", this);
        }
      }
      /**
       * @see https://w3c.github.io/FileAPI/#dom-filereader-readystate
       */
      get readyState() {
        webidl.brandCheck(this, _FileReader);
        switch (this[kState]) {
          case "empty":
            return this.EMPTY;
          case "loading":
            return this.LOADING;
          case "done":
            return this.DONE;
        }
      }
      /**
       * @see https://w3c.github.io/FileAPI/#dom-filereader-result
       */
      get result() {
        webidl.brandCheck(this, _FileReader);
        return this[kResult];
      }
      /**
       * @see https://w3c.github.io/FileAPI/#dom-filereader-error
       */
      get error() {
        webidl.brandCheck(this, _FileReader);
        return this[kError];
      }
      get onloadend() {
        webidl.brandCheck(this, _FileReader);
        return this[kEvents].loadend;
      }
      set onloadend(fn) {
        webidl.brandCheck(this, _FileReader);
        if (this[kEvents].loadend) {
          this.removeEventListener("loadend", this[kEvents].loadend);
        }
        if (typeof fn === "function") {
          this[kEvents].loadend = fn;
          this.addEventListener("loadend", fn);
        } else {
          this[kEvents].loadend = null;
        }
      }
      get onerror() {
        webidl.brandCheck(this, _FileReader);
        return this[kEvents].error;
      }
      set onerror(fn) {
        webidl.brandCheck(this, _FileReader);
        if (this[kEvents].error) {
          this.removeEventListener("error", this[kEvents].error);
        }
        if (typeof fn === "function") {
          this[kEvents].error = fn;
          this.addEventListener("error", fn);
        } else {
          this[kEvents].error = null;
        }
      }
      get onloadstart() {
        webidl.brandCheck(this, _FileReader);
        return this[kEvents].loadstart;
      }
      set onloadstart(fn) {
        webidl.brandCheck(this, _FileReader);
        if (this[kEvents].loadstart) {
          this.removeEventListener("loadstart", this[kEvents].loadstart);
        }
        if (typeof fn === "function") {
          this[kEvents].loadstart = fn;
          this.addEventListener("loadstart", fn);
        } else {
          this[kEvents].loadstart = null;
        }
      }
      get onprogress() {
        webidl.brandCheck(this, _FileReader);
        return this[kEvents].progress;
      }
      set onprogress(fn) {
        webidl.brandCheck(this, _FileReader);
        if (this[kEvents].progress) {
          this.removeEventListener("progress", this[kEvents].progress);
        }
        if (typeof fn === "function") {
          this[kEvents].progress = fn;
          this.addEventListener("progress", fn);
        } else {
          this[kEvents].progress = null;
        }
      }
      get onload() {
        webidl.brandCheck(this, _FileReader);
        return this[kEvents].load;
      }
      set onload(fn) {
        webidl.brandCheck(this, _FileReader);
        if (this[kEvents].load) {
          this.removeEventListener("load", this[kEvents].load);
        }
        if (typeof fn === "function") {
          this[kEvents].load = fn;
          this.addEventListener("load", fn);
        } else {
          this[kEvents].load = null;
        }
      }
      get onabort() {
        webidl.brandCheck(this, _FileReader);
        return this[kEvents].abort;
      }
      set onabort(fn) {
        webidl.brandCheck(this, _FileReader);
        if (this[kEvents].abort) {
          this.removeEventListener("abort", this[kEvents].abort);
        }
        if (typeof fn === "function") {
          this[kEvents].abort = fn;
          this.addEventListener("abort", fn);
        } else {
          this[kEvents].abort = null;
        }
      }
    };
    FileReader.EMPTY = FileReader.prototype.EMPTY = 0;
    FileReader.LOADING = FileReader.prototype.LOADING = 1;
    FileReader.DONE = FileReader.prototype.DONE = 2;
    Object.defineProperties(FileReader.prototype, {
      EMPTY: staticPropertyDescriptors,
      LOADING: staticPropertyDescriptors,
      DONE: staticPropertyDescriptors,
      readAsArrayBuffer: kEnumerableProperty,
      readAsBinaryString: kEnumerableProperty,
      readAsText: kEnumerableProperty,
      readAsDataURL: kEnumerableProperty,
      abort: kEnumerableProperty,
      readyState: kEnumerableProperty,
      result: kEnumerableProperty,
      error: kEnumerableProperty,
      onloadstart: kEnumerableProperty,
      onprogress: kEnumerableProperty,
      onload: kEnumerableProperty,
      onabort: kEnumerableProperty,
      onerror: kEnumerableProperty,
      onloadend: kEnumerableProperty,
      [Symbol.toStringTag]: {
        value: "FileReader",
        writable: false,
        enumerable: false,
        configurable: true
      }
    });
    Object.defineProperties(FileReader, {
      EMPTY: staticPropertyDescriptors,
      LOADING: staticPropertyDescriptors,
      DONE: staticPropertyDescriptors
    });
    module2.exports = {
      FileReader
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/cache/symbols.js
var require_symbols4 = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/cache/symbols.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      kConstruct: require_symbols().kConstruct
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/cache/util.js
var require_util6 = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/cache/util.js"(exports2, module2) {
    "use strict";
    var assert = require_node_assert();
    var { URLSerializer } = require_data_url();
    var { isValidHeaderName } = require_util3();
    function urlEquals(A, B, excludeFragment = false) {
      const serializedA = URLSerializer(A, excludeFragment);
      const serializedB = URLSerializer(B, excludeFragment);
      return serializedA === serializedB;
    }
    function getFieldValues(header) {
      assert(header !== null);
      const values = [];
      for (let value of header.split(",")) {
        value = value.trim();
        if (isValidHeaderName(value)) {
          values.push(value);
        }
      }
      return values;
    }
    module2.exports = {
      urlEquals,
      getFieldValues
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/cache/cache.js
var require_cache = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/cache/cache.js"(exports2, module2) {
    "use strict";
    var { kConstruct } = require_symbols4();
    var { urlEquals, getFieldValues } = require_util6();
    var { kEnumerableProperty, isDisturbed } = require_util2();
    var { webidl } = require_webidl();
    var { Response, cloneResponse, fromInnerResponse } = require_response();
    var { Request, fromInnerRequest } = require_request2();
    var { kState } = require_symbols2();
    var { fetching } = require_fetch();
    var { urlIsHttpHttpsScheme, createDeferredPromise, readAllBytes } = require_util3();
    var assert = require_node_assert();
    var _relevantRequestResponseList, _Cache_instances, batchCacheOperations_fn, queryCache_fn, requestMatchesCachedItem_fn, internalMatchAll_fn;
    var _Cache = class _Cache {
      constructor() {
        __privateAdd(this, _Cache_instances);
        /**
         * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-request-response-list
         * @type {requestResponseList}
         */
        __privateAdd(this, _relevantRequestResponseList);
        if (arguments[0] !== kConstruct) {
          webidl.illegalConstructor();
        }
        webidl.util.markAsUncloneable(this);
        __privateSet(this, _relevantRequestResponseList, arguments[1]);
      }
      async match(request, options = {}) {
        webidl.brandCheck(this, _Cache);
        const prefix = "Cache.match";
        webidl.argumentLengthCheck(arguments, 1, prefix);
        request = webidl.converters.RequestInfo(request, prefix, "request");
        options = webidl.converters.CacheQueryOptions(options, prefix, "options");
        const p = __privateMethod(this, _Cache_instances, internalMatchAll_fn).call(this, request, options, 1);
        if (p.length === 0) {
          return;
        }
        return p[0];
      }
      async matchAll(request = void 0, options = {}) {
        webidl.brandCheck(this, _Cache);
        const prefix = "Cache.matchAll";
        if (request !== void 0) request = webidl.converters.RequestInfo(request, prefix, "request");
        options = webidl.converters.CacheQueryOptions(options, prefix, "options");
        return __privateMethod(this, _Cache_instances, internalMatchAll_fn).call(this, request, options);
      }
      async add(request) {
        webidl.brandCheck(this, _Cache);
        const prefix = "Cache.add";
        webidl.argumentLengthCheck(arguments, 1, prefix);
        request = webidl.converters.RequestInfo(request, prefix, "request");
        const requests = [request];
        const responseArrayPromise = this.addAll(requests);
        return await responseArrayPromise;
      }
      async addAll(requests) {
        webidl.brandCheck(this, _Cache);
        const prefix = "Cache.addAll";
        webidl.argumentLengthCheck(arguments, 1, prefix);
        const responsePromises = [];
        const requestList = [];
        for (let request of requests) {
          if (request === void 0) {
            throw webidl.errors.conversionFailed({
              prefix,
              argument: "Argument 1",
              types: ["undefined is not allowed"]
            });
          }
          request = webidl.converters.RequestInfo(request);
          if (typeof request === "string") {
            continue;
          }
          const r = request[kState];
          if (!urlIsHttpHttpsScheme(r.url) || r.method !== "GET") {
            throw webidl.errors.exception({
              header: prefix,
              message: "Expected http/s scheme when method is not GET."
            });
          }
        }
        const fetchControllers = [];
        for (const request of requests) {
          const r = new Request(request)[kState];
          if (!urlIsHttpHttpsScheme(r.url)) {
            throw webidl.errors.exception({
              header: prefix,
              message: "Expected http/s scheme."
            });
          }
          r.initiator = "fetch";
          r.destination = "subresource";
          requestList.push(r);
          const responsePromise = createDeferredPromise();
          fetchControllers.push(fetching({
            request: r,
            processResponse(response) {
              if (response.type === "error" || response.status === 206 || response.status < 200 || response.status > 299) {
                responsePromise.reject(webidl.errors.exception({
                  header: "Cache.addAll",
                  message: "Received an invalid status code or the request failed."
                }));
              } else if (response.headersList.contains("vary")) {
                const fieldValues = getFieldValues(response.headersList.get("vary"));
                for (const fieldValue of fieldValues) {
                  if (fieldValue === "*") {
                    responsePromise.reject(webidl.errors.exception({
                      header: "Cache.addAll",
                      message: "invalid vary field value"
                    }));
                    for (const controller of fetchControllers) {
                      controller.abort();
                    }
                    return;
                  }
                }
              }
            },
            processResponseEndOfBody(response) {
              if (response.aborted) {
                responsePromise.reject(new DOMException("aborted", "AbortError"));
                return;
              }
              responsePromise.resolve(response);
            }
          }));
          responsePromises.push(responsePromise.promise);
        }
        const p = Promise.all(responsePromises);
        const responses = await p;
        const operations = [];
        let index = 0;
        for (const response of responses) {
          const operation = {
            type: "put",
            // 7.3.2
            request: requestList[index],
            // 7.3.3
            response
            // 7.3.4
          };
          operations.push(operation);
          index++;
        }
        const cacheJobPromise = createDeferredPromise();
        let errorData = null;
        try {
          __privateMethod(this, _Cache_instances, batchCacheOperations_fn).call(this, operations);
        } catch (e) {
          errorData = e;
        }
        queueMicrotask(() => {
          if (errorData === null) {
            cacheJobPromise.resolve(void 0);
          } else {
            cacheJobPromise.reject(errorData);
          }
        });
        return cacheJobPromise.promise;
      }
      async put(request, response) {
        webidl.brandCheck(this, _Cache);
        const prefix = "Cache.put";
        webidl.argumentLengthCheck(arguments, 2, prefix);
        request = webidl.converters.RequestInfo(request, prefix, "request");
        response = webidl.converters.Response(response, prefix, "response");
        let innerRequest = null;
        if (request instanceof Request) {
          innerRequest = request[kState];
        } else {
          innerRequest = new Request(request)[kState];
        }
        if (!urlIsHttpHttpsScheme(innerRequest.url) || innerRequest.method !== "GET") {
          throw webidl.errors.exception({
            header: prefix,
            message: "Expected an http/s scheme when method is not GET"
          });
        }
        const innerResponse = response[kState];
        if (innerResponse.status === 206) {
          throw webidl.errors.exception({
            header: prefix,
            message: "Got 206 status"
          });
        }
        if (innerResponse.headersList.contains("vary")) {
          const fieldValues = getFieldValues(innerResponse.headersList.get("vary"));
          for (const fieldValue of fieldValues) {
            if (fieldValue === "*") {
              throw webidl.errors.exception({
                header: prefix,
                message: "Got * vary field value"
              });
            }
          }
        }
        if (innerResponse.body && (isDisturbed(innerResponse.body.stream) || innerResponse.body.stream.locked)) {
          throw webidl.errors.exception({
            header: prefix,
            message: "Response body is locked or disturbed"
          });
        }
        const clonedResponse = cloneResponse(innerResponse);
        const bodyReadPromise = createDeferredPromise();
        if (innerResponse.body != null) {
          const stream = innerResponse.body.stream;
          const reader = stream.getReader();
          readAllBytes(reader).then(bodyReadPromise.resolve, bodyReadPromise.reject);
        } else {
          bodyReadPromise.resolve(void 0);
        }
        const operations = [];
        const operation = {
          type: "put",
          // 14.
          request: innerRequest,
          // 15.
          response: clonedResponse
          // 16.
        };
        operations.push(operation);
        const bytes = await bodyReadPromise.promise;
        if (clonedResponse.body != null) {
          clonedResponse.body.source = bytes;
        }
        const cacheJobPromise = createDeferredPromise();
        let errorData = null;
        try {
          __privateMethod(this, _Cache_instances, batchCacheOperations_fn).call(this, operations);
        } catch (e) {
          errorData = e;
        }
        queueMicrotask(() => {
          if (errorData === null) {
            cacheJobPromise.resolve();
          } else {
            cacheJobPromise.reject(errorData);
          }
        });
        return cacheJobPromise.promise;
      }
      async delete(request, options = {}) {
        webidl.brandCheck(this, _Cache);
        const prefix = "Cache.delete";
        webidl.argumentLengthCheck(arguments, 1, prefix);
        request = webidl.converters.RequestInfo(request, prefix, "request");
        options = webidl.converters.CacheQueryOptions(options, prefix, "options");
        let r = null;
        if (request instanceof Request) {
          r = request[kState];
          if (r.method !== "GET" && !options.ignoreMethod) {
            return false;
          }
        } else {
          assert(typeof request === "string");
          r = new Request(request)[kState];
        }
        const operations = [];
        const operation = {
          type: "delete",
          request: r,
          options
        };
        operations.push(operation);
        const cacheJobPromise = createDeferredPromise();
        let errorData = null;
        let requestResponses;
        try {
          requestResponses = __privateMethod(this, _Cache_instances, batchCacheOperations_fn).call(this, operations);
        } catch (e) {
          errorData = e;
        }
        queueMicrotask(() => {
          if (errorData === null) {
            cacheJobPromise.resolve(!!(requestResponses == null ? void 0 : requestResponses.length));
          } else {
            cacheJobPromise.reject(errorData);
          }
        });
        return cacheJobPromise.promise;
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#dom-cache-keys
       * @param {any} request
       * @param {import('../../types/cache').CacheQueryOptions} options
       * @returns {Promise<readonly Request[]>}
       */
      async keys(request = void 0, options = {}) {
        webidl.brandCheck(this, _Cache);
        const prefix = "Cache.keys";
        if (request !== void 0) request = webidl.converters.RequestInfo(request, prefix, "request");
        options = webidl.converters.CacheQueryOptions(options, prefix, "options");
        let r = null;
        if (request !== void 0) {
          if (request instanceof Request) {
            r = request[kState];
            if (r.method !== "GET" && !options.ignoreMethod) {
              return [];
            }
          } else if (typeof request === "string") {
            r = new Request(request)[kState];
          }
        }
        const promise = createDeferredPromise();
        const requests = [];
        if (request === void 0) {
          for (const requestResponse of __privateGet(this, _relevantRequestResponseList)) {
            requests.push(requestResponse[0]);
          }
        } else {
          const requestResponses = __privateMethod(this, _Cache_instances, queryCache_fn).call(this, r, options);
          for (const requestResponse of requestResponses) {
            requests.push(requestResponse[0]);
          }
        }
        queueMicrotask(() => {
          const requestList = [];
          for (const request2 of requests) {
            const requestObject = fromInnerRequest(
              request2,
              new AbortController().signal,
              "immutable"
            );
            requestList.push(requestObject);
          }
          promise.resolve(Object.freeze(requestList));
        });
        return promise.promise;
      }
    };
    _relevantRequestResponseList = new WeakMap();
    _Cache_instances = new WeakSet();
    /**
     * @see https://w3c.github.io/ServiceWorker/#batch-cache-operations-algorithm
     * @param {CacheBatchOperation[]} operations
     * @returns {requestResponseList}
     */
    batchCacheOperations_fn = function(operations) {
      const cache = __privateGet(this, _relevantRequestResponseList);
      const backupCache = [...cache];
      const addedItems = [];
      const resultList = [];
      try {
        for (const operation of operations) {
          if (operation.type !== "delete" && operation.type !== "put") {
            throw webidl.errors.exception({
              header: "Cache.#batchCacheOperations",
              message: 'operation type does not match "delete" or "put"'
            });
          }
          if (operation.type === "delete" && operation.response != null) {
            throw webidl.errors.exception({
              header: "Cache.#batchCacheOperations",
              message: "delete operation should not have an associated response"
            });
          }
          if (__privateMethod(this, _Cache_instances, queryCache_fn).call(this, operation.request, operation.options, addedItems).length) {
            throw new DOMException("???", "InvalidStateError");
          }
          let requestResponses;
          if (operation.type === "delete") {
            requestResponses = __privateMethod(this, _Cache_instances, queryCache_fn).call(this, operation.request, operation.options);
            if (requestResponses.length === 0) {
              return [];
            }
            for (const requestResponse of requestResponses) {
              const idx = cache.indexOf(requestResponse);
              assert(idx !== -1);
              cache.splice(idx, 1);
            }
          } else if (operation.type === "put") {
            if (operation.response == null) {
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "put operation should have an associated response"
              });
            }
            const r = operation.request;
            if (!urlIsHttpHttpsScheme(r.url)) {
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "expected http or https scheme"
              });
            }
            if (r.method !== "GET") {
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "not get method"
              });
            }
            if (operation.options != null) {
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "options must not be defined"
              });
            }
            requestResponses = __privateMethod(this, _Cache_instances, queryCache_fn).call(this, operation.request);
            for (const requestResponse of requestResponses) {
              const idx = cache.indexOf(requestResponse);
              assert(idx !== -1);
              cache.splice(idx, 1);
            }
            cache.push([operation.request, operation.response]);
            addedItems.push([operation.request, operation.response]);
          }
          resultList.push([operation.request, operation.response]);
        }
        return resultList;
      } catch (e) {
        __privateGet(this, _relevantRequestResponseList).length = 0;
        __privateSet(this, _relevantRequestResponseList, backupCache);
        throw e;
      }
    };
    /**
     * @see https://w3c.github.io/ServiceWorker/#query-cache
     * @param {any} requestQuery
     * @param {import('../../types/cache').CacheQueryOptions} options
     * @param {requestResponseList} targetStorage
     * @returns {requestResponseList}
     */
    queryCache_fn = function(requestQuery, options, targetStorage) {
      const resultList = [];
      const storage = targetStorage ?? __privateGet(this, _relevantRequestResponseList);
      for (const requestResponse of storage) {
        const [cachedRequest, cachedResponse] = requestResponse;
        if (__privateMethod(this, _Cache_instances, requestMatchesCachedItem_fn).call(this, requestQuery, cachedRequest, cachedResponse, options)) {
          resultList.push(requestResponse);
        }
      }
      return resultList;
    };
    /**
     * @see https://w3c.github.io/ServiceWorker/#request-matches-cached-item-algorithm
     * @param {any} requestQuery
     * @param {any} request
     * @param {any | null} response
     * @param {import('../../types/cache').CacheQueryOptions | undefined} options
     * @returns {boolean}
     */
    requestMatchesCachedItem_fn = function(requestQuery, request, response = null, options) {
      const queryURL = new URL(requestQuery.url);
      const cachedURL = new URL(request.url);
      if (options == null ? void 0 : options.ignoreSearch) {
        cachedURL.search = "";
        queryURL.search = "";
      }
      if (!urlEquals(queryURL, cachedURL, true)) {
        return false;
      }
      if (response == null || (options == null ? void 0 : options.ignoreVary) || !response.headersList.contains("vary")) {
        return true;
      }
      const fieldValues = getFieldValues(response.headersList.get("vary"));
      for (const fieldValue of fieldValues) {
        if (fieldValue === "*") {
          return false;
        }
        const requestValue = request.headersList.get(fieldValue);
        const queryValue = requestQuery.headersList.get(fieldValue);
        if (requestValue !== queryValue) {
          return false;
        }
      }
      return true;
    };
    internalMatchAll_fn = function(request, options, maxResponses = Infinity) {
      let r = null;
      if (request !== void 0) {
        if (request instanceof Request) {
          r = request[kState];
          if (r.method !== "GET" && !options.ignoreMethod) {
            return [];
          }
        } else if (typeof request === "string") {
          r = new Request(request)[kState];
        }
      }
      const responses = [];
      if (request === void 0) {
        for (const requestResponse of __privateGet(this, _relevantRequestResponseList)) {
          responses.push(requestResponse[1]);
        }
      } else {
        const requestResponses = __privateMethod(this, _Cache_instances, queryCache_fn).call(this, r, options);
        for (const requestResponse of requestResponses) {
          responses.push(requestResponse[1]);
        }
      }
      const responseList = [];
      for (const response of responses) {
        const responseObject = fromInnerResponse(response, "immutable");
        responseList.push(responseObject.clone());
        if (responseList.length >= maxResponses) {
          break;
        }
      }
      return Object.freeze(responseList);
    };
    var Cache = _Cache;
    Object.defineProperties(Cache.prototype, {
      [Symbol.toStringTag]: {
        value: "Cache",
        configurable: true
      },
      match: kEnumerableProperty,
      matchAll: kEnumerableProperty,
      add: kEnumerableProperty,
      addAll: kEnumerableProperty,
      put: kEnumerableProperty,
      delete: kEnumerableProperty,
      keys: kEnumerableProperty
    });
    var cacheQueryOptionConverters = [
      {
        key: "ignoreSearch",
        converter: webidl.converters.boolean,
        defaultValue: () => false
      },
      {
        key: "ignoreMethod",
        converter: webidl.converters.boolean,
        defaultValue: () => false
      },
      {
        key: "ignoreVary",
        converter: webidl.converters.boolean,
        defaultValue: () => false
      }
    ];
    webidl.converters.CacheQueryOptions = webidl.dictionaryConverter(cacheQueryOptionConverters);
    webidl.converters.MultiCacheQueryOptions = webidl.dictionaryConverter([
      ...cacheQueryOptionConverters,
      {
        key: "cacheName",
        converter: webidl.converters.DOMString
      }
    ]);
    webidl.converters.Response = webidl.interfaceConverter(Response);
    webidl.converters["sequence<RequestInfo>"] = webidl.sequenceConverter(
      webidl.converters.RequestInfo
    );
    module2.exports = {
      Cache
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/cache/cachestorage.js
var require_cachestorage = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/cache/cachestorage.js"(exports2, module2) {
    "use strict";
    var { kConstruct } = require_symbols4();
    var { Cache } = require_cache();
    var { webidl } = require_webidl();
    var { kEnumerableProperty } = require_util2();
    var _caches;
    var _CacheStorage = class _CacheStorage {
      constructor() {
        /**
         * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-name-to-cache-map
         * @type {Map<string, import('./cache').requestResponseList}
         */
        __privateAdd(this, _caches, /* @__PURE__ */ new Map());
        if (arguments[0] !== kConstruct) {
          webidl.illegalConstructor();
        }
        webidl.util.markAsUncloneable(this);
      }
      async match(request, options = {}) {
        webidl.brandCheck(this, _CacheStorage);
        webidl.argumentLengthCheck(arguments, 1, "CacheStorage.match");
        request = webidl.converters.RequestInfo(request);
        options = webidl.converters.MultiCacheQueryOptions(options);
        if (options.cacheName != null) {
          if (__privateGet(this, _caches).has(options.cacheName)) {
            const cacheList = __privateGet(this, _caches).get(options.cacheName);
            const cache = new Cache(kConstruct, cacheList);
            return await cache.match(request, options);
          }
        } else {
          for (const cacheList of __privateGet(this, _caches).values()) {
            const cache = new Cache(kConstruct, cacheList);
            const response = await cache.match(request, options);
            if (response !== void 0) {
              return response;
            }
          }
        }
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#cache-storage-has
       * @param {string} cacheName
       * @returns {Promise<boolean>}
       */
      async has(cacheName) {
        webidl.brandCheck(this, _CacheStorage);
        const prefix = "CacheStorage.has";
        webidl.argumentLengthCheck(arguments, 1, prefix);
        cacheName = webidl.converters.DOMString(cacheName, prefix, "cacheName");
        return __privateGet(this, _caches).has(cacheName);
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#dom-cachestorage-open
       * @param {string} cacheName
       * @returns {Promise<Cache>}
       */
      async open(cacheName) {
        webidl.brandCheck(this, _CacheStorage);
        const prefix = "CacheStorage.open";
        webidl.argumentLengthCheck(arguments, 1, prefix);
        cacheName = webidl.converters.DOMString(cacheName, prefix, "cacheName");
        if (__privateGet(this, _caches).has(cacheName)) {
          const cache2 = __privateGet(this, _caches).get(cacheName);
          return new Cache(kConstruct, cache2);
        }
        const cache = [];
        __privateGet(this, _caches).set(cacheName, cache);
        return new Cache(kConstruct, cache);
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#cache-storage-delete
       * @param {string} cacheName
       * @returns {Promise<boolean>}
       */
      async delete(cacheName) {
        webidl.brandCheck(this, _CacheStorage);
        const prefix = "CacheStorage.delete";
        webidl.argumentLengthCheck(arguments, 1, prefix);
        cacheName = webidl.converters.DOMString(cacheName, prefix, "cacheName");
        return __privateGet(this, _caches).delete(cacheName);
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#cache-storage-keys
       * @returns {Promise<string[]>}
       */
      async keys() {
        webidl.brandCheck(this, _CacheStorage);
        const keys = __privateGet(this, _caches).keys();
        return [...keys];
      }
    };
    _caches = new WeakMap();
    var CacheStorage = _CacheStorage;
    Object.defineProperties(CacheStorage.prototype, {
      [Symbol.toStringTag]: {
        value: "CacheStorage",
        configurable: true
      },
      match: kEnumerableProperty,
      has: kEnumerableProperty,
      open: kEnumerableProperty,
      delete: kEnumerableProperty,
      keys: kEnumerableProperty
    });
    module2.exports = {
      CacheStorage
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/cookies/constants.js
var require_constants4 = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/cookies/constants.js"(exports2, module2) {
    "use strict";
    var maxAttributeValueSize = 1024;
    var maxNameValuePairSize = 4096;
    module2.exports = {
      maxAttributeValueSize,
      maxNameValuePairSize
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/cookies/util.js
var require_util7 = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/cookies/util.js"(exports2, module2) {
    "use strict";
    function isCTLExcludingHtab(value) {
      for (let i = 0; i < value.length; ++i) {
        const code = value.charCodeAt(i);
        if (code >= 0 && code <= 8 || code >= 10 && code <= 31 || code === 127) {
          return true;
        }
      }
      return false;
    }
    function validateCookieName(name) {
      for (let i = 0; i < name.length; ++i) {
        const code = name.charCodeAt(i);
        if (code < 33 || // exclude CTLs (0-31), SP and HT
        code > 126 || // exclude non-ascii and DEL
        code === 34 || // "
        code === 40 || // (
        code === 41 || // )
        code === 60 || // <
        code === 62 || // >
        code === 64 || // @
        code === 44 || // ,
        code === 59 || // ;
        code === 58 || // :
        code === 92 || // \
        code === 47 || // /
        code === 91 || // [
        code === 93 || // ]
        code === 63 || // ?
        code === 61 || // =
        code === 123 || // {
        code === 125) {
          throw new Error("Invalid cookie name");
        }
      }
    }
    function validateCookieValue(value) {
      let len = value.length;
      let i = 0;
      if (value[0] === '"') {
        if (len === 1 || value[len - 1] !== '"') {
          throw new Error("Invalid cookie value");
        }
        --len;
        ++i;
      }
      while (i < len) {
        const code = value.charCodeAt(i++);
        if (code < 33 || // exclude CTLs (0-31)
        code > 126 || // non-ascii and DEL (127)
        code === 34 || // "
        code === 44 || // ,
        code === 59 || // ;
        code === 92) {
          throw new Error("Invalid cookie value");
        }
      }
    }
    function validateCookiePath(path) {
      for (let i = 0; i < path.length; ++i) {
        const code = path.charCodeAt(i);
        if (code < 32 || // exclude CTLs (0-31)
        code === 127 || // DEL
        code === 59) {
          throw new Error("Invalid cookie path");
        }
      }
    }
    function validateCookieDomain(domain) {
      if (domain.startsWith("-") || domain.endsWith(".") || domain.endsWith("-")) {
        throw new Error("Invalid cookie domain");
      }
    }
    var IMFDays = [
      "Sun",
      "Mon",
      "Tue",
      "Wed",
      "Thu",
      "Fri",
      "Sat"
    ];
    var IMFMonths = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    var IMFPaddedNumbers = Array(61).fill(0).map((_, i) => i.toString().padStart(2, "0"));
    function toIMFDate(date) {
      if (typeof date === "number") {
        date = new Date(date);
      }
      return `${IMFDays[date.getUTCDay()]}, ${IMFPaddedNumbers[date.getUTCDate()]} ${IMFMonths[date.getUTCMonth()]} ${date.getUTCFullYear()} ${IMFPaddedNumbers[date.getUTCHours()]}:${IMFPaddedNumbers[date.getUTCMinutes()]}:${IMFPaddedNumbers[date.getUTCSeconds()]} GMT`;
    }
    function validateCookieMaxAge(maxAge) {
      if (maxAge < 0) {
        throw new Error("Invalid cookie max-age");
      }
    }
    function stringify(cookie) {
      if (cookie.name.length === 0) {
        return null;
      }
      validateCookieName(cookie.name);
      validateCookieValue(cookie.value);
      const out = [`${cookie.name}=${cookie.value}`];
      if (cookie.name.startsWith("__Secure-")) {
        cookie.secure = true;
      }
      if (cookie.name.startsWith("__Host-")) {
        cookie.secure = true;
        cookie.domain = null;
        cookie.path = "/";
      }
      if (cookie.secure) {
        out.push("Secure");
      }
      if (cookie.httpOnly) {
        out.push("HttpOnly");
      }
      if (typeof cookie.maxAge === "number") {
        validateCookieMaxAge(cookie.maxAge);
        out.push(`Max-Age=${cookie.maxAge}`);
      }
      if (cookie.domain) {
        validateCookieDomain(cookie.domain);
        out.push(`Domain=${cookie.domain}`);
      }
      if (cookie.path) {
        validateCookiePath(cookie.path);
        out.push(`Path=${cookie.path}`);
      }
      if (cookie.expires && cookie.expires.toString() !== "Invalid Date") {
        out.push(`Expires=${toIMFDate(cookie.expires)}`);
      }
      if (cookie.sameSite) {
        out.push(`SameSite=${cookie.sameSite}`);
      }
      for (const part of cookie.unparsed) {
        if (!part.includes("=")) {
          throw new Error("Invalid unparsed");
        }
        const [key, ...value] = part.split("=");
        out.push(`${key.trim()}=${value.join("=")}`);
      }
      return out.join("; ");
    }
    module2.exports = {
      isCTLExcludingHtab,
      validateCookieName,
      validateCookiePath,
      validateCookieValue,
      toIMFDate,
      stringify
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/cookies/parse.js
var require_parse = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/cookies/parse.js"(exports2, module2) {
    "use strict";
    var { maxNameValuePairSize, maxAttributeValueSize } = require_constants4();
    var { isCTLExcludingHtab } = require_util7();
    var { collectASequenceOfCodePointsFast } = require_data_url();
    var assert = require_node_assert();
    function parseSetCookie(header) {
      if (isCTLExcludingHtab(header)) {
        return null;
      }
      let nameValuePair = "";
      let unparsedAttributes = "";
      let name = "";
      let value = "";
      if (header.includes(";")) {
        const position = { position: 0 };
        nameValuePair = collectASequenceOfCodePointsFast(";", header, position);
        unparsedAttributes = header.slice(position.position);
      } else {
        nameValuePair = header;
      }
      if (!nameValuePair.includes("=")) {
        value = nameValuePair;
      } else {
        const position = { position: 0 };
        name = collectASequenceOfCodePointsFast(
          "=",
          nameValuePair,
          position
        );
        value = nameValuePair.slice(position.position + 1);
      }
      name = name.trim();
      value = value.trim();
      if (name.length + value.length > maxNameValuePairSize) {
        return null;
      }
      return {
        name,
        value,
        ...parseUnparsedAttributes(unparsedAttributes)
      };
    }
    function parseUnparsedAttributes(unparsedAttributes, cookieAttributeList = {}) {
      if (unparsedAttributes.length === 0) {
        return cookieAttributeList;
      }
      assert(unparsedAttributes[0] === ";");
      unparsedAttributes = unparsedAttributes.slice(1);
      let cookieAv = "";
      if (unparsedAttributes.includes(";")) {
        cookieAv = collectASequenceOfCodePointsFast(
          ";",
          unparsedAttributes,
          { position: 0 }
        );
        unparsedAttributes = unparsedAttributes.slice(cookieAv.length);
      } else {
        cookieAv = unparsedAttributes;
        unparsedAttributes = "";
      }
      let attributeName = "";
      let attributeValue = "";
      if (cookieAv.includes("=")) {
        const position = { position: 0 };
        attributeName = collectASequenceOfCodePointsFast(
          "=",
          cookieAv,
          position
        );
        attributeValue = cookieAv.slice(position.position + 1);
      } else {
        attributeName = cookieAv;
      }
      attributeName = attributeName.trim();
      attributeValue = attributeValue.trim();
      if (attributeValue.length > maxAttributeValueSize) {
        return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
      }
      const attributeNameLowercase = attributeName.toLowerCase();
      if (attributeNameLowercase === "expires") {
        const expiryTime = new Date(attributeValue);
        cookieAttributeList.expires = expiryTime;
      } else if (attributeNameLowercase === "max-age") {
        const charCode = attributeValue.charCodeAt(0);
        if ((charCode < 48 || charCode > 57) && attributeValue[0] !== "-") {
          return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
        }
        if (!/^\d+$/.test(attributeValue)) {
          return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
        }
        const deltaSeconds = Number(attributeValue);
        cookieAttributeList.maxAge = deltaSeconds;
      } else if (attributeNameLowercase === "domain") {
        let cookieDomain = attributeValue;
        if (cookieDomain[0] === ".") {
          cookieDomain = cookieDomain.slice(1);
        }
        cookieDomain = cookieDomain.toLowerCase();
        cookieAttributeList.domain = cookieDomain;
      } else if (attributeNameLowercase === "path") {
        let cookiePath = "";
        if (attributeValue.length === 0 || attributeValue[0] !== "/") {
          cookiePath = "/";
        } else {
          cookiePath = attributeValue;
        }
        cookieAttributeList.path = cookiePath;
      } else if (attributeNameLowercase === "secure") {
        cookieAttributeList.secure = true;
      } else if (attributeNameLowercase === "httponly") {
        cookieAttributeList.httpOnly = true;
      } else if (attributeNameLowercase === "samesite") {
        let enforcement = "Default";
        const attributeValueLowercase = attributeValue.toLowerCase();
        if (attributeValueLowercase.includes("none")) {
          enforcement = "None";
        }
        if (attributeValueLowercase.includes("strict")) {
          enforcement = "Strict";
        }
        if (attributeValueLowercase.includes("lax")) {
          enforcement = "Lax";
        }
        cookieAttributeList.sameSite = enforcement;
      } else {
        cookieAttributeList.unparsed ?? (cookieAttributeList.unparsed = []);
        cookieAttributeList.unparsed.push(`${attributeName}=${attributeValue}`);
      }
      return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
    }
    module2.exports = {
      parseSetCookie,
      parseUnparsedAttributes
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/cookies/index.js
var require_cookies = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/cookies/index.js"(exports2, module2) {
    "use strict";
    var { parseSetCookie } = require_parse();
    var { stringify } = require_util7();
    var { webidl } = require_webidl();
    var { Headers } = require_headers();
    function getCookies(headers) {
      webidl.argumentLengthCheck(arguments, 1, "getCookies");
      webidl.brandCheck(headers, Headers, { strict: false });
      const cookie = headers.get("cookie");
      const out = {};
      if (!cookie) {
        return out;
      }
      for (const piece of cookie.split(";")) {
        const [name, ...value] = piece.split("=");
        out[name.trim()] = value.join("=");
      }
      return out;
    }
    function deleteCookie(headers, name, attributes) {
      webidl.brandCheck(headers, Headers, { strict: false });
      const prefix = "deleteCookie";
      webidl.argumentLengthCheck(arguments, 2, prefix);
      name = webidl.converters.DOMString(name, prefix, "name");
      attributes = webidl.converters.DeleteCookieAttributes(attributes);
      setCookie(headers, {
        name,
        value: "",
        expires: /* @__PURE__ */ new Date(0),
        ...attributes
      });
    }
    function getSetCookies(headers) {
      webidl.argumentLengthCheck(arguments, 1, "getSetCookies");
      webidl.brandCheck(headers, Headers, { strict: false });
      const cookies = headers.getSetCookie();
      if (!cookies) {
        return [];
      }
      return cookies.map((pair) => parseSetCookie(pair));
    }
    function setCookie(headers, cookie) {
      webidl.argumentLengthCheck(arguments, 2, "setCookie");
      webidl.brandCheck(headers, Headers, { strict: false });
      cookie = webidl.converters.Cookie(cookie);
      const str = stringify(cookie);
      if (str) {
        headers.append("Set-Cookie", str);
      }
    }
    webidl.converters.DeleteCookieAttributes = webidl.dictionaryConverter([
      {
        converter: webidl.nullableConverter(webidl.converters.DOMString),
        key: "path",
        defaultValue: () => null
      },
      {
        converter: webidl.nullableConverter(webidl.converters.DOMString),
        key: "domain",
        defaultValue: () => null
      }
    ]);
    webidl.converters.Cookie = webidl.dictionaryConverter([
      {
        converter: webidl.converters.DOMString,
        key: "name"
      },
      {
        converter: webidl.converters.DOMString,
        key: "value"
      },
      {
        converter: webidl.nullableConverter((value) => {
          if (typeof value === "number") {
            return webidl.converters["unsigned long long"](value);
          }
          return new Date(value);
        }),
        key: "expires",
        defaultValue: () => null
      },
      {
        converter: webidl.nullableConverter(webidl.converters["long long"]),
        key: "maxAge",
        defaultValue: () => null
      },
      {
        converter: webidl.nullableConverter(webidl.converters.DOMString),
        key: "domain",
        defaultValue: () => null
      },
      {
        converter: webidl.nullableConverter(webidl.converters.DOMString),
        key: "path",
        defaultValue: () => null
      },
      {
        converter: webidl.nullableConverter(webidl.converters.boolean),
        key: "secure",
        defaultValue: () => null
      },
      {
        converter: webidl.nullableConverter(webidl.converters.boolean),
        key: "httpOnly",
        defaultValue: () => null
      },
      {
        converter: webidl.converters.USVString,
        key: "sameSite",
        allowedValues: ["Strict", "Lax", "None"]
      },
      {
        converter: webidl.sequenceConverter(webidl.converters.DOMString),
        key: "unparsed",
        defaultValue: () => new Array(0)
      }
    ]);
    module2.exports = {
      getCookies,
      deleteCookie,
      getSetCookies,
      setCookie
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/websocket/events.js
var require_events2 = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/websocket/events.js"(exports2, module2) {
    "use strict";
    var { webidl } = require_webidl();
    var { kEnumerableProperty } = require_util2();
    var { kConstruct } = require_symbols();
    var { MessagePort } = require_node_worker_threads();
    var _eventInit;
    var _MessageEvent = class _MessageEvent extends Event {
      constructor(type, eventInitDict = {}) {
        var __super = (...args) => {
          super(...args);
          __privateAdd(this, _eventInit);
          return this;
        };
        if (type === kConstruct) {
          __super(arguments[1], arguments[2]);
          webidl.util.markAsUncloneable(this);
          return;
        }
        const prefix = "MessageEvent constructor";
        webidl.argumentLengthCheck(arguments, 1, prefix);
        type = webidl.converters.DOMString(type, prefix, "type");
        eventInitDict = webidl.converters.MessageEventInit(eventInitDict, prefix, "eventInitDict");
        __super(type, eventInitDict);
        __privateSet(this, _eventInit, eventInitDict);
        webidl.util.markAsUncloneable(this);
      }
      get data() {
        webidl.brandCheck(this, _MessageEvent);
        return __privateGet(this, _eventInit).data;
      }
      get origin() {
        webidl.brandCheck(this, _MessageEvent);
        return __privateGet(this, _eventInit).origin;
      }
      get lastEventId() {
        webidl.brandCheck(this, _MessageEvent);
        return __privateGet(this, _eventInit).lastEventId;
      }
      get source() {
        webidl.brandCheck(this, _MessageEvent);
        return __privateGet(this, _eventInit).source;
      }
      get ports() {
        webidl.brandCheck(this, _MessageEvent);
        if (!Object.isFrozen(__privateGet(this, _eventInit).ports)) {
          Object.freeze(__privateGet(this, _eventInit).ports);
        }
        return __privateGet(this, _eventInit).ports;
      }
      initMessageEvent(type, bubbles = false, cancelable = false, data = null, origin = "", lastEventId = "", source = null, ports = []) {
        webidl.brandCheck(this, _MessageEvent);
        webidl.argumentLengthCheck(arguments, 1, "MessageEvent.initMessageEvent");
        return new _MessageEvent(type, {
          bubbles,
          cancelable,
          data,
          origin,
          lastEventId,
          source,
          ports
        });
      }
      static createFastMessageEvent(type, init) {
        var _a, _b, _c, _d, _e;
        const messageEvent = new _MessageEvent(kConstruct, type, init);
        __privateSet(messageEvent, _eventInit, init);
        (_a = __privateGet(messageEvent, _eventInit)).data ?? (_a.data = null);
        (_b = __privateGet(messageEvent, _eventInit)).origin ?? (_b.origin = "");
        (_c = __privateGet(messageEvent, _eventInit)).lastEventId ?? (_c.lastEventId = "");
        (_d = __privateGet(messageEvent, _eventInit)).source ?? (_d.source = null);
        (_e = __privateGet(messageEvent, _eventInit)).ports ?? (_e.ports = []);
        return messageEvent;
      }
    };
    _eventInit = new WeakMap();
    var MessageEvent = _MessageEvent;
    var { createFastMessageEvent } = MessageEvent;
    delete MessageEvent.createFastMessageEvent;
    var _eventInit2;
    var _CloseEvent = class _CloseEvent extends Event {
      constructor(type, eventInitDict = {}) {
        const prefix = "CloseEvent constructor";
        webidl.argumentLengthCheck(arguments, 1, prefix);
        type = webidl.converters.DOMString(type, prefix, "type");
        eventInitDict = webidl.converters.CloseEventInit(eventInitDict);
        super(type, eventInitDict);
        __privateAdd(this, _eventInit2);
        __privateSet(this, _eventInit2, eventInitDict);
        webidl.util.markAsUncloneable(this);
      }
      get wasClean() {
        webidl.brandCheck(this, _CloseEvent);
        return __privateGet(this, _eventInit2).wasClean;
      }
      get code() {
        webidl.brandCheck(this, _CloseEvent);
        return __privateGet(this, _eventInit2).code;
      }
      get reason() {
        webidl.brandCheck(this, _CloseEvent);
        return __privateGet(this, _eventInit2).reason;
      }
    };
    _eventInit2 = new WeakMap();
    var CloseEvent = _CloseEvent;
    var _eventInit3;
    var _ErrorEvent = class _ErrorEvent extends Event {
      constructor(type, eventInitDict) {
        const prefix = "ErrorEvent constructor";
        webidl.argumentLengthCheck(arguments, 1, prefix);
        super(type, eventInitDict);
        __privateAdd(this, _eventInit3);
        webidl.util.markAsUncloneable(this);
        type = webidl.converters.DOMString(type, prefix, "type");
        eventInitDict = webidl.converters.ErrorEventInit(eventInitDict ?? {});
        __privateSet(this, _eventInit3, eventInitDict);
      }
      get message() {
        webidl.brandCheck(this, _ErrorEvent);
        return __privateGet(this, _eventInit3).message;
      }
      get filename() {
        webidl.brandCheck(this, _ErrorEvent);
        return __privateGet(this, _eventInit3).filename;
      }
      get lineno() {
        webidl.brandCheck(this, _ErrorEvent);
        return __privateGet(this, _eventInit3).lineno;
      }
      get colno() {
        webidl.brandCheck(this, _ErrorEvent);
        return __privateGet(this, _eventInit3).colno;
      }
      get error() {
        webidl.brandCheck(this, _ErrorEvent);
        return __privateGet(this, _eventInit3).error;
      }
    };
    _eventInit3 = new WeakMap();
    var ErrorEvent = _ErrorEvent;
    Object.defineProperties(MessageEvent.prototype, {
      [Symbol.toStringTag]: {
        value: "MessageEvent",
        configurable: true
      },
      data: kEnumerableProperty,
      origin: kEnumerableProperty,
      lastEventId: kEnumerableProperty,
      source: kEnumerableProperty,
      ports: kEnumerableProperty,
      initMessageEvent: kEnumerableProperty
    });
    Object.defineProperties(CloseEvent.prototype, {
      [Symbol.toStringTag]: {
        value: "CloseEvent",
        configurable: true
      },
      reason: kEnumerableProperty,
      code: kEnumerableProperty,
      wasClean: kEnumerableProperty
    });
    Object.defineProperties(ErrorEvent.prototype, {
      [Symbol.toStringTag]: {
        value: "ErrorEvent",
        configurable: true
      },
      message: kEnumerableProperty,
      filename: kEnumerableProperty,
      lineno: kEnumerableProperty,
      colno: kEnumerableProperty,
      error: kEnumerableProperty
    });
    webidl.converters.MessagePort = webidl.interfaceConverter(MessagePort);
    webidl.converters["sequence<MessagePort>"] = webidl.sequenceConverter(
      webidl.converters.MessagePort
    );
    var eventInit = [
      {
        key: "bubbles",
        converter: webidl.converters.boolean,
        defaultValue: () => false
      },
      {
        key: "cancelable",
        converter: webidl.converters.boolean,
        defaultValue: () => false
      },
      {
        key: "composed",
        converter: webidl.converters.boolean,
        defaultValue: () => false
      }
    ];
    webidl.converters.MessageEventInit = webidl.dictionaryConverter([
      ...eventInit,
      {
        key: "data",
        converter: webidl.converters.any,
        defaultValue: () => null
      },
      {
        key: "origin",
        converter: webidl.converters.USVString,
        defaultValue: () => ""
      },
      {
        key: "lastEventId",
        converter: webidl.converters.DOMString,
        defaultValue: () => ""
      },
      {
        key: "source",
        // Node doesn't implement WindowProxy or ServiceWorker, so the only
        // valid value for source is a MessagePort.
        converter: webidl.nullableConverter(webidl.converters.MessagePort),
        defaultValue: () => null
      },
      {
        key: "ports",
        converter: webidl.converters["sequence<MessagePort>"],
        defaultValue: () => new Array(0)
      }
    ]);
    webidl.converters.CloseEventInit = webidl.dictionaryConverter([
      ...eventInit,
      {
        key: "wasClean",
        converter: webidl.converters.boolean,
        defaultValue: () => false
      },
      {
        key: "code",
        converter: webidl.converters["unsigned short"],
        defaultValue: () => 0
      },
      {
        key: "reason",
        converter: webidl.converters.USVString,
        defaultValue: () => ""
      }
    ]);
    webidl.converters.ErrorEventInit = webidl.dictionaryConverter([
      ...eventInit,
      {
        key: "message",
        converter: webidl.converters.DOMString,
        defaultValue: () => ""
      },
      {
        key: "filename",
        converter: webidl.converters.USVString,
        defaultValue: () => ""
      },
      {
        key: "lineno",
        converter: webidl.converters["unsigned long"],
        defaultValue: () => 0
      },
      {
        key: "colno",
        converter: webidl.converters["unsigned long"],
        defaultValue: () => 0
      },
      {
        key: "error",
        converter: webidl.converters.any
      }
    ]);
    module2.exports = {
      MessageEvent,
      CloseEvent,
      ErrorEvent,
      createFastMessageEvent
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/websocket/constants.js
var require_constants5 = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/websocket/constants.js"(exports2, module2) {
    "use strict";
    var uid = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
    var staticPropertyDescriptors = {
      enumerable: true,
      writable: false,
      configurable: false
    };
    var states = {
      CONNECTING: 0,
      OPEN: 1,
      CLOSING: 2,
      CLOSED: 3
    };
    var sentCloseFrameState = {
      NOT_SENT: 0,
      PROCESSING: 1,
      SENT: 2
    };
    var opcodes = {
      CONTINUATION: 0,
      TEXT: 1,
      BINARY: 2,
      CLOSE: 8,
      PING: 9,
      PONG: 10
    };
    var maxUnsigned16Bit = 2 ** 16 - 1;
    var parserStates = {
      INFO: 0,
      PAYLOADLENGTH_16: 2,
      PAYLOADLENGTH_64: 3,
      READ_DATA: 4
    };
    var emptyBuffer = Buffer.allocUnsafe(0);
    var sendHints = {
      string: 1,
      typedArray: 2,
      arrayBuffer: 3,
      blob: 4
    };
    module2.exports = {
      uid,
      sentCloseFrameState,
      staticPropertyDescriptors,
      states,
      opcodes,
      maxUnsigned16Bit,
      parserStates,
      emptyBuffer,
      sendHints
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/websocket/symbols.js
var require_symbols5 = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/websocket/symbols.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      kWebSocketURL: Symbol("url"),
      kReadyState: Symbol("ready state"),
      kController: Symbol("controller"),
      kResponse: Symbol("response"),
      kBinaryType: Symbol("binary type"),
      kSentClose: Symbol("sent close"),
      kReceivedClose: Symbol("received close"),
      kByteParser: Symbol("byte parser")
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/websocket/util.js
var require_util8 = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/websocket/util.js"(exports2, module2) {
    "use strict";
    var { kReadyState, kController, kResponse, kBinaryType, kWebSocketURL } = require_symbols5();
    var { states, opcodes } = require_constants5();
    var { ErrorEvent, createFastMessageEvent } = require_events2();
    var { isUtf8 } = require_node_buffer();
    var { collectASequenceOfCodePointsFast, removeHTTPWhitespace } = require_data_url();
    function isConnecting(ws) {
      return ws[kReadyState] === states.CONNECTING;
    }
    function isEstablished(ws) {
      return ws[kReadyState] === states.OPEN;
    }
    function isClosing(ws) {
      return ws[kReadyState] === states.CLOSING;
    }
    function isClosed(ws) {
      return ws[kReadyState] === states.CLOSED;
    }
    function fireEvent(e, target, eventFactory = (type, init) => new Event(type, init), eventInitDict = {}) {
      const event = eventFactory(e, eventInitDict);
      target.dispatchEvent(event);
    }
    function websocketMessageReceived(ws, type, data) {
      if (ws[kReadyState] !== states.OPEN) {
        return;
      }
      let dataForEvent;
      if (type === opcodes.TEXT) {
        try {
          dataForEvent = utf8Decode(data);
        } catch {
          failWebsocketConnection(ws, "Received invalid UTF-8 in text frame.");
          return;
        }
      } else if (type === opcodes.BINARY) {
        if (ws[kBinaryType] === "blob") {
          dataForEvent = new Blob([data]);
        } else {
          dataForEvent = toArrayBuffer(data);
        }
      }
      fireEvent("message", ws, createFastMessageEvent, {
        origin: ws[kWebSocketURL].origin,
        data: dataForEvent
      });
    }
    function toArrayBuffer(buffer) {
      if (buffer.byteLength === buffer.buffer.byteLength) {
        return buffer.buffer;
      }
      return buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength);
    }
    function isValidSubprotocol(protocol) {
      if (protocol.length === 0) {
        return false;
      }
      for (let i = 0; i < protocol.length; ++i) {
        const code = protocol.charCodeAt(i);
        if (code < 33 || // CTL, contains SP (0x20) and HT (0x09)
        code > 126 || code === 34 || // "
        code === 40 || // (
        code === 41 || // )
        code === 44 || // ,
        code === 47 || // /
        code === 58 || // :
        code === 59 || // ;
        code === 60 || // <
        code === 61 || // =
        code === 62 || // >
        code === 63 || // ?
        code === 64 || // @
        code === 91 || // [
        code === 92 || // \
        code === 93 || // ]
        code === 123 || // {
        code === 125) {
          return false;
        }
      }
      return true;
    }
    function isValidStatusCode(code) {
      if (code >= 1e3 && code < 1015) {
        return code !== 1004 && // reserved
        code !== 1005 && // "MUST NOT be set as a status code"
        code !== 1006;
      }
      return code >= 3e3 && code <= 4999;
    }
    function failWebsocketConnection(ws, reason) {
      const { [kController]: controller, [kResponse]: response } = ws;
      controller.abort();
      if ((response == null ? void 0 : response.socket) && !response.socket.destroyed) {
        response.socket.destroy();
      }
      if (reason) {
        fireEvent("error", ws, (type, init) => new ErrorEvent(type, init), {
          error: new Error(reason),
          message: reason
        });
      }
    }
    function isControlFrame(opcode) {
      return opcode === opcodes.CLOSE || opcode === opcodes.PING || opcode === opcodes.PONG;
    }
    function isContinuationFrame(opcode) {
      return opcode === opcodes.CONTINUATION;
    }
    function isTextBinaryFrame(opcode) {
      return opcode === opcodes.TEXT || opcode === opcodes.BINARY;
    }
    function isValidOpcode(opcode) {
      return isTextBinaryFrame(opcode) || isContinuationFrame(opcode) || isControlFrame(opcode);
    }
    function parseExtensions(extensions) {
      const position = { position: 0 };
      const extensionList = /* @__PURE__ */ new Map();
      while (position.position < extensions.length) {
        const pair = collectASequenceOfCodePointsFast(";", extensions, position);
        const [name, value = ""] = pair.split("=");
        extensionList.set(
          removeHTTPWhitespace(name, true, false),
          removeHTTPWhitespace(value, false, true)
        );
        position.position++;
      }
      return extensionList;
    }
    function isValidClientWindowBits(value) {
      for (let i = 0; i < value.length; i++) {
        const byte = value.charCodeAt(i);
        if (byte < 48 || byte > 57) {
          return false;
        }
      }
      return true;
    }
    var hasIntl = typeof process.versions.icu === "string";
    var fatalDecoder = hasIntl ? new TextDecoder("utf-8", { fatal: true }) : void 0;
    var utf8Decode = hasIntl ? fatalDecoder.decode.bind(fatalDecoder) : function(buffer) {
      if (isUtf8(buffer)) {
        return buffer.toString("utf-8");
      }
      throw new TypeError("Invalid utf-8 received.");
    };
    module2.exports = {
      isConnecting,
      isEstablished,
      isClosing,
      isClosed,
      fireEvent,
      isValidSubprotocol,
      isValidStatusCode,
      failWebsocketConnection,
      websocketMessageReceived,
      utf8Decode,
      isControlFrame,
      isContinuationFrame,
      isTextBinaryFrame,
      isValidOpcode,
      parseExtensions,
      isValidClientWindowBits
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/websocket/frame.js
var require_frame = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/websocket/frame.js"(exports2, module2) {
    "use strict";
    var { maxUnsigned16Bit } = require_constants5();
    var BUFFER_SIZE = 16386;
    var crypto;
    var buffer = null;
    var bufIdx = BUFFER_SIZE;
    try {
      crypto = require_node_crypto();
    } catch {
      crypto = {
        // not full compatibility, but minimum.
        randomFillSync: function randomFillSync(buffer2, _offset, _size) {
          for (let i = 0; i < buffer2.length; ++i) {
            buffer2[i] = Math.random() * 255 | 0;
          }
          return buffer2;
        }
      };
    }
    function generateMask() {
      if (bufIdx === BUFFER_SIZE) {
        bufIdx = 0;
        crypto.randomFillSync(buffer ?? (buffer = Buffer.allocUnsafe(BUFFER_SIZE)), 0, BUFFER_SIZE);
      }
      return [buffer[bufIdx++], buffer[bufIdx++], buffer[bufIdx++], buffer[bufIdx++]];
    }
    var WebsocketFrameSend = class {
      /**
       * @param {Buffer|undefined} data
       */
      constructor(data) {
        this.frameData = data;
      }
      createFrame(opcode) {
        const frameData = this.frameData;
        const maskKey = generateMask();
        const bodyLength = (frameData == null ? void 0 : frameData.byteLength) ?? 0;
        let payloadLength = bodyLength;
        let offset = 6;
        if (bodyLength > maxUnsigned16Bit) {
          offset += 8;
          payloadLength = 127;
        } else if (bodyLength > 125) {
          offset += 2;
          payloadLength = 126;
        }
        const buffer2 = Buffer.allocUnsafe(bodyLength + offset);
        buffer2[0] = buffer2[1] = 0;
        buffer2[0] |= 128;
        buffer2[0] = (buffer2[0] & 240) + opcode;
        buffer2[offset - 4] = maskKey[0];
        buffer2[offset - 3] = maskKey[1];
        buffer2[offset - 2] = maskKey[2];
        buffer2[offset - 1] = maskKey[3];
        buffer2[1] = payloadLength;
        if (payloadLength === 126) {
          buffer2.writeUInt16BE(bodyLength, 2);
        } else if (payloadLength === 127) {
          buffer2[2] = buffer2[3] = 0;
          buffer2.writeUIntBE(bodyLength, 4, 6);
        }
        buffer2[1] |= 128;
        for (let i = 0; i < bodyLength; ++i) {
          buffer2[offset + i] = frameData[i] ^ maskKey[i & 3];
        }
        return buffer2;
      }
    };
    module2.exports = {
      WebsocketFrameSend
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/websocket/connection.js
var require_connection = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/websocket/connection.js"(exports2, module2) {
    "use strict";
    var { uid, states, sentCloseFrameState, emptyBuffer, opcodes } = require_constants5();
    var {
      kReadyState,
      kSentClose,
      kByteParser,
      kReceivedClose,
      kResponse
    } = require_symbols5();
    var { fireEvent, failWebsocketConnection, isClosing, isClosed, isEstablished, parseExtensions } = require_util8();
    var { channels } = require_diagnostics();
    var { CloseEvent } = require_events2();
    var { makeRequest } = require_request2();
    var { fetching } = require_fetch();
    var { Headers, getHeadersList } = require_headers();
    var { getDecodeSplit } = require_util3();
    var { WebsocketFrameSend } = require_frame();
    var crypto;
    try {
      crypto = require_node_crypto();
    } catch {
    }
    function establishWebSocketConnection(url, protocols, client, ws, onEstablish, options) {
      const requestURL = url;
      requestURL.protocol = url.protocol === "ws:" ? "http:" : "https:";
      const request = makeRequest({
        urlList: [requestURL],
        client,
        serviceWorkers: "none",
        referrer: "no-referrer",
        mode: "websocket",
        credentials: "include",
        cache: "no-store",
        redirect: "error"
      });
      if (options.headers) {
        const headersList = getHeadersList(new Headers(options.headers));
        request.headersList = headersList;
      }
      const keyValue = crypto.randomBytes(16).toString("base64");
      request.headersList.append("sec-websocket-key", keyValue);
      request.headersList.append("sec-websocket-version", "13");
      for (const protocol of protocols) {
        request.headersList.append("sec-websocket-protocol", protocol);
      }
      const permessageDeflate = "permessage-deflate; client_max_window_bits";
      request.headersList.append("sec-websocket-extensions", permessageDeflate);
      const controller = fetching({
        request,
        useParallelQueue: true,
        dispatcher: options.dispatcher,
        processResponse(response) {
          var _a, _b;
          if (response.type === "error" || response.status !== 101) {
            failWebsocketConnection(ws, "Received network error or non-101 status code.");
            return;
          }
          if (protocols.length !== 0 && !response.headersList.get("Sec-WebSocket-Protocol")) {
            failWebsocketConnection(ws, "Server did not respond with sent protocols.");
            return;
          }
          if (((_a = response.headersList.get("Upgrade")) == null ? void 0 : _a.toLowerCase()) !== "websocket") {
            failWebsocketConnection(ws, 'Server did not set Upgrade header to "websocket".');
            return;
          }
          if (((_b = response.headersList.get("Connection")) == null ? void 0 : _b.toLowerCase()) !== "upgrade") {
            failWebsocketConnection(ws, 'Server did not set Connection header to "upgrade".');
            return;
          }
          const secWSAccept = response.headersList.get("Sec-WebSocket-Accept");
          const digest = crypto.createHash("sha1").update(keyValue + uid).digest("base64");
          if (secWSAccept !== digest) {
            failWebsocketConnection(ws, "Incorrect hash received in Sec-WebSocket-Accept header.");
            return;
          }
          const secExtension = response.headersList.get("Sec-WebSocket-Extensions");
          let extensions;
          if (secExtension !== null) {
            extensions = parseExtensions(secExtension);
            if (!extensions.has("permessage-deflate")) {
              failWebsocketConnection(ws, "Sec-WebSocket-Extensions header does not match.");
              return;
            }
          }
          const secProtocol = response.headersList.get("Sec-WebSocket-Protocol");
          if (secProtocol !== null) {
            const requestProtocols = getDecodeSplit("sec-websocket-protocol", request.headersList);
            if (!requestProtocols.includes(secProtocol)) {
              failWebsocketConnection(ws, "Protocol was not set in the opening handshake.");
              return;
            }
          }
          response.socket.on("data", onSocketData);
          response.socket.on("close", onSocketClose);
          response.socket.on("error", onSocketError);
          if (channels.open.hasSubscribers) {
            channels.open.publish({
              address: response.socket.address(),
              protocol: secProtocol,
              extensions: secExtension
            });
          }
          onEstablish(response, extensions);
        }
      });
      return controller;
    }
    function closeWebSocketConnection(ws, code, reason, reasonByteLength) {
      if (isClosing(ws) || isClosed(ws)) {
      } else if (!isEstablished(ws)) {
        failWebsocketConnection(ws, "Connection was closed before it was established.");
        ws[kReadyState] = states.CLOSING;
      } else if (ws[kSentClose] === sentCloseFrameState.NOT_SENT) {
        ws[kSentClose] = sentCloseFrameState.PROCESSING;
        const frame = new WebsocketFrameSend();
        if (code !== void 0 && reason === void 0) {
          frame.frameData = Buffer.allocUnsafe(2);
          frame.frameData.writeUInt16BE(code, 0);
        } else if (code !== void 0 && reason !== void 0) {
          frame.frameData = Buffer.allocUnsafe(2 + reasonByteLength);
          frame.frameData.writeUInt16BE(code, 0);
          frame.frameData.write(reason, 2, "utf-8");
        } else {
          frame.frameData = emptyBuffer;
        }
        const socket = ws[kResponse].socket;
        socket.write(frame.createFrame(opcodes.CLOSE));
        ws[kSentClose] = sentCloseFrameState.SENT;
        ws[kReadyState] = states.CLOSING;
      } else {
        ws[kReadyState] = states.CLOSING;
      }
    }
    function onSocketData(chunk) {
      if (!this.ws[kByteParser].write(chunk)) {
        this.pause();
      }
    }
    function onSocketClose() {
      const { ws } = this;
      const { [kResponse]: response } = ws;
      response.socket.off("data", onSocketData);
      response.socket.off("close", onSocketClose);
      response.socket.off("error", onSocketError);
      const wasClean = ws[kSentClose] === sentCloseFrameState.SENT && ws[kReceivedClose];
      let code = 1005;
      let reason = "";
      const result = ws[kByteParser].closingInfo;
      if (result && !result.error) {
        code = result.code ?? 1005;
        reason = result.reason;
      } else if (!ws[kReceivedClose]) {
        code = 1006;
      }
      ws[kReadyState] = states.CLOSED;
      fireEvent("close", ws, (type, init) => new CloseEvent(type, init), {
        wasClean,
        code,
        reason
      });
      if (channels.close.hasSubscribers) {
        channels.close.publish({
          websocket: ws,
          code,
          reason
        });
      }
    }
    function onSocketError(error2) {
      const { ws } = this;
      ws[kReadyState] = states.CLOSING;
      if (channels.socketError.hasSubscribers) {
        channels.socketError.publish(error2);
      }
      this.destroy();
    }
    module2.exports = {
      establishWebSocketConnection,
      closeWebSocketConnection
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/websocket/permessage-deflate.js
var require_permessage_deflate = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/websocket/permessage-deflate.js"(exports2, module2) {
    "use strict";
    var { createInflateRaw, Z_DEFAULT_WINDOWBITS } = require_node_zlib();
    var { isValidClientWindowBits } = require_util8();
    var tail = Buffer.from([0, 0, 255, 255]);
    var kBuffer = Symbol("kBuffer");
    var kLength = Symbol("kLength");
    var _inflate, _options;
    var PerMessageDeflate = class {
      constructor(extensions) {
        /** @type {import('node:zlib').InflateRaw} */
        __privateAdd(this, _inflate);
        __privateAdd(this, _options, {});
        __privateGet(this, _options).serverNoContextTakeover = extensions.has("server_no_context_takeover");
        __privateGet(this, _options).serverMaxWindowBits = extensions.get("server_max_window_bits");
      }
      decompress(chunk, fin, callback) {
        if (!__privateGet(this, _inflate)) {
          let windowBits = Z_DEFAULT_WINDOWBITS;
          if (__privateGet(this, _options).serverMaxWindowBits) {
            if (!isValidClientWindowBits(__privateGet(this, _options).serverMaxWindowBits)) {
              callback(new Error("Invalid server_max_window_bits"));
              return;
            }
            windowBits = Number.parseInt(__privateGet(this, _options).serverMaxWindowBits);
          }
          __privateSet(this, _inflate, createInflateRaw({ windowBits }));
          __privateGet(this, _inflate)[kBuffer] = [];
          __privateGet(this, _inflate)[kLength] = 0;
          __privateGet(this, _inflate).on("data", (data) => {
            __privateGet(this, _inflate)[kBuffer].push(data);
            __privateGet(this, _inflate)[kLength] += data.length;
          });
          __privateGet(this, _inflate).on("error", (err) => {
            __privateSet(this, _inflate, null);
            callback(err);
          });
        }
        __privateGet(this, _inflate).write(chunk);
        if (fin) {
          __privateGet(this, _inflate).write(tail);
        }
        __privateGet(this, _inflate).flush(() => {
          const full = Buffer.concat(__privateGet(this, _inflate)[kBuffer], __privateGet(this, _inflate)[kLength]);
          __privateGet(this, _inflate)[kBuffer].length = 0;
          __privateGet(this, _inflate)[kLength] = 0;
          callback(null, full);
        });
      }
    };
    _inflate = new WeakMap();
    _options = new WeakMap();
    module2.exports = { PerMessageDeflate };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/websocket/receiver.js
var require_receiver = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/websocket/receiver.js"(exports2, module2) {
    "use strict";
    var { Writable } = require_node_stream();
    var assert = require_node_assert();
    var { parserStates, opcodes, states, emptyBuffer, sentCloseFrameState } = require_constants5();
    var { kReadyState, kSentClose, kResponse, kReceivedClose } = require_symbols5();
    var { channels } = require_diagnostics();
    var {
      isValidStatusCode,
      isValidOpcode,
      failWebsocketConnection,
      websocketMessageReceived,
      utf8Decode,
      isControlFrame,
      isTextBinaryFrame,
      isContinuationFrame
    } = require_util8();
    var { WebsocketFrameSend } = require_frame();
    var { closeWebSocketConnection } = require_connection();
    var { PerMessageDeflate } = require_permessage_deflate();
    var _buffers, _byteOffset, _loop, _state, _info, _fragments, _extensions;
    var ByteParser = class extends Writable {
      constructor(ws, extensions) {
        super();
        __privateAdd(this, _buffers, []);
        __privateAdd(this, _byteOffset, 0);
        __privateAdd(this, _loop, false);
        __privateAdd(this, _state, parserStates.INFO);
        __privateAdd(this, _info, {});
        __privateAdd(this, _fragments, []);
        /** @type {Map<string, PerMessageDeflate>} */
        __privateAdd(this, _extensions);
        this.ws = ws;
        __privateSet(this, _extensions, extensions == null ? /* @__PURE__ */ new Map() : extensions);
        if (__privateGet(this, _extensions).has("permessage-deflate")) {
          __privateGet(this, _extensions).set("permessage-deflate", new PerMessageDeflate(extensions));
        }
      }
      /**
       * @param {Buffer} chunk
       * @param {() => void} callback
       */
      _write(chunk, _, callback) {
        __privateGet(this, _buffers).push(chunk);
        __privateSet(this, _byteOffset, __privateGet(this, _byteOffset) + chunk.length);
        __privateSet(this, _loop, true);
        this.run(callback);
      }
      /**
       * Runs whenever a new chunk is received.
       * Callback is called whenever there are no more chunks buffering,
       * or not enough bytes are buffered to parse.
       */
      run(callback) {
        while (__privateGet(this, _loop)) {
          if (__privateGet(this, _state) === parserStates.INFO) {
            if (__privateGet(this, _byteOffset) < 2) {
              return callback();
            }
            const buffer = this.consume(2);
            const fin = (buffer[0] & 128) !== 0;
            const opcode = buffer[0] & 15;
            const masked = (buffer[1] & 128) === 128;
            const fragmented = !fin && opcode !== opcodes.CONTINUATION;
            const payloadLength = buffer[1] & 127;
            const rsv1 = buffer[0] & 64;
            const rsv2 = buffer[0] & 32;
            const rsv3 = buffer[0] & 16;
            if (!isValidOpcode(opcode)) {
              failWebsocketConnection(this.ws, "Invalid opcode received");
              return callback();
            }
            if (masked) {
              failWebsocketConnection(this.ws, "Frame cannot be masked");
              return callback();
            }
            if (rsv1 !== 0 && !__privateGet(this, _extensions).has("permessage-deflate")) {
              failWebsocketConnection(this.ws, "Expected RSV1 to be clear.");
              return;
            }
            if (rsv2 !== 0 || rsv3 !== 0) {
              failWebsocketConnection(this.ws, "RSV1, RSV2, RSV3 must be clear");
              return;
            }
            if (fragmented && !isTextBinaryFrame(opcode)) {
              failWebsocketConnection(this.ws, "Invalid frame type was fragmented.");
              return;
            }
            if (isTextBinaryFrame(opcode) && __privateGet(this, _fragments).length > 0) {
              failWebsocketConnection(this.ws, "Expected continuation frame");
              return;
            }
            if (__privateGet(this, _info).fragmented && fragmented) {
              failWebsocketConnection(this.ws, "Fragmented frame exceeded 125 bytes.");
              return;
            }
            if ((payloadLength > 125 || fragmented) && isControlFrame(opcode)) {
              failWebsocketConnection(this.ws, "Control frame either too large or fragmented");
              return;
            }
            if (isContinuationFrame(opcode) && __privateGet(this, _fragments).length === 0 && !__privateGet(this, _info).compressed) {
              failWebsocketConnection(this.ws, "Unexpected continuation frame");
              return;
            }
            if (payloadLength <= 125) {
              __privateGet(this, _info).payloadLength = payloadLength;
              __privateSet(this, _state, parserStates.READ_DATA);
            } else if (payloadLength === 126) {
              __privateSet(this, _state, parserStates.PAYLOADLENGTH_16);
            } else if (payloadLength === 127) {
              __privateSet(this, _state, parserStates.PAYLOADLENGTH_64);
            }
            if (isTextBinaryFrame(opcode)) {
              __privateGet(this, _info).binaryType = opcode;
              __privateGet(this, _info).compressed = rsv1 !== 0;
            }
            __privateGet(this, _info).opcode = opcode;
            __privateGet(this, _info).masked = masked;
            __privateGet(this, _info).fin = fin;
            __privateGet(this, _info).fragmented = fragmented;
          } else if (__privateGet(this, _state) === parserStates.PAYLOADLENGTH_16) {
            if (__privateGet(this, _byteOffset) < 2) {
              return callback();
            }
            const buffer = this.consume(2);
            __privateGet(this, _info).payloadLength = buffer.readUInt16BE(0);
            __privateSet(this, _state, parserStates.READ_DATA);
          } else if (__privateGet(this, _state) === parserStates.PAYLOADLENGTH_64) {
            if (__privateGet(this, _byteOffset) < 8) {
              return callback();
            }
            const buffer = this.consume(8);
            const upper = buffer.readUInt32BE(0);
            if (upper > 2 ** 31 - 1) {
              failWebsocketConnection(this.ws, "Received payload length > 2^31 bytes.");
              return;
            }
            const lower = buffer.readUInt32BE(4);
            __privateGet(this, _info).payloadLength = (upper << 8) + lower;
            __privateSet(this, _state, parserStates.READ_DATA);
          } else if (__privateGet(this, _state) === parserStates.READ_DATA) {
            if (__privateGet(this, _byteOffset) < __privateGet(this, _info).payloadLength) {
              return callback();
            }
            const body = this.consume(__privateGet(this, _info).payloadLength);
            if (isControlFrame(__privateGet(this, _info).opcode)) {
              __privateSet(this, _loop, this.parseControlFrame(body));
              __privateSet(this, _state, parserStates.INFO);
            } else {
              if (!__privateGet(this, _info).compressed) {
                __privateGet(this, _fragments).push(body);
                if (!__privateGet(this, _info).fragmented && __privateGet(this, _info).fin) {
                  const fullMessage = Buffer.concat(__privateGet(this, _fragments));
                  websocketMessageReceived(this.ws, __privateGet(this, _info).binaryType, fullMessage);
                  __privateGet(this, _fragments).length = 0;
                }
                __privateSet(this, _state, parserStates.INFO);
              } else {
                __privateGet(this, _extensions).get("permessage-deflate").decompress(body, __privateGet(this, _info).fin, (error2, data) => {
                  if (error2) {
                    closeWebSocketConnection(this.ws, 1007, error2.message, error2.message.length);
                    return;
                  }
                  __privateGet(this, _fragments).push(data);
                  if (!__privateGet(this, _info).fin) {
                    __privateSet(this, _state, parserStates.INFO);
                    __privateSet(this, _loop, true);
                    this.run(callback);
                    return;
                  }
                  websocketMessageReceived(this.ws, __privateGet(this, _info).binaryType, Buffer.concat(__privateGet(this, _fragments)));
                  __privateSet(this, _loop, true);
                  __privateSet(this, _state, parserStates.INFO);
                  __privateGet(this, _fragments).length = 0;
                  this.run(callback);
                });
                __privateSet(this, _loop, false);
                break;
              }
            }
          }
        }
      }
      /**
       * Take n bytes from the buffered Buffers
       * @param {number} n
       * @returns {Buffer}
       */
      consume(n) {
        if (n > __privateGet(this, _byteOffset)) {
          throw new Error("Called consume() before buffers satiated.");
        } else if (n === 0) {
          return emptyBuffer;
        }
        if (__privateGet(this, _buffers)[0].length === n) {
          __privateSet(this, _byteOffset, __privateGet(this, _byteOffset) - __privateGet(this, _buffers)[0].length);
          return __privateGet(this, _buffers).shift();
        }
        const buffer = Buffer.allocUnsafe(n);
        let offset = 0;
        while (offset !== n) {
          const next = __privateGet(this, _buffers)[0];
          const { length } = next;
          if (length + offset === n) {
            buffer.set(__privateGet(this, _buffers).shift(), offset);
            break;
          } else if (length + offset > n) {
            buffer.set(next.subarray(0, n - offset), offset);
            __privateGet(this, _buffers)[0] = next.subarray(n - offset);
            break;
          } else {
            buffer.set(__privateGet(this, _buffers).shift(), offset);
            offset += next.length;
          }
        }
        __privateSet(this, _byteOffset, __privateGet(this, _byteOffset) - n);
        return buffer;
      }
      parseCloseBody(data) {
        assert(data.length !== 1);
        let code;
        if (data.length >= 2) {
          code = data.readUInt16BE(0);
        }
        if (code !== void 0 && !isValidStatusCode(code)) {
          return { code: 1002, reason: "Invalid status code", error: true };
        }
        let reason = data.subarray(2);
        if (reason[0] === 239 && reason[1] === 187 && reason[2] === 191) {
          reason = reason.subarray(3);
        }
        try {
          reason = utf8Decode(reason);
        } catch {
          return { code: 1007, reason: "Invalid UTF-8", error: true };
        }
        return { code, reason, error: false };
      }
      /**
       * Parses control frames.
       * @param {Buffer} body
       */
      parseControlFrame(body) {
        const { opcode, payloadLength } = __privateGet(this, _info);
        if (opcode === opcodes.CLOSE) {
          if (payloadLength === 1) {
            failWebsocketConnection(this.ws, "Received close frame with a 1-byte body.");
            return false;
          }
          __privateGet(this, _info).closeInfo = this.parseCloseBody(body);
          if (__privateGet(this, _info).closeInfo.error) {
            const { code, reason } = __privateGet(this, _info).closeInfo;
            closeWebSocketConnection(this.ws, code, reason, reason.length);
            failWebsocketConnection(this.ws, reason);
            return false;
          }
          if (this.ws[kSentClose] !== sentCloseFrameState.SENT) {
            let body2 = emptyBuffer;
            if (__privateGet(this, _info).closeInfo.code) {
              body2 = Buffer.allocUnsafe(2);
              body2.writeUInt16BE(__privateGet(this, _info).closeInfo.code, 0);
            }
            const closeFrame = new WebsocketFrameSend(body2);
            this.ws[kResponse].socket.write(
              closeFrame.createFrame(opcodes.CLOSE),
              (err) => {
                if (!err) {
                  this.ws[kSentClose] = sentCloseFrameState.SENT;
                }
              }
            );
          }
          this.ws[kReadyState] = states.CLOSING;
          this.ws[kReceivedClose] = true;
          return false;
        } else if (opcode === opcodes.PING) {
          if (!this.ws[kReceivedClose]) {
            const frame = new WebsocketFrameSend(body);
            this.ws[kResponse].socket.write(frame.createFrame(opcodes.PONG));
            if (channels.ping.hasSubscribers) {
              channels.ping.publish({
                payload: body
              });
            }
          }
        } else if (opcode === opcodes.PONG) {
          if (channels.pong.hasSubscribers) {
            channels.pong.publish({
              payload: body
            });
          }
        }
        return true;
      }
      get closingInfo() {
        return __privateGet(this, _info).closeInfo;
      }
    };
    _buffers = new WeakMap();
    _byteOffset = new WeakMap();
    _loop = new WeakMap();
    _state = new WeakMap();
    _info = new WeakMap();
    _fragments = new WeakMap();
    _extensions = new WeakMap();
    module2.exports = {
      ByteParser
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/websocket/sender.js
var require_sender = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/websocket/sender.js"(exports2, module2) {
    "use strict";
    var { WebsocketFrameSend } = require_frame();
    var { opcodes, sendHints } = require_constants5();
    var FixedQueue = require_fixed_queue();
    var FastBuffer = Buffer[Symbol.species];
    var _queue, _running, _socket, _SendQueue_instances, run_fn;
    var SendQueue = class {
      constructor(socket) {
        __privateAdd(this, _SendQueue_instances);
        /**
         * @type {FixedQueue}
         */
        __privateAdd(this, _queue, new FixedQueue());
        /**
         * @type {boolean}
         */
        __privateAdd(this, _running, false);
        /** @type {import('node:net').Socket} */
        __privateAdd(this, _socket);
        __privateSet(this, _socket, socket);
      }
      add(item, cb, hint) {
        if (hint !== sendHints.blob) {
          const frame = createFrame(item, hint);
          if (!__privateGet(this, _running)) {
            __privateGet(this, _socket).write(frame, cb);
          } else {
            const node2 = {
              promise: null,
              callback: cb,
              frame
            };
            __privateGet(this, _queue).push(node2);
          }
          return;
        }
        const node = {
          promise: item.arrayBuffer().then((ab) => {
            node.promise = null;
            node.frame = createFrame(ab, hint);
          }),
          callback: cb,
          frame: null
        };
        __privateGet(this, _queue).push(node);
        if (!__privateGet(this, _running)) {
          __privateMethod(this, _SendQueue_instances, run_fn).call(this);
        }
      }
    };
    _queue = new WeakMap();
    _running = new WeakMap();
    _socket = new WeakMap();
    _SendQueue_instances = new WeakSet();
    run_fn = async function() {
      __privateSet(this, _running, true);
      const queue = __privateGet(this, _queue);
      while (!queue.isEmpty()) {
        const node = queue.shift();
        if (node.promise !== null) {
          await node.promise;
        }
        __privateGet(this, _socket).write(node.frame, node.callback);
        node.callback = node.frame = null;
      }
      __privateSet(this, _running, false);
    };
    function createFrame(data, hint) {
      return new WebsocketFrameSend(toBuffer(data, hint)).createFrame(hint === sendHints.string ? opcodes.TEXT : opcodes.BINARY);
    }
    function toBuffer(data, hint) {
      switch (hint) {
        case sendHints.string:
          return Buffer.from(data);
        case sendHints.arrayBuffer:
        case sendHints.blob:
          return new FastBuffer(data);
        case sendHints.typedArray:
          return new FastBuffer(data.buffer, data.byteOffset, data.byteLength);
      }
    }
    module2.exports = { SendQueue };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/websocket/websocket.js
var require_websocket = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/websocket/websocket.js"(exports2, module2) {
    "use strict";
    var { webidl } = require_webidl();
    var { URLSerializer } = require_data_url();
    var { environmentSettingsObject } = require_util3();
    var { staticPropertyDescriptors, states, sentCloseFrameState, sendHints } = require_constants5();
    var {
      kWebSocketURL,
      kReadyState,
      kController,
      kBinaryType,
      kResponse,
      kSentClose,
      kByteParser
    } = require_symbols5();
    var {
      isConnecting,
      isEstablished,
      isClosing,
      isValidSubprotocol,
      fireEvent
    } = require_util8();
    var { establishWebSocketConnection, closeWebSocketConnection } = require_connection();
    var { ByteParser } = require_receiver();
    var { kEnumerableProperty, isBlobLike } = require_util2();
    var { getGlobalDispatcher } = require_global2();
    var { types } = require_node_util();
    var { ErrorEvent, CloseEvent } = require_events2();
    var { SendQueue } = require_sender();
    var _events, _bufferedAmount, _protocol, _extensions, _sendQueue, _WebSocket_instances, onConnectionEstablished_fn;
    var _WebSocket = class _WebSocket extends EventTarget {
      /**
       * @param {string} url
       * @param {string|string[]} protocols
       */
      constructor(url, protocols = []) {
        super();
        __privateAdd(this, _WebSocket_instances);
        __privateAdd(this, _events, {
          open: null,
          error: null,
          close: null,
          message: null
        });
        __privateAdd(this, _bufferedAmount, 0);
        __privateAdd(this, _protocol, "");
        __privateAdd(this, _extensions, "");
        /** @type {SendQueue} */
        __privateAdd(this, _sendQueue);
        webidl.util.markAsUncloneable(this);
        const prefix = "WebSocket constructor";
        webidl.argumentLengthCheck(arguments, 1, prefix);
        const options = webidl.converters["DOMString or sequence<DOMString> or WebSocketInit"](protocols, prefix, "options");
        url = webidl.converters.USVString(url, prefix, "url");
        protocols = options.protocols;
        const baseURL = environmentSettingsObject.settingsObject.baseUrl;
        let urlRecord;
        try {
          urlRecord = new URL(url, baseURL);
        } catch (e) {
          throw new DOMException(e, "SyntaxError");
        }
        if (urlRecord.protocol === "http:") {
          urlRecord.protocol = "ws:";
        } else if (urlRecord.protocol === "https:") {
          urlRecord.protocol = "wss:";
        }
        if (urlRecord.protocol !== "ws:" && urlRecord.protocol !== "wss:") {
          throw new DOMException(
            `Expected a ws: or wss: protocol, got ${urlRecord.protocol}`,
            "SyntaxError"
          );
        }
        if (urlRecord.hash || urlRecord.href.endsWith("#")) {
          throw new DOMException("Got fragment", "SyntaxError");
        }
        if (typeof protocols === "string") {
          protocols = [protocols];
        }
        if (protocols.length !== new Set(protocols.map((p) => p.toLowerCase())).size) {
          throw new DOMException("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
        }
        if (protocols.length > 0 && !protocols.every((p) => isValidSubprotocol(p))) {
          throw new DOMException("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
        }
        this[kWebSocketURL] = new URL(urlRecord.href);
        const client = environmentSettingsObject.settingsObject;
        this[kController] = establishWebSocketConnection(
          urlRecord,
          protocols,
          client,
          this,
          (response, extensions) => __privateMethod(this, _WebSocket_instances, onConnectionEstablished_fn).call(this, response, extensions),
          options
        );
        this[kReadyState] = _WebSocket.CONNECTING;
        this[kSentClose] = sentCloseFrameState.NOT_SENT;
        this[kBinaryType] = "blob";
      }
      /**
       * @see https://websockets.spec.whatwg.org/#dom-websocket-close
       * @param {number|undefined} code
       * @param {string|undefined} reason
       */
      close(code = void 0, reason = void 0) {
        webidl.brandCheck(this, _WebSocket);
        const prefix = "WebSocket.close";
        if (code !== void 0) {
          code = webidl.converters["unsigned short"](code, prefix, "code", { clamp: true });
        }
        if (reason !== void 0) {
          reason = webidl.converters.USVString(reason, prefix, "reason");
        }
        if (code !== void 0) {
          if (code !== 1e3 && (code < 3e3 || code > 4999)) {
            throw new DOMException("invalid code", "InvalidAccessError");
          }
        }
        let reasonByteLength = 0;
        if (reason !== void 0) {
          reasonByteLength = Buffer.byteLength(reason);
          if (reasonByteLength > 123) {
            throw new DOMException(
              `Reason must be less than 123 bytes; received ${reasonByteLength}`,
              "SyntaxError"
            );
          }
        }
        closeWebSocketConnection(this, code, reason, reasonByteLength);
      }
      /**
       * @see https://websockets.spec.whatwg.org/#dom-websocket-send
       * @param {NodeJS.TypedArray|ArrayBuffer|Blob|string} data
       */
      send(data) {
        webidl.brandCheck(this, _WebSocket);
        const prefix = "WebSocket.send";
        webidl.argumentLengthCheck(arguments, 1, prefix);
        data = webidl.converters.WebSocketSendData(data, prefix, "data");
        if (isConnecting(this)) {
          throw new DOMException("Sent before connected.", "InvalidStateError");
        }
        if (!isEstablished(this) || isClosing(this)) {
          return;
        }
        if (typeof data === "string") {
          const length = Buffer.byteLength(data);
          __privateSet(this, _bufferedAmount, __privateGet(this, _bufferedAmount) + length);
          __privateGet(this, _sendQueue).add(data, () => {
            __privateSet(this, _bufferedAmount, __privateGet(this, _bufferedAmount) - length);
          }, sendHints.string);
        } else if (types.isArrayBuffer(data)) {
          __privateSet(this, _bufferedAmount, __privateGet(this, _bufferedAmount) + data.byteLength);
          __privateGet(this, _sendQueue).add(data, () => {
            __privateSet(this, _bufferedAmount, __privateGet(this, _bufferedAmount) - data.byteLength);
          }, sendHints.arrayBuffer);
        } else if (ArrayBuffer.isView(data)) {
          __privateSet(this, _bufferedAmount, __privateGet(this, _bufferedAmount) + data.byteLength);
          __privateGet(this, _sendQueue).add(data, () => {
            __privateSet(this, _bufferedAmount, __privateGet(this, _bufferedAmount) - data.byteLength);
          }, sendHints.typedArray);
        } else if (isBlobLike(data)) {
          __privateSet(this, _bufferedAmount, __privateGet(this, _bufferedAmount) + data.size);
          __privateGet(this, _sendQueue).add(data, () => {
            __privateSet(this, _bufferedAmount, __privateGet(this, _bufferedAmount) - data.size);
          }, sendHints.blob);
        }
      }
      get readyState() {
        webidl.brandCheck(this, _WebSocket);
        return this[kReadyState];
      }
      get bufferedAmount() {
        webidl.brandCheck(this, _WebSocket);
        return __privateGet(this, _bufferedAmount);
      }
      get url() {
        webidl.brandCheck(this, _WebSocket);
        return URLSerializer(this[kWebSocketURL]);
      }
      get extensions() {
        webidl.brandCheck(this, _WebSocket);
        return __privateGet(this, _extensions);
      }
      get protocol() {
        webidl.brandCheck(this, _WebSocket);
        return __privateGet(this, _protocol);
      }
      get onopen() {
        webidl.brandCheck(this, _WebSocket);
        return __privateGet(this, _events).open;
      }
      set onopen(fn) {
        webidl.brandCheck(this, _WebSocket);
        if (__privateGet(this, _events).open) {
          this.removeEventListener("open", __privateGet(this, _events).open);
        }
        if (typeof fn === "function") {
          __privateGet(this, _events).open = fn;
          this.addEventListener("open", fn);
        } else {
          __privateGet(this, _events).open = null;
        }
      }
      get onerror() {
        webidl.brandCheck(this, _WebSocket);
        return __privateGet(this, _events).error;
      }
      set onerror(fn) {
        webidl.brandCheck(this, _WebSocket);
        if (__privateGet(this, _events).error) {
          this.removeEventListener("error", __privateGet(this, _events).error);
        }
        if (typeof fn === "function") {
          __privateGet(this, _events).error = fn;
          this.addEventListener("error", fn);
        } else {
          __privateGet(this, _events).error = null;
        }
      }
      get onclose() {
        webidl.brandCheck(this, _WebSocket);
        return __privateGet(this, _events).close;
      }
      set onclose(fn) {
        webidl.brandCheck(this, _WebSocket);
        if (__privateGet(this, _events).close) {
          this.removeEventListener("close", __privateGet(this, _events).close);
        }
        if (typeof fn === "function") {
          __privateGet(this, _events).close = fn;
          this.addEventListener("close", fn);
        } else {
          __privateGet(this, _events).close = null;
        }
      }
      get onmessage() {
        webidl.brandCheck(this, _WebSocket);
        return __privateGet(this, _events).message;
      }
      set onmessage(fn) {
        webidl.brandCheck(this, _WebSocket);
        if (__privateGet(this, _events).message) {
          this.removeEventListener("message", __privateGet(this, _events).message);
        }
        if (typeof fn === "function") {
          __privateGet(this, _events).message = fn;
          this.addEventListener("message", fn);
        } else {
          __privateGet(this, _events).message = null;
        }
      }
      get binaryType() {
        webidl.brandCheck(this, _WebSocket);
        return this[kBinaryType];
      }
      set binaryType(type) {
        webidl.brandCheck(this, _WebSocket);
        if (type !== "blob" && type !== "arraybuffer") {
          this[kBinaryType] = "blob";
        } else {
          this[kBinaryType] = type;
        }
      }
    };
    _events = new WeakMap();
    _bufferedAmount = new WeakMap();
    _protocol = new WeakMap();
    _extensions = new WeakMap();
    _sendQueue = new WeakMap();
    _WebSocket_instances = new WeakSet();
    /**
     * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol
     */
    onConnectionEstablished_fn = function(response, parsedExtensions) {
      this[kResponse] = response;
      const parser = new ByteParser(this, parsedExtensions);
      parser.on("drain", onParserDrain);
      parser.on("error", onParserError.bind(this));
      response.socket.ws = this;
      this[kByteParser] = parser;
      __privateSet(this, _sendQueue, new SendQueue(response.socket));
      this[kReadyState] = states.OPEN;
      const extensions = response.headersList.get("sec-websocket-extensions");
      if (extensions !== null) {
        __privateSet(this, _extensions, extensions);
      }
      const protocol = response.headersList.get("sec-websocket-protocol");
      if (protocol !== null) {
        __privateSet(this, _protocol, protocol);
      }
      fireEvent("open", this);
    };
    var WebSocket = _WebSocket;
    WebSocket.CONNECTING = WebSocket.prototype.CONNECTING = states.CONNECTING;
    WebSocket.OPEN = WebSocket.prototype.OPEN = states.OPEN;
    WebSocket.CLOSING = WebSocket.prototype.CLOSING = states.CLOSING;
    WebSocket.CLOSED = WebSocket.prototype.CLOSED = states.CLOSED;
    Object.defineProperties(WebSocket.prototype, {
      CONNECTING: staticPropertyDescriptors,
      OPEN: staticPropertyDescriptors,
      CLOSING: staticPropertyDescriptors,
      CLOSED: staticPropertyDescriptors,
      url: kEnumerableProperty,
      readyState: kEnumerableProperty,
      bufferedAmount: kEnumerableProperty,
      onopen: kEnumerableProperty,
      onerror: kEnumerableProperty,
      onclose: kEnumerableProperty,
      close: kEnumerableProperty,
      onmessage: kEnumerableProperty,
      binaryType: kEnumerableProperty,
      send: kEnumerableProperty,
      extensions: kEnumerableProperty,
      protocol: kEnumerableProperty,
      [Symbol.toStringTag]: {
        value: "WebSocket",
        writable: false,
        enumerable: false,
        configurable: true
      }
    });
    Object.defineProperties(WebSocket, {
      CONNECTING: staticPropertyDescriptors,
      OPEN: staticPropertyDescriptors,
      CLOSING: staticPropertyDescriptors,
      CLOSED: staticPropertyDescriptors
    });
    webidl.converters["sequence<DOMString>"] = webidl.sequenceConverter(
      webidl.converters.DOMString
    );
    webidl.converters["DOMString or sequence<DOMString>"] = function(V, prefix, argument) {
      if (webidl.util.Type(V) === "Object" && Symbol.iterator in V) {
        return webidl.converters["sequence<DOMString>"](V);
      }
      return webidl.converters.DOMString(V, prefix, argument);
    };
    webidl.converters.WebSocketInit = webidl.dictionaryConverter([
      {
        key: "protocols",
        converter: webidl.converters["DOMString or sequence<DOMString>"],
        defaultValue: () => new Array(0)
      },
      {
        key: "dispatcher",
        converter: webidl.converters.any,
        defaultValue: () => getGlobalDispatcher()
      },
      {
        key: "headers",
        converter: webidl.nullableConverter(webidl.converters.HeadersInit)
      }
    ]);
    webidl.converters["DOMString or sequence<DOMString> or WebSocketInit"] = function(V) {
      if (webidl.util.Type(V) === "Object" && !(Symbol.iterator in V)) {
        return webidl.converters.WebSocketInit(V);
      }
      return { protocols: webidl.converters["DOMString or sequence<DOMString>"](V) };
    };
    webidl.converters.WebSocketSendData = function(V) {
      if (webidl.util.Type(V) === "Object") {
        if (isBlobLike(V)) {
          return webidl.converters.Blob(V, { strict: false });
        }
        if (ArrayBuffer.isView(V) || types.isArrayBuffer(V)) {
          return webidl.converters.BufferSource(V);
        }
      }
      return webidl.converters.USVString(V);
    };
    function onParserDrain() {
      this.ws[kResponse].socket.resume();
    }
    function onParserError(err) {
      let message;
      let code;
      if (err instanceof CloseEvent) {
        message = err.reason;
        code = err.code;
      } else {
        message = err.message;
      }
      fireEvent("error", this, () => new ErrorEvent("error", { error: err, message }));
      closeWebSocketConnection(this, code);
    }
    module2.exports = {
      WebSocket
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/eventsource/util.js
var require_util9 = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/eventsource/util.js"(exports2, module2) {
    "use strict";
    function isValidLastEventId(value) {
      return value.indexOf("\0") === -1;
    }
    function isASCIINumber(value) {
      if (value.length === 0) return false;
      for (let i = 0; i < value.length; i++) {
        if (value.charCodeAt(i) < 48 || value.charCodeAt(i) > 57) return false;
      }
      return true;
    }
    function delay(ms) {
      return new Promise((resolve) => {
        setTimeout(resolve, ms).unref();
      });
    }
    module2.exports = {
      isValidLastEventId,
      isASCIINumber,
      delay
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/eventsource/eventsource-stream.js
var require_eventsource_stream = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/eventsource/eventsource-stream.js"(exports2, module2) {
    "use strict";
    var { Transform } = require_node_stream();
    var { isASCIINumber, isValidLastEventId } = require_util9();
    var BOM = [239, 187, 191];
    var LF = 10;
    var CR = 13;
    var COLON = 58;
    var SPACE = 32;
    var EventSourceStream = class extends Transform {
      /**
       * @param {object} options
       * @param {eventSourceSettings} options.eventSourceSettings
       * @param {Function} [options.push]
       */
      constructor(options = {}) {
        options.readableObjectMode = true;
        super(options);
        /**
         * @type {eventSourceSettings}
         */
        __publicField(this, "state", null);
        /**
         * Leading byte-order-mark check.
         * @type {boolean}
         */
        __publicField(this, "checkBOM", true);
        /**
         * @type {boolean}
         */
        __publicField(this, "crlfCheck", false);
        /**
         * @type {boolean}
         */
        __publicField(this, "eventEndCheck", false);
        /**
         * @type {Buffer}
         */
        __publicField(this, "buffer", null);
        __publicField(this, "pos", 0);
        __publicField(this, "event", {
          data: void 0,
          event: void 0,
          id: void 0,
          retry: void 0
        });
        this.state = options.eventSourceSettings || {};
        if (options.push) {
          this.push = options.push;
        }
      }
      /**
       * @param {Buffer} chunk
       * @param {string} _encoding
       * @param {Function} callback
       * @returns {void}
       */
      _transform(chunk, _encoding, callback) {
        if (chunk.length === 0) {
          callback();
          return;
        }
        if (this.buffer) {
          this.buffer = Buffer.concat([this.buffer, chunk]);
        } else {
          this.buffer = chunk;
        }
        if (this.checkBOM) {
          switch (this.buffer.length) {
            case 1:
              if (this.buffer[0] === BOM[0]) {
                callback();
                return;
              }
              this.checkBOM = false;
              callback();
              return;
            case 2:
              if (this.buffer[0] === BOM[0] && this.buffer[1] === BOM[1]) {
                callback();
                return;
              }
              this.checkBOM = false;
              break;
            case 3:
              if (this.buffer[0] === BOM[0] && this.buffer[1] === BOM[1] && this.buffer[2] === BOM[2]) {
                this.buffer = Buffer.alloc(0);
                this.checkBOM = false;
                callback();
                return;
              }
              this.checkBOM = false;
              break;
            default:
              if (this.buffer[0] === BOM[0] && this.buffer[1] === BOM[1] && this.buffer[2] === BOM[2]) {
                this.buffer = this.buffer.subarray(3);
              }
              this.checkBOM = false;
              break;
          }
        }
        while (this.pos < this.buffer.length) {
          if (this.eventEndCheck) {
            if (this.crlfCheck) {
              if (this.buffer[this.pos] === LF) {
                this.buffer = this.buffer.subarray(this.pos + 1);
                this.pos = 0;
                this.crlfCheck = false;
                continue;
              }
              this.crlfCheck = false;
            }
            if (this.buffer[this.pos] === LF || this.buffer[this.pos] === CR) {
              if (this.buffer[this.pos] === CR) {
                this.crlfCheck = true;
              }
              this.buffer = this.buffer.subarray(this.pos + 1);
              this.pos = 0;
              if (this.event.data !== void 0 || this.event.event || this.event.id || this.event.retry) {
                this.processEvent(this.event);
              }
              this.clearEvent();
              continue;
            }
            this.eventEndCheck = false;
            continue;
          }
          if (this.buffer[this.pos] === LF || this.buffer[this.pos] === CR) {
            if (this.buffer[this.pos] === CR) {
              this.crlfCheck = true;
            }
            this.parseLine(this.buffer.subarray(0, this.pos), this.event);
            this.buffer = this.buffer.subarray(this.pos + 1);
            this.pos = 0;
            this.eventEndCheck = true;
            continue;
          }
          this.pos++;
        }
        callback();
      }
      /**
       * @param {Buffer} line
       * @param {EventStreamEvent} event
       */
      parseLine(line, event) {
        if (line.length === 0) {
          return;
        }
        const colonPosition = line.indexOf(COLON);
        if (colonPosition === 0) {
          return;
        }
        let field = "";
        let value = "";
        if (colonPosition !== -1) {
          field = line.subarray(0, colonPosition).toString("utf8");
          let valueStart = colonPosition + 1;
          if (line[valueStart] === SPACE) {
            ++valueStart;
          }
          value = line.subarray(valueStart).toString("utf8");
        } else {
          field = line.toString("utf8");
          value = "";
        }
        switch (field) {
          case "data":
            if (event[field] === void 0) {
              event[field] = value;
            } else {
              event[field] += `
${value}`;
            }
            break;
          case "retry":
            if (isASCIINumber(value)) {
              event[field] = value;
            }
            break;
          case "id":
            if (isValidLastEventId(value)) {
              event[field] = value;
            }
            break;
          case "event":
            if (value.length > 0) {
              event[field] = value;
            }
            break;
        }
      }
      /**
       * @param {EventSourceStreamEvent} event
       */
      processEvent(event) {
        if (event.retry && isASCIINumber(event.retry)) {
          this.state.reconnectionTime = parseInt(event.retry, 10);
        }
        if (event.id && isValidLastEventId(event.id)) {
          this.state.lastEventId = event.id;
        }
        if (event.data !== void 0) {
          this.push({
            type: event.event || "message",
            options: {
              data: event.data,
              lastEventId: this.state.lastEventId,
              origin: this.state.origin
            }
          });
        }
      }
      clearEvent() {
        this.event = {
          data: void 0,
          event: void 0,
          id: void 0,
          retry: void 0
        };
      }
    };
    module2.exports = {
      EventSourceStream
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/eventsource/eventsource.js
var require_eventsource = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/lib/web/eventsource/eventsource.js"(exports2, module2) {
    "use strict";
    var { pipeline } = require_node_stream();
    var { fetching } = require_fetch();
    var { makeRequest } = require_request2();
    var { webidl } = require_webidl();
    var { EventSourceStream } = require_eventsource_stream();
    var { parseMIMEType } = require_data_url();
    var { createFastMessageEvent } = require_events2();
    var { isNetworkError } = require_response();
    var { delay } = require_util9();
    var { kEnumerableProperty } = require_util2();
    var { environmentSettingsObject } = require_util3();
    var experimentalWarned = false;
    var defaultReconnectionTime = 3e3;
    var CONNECTING = 0;
    var OPEN = 1;
    var CLOSED = 2;
    var ANONYMOUS = "anonymous";
    var USE_CREDENTIALS = "use-credentials";
    var _events, _url, _withCredentials, _readyState, _request, _controller, _dispatcher, _state, _EventSource_instances, connect_fn, reconnect_fn;
    var _EventSource = class _EventSource extends EventTarget {
      /**
       * Creates a new EventSource object.
       * @param {string} url
       * @param {EventSourceInit} [eventSourceInitDict]
       * @see https://html.spec.whatwg.org/multipage/server-sent-events.html#the-eventsource-interface
       */
      constructor(url, eventSourceInitDict = {}) {
        super();
        __privateAdd(this, _EventSource_instances);
        __privateAdd(this, _events, {
          open: null,
          error: null,
          message: null
        });
        __privateAdd(this, _url, null);
        __privateAdd(this, _withCredentials, false);
        __privateAdd(this, _readyState, CONNECTING);
        __privateAdd(this, _request, null);
        __privateAdd(this, _controller, null);
        __privateAdd(this, _dispatcher);
        /**
         * @type {import('./eventsource-stream').eventSourceSettings}
         */
        __privateAdd(this, _state);
        webidl.util.markAsUncloneable(this);
        const prefix = "EventSource constructor";
        webidl.argumentLengthCheck(arguments, 1, prefix);
        if (!experimentalWarned) {
          experimentalWarned = true;
          process.emitWarning("EventSource is experimental, expect them to change at any time.", {
            code: "UNDICI-ES"
          });
        }
        url = webidl.converters.USVString(url, prefix, "url");
        eventSourceInitDict = webidl.converters.EventSourceInitDict(eventSourceInitDict, prefix, "eventSourceInitDict");
        __privateSet(this, _dispatcher, eventSourceInitDict.dispatcher);
        __privateSet(this, _state, {
          lastEventId: "",
          reconnectionTime: defaultReconnectionTime
        });
        const settings = environmentSettingsObject;
        let urlRecord;
        try {
          urlRecord = new URL(url, settings.settingsObject.baseUrl);
          __privateGet(this, _state).origin = urlRecord.origin;
        } catch (e) {
          throw new DOMException(e, "SyntaxError");
        }
        __privateSet(this, _url, urlRecord.href);
        let corsAttributeState = ANONYMOUS;
        if (eventSourceInitDict.withCredentials) {
          corsAttributeState = USE_CREDENTIALS;
          __privateSet(this, _withCredentials, true);
        }
        const initRequest = {
          redirect: "follow",
          keepalive: true,
          // @see https://html.spec.whatwg.org/multipage/urls-and-fetching.html#cors-settings-attributes
          mode: "cors",
          credentials: corsAttributeState === "anonymous" ? "same-origin" : "omit",
          referrer: "no-referrer"
        };
        initRequest.client = environmentSettingsObject.settingsObject;
        initRequest.headersList = [["accept", { name: "accept", value: "text/event-stream" }]];
        initRequest.cache = "no-store";
        initRequest.initiator = "other";
        initRequest.urlList = [new URL(__privateGet(this, _url))];
        __privateSet(this, _request, makeRequest(initRequest));
        __privateMethod(this, _EventSource_instances, connect_fn).call(this);
      }
      /**
       * Returns the state of this EventSource object's connection. It can have the
       * values described below.
       * @returns {0|1|2}
       * @readonly
       */
      get readyState() {
        return __privateGet(this, _readyState);
      }
      /**
       * Returns the URL providing the event stream.
       * @readonly
       * @returns {string}
       */
      get url() {
        return __privateGet(this, _url);
      }
      /**
       * Returns a boolean indicating whether the EventSource object was
       * instantiated with CORS credentials set (true), or not (false, the default).
       */
      get withCredentials() {
        return __privateGet(this, _withCredentials);
      }
      /**
       * Closes the connection, if any, and sets the readyState attribute to
       * CLOSED.
       */
      close() {
        webidl.brandCheck(this, _EventSource);
        if (__privateGet(this, _readyState) === CLOSED) return;
        __privateSet(this, _readyState, CLOSED);
        __privateGet(this, _controller).abort();
        __privateSet(this, _request, null);
      }
      get onopen() {
        return __privateGet(this, _events).open;
      }
      set onopen(fn) {
        if (__privateGet(this, _events).open) {
          this.removeEventListener("open", __privateGet(this, _events).open);
        }
        if (typeof fn === "function") {
          __privateGet(this, _events).open = fn;
          this.addEventListener("open", fn);
        } else {
          __privateGet(this, _events).open = null;
        }
      }
      get onmessage() {
        return __privateGet(this, _events).message;
      }
      set onmessage(fn) {
        if (__privateGet(this, _events).message) {
          this.removeEventListener("message", __privateGet(this, _events).message);
        }
        if (typeof fn === "function") {
          __privateGet(this, _events).message = fn;
          this.addEventListener("message", fn);
        } else {
          __privateGet(this, _events).message = null;
        }
      }
      get onerror() {
        return __privateGet(this, _events).error;
      }
      set onerror(fn) {
        if (__privateGet(this, _events).error) {
          this.removeEventListener("error", __privateGet(this, _events).error);
        }
        if (typeof fn === "function") {
          __privateGet(this, _events).error = fn;
          this.addEventListener("error", fn);
        } else {
          __privateGet(this, _events).error = null;
        }
      }
    };
    _events = new WeakMap();
    _url = new WeakMap();
    _withCredentials = new WeakMap();
    _readyState = new WeakMap();
    _request = new WeakMap();
    _controller = new WeakMap();
    _dispatcher = new WeakMap();
    _state = new WeakMap();
    _EventSource_instances = new WeakSet();
    connect_fn = function() {
      if (__privateGet(this, _readyState) === CLOSED) return;
      __privateSet(this, _readyState, CONNECTING);
      const fetchParams = {
        request: __privateGet(this, _request),
        dispatcher: __privateGet(this, _dispatcher)
      };
      const processEventSourceEndOfBody = (response) => {
        if (isNetworkError(response)) {
          this.dispatchEvent(new Event("error"));
          this.close();
        }
        __privateMethod(this, _EventSource_instances, reconnect_fn).call(this);
      };
      fetchParams.processResponseEndOfBody = processEventSourceEndOfBody;
      fetchParams.processResponse = (response) => {
        if (isNetworkError(response)) {
          if (response.aborted) {
            this.close();
            this.dispatchEvent(new Event("error"));
            return;
          } else {
            __privateMethod(this, _EventSource_instances, reconnect_fn).call(this);
            return;
          }
        }
        const contentType = response.headersList.get("content-type", true);
        const mimeType = contentType !== null ? parseMIMEType(contentType) : "failure";
        const contentTypeValid = mimeType !== "failure" && mimeType.essence === "text/event-stream";
        if (response.status !== 200 || contentTypeValid === false) {
          this.close();
          this.dispatchEvent(new Event("error"));
          return;
        }
        __privateSet(this, _readyState, OPEN);
        this.dispatchEvent(new Event("open"));
        __privateGet(this, _state).origin = response.urlList[response.urlList.length - 1].origin;
        const eventSourceStream = new EventSourceStream({
          eventSourceSettings: __privateGet(this, _state),
          push: (event) => {
            this.dispatchEvent(createFastMessageEvent(
              event.type,
              event.options
            ));
          }
        });
        pipeline(
          response.body.stream,
          eventSourceStream,
          (error2) => {
            if ((error2 == null ? void 0 : error2.aborted) === false) {
              this.close();
              this.dispatchEvent(new Event("error"));
            }
          }
        );
      };
      __privateSet(this, _controller, fetching(fetchParams));
    };
    reconnect_fn = async function() {
      if (__privateGet(this, _readyState) === CLOSED) return;
      __privateSet(this, _readyState, CONNECTING);
      this.dispatchEvent(new Event("error"));
      await delay(__privateGet(this, _state).reconnectionTime);
      if (__privateGet(this, _readyState) !== CONNECTING) return;
      if (__privateGet(this, _state).lastEventId.length) {
        __privateGet(this, _request).headersList.set("last-event-id", __privateGet(this, _state).lastEventId, true);
      }
      __privateMethod(this, _EventSource_instances, connect_fn).call(this);
    };
    var EventSource = _EventSource;
    var constantsPropertyDescriptors = {
      CONNECTING: {
        __proto__: null,
        configurable: false,
        enumerable: true,
        value: CONNECTING,
        writable: false
      },
      OPEN: {
        __proto__: null,
        configurable: false,
        enumerable: true,
        value: OPEN,
        writable: false
      },
      CLOSED: {
        __proto__: null,
        configurable: false,
        enumerable: true,
        value: CLOSED,
        writable: false
      }
    };
    Object.defineProperties(EventSource, constantsPropertyDescriptors);
    Object.defineProperties(EventSource.prototype, constantsPropertyDescriptors);
    Object.defineProperties(EventSource.prototype, {
      close: kEnumerableProperty,
      onerror: kEnumerableProperty,
      onmessage: kEnumerableProperty,
      onopen: kEnumerableProperty,
      readyState: kEnumerableProperty,
      url: kEnumerableProperty,
      withCredentials: kEnumerableProperty
    });
    webidl.converters.EventSourceInitDict = webidl.dictionaryConverter([
      {
        key: "withCredentials",
        converter: webidl.converters.boolean,
        defaultValue: () => false
      },
      {
        key: "dispatcher",
        // undici only
        converter: webidl.converters.any
      }
    ]);
    module2.exports = {
      EventSource,
      defaultReconnectionTime
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/undici/index.js
var require_undici = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/undici/index.js"(exports2, module2) {
    "use strict";
    var Client2 = require_client();
    var Dispatcher = require_dispatcher();
    var Pool = require_pool();
    var BalancedPool = require_balanced_pool();
    var Agent = require_agent();
    var ProxyAgent = require_proxy_agent();
    var EnvHttpProxyAgent = require_env_http_proxy_agent();
    var RetryAgent = require_retry_agent();
    var errors2 = require_errors();
    var util = require_util2();
    var { InvalidArgumentError } = errors2;
    var api = require_api();
    var buildConnector = require_connect();
    var MockClient = require_mock_client();
    var MockAgent = require_mock_agent();
    var MockPool = require_mock_pool();
    var mockErrors = require_mock_errors();
    var RetryHandler = require_retry_handler();
    var { getGlobalDispatcher, setGlobalDispatcher } = require_global2();
    var DecoratorHandler = require_decorator_handler();
    var RedirectHandler = require_redirect_handler();
    var createRedirectInterceptor = require_redirect_interceptor();
    Object.assign(Dispatcher.prototype, api);
    module2.exports.Dispatcher = Dispatcher;
    module2.exports.Client = Client2;
    module2.exports.Pool = Pool;
    module2.exports.BalancedPool = BalancedPool;
    module2.exports.Agent = Agent;
    module2.exports.ProxyAgent = ProxyAgent;
    module2.exports.EnvHttpProxyAgent = EnvHttpProxyAgent;
    module2.exports.RetryAgent = RetryAgent;
    module2.exports.RetryHandler = RetryHandler;
    module2.exports.DecoratorHandler = DecoratorHandler;
    module2.exports.RedirectHandler = RedirectHandler;
    module2.exports.createRedirectInterceptor = createRedirectInterceptor;
    module2.exports.interceptors = {
      redirect: require_redirect(),
      retry: require_retry(),
      dump: require_dump()
    };
    module2.exports.buildConnector = buildConnector;
    module2.exports.errors = errors2;
    module2.exports.util = {
      parseHeaders: util.parseHeaders,
      headerNameToString: util.headerNameToString
    };
    function makeDispatcher(fn) {
      return (url, opts, handler) => {
        if (typeof opts === "function") {
          handler = opts;
          opts = null;
        }
        if (!url || typeof url !== "string" && typeof url !== "object" && !(url instanceof URL)) {
          throw new InvalidArgumentError("invalid url");
        }
        if (opts != null && typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        if (opts && opts.path != null) {
          if (typeof opts.path !== "string") {
            throw new InvalidArgumentError("invalid opts.path");
          }
          let path = opts.path;
          if (!opts.path.startsWith("/")) {
            path = `/${path}`;
          }
          url = new URL(util.parseOrigin(url).origin + path);
        } else {
          if (!opts) {
            opts = typeof url === "object" ? url : {};
          }
          url = util.parseURL(url);
        }
        const { agent, dispatcher = getGlobalDispatcher() } = opts;
        if (agent) {
          throw new InvalidArgumentError("unsupported opts.agent. Did you mean opts.client?");
        }
        return fn.call(dispatcher, {
          ...opts,
          origin: url.origin,
          path: url.search ? `${url.pathname}${url.search}` : url.pathname,
          method: opts.method || (opts.body ? "PUT" : "GET")
        }, handler);
      };
    }
    module2.exports.setGlobalDispatcher = setGlobalDispatcher;
    module2.exports.getGlobalDispatcher = getGlobalDispatcher;
    var fetchImpl = require_fetch().fetch;
    module2.exports.fetch = async function fetch(init, options = void 0) {
      try {
        return await fetchImpl(init, options);
      } catch (err) {
        if (err && typeof err === "object") {
          Error.captureStackTrace(err);
        }
        throw err;
      }
    };
    module2.exports.Headers = require_headers().Headers;
    module2.exports.Response = require_response().Response;
    module2.exports.Request = require_request2().Request;
    module2.exports.FormData = require_formdata().FormData;
    module2.exports.File = globalThis.File ?? require_node_buffer().File;
    module2.exports.FileReader = require_filereader().FileReader;
    var { setGlobalOrigin, getGlobalOrigin } = require_global();
    module2.exports.setGlobalOrigin = setGlobalOrigin;
    module2.exports.getGlobalOrigin = getGlobalOrigin;
    var { CacheStorage } = require_cachestorage();
    var { kConstruct } = require_symbols4();
    module2.exports.caches = new CacheStorage(kConstruct);
    var { deleteCookie, getCookies, getSetCookies, setCookie } = require_cookies();
    module2.exports.deleteCookie = deleteCookie;
    module2.exports.getCookies = getCookies;
    module2.exports.getSetCookies = getSetCookies;
    module2.exports.setCookie = setCookie;
    var { parseMIMEType, serializeAMimeType } = require_data_url();
    module2.exports.parseMIMEType = parseMIMEType;
    module2.exports.serializeAMimeType = serializeAMimeType;
    var { CloseEvent, ErrorEvent, MessageEvent } = require_events2();
    module2.exports.WebSocket = require_websocket().WebSocket;
    module2.exports.CloseEvent = CloseEvent;
    module2.exports.ErrorEvent = ErrorEvent;
    module2.exports.MessageEvent = MessageEvent;
    module2.exports.request = makeDispatcher(api.request);
    module2.exports.stream = makeDispatcher(api.stream);
    module2.exports.pipeline = makeDispatcher(api.pipeline);
    module2.exports.connect = makeDispatcher(api.connect);
    module2.exports.upgrade = makeDispatcher(api.upgrade);
    module2.exports.MockClient = MockClient;
    module2.exports.MockPool = MockPool;
    module2.exports.MockAgent = MockAgent;
    module2.exports.mockErrors = mockErrors;
    var { EventSource } = require_eventsource();
    module2.exports.EventSource = EventSource;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/errors/DJSError.js
var require_DJSError = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/errors/DJSError.js"(exports2, module2) {
    "use strict";
    var kCode = Symbol("code");
    var messages = /* @__PURE__ */ new Map();
    function makeDiscordjsError(Base) {
      return class DiscordjsError extends Base {
        constructor(key, ...args) {
          super(message(key, args));
          this[kCode] = key;
          if (Error.captureStackTrace) Error.captureStackTrace(this, DiscordjsError);
        }
        get name() {
          return `${super.name} [${this[kCode]}]`;
        }
        get code() {
          return this[kCode];
        }
      };
    }
    function message(key, args) {
      if (typeof key !== "string") throw new Error("Error message key must be a string");
      const msg = messages.get(key);
      if (!msg) throw new Error(`An invalid error message key was used: ${key}.`);
      if (typeof msg === "function") return msg(...args);
      if (!(args == null ? void 0 : args.length)) return msg;
      args.unshift(msg);
      return String(...args);
    }
    function register(sym, val) {
      messages.set(sym, typeof val === "function" ? val : String(val));
    }
    module2.exports = {
      register,
      Error: makeDiscordjsError(Error),
      TypeError: makeDiscordjsError(TypeError),
      RangeError: makeDiscordjsError(RangeError)
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/errors/Messages.js
var require_Messages = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/errors/Messages.js"() {
    "use strict";
    var { register } = require_DJSError();
    var Messages = {
      CLIENT_INVALID_OPTION: (prop, must) => `The ${prop} option must be ${must}`,
      CLIENT_INVALID_PROVIDED_SHARDS: "None of the provided shards were valid.",
      CLIENT_MISSING_INTENTS: "Valid intents must be provided for the Client.",
      CLIENT_NOT_READY: (action) => `The client needs to be logged in to ${action}.`,
      TOKEN_INVALID: "An invalid token was provided.",
      TOKEN_MISSING: "Request to use token, but token was unavailable to the client.",
      WS_CLOSE_REQUESTED: "WebSocket closed due to user request.",
      WS_CONNECTION_EXISTS: "There is already an existing WebSocket connection.",
      WS_NOT_OPEN: (data = "data") => `WebSocket not open to send ${data}`,
      MANAGER_DESTROYED: "Manager was destroyed.",
      BITFIELD_INVALID: (bit) => `Invalid bitfield flag or number: ${bit}.`,
      SHARDING_INVALID: "[Bot Token] Invalid shard settings were provided.",
      SHARDING_REQUIRED: "[Bot Token] This session would have handled too many guilds - Sharding is required.",
      INVALID_INTENTS: "[Bot Token] Invalid intent provided for WebSocket intents.",
      DISALLOWED_INTENTS: "[Bot Token] Privileged intent provided is not enabled or whitelisted.",
      SHARDING_NO_SHARDS: "No shards have been spawned.",
      SHARDING_IN_PROCESS: "Shards are still being spawned.",
      SHARDING_INVALID_EVAL_BROADCAST: "Script to evaluate must be a function",
      SHARDING_SHARD_NOT_FOUND: (id) => `Shard ${id} could not be found.`,
      SHARDING_ALREADY_SPAWNED: (count) => `Already spawned ${count} shards.`,
      SHARDING_PROCESS_EXISTS: (id) => `Shard ${id} already has an active process.`,
      SHARDING_WORKER_EXISTS: (id) => `Shard ${id} already has an active worker.`,
      SHARDING_READY_TIMEOUT: (id) => `Shard ${id}'s Client took too long to become ready.`,
      SHARDING_READY_DISCONNECTED: (id) => `Shard ${id}'s Client disconnected before becoming ready.`,
      SHARDING_READY_DIED: (id) => `Shard ${id}'s process exited before its Client became ready.`,
      SHARDING_NO_CHILD_EXISTS: (id) => `Shard ${id} has no active process or worker.`,
      SHARDING_SHARD_MISCALCULATION: (shard, guild, count) => `Calculated invalid shard ${shard} for guild ${guild} with ${count} shards.`,
      COLOR_RANGE: "Color must be within the range 0 - 16777215 (0xFFFFFF).",
      COLOR_CONVERT: "Unable to convert color to a number.",
      INVITE_OPTIONS_MISSING_CHANNEL: "A valid guild channel must be provided when GuildScheduledEvent is EXTERNAL.",
      EMBED_TITLE: "MessageEmbed title must be a string.",
      EMBED_FIELD_NAME: "MessageEmbed field names must be non-empty strings.",
      EMBED_FIELD_VALUE: "MessageEmbed field values must be non-empty strings.",
      EMBED_FOOTER_TEXT: "MessageEmbed footer text must be a string.",
      EMBED_DESCRIPTION: "MessageEmbed description must be a string.",
      EMBED_AUTHOR_NAME: "MessageEmbed author name must be a string.",
      BUTTON_LABEL: "MessageButton label must be a string",
      BUTTON_URL: "MessageButton URL must be a string",
      BUTTON_CUSTOM_ID: "MessageButton customId must be a string",
      SELECT_MENU_CUSTOM_ID: "MessageSelectMenu customId must be a string",
      SELECT_MENU_PLACEHOLDER: "MessageSelectMenu placeholder must be a string",
      SELECT_OPTION_LABEL: "MessageSelectOption label must be a string",
      SELECT_OPTION_VALUE: "MessageSelectOption value must be a string",
      SELECT_OPTION_DESCRIPTION: "MessageSelectOption description must be a string",
      TEXT_INPUT_CUSTOM_ID: "TextInputComponent customId must be a string",
      TEXT_INPUT_LABEL: "TextInputComponent label must be a string",
      TEXT_INPUT_PLACEHOLDER: "TextInputComponent placeholder must be a string",
      TEXT_INPUT_VALUE: "TextInputComponent value must be a string",
      MODAL_CUSTOM_ID: "Modal customId must be a string",
      MODAL_TITLE: "Modal title must be a string",
      INTERACTION_COLLECTOR_ERROR: (reason) => `Collector received no interactions before ending with reason: ${reason}`,
      FILE_NOT_FOUND: (file) => `File could not be found: ${file}`,
      USER_BANNER_NOT_FETCHED: "You must fetch this user's banner before trying to generate its URL!",
      USER_NO_DM_CHANNEL: "No DM Channel exists!",
      VOICE_NOT_STAGE_CHANNEL: "You are only allowed to do this in stage channels.",
      VOICE_STATE_NOT_OWN: "You cannot self-deafen/mute/request to speak on VoiceStates that do not belong to the ClientUser.",
      VOICE_STATE_INVALID_TYPE: (name) => `${name} must be a boolean.`,
      REQ_RESOURCE_TYPE: "The resource must be a string, Buffer or a valid file stream.",
      IMAGE_FORMAT: (format) => `Invalid image format: ${format}`,
      IMAGE_SIZE: (size) => `Invalid image size: ${size}`,
      MESSAGE_BULK_DELETE_TYPE: "The messages must be an Array, Collection, or number.",
      MESSAGE_NONCE_TYPE: "Message nonce must be an integer or a string.",
      MESSAGE_CONTENT_TYPE: "Message content must be a non-empty string.",
      SPLIT_MAX_LEN: "Chunk exceeds the max length and contains no split characters.",
      BAN_RESOLVE_ID: (ban = false) => `Couldn't resolve the user id to ${ban ? "ban" : "unban"}.`,
      FETCH_BAN_RESOLVE_ID: "Couldn't resolve the user id to fetch the ban.",
      PRUNE_DAYS_TYPE: "Days must be a number",
      GUILD_CHANNEL_RESOLVE: "Could not resolve channel to a guild channel.",
      GUILD_VOICE_CHANNEL_RESOLVE: "Could not resolve channel to a guild voice channel.",
      GUILD_CHANNEL_ORPHAN: "Could not find a parent to this guild channel.",
      GUILD_CHANNEL_UNOWNED: "The fetched channel does not belong to this manager's guild.",
      GUILD_OWNED: "Guild is owned by the client.",
      GUILD_MEMBERS_TIMEOUT: "Members didn't arrive in time.",
      GUILD_UNCACHED_ME: "The client user as a member of this guild is uncached.",
      CHANNEL_NOT_CACHED: "Could not find the channel where this message came from in the cache!",
      STAGE_CHANNEL_RESOLVE: "Could not resolve channel to a stage channel.",
      GUILD_SCHEDULED_EVENT_RESOLVE: "Could not resolve the guild scheduled event.",
      INVALID_TYPE: (name, expected, an = false) => `Supplied ${name} is not a${an ? "n" : ""} ${expected}.`,
      INVALID_ELEMENT: (type, name, elem) => `Supplied ${type} ${name} includes an invalid element: ${elem}`,
      MESSAGE_THREAD_PARENT: "The message was not sent in a guild text or news channel",
      MESSAGE_EXISTING_THREAD: "The message already has a thread",
      THREAD_INVITABLE_TYPE: (type) => `Invitable cannot be edited on ${type}`,
      WEBHOOK_MESSAGE: "The message was not sent by a webhook.",
      WEBHOOK_TOKEN_UNAVAILABLE: "This action requires a webhook token, but none is available.",
      WEBHOOK_URL_INVALID: "The provided webhook URL is not valid.",
      WEBHOOK_APPLICATION: "This message webhook belongs to an application and cannot be fetched.",
      MESSAGE_REFERENCE_MISSING: "The message does not reference another message",
      EMOJI_TYPE: "Emoji must be a string or GuildEmoji/ReactionEmoji",
      EMOJI_MANAGED: "Emoji is managed and has no Author.",
      MISSING_MANAGE_EMOJIS_AND_STICKERS_PERMISSION: (guild) => `Client must have Manage Emojis and Stickers permission in guild ${guild} to see emoji authors.`,
      NOT_GUILD_STICKER: "Sticker is a standard (non-guild) sticker and has no author.",
      REACTION_RESOLVE_USER: "Couldn't resolve the user id to remove from the reaction.",
      VANITY_URL: "This guild does not have the VANITY_URL feature enabled.",
      INVITE_RESOLVE_CODE: "Could not resolve the code to fetch the invite.",
      INVITE_NOT_FOUND: "Could not find the requested invite.",
      DELETE_GROUP_DM_CHANNEL: "Bots don't have access to Group DM Channels and cannot delete them",
      FETCH_GROUP_DM_CHANNEL: "Bots don't have access to Group DM Channels and cannot fetch them",
      MEMBER_FETCH_NONCE_LENGTH: "Nonce length must not exceed 32 characters.",
      GLOBAL_COMMAND_PERMISSIONS: "Permissions for global commands may only be fetched or modified by providing a GuildResolvable or from a guild's application command manager.",
      GUILD_UNCACHED_ROLE_RESOLVE: "Cannot resolve roles from an arbitrary guild, provide an id instead",
      INTERACTION_ALREADY_REPLIED: "The reply to this interaction has already been sent or deferred.",
      INTERACTION_NOT_REPLIED: "The reply to this interaction has not been sent or deferred.",
      COMMAND_INTERACTION_OPTION_NOT_FOUND: (name) => `Required option "${name}" not found.`,
      COMMAND_INTERACTION_OPTION_TYPE: (name, type, expected) => `Option "${name}" is of type: ${type}; expected ${expected}.`,
      COMMAND_INTERACTION_OPTION_EMPTY: (name, type) => `Required option "${name}" is of type: ${type}; expected a non-empty value.`,
      COMMAND_INTERACTION_OPTION_NO_SUB_COMMAND: "No subcommand specified for interaction.",
      COMMAND_INTERACTION_OPTION_NO_SUB_COMMAND_GROUP: "No subcommand group specified for interaction.",
      AUTOCOMPLETE_INTERACTION_OPTION_NO_FOCUSED_OPTION: "No focused option for autocomplete interaction.",
      MODAL_SUBMIT_INTERACTION_FIELD_NOT_FOUND: (customId) => `Required field with custom id "${customId}" not found.`,
      MODAL_SUBMIT_INTERACTION_FIELD_TYPE: (customId, type, expected) => `Field with custom id "${customId}" is of type: ${type}; expected ${expected}.`,
      INVITE_MISSING_SCOPES: "At least one valid scope must be provided for the invite",
      NOT_IMPLEMENTED: (what, name) => `Method ${what} not implemented on ${name}.`,
      SWEEP_FILTER_RETURN: "The return value of the sweepFilter function was not false or a Function",
      GUILD_FORUM_MESSAGE_REQUIRED: "You must provide a message to create a guild forum thread",
      // Selfbot
      INVALID_USER_API: "User accounts cannot use this endpoint",
      INVALID_APPLICATION_COMMAND: (id) => `Could not find a valid command for this bot: ${id}`,
      INVALID_COMMAND_NAME: (allCMD) => `Could not parse subGroupCommand and subCommand due to too long: ${allCMD.join(" ")}`,
      INVALID_SLASH_COMMAND_CHOICES: (parentOptions, value) => `${value} is not a valid choice for this option (${parentOptions})`,
      SLASH_COMMAND_REQUIRED_OPTIONS_MISSING: (req, opt) => `Value required (${req}) missing (Options: ${opt})`,
      SLASH_COMMAND_SUB_COMMAND_GROUP_INVALID: (n) => `${n} is not a valid sub command group`,
      SLASH_COMMAND_SUB_COMMAND_INVALID: (n) => `${n} is not a valid sub command`,
      INTERACTION_FAILED: "No responsed from Application Command",
      USER_NOT_STREAMING: "User is not streaming",
      BULK_BAN_USERS_OPTION_EMPTY: 'Option "users" array or collection is empty',
      // Djs v12
      VOICE_INVALID_HEARTBEAT: "Tried to set voice heartbeat but no valid interval was specified.",
      VOICE_USER_MISSING: "Couldn't resolve the user to create stream.",
      VOICE_JOIN_CHANNEL: (full = false) => `You do not have permission to join this voice channel${full ? "; it is full." : "."}`,
      VOICE_CONNECTION_TIMEOUT: "Connection not established within 15 seconds.",
      VOICE_TOKEN_ABSENT: "Token not provided from voice server packet.",
      VOICE_SESSION_ABSENT: "Session ID not supplied.",
      VOICE_INVALID_ENDPOINT: "Invalid endpoint received.",
      VOICE_NO_BROWSER: "Voice connections are not available in browsers.",
      VOICE_CONNECTION_ATTEMPTS_EXCEEDED: (attempts) => `Too many connection attempts (${attempts}).`,
      VOICE_JOIN_SOCKET_CLOSED: "Tried to send join packet, but the WebSocket is not open.",
      VOICE_PLAY_INTERFACE_NO_BROADCAST: "A broadcast cannot be played in this context.",
      VOICE_PLAY_INTERFACE_BAD_TYPE: "Unknown stream type",
      VOICE_PRISM_DEMUXERS_NEED_STREAM: "To play a webm/ogg stream, you need to pass a ReadableStream.",
      VOICE_STATE_UNCACHED_MEMBER: "The member of this voice state is uncached.",
      UDP_SEND_FAIL: "Tried to send a UDP packet, but there is no socket available.",
      UDP_ADDRESS_MALFORMED: "Malformed UDP address or port.",
      UDP_CONNECTION_EXISTS: "There is already an existing UDP connection.",
      UDP_WRONG_HANDSHAKE: "Wrong handshake packet for UDP",
      INVALID_VIDEO_CODEC: (codecs) => `Only these codecs are supported: ${codecs.join(", ")}`,
      STREAM_CONNECTION_READONLY: "Cannot send data to a read-only stream",
      STREAM_CANNOT_JOIN: "Cannot join a stream to itself",
      VOICE_USER_NOT_STREAMING: "User is not streaming",
      POLL_ALREADY_EXPIRED: "This poll has already expired.",
      INVALID_OAUTH_OPTIONS: "Invalid options for authenticating with OAuth2.",
      METHOD_WARNING: "This method is flagged as it may lead to a temporary or permanent account ban. Do not use until further notice."
    };
    for (const [name, message] of Object.entries(Messages)) register(name, message);
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/errors/index.js
var require_errors2 = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/errors/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_DJSError();
    module2.exports.Messages = require_Messages();
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/util/Constants.js
var require_Constants = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/util/Constants.js"(exports2) {
    "use strict";
    var { Error: Error2, RangeError: RangeError2, TypeError: TypeError2 } = require_errors2();
    exports2.MaxBulkDeletableMessageAge = 12096e5;
    exports2.UserAgent = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Electron/33.0.0 Safari/537.36";
    exports2.ciphers = [
      "TLS_AES_128_GCM_SHA256",
      "TLS_AES_256_GCM_SHA384",
      "TLS_CHACHA20_POLY1305_SHA256",
      "ECDHE-ECDSA-AES128-GCM-SHA256",
      "ECDHE-RSA-AES128-GCM-SHA256",
      "ECDHE-ECDSA-AES256-GCM-SHA384",
      "ECDHE-RSA-AES256-GCM-SHA384",
      "ECDHE-ECDSA-CHACHA20-POLY1305",
      "ECDHE-RSA-CHACHA20-POLY1305",
      "ECDHE-RSA-AES128-SHA",
      "ECDHE-RSA-AES256-SHA",
      "AES128-GCM-SHA256",
      "AES256-GCM-SHA384",
      "AES128-SHA",
      "AES256-SHA"
    ];
    exports2.WSCodes = {
      1e3: "WS_CLOSE_REQUESTED",
      1011: "INTERNAL_ERROR",
      4004: "TOKEN_INVALID",
      4010: "SHARDING_INVALID",
      4011: "SHARDING_REQUIRED",
      4013: "INVALID_INTENTS",
      4014: "DISALLOWED_INTENTS"
    };
    var AllowedImageFormats = ["webp", "png", "jpg", "jpeg", "gif"];
    var AllowedImageSizes = [16, 32, 56, 64, 96, 128, 256, 300, 512, 600, 1024, 2048, 4096];
    function makeImageUrl(root, { format = "webp", size } = {}) {
      if (!["undefined", "number"].includes(typeof size)) throw new TypeError2("INVALID_TYPE", "size", "number");
      if (format && !AllowedImageFormats.includes(format)) throw new Error2("IMAGE_FORMAT", format);
      if (size && !AllowedImageSizes.includes(size)) throw new RangeError2("IMAGE_SIZE", size);
      return `${root}.${format}${size ? `?size=${size}` : ""}`;
    }
    exports2.Endpoints = {
      CDN(root) {
        return {
          Emoji: (emojiId, format = "webp") => `${root}/emojis/${emojiId}.${format}`,
          Asset: (name) => `${root}/assets/${name}`,
          DefaultAvatar: (index) => `${root}/embed/avatars/${index}.png`,
          Avatar: (userId, hash, format, size, dynamic = false) => {
            if (dynamic && hash.startsWith("a_")) format = "gif";
            return makeImageUrl(`${root}/avatars/${userId}/${hash}`, { format, size });
          },
          AvatarDecoration: (hash, size) => makeImageUrl(`${root}/avatar-decoration-presets/${hash}`, { format: "png", size }),
          ClanBadge: (guildId, hash) => `${root}/clan-badges/${guildId}/${hash}.png`,
          GuildMemberAvatar: (guildId, memberId, hash, format = "webp", size, dynamic = false) => {
            if (dynamic && hash.startsWith("a_")) format = "gif";
            return makeImageUrl(`${root}/guilds/${guildId}/users/${memberId}/avatars/${hash}`, { format, size });
          },
          GuildMemberBanner: (guildId, memberId, hash, format = "webp", size, dynamic = false) => {
            if (dynamic && hash.startsWith("a_")) format = "gif";
            return makeImageUrl(`${root}/guilds/${guildId}/users/${memberId}/banners/${hash}`, { format, size });
          },
          Banner: (id, hash, format, size, dynamic = false) => {
            if (dynamic && hash.startsWith("a_")) format = "gif";
            return makeImageUrl(`${root}/banners/${id}/${hash}`, { format, size });
          },
          Icon: (guildId, hash, format, size, dynamic = false) => {
            if (dynamic && hash.startsWith("a_")) format = "gif";
            return makeImageUrl(`${root}/icons/${guildId}/${hash}`, { format, size });
          },
          AppIcon: (appId, hash, options) => makeImageUrl(`${root}/app-icons/${appId}/${hash}`, options),
          AppAsset: (appId, hash, options) => makeImageUrl(`${root}/app-assets/${appId}/${hash}`, options),
          StickerPackBanner: (bannerId, format, size) => makeImageUrl(`${root}/app-assets/710982414301790216/store/${bannerId}`, { size, format }),
          GDMIcon: (channelId, hash, format, size) => makeImageUrl(`${root}/channel-icons/${channelId}/${hash}`, { size, format }),
          Splash: (guildId, hash, format, size) => makeImageUrl(`${root}/splashes/${guildId}/${hash}`, { size, format }),
          DiscoverySplash: (guildId, hash, format, size) => makeImageUrl(`${root}/discovery-splashes/${guildId}/${hash}`, { size, format }),
          TeamIcon: (teamId, hash, options) => makeImageUrl(`${root}/team-icons/${teamId}/${hash}`, options),
          Sticker: (stickerId, stickerFormat) => `${root}/stickers/${stickerId}.${stickerFormat === "LOTTIE" ? "json" : stickerFormat === "GIF" ? "gif" : "png"}`,
          RoleIcon: (roleId, hash, format = "webp", size) => makeImageUrl(`${root}/role-icons/${roleId}/${hash}`, { size, format }),
          GuildScheduledEventCover: (scheduledEventId, coverHash, format, size) => makeImageUrl(`${root}/guild-events/${scheduledEventId}/${coverHash}`, { size, format })
        };
      },
      invite: (root, code, eventId) => eventId ? `${root}/${code}?event=${eventId}` : `${root}/${code}`,
      scheduledEvent: (root, guildId, eventId) => `${root}/${guildId}/${eventId}`,
      botGateway: "/gateway"
    };
    exports2.Status = {
      READY: 0,
      CONNECTING: 1,
      RECONNECTING: 2,
      IDLE: 3,
      NEARLY: 4,
      DISCONNECTED: 5,
      WAITING_FOR_GUILDS: 6,
      IDENTIFYING: 7,
      RESUMING: 8
    };
    exports2.VoiceStatus = {
      CONNECTED: 0,
      CONNECTING: 1,
      AUTHENTICATING: 2,
      RECONNECTING: 3,
      DISCONNECTED: 4
    };
    exports2.Opcodes = {
      DISPATCH: 0,
      HEARTBEAT: 1,
      IDENTIFY: 2,
      STATUS_UPDATE: 3,
      VOICE_STATE_UPDATE: 4,
      VOICE_GUILD_PING: 5,
      RESUME: 6,
      RECONNECT: 7,
      REQUEST_GUILD_MEMBERS: 8,
      INVALID_SESSION: 9,
      HELLO: 10,
      HEARTBEAT_ACK: 11,
      GUILD_SYNC: 12,
      DM_UPDATE: 13,
      GUILD_SUBSCRIPTIONS: 14,
      LOBBY_CONNECT: 15,
      LOBBY_DISCONNECT: 16,
      LOBBY_VOICE_STATE_UPDATE: 17,
      STREAM_CREATE: 18,
      STREAM_DELETE: 19,
      STREAM_WATCH: 20,
      STREAM_PING: 21,
      STREAM_SET_PAUSED: 22,
      REQUEST_GUILD_APPLICATION_COMMANDS: 24,
      EMBEDDED_ACTIVITY_LAUNCH: 25,
      EMBEDDED_ACTIVITY_CLOSE: 26,
      EMBEDDED_ACTIVITY_UPDATE: 27,
      REQUEST_FORUM_UNREADS: 28,
      // Payload: { guild_id: Snowflake, channel_id: Snowflake, threads: { thread_id: Snowflake, ack_message_id: Snowflake }[] }
      REMOTE_COMMAND: 29,
      // Payload: { target_session_id: string, payload: any }
      GET_DELETED_ENTITY_IDS_NOT_MATCHING_HASH: 30,
      // Payload: { guild_id: Snowflake, channel_ids_hash: string[], role_ids_hash: string[], emoji_ids_hash: string[], sticker_ids_hash: string[] }
      REQUEST_SOUNDBOARD_SOUNDS: 31,
      // Payload: { guild_ids: string[] }
      SPEED_TEST_CREATE: 32,
      // Payload: { preferred_region: string }
      SPEED_TEST_DELETE: 33,
      // Payload: null
      REQUEST_LAST_MESSAGES: 34,
      // Payload: { guild_id: string, channel_ids: string[] }
      SEARCH_RECENT_MEMBERS: 35,
      // Payload: { guild_id: string, query: string, continuation_token?: Snowflake }
      REQUEST_CHANNEL_STATUSES: 36,
      // Payload: { guild_id: string } | Response: CHANNEL_STATUSES | { guild_id, channels: { status, id }[] }
      GUILD_SUBSCRIPTIONS_BULK: 37
      // Payload: { subscriptions: Object<guild_id, { Payload_op14 - guild_id }> } | Response: Opcode 14
      // Updated: 23/1/2024
    };
    exports2.VoiceOpcodes = {
      IDENTIFY: 0,
      SELECT_PROTOCOL: 1,
      READY: 2,
      HEARTBEAT: 3,
      SESSION_DESCRIPTION: 4,
      SPEAKING: 5,
      HEARTBEAT_ACK: 6,
      RESUME: 7,
      HELLO: 8,
      RESUMED: 9,
      SOURCES: 12,
      CLIENT_DISCONNECT: 13,
      SESSION_UPDATE: 14,
      MEDIA_SINK_WANTS: 15,
      VOICE_BACKEND_VERSION: 16,
      CHANNEL_OPTIONS_UPDATE: 17
    };
    exports2.Events = {
      RATE_LIMIT: "rateLimit",
      INVALID_REQUEST_WARNING: "invalidRequestWarning",
      API_RESPONSE: "apiResponse",
      API_REQUEST: "apiRequest",
      CLIENT_READY: "ready",
      APPLICATION_COMMAND_CREATE: "applicationCommandCreate",
      APPLICATION_COMMAND_DELETE: "applicationCommandDelete",
      APPLICATION_COMMAND_UPDATE: "applicationCommandUpdate",
      APPLICATION_COMMAND_PERMISSIONS_UPDATE: "applicationCommandPermissionsUpdate",
      AUTO_MODERATION_ACTION_EXECUTION: "autoModerationActionExecution",
      AUTO_MODERATION_RULE_CREATE: "autoModerationRuleCreate",
      AUTO_MODERATION_RULE_DELETE: "autoModerationRuleDelete",
      AUTO_MODERATION_RULE_UPDATE: "autoModerationRuleUpdate",
      GUILD_AVAILABLE: "guildAvailable",
      GUILD_CREATE: "guildCreate",
      GUILD_DELETE: "guildDelete",
      GUILD_UPDATE: "guildUpdate",
      GUILD_UNAVAILABLE: "guildUnavailable",
      GUILD_MEMBER_ADD: "guildMemberAdd",
      GUILD_MEMBER_REMOVE: "guildMemberRemove",
      GUILD_MEMBER_UPDATE: "guildMemberUpdate",
      GUILD_MEMBER_AVAILABLE: "guildMemberAvailable",
      GUILD_MEMBERS_CHUNK: "guildMembersChunk",
      GUILD_INTEGRATIONS_UPDATE: "guildIntegrationsUpdate",
      GUILD_ROLE_CREATE: "roleCreate",
      GUILD_ROLE_DELETE: "roleDelete",
      INVITE_CREATE: "inviteCreate",
      INVITE_DELETE: "inviteDelete",
      GUILD_ROLE_UPDATE: "roleUpdate",
      GUILD_EMOJI_CREATE: "emojiCreate",
      GUILD_EMOJI_DELETE: "emojiDelete",
      GUILD_EMOJI_UPDATE: "emojiUpdate",
      GUILD_BAN_ADD: "guildBanAdd",
      GUILD_BAN_REMOVE: "guildBanRemove",
      CHANNEL_CREATE: "channelCreate",
      CHANNEL_DELETE: "channelDelete",
      CHANNEL_UPDATE: "channelUpdate",
      CHANNEL_PINS_UPDATE: "channelPinsUpdate",
      MESSAGE_CREATE: "messageCreate",
      MESSAGE_DELETE: "messageDelete",
      MESSAGE_UPDATE: "messageUpdate",
      MESSAGE_BULK_DELETE: "messageDeleteBulk",
      MESSAGE_REACTION_ADD: "messageReactionAdd",
      MESSAGE_REACTION_REMOVE: "messageReactionRemove",
      MESSAGE_REACTION_REMOVE_ALL: "messageReactionRemoveAll",
      MESSAGE_REACTION_REMOVE_EMOJI: "messageReactionRemoveEmoji",
      THREAD_CREATE: "threadCreate",
      THREAD_DELETE: "threadDelete",
      THREAD_UPDATE: "threadUpdate",
      THREAD_LIST_SYNC: "threadListSync",
      THREAD_MEMBER_UPDATE: "threadMemberUpdate",
      THREAD_MEMBERS_UPDATE: "threadMembersUpdate",
      USER_UPDATE: "userUpdate",
      PRESENCE_UPDATE: "presenceUpdate",
      VOICE_SERVER_UPDATE: "voiceServerUpdate",
      VOICE_STATE_UPDATE: "voiceStateUpdate",
      TYPING_START: "typingStart",
      WEBHOOKS_UPDATE: "webhookUpdate",
      ERROR: "error",
      WARN: "warn",
      DEBUG: "debug",
      CACHE_SWEEP: "cacheSweep",
      SHARD_DISCONNECT: "shardDisconnect",
      SHARD_ERROR: "shardError",
      SHARD_RECONNECTING: "shardReconnecting",
      SHARD_READY: "shardReady",
      SHARD_RESUME: "shardResume",
      INVALIDATED: "invalidated",
      RAW: "raw",
      STAGE_INSTANCE_CREATE: "stageInstanceCreate",
      STAGE_INSTANCE_UPDATE: "stageInstanceUpdate",
      STAGE_INSTANCE_DELETE: "stageInstanceDelete",
      GUILD_STICKER_CREATE: "stickerCreate",
      GUILD_STICKER_DELETE: "stickerDelete",
      GUILD_STICKER_UPDATE: "stickerUpdate",
      GUILD_SCHEDULED_EVENT_CREATE: "guildScheduledEventCreate",
      GUILD_SCHEDULED_EVENT_UPDATE: "guildScheduledEventUpdate",
      GUILD_SCHEDULED_EVENT_DELETE: "guildScheduledEventDelete",
      GUILD_SCHEDULED_EVENT_USER_ADD: "guildScheduledEventUserAdd",
      GUILD_SCHEDULED_EVENT_USER_REMOVE: "guildScheduledEventUserRemove",
      GUILD_AUDIT_LOG_ENTRY_CREATE: "guildAuditLogEntryCreate",
      UNHANDLED_PACKET: "unhandledPacket",
      RELATIONSHIP_ADD: "relationshipAdd",
      RELATIONSHIP_UPDATE: "relationshipUpdate",
      RELATIONSHIP_REMOVE: "relationshipRemove",
      CHANNEL_RECIPIENT_ADD: "channelRecipientAdd",
      CHANNEL_RECIPIENT_REMOVE: "channelRecipientRemove",
      INTERACTION_MODAL_CREATE: "interactionModalCreate",
      CALL_CREATE: "callCreate",
      CALL_UPDATE: "callUpdate",
      CALL_DELETE: "callDelete",
      MESSAGE_POLL_VOTE_ADD: "messagePollVoteAdd",
      MESSAGE_POLL_VOTE_REMOVE: "messagePollVoteRemove",
      // Djs v12
      VOICE_BROADCAST_SUBSCRIBE: "subscribe",
      VOICE_BROADCAST_UNSUBSCRIBE: "unsubscribe"
    };
    exports2.ShardEvents = {
      CLOSE: "close",
      DESTROYED: "destroyed",
      INVALID_SESSION: "invalidSession",
      READY: "ready",
      RESUMED: "resumed",
      ALL_READY: "allReady"
    };
    exports2.PartialTypes = keyMirror(["USER", "CHANNEL", "GUILD_MEMBER", "MESSAGE", "REACTION", "GUILD_SCHEDULED_EVENT"]);
    exports2.WSEvents = keyMirror([
      "READY",
      "RESUMED",
      "APPLICATION_COMMAND_CREATE",
      "APPLICATION_COMMAND_DELETE",
      "APPLICATION_COMMAND_UPDATE",
      "APPLICATION_COMMAND_PERMISSIONS_UPDATE",
      "AUTO_MODERATION_ACTION_EXECUTION",
      "AUTO_MODERATION_RULE_CREATE",
      "AUTO_MODERATION_RULE_DELETE",
      "AUTO_MODERATION_RULE_UPDATE",
      "GUILD_CREATE",
      "GUILD_DELETE",
      "GUILD_UPDATE",
      "INVITE_CREATE",
      "INVITE_DELETE",
      "GUILD_MEMBER_ADD",
      "GUILD_MEMBER_REMOVE",
      "GUILD_MEMBER_UPDATE",
      "GUILD_MEMBERS_CHUNK",
      "GUILD_INTEGRATIONS_UPDATE",
      "GUILD_ROLE_CREATE",
      "GUILD_ROLE_DELETE",
      "GUILD_ROLE_UPDATE",
      "GUILD_BAN_ADD",
      "GUILD_BAN_REMOVE",
      "GUILD_EMOJIS_UPDATE",
      "CHANNEL_CREATE",
      "CHANNEL_DELETE",
      "CHANNEL_UPDATE",
      "CHANNEL_PINS_UPDATE",
      "MESSAGE_CREATE",
      "MESSAGE_DELETE",
      "MESSAGE_UPDATE",
      "MESSAGE_DELETE_BULK",
      "MESSAGE_REACTION_ADD",
      "MESSAGE_REACTION_REMOVE",
      "MESSAGE_REACTION_REMOVE_ALL",
      "MESSAGE_REACTION_REMOVE_EMOJI",
      "THREAD_CREATE",
      "THREAD_UPDATE",
      "THREAD_DELETE",
      "THREAD_LIST_SYNC",
      "THREAD_MEMBER_UPDATE",
      "THREAD_MEMBERS_UPDATE",
      "USER_UPDATE",
      "PRESENCE_UPDATE",
      "TYPING_START",
      "VOICE_STATE_UPDATE",
      "VOICE_SERVER_UPDATE",
      "WEBHOOKS_UPDATE",
      "STAGE_INSTANCE_CREATE",
      "STAGE_INSTANCE_UPDATE",
      "STAGE_INSTANCE_DELETE",
      "GUILD_STICKERS_UPDATE",
      "GUILD_SCHEDULED_EVENT_CREATE",
      "GUILD_SCHEDULED_EVENT_UPDATE",
      "GUILD_SCHEDULED_EVENT_DELETE",
      "GUILD_SCHEDULED_EVENT_USER_ADD",
      "GUILD_SCHEDULED_EVENT_USER_REMOVE",
      "GUILD_AUDIT_LOG_ENTRY_CREATE"
    ]);
    exports2.InviteScopes = [
      "applications.builds.read",
      "applications.commands",
      "applications.entitlements",
      "applications.store.update",
      "bot",
      "connections",
      "email",
      "identify",
      "guilds",
      "guilds.join",
      "gdm.join",
      "webhook.incoming",
      "role_connections.write"
    ];
    exports2.IntegrationExpireBehaviors = createEnum(["REMOVE_ROLE", "KICK"]);
    exports2.MessageTypes = [
      "DEFAULT",
      // 0
      "RECIPIENT_ADD",
      "RECIPIENT_REMOVE",
      "CALL",
      "CHANNEL_NAME_CHANGE",
      "CHANNEL_ICON_CHANGE",
      "CHANNEL_PINNED_MESSAGE",
      "GUILD_MEMBER_JOIN",
      "USER_PREMIUM_GUILD_SUBSCRIPTION",
      "USER_PREMIUM_GUILD_SUBSCRIPTION_TIER_1",
      "USER_PREMIUM_GUILD_SUBSCRIPTION_TIER_2",
      "USER_PREMIUM_GUILD_SUBSCRIPTION_TIER_3",
      "CHANNEL_FOLLOW_ADD",
      null,
      // 13
      "GUILD_DISCOVERY_DISQUALIFIED",
      "GUILD_DISCOVERY_REQUALIFIED",
      "GUILD_DISCOVERY_GRACE_PERIOD_INITIAL_WARNING",
      "GUILD_DISCOVERY_GRACE_PERIOD_FINAL_WARNING",
      "THREAD_CREATED",
      "REPLY",
      "APPLICATION_COMMAND",
      "THREAD_STARTER_MESSAGE",
      "GUILD_INVITE_REMINDER",
      "CONTEXT_MENU_COMMAND",
      "AUTO_MODERATION_ACTION",
      "ROLE_SUBSCRIPTION_PURCHASE",
      "INTERACTION_PREMIUM_UPSELL",
      "STAGE_START",
      "STAGE_END",
      "STAGE_SPEAKER",
      "STAGE_RAISE_HAND",
      "STAGE_TOPIC",
      "GUILD_APPLICATION_PREMIUM_SUBSCRIPTION",
      null,
      // 33
      null,
      "PREMIUM_REFERRAL",
      "GUILD_INCIDENT_ALERT_MODE_ENABLED",
      "GUILD_INCIDENT_ALERT_MODE_DISABLED",
      "GUILD_INCIDENT_REPORT_RAID",
      "GUILD_INCIDENT_REPORT_FALSE_ALARM",
      "GUILD_DEADCHAT_REVIVE_PROMPT",
      "CUSTOM_GIFT",
      "GUILD_GAMING_STATS_PROMPT",
      null,
      "PURCHASE_NOTIFICATION",
      null,
      "POLL_RESULT",
      "CHANGELOG",
      "NITRO_NOTIFICATION"
    ];
    exports2.MessageReferenceTypes = [
      "DEFAULT",
      // 0
      "FORWARD"
    ];
    exports2.SweeperKeys = [
      "applicationCommands",
      "autoModerationRules",
      "bans",
      "emojis",
      "invites",
      "guildMembers",
      "messages",
      "presences",
      "reactions",
      "stageInstances",
      "stickers",
      "threadMembers",
      "threads",
      "users",
      "voiceStates"
    ];
    exports2.SystemMessageTypes = exports2.MessageTypes.filter(
      (type) => type && !["DEFAULT", "REPLY", "APPLICATION_COMMAND", "CONTEXT_MENU_COMMAND"].includes(type)
    );
    exports2.ActivityTypes = createEnum(["PLAYING", "STREAMING", "LISTENING", "WATCHING", "CUSTOM", "COMPETING", "HANG"]);
    exports2.ChannelTypes = createEnum([
      "GUILD_TEXT",
      "DM",
      "GUILD_VOICE",
      "GROUP_DM",
      "GUILD_CATEGORY",
      "GUILD_NEWS",
      "GUILD_STORE",
      ...Array(3).fill(null),
      // 10
      "GUILD_NEWS_THREAD",
      "GUILD_PUBLIC_THREAD",
      "GUILD_PRIVATE_THREAD",
      "GUILD_STAGE_VOICE",
      "GUILD_DIRECTORY",
      "GUILD_FORUM",
      "GUILD_MEDIA"
    ]);
    exports2.TextBasedChannelTypes = [
      "DM",
      "GUILD_TEXT",
      "GUILD_NEWS",
      "GUILD_NEWS_THREAD",
      "GUILD_PUBLIC_THREAD",
      "GUILD_PRIVATE_THREAD",
      "GUILD_VOICE",
      "GUILD_STAGE_VOICE"
    ];
    exports2.ThreadChannelTypes = ["GUILD_NEWS_THREAD", "GUILD_PUBLIC_THREAD", "GUILD_PRIVATE_THREAD"];
    exports2.VoiceBasedChannelTypes = ["GUILD_VOICE", "GUILD_STAGE_VOICE"];
    exports2.ClientApplicationAssetTypes = {
      SMALL: 1,
      BIG: 2
    };
    exports2.Colors = {
      DEFAULT: 0,
      WHITE: 16777215,
      AQUA: 1752220,
      GREEN: 5763719,
      BLUE: 3447003,
      YELLOW: 16705372,
      PURPLE: 10181046,
      LUMINOUS_VIVID_PINK: 15277667,
      FUCHSIA: 15418782,
      GOLD: 15844367,
      ORANGE: 15105570,
      RED: 15548997,
      GREY: 9807270,
      NAVY: 3426654,
      DARK_AQUA: 1146986,
      DARK_GREEN: 2067276,
      DARK_BLUE: 2123412,
      DARK_PURPLE: 7419530,
      DARK_VIVID_PINK: 11342935,
      DARK_GOLD: 12745742,
      DARK_ORANGE: 11027200,
      DARK_RED: 10038562,
      DARK_GREY: 9936031,
      DARKER_GREY: 8359053,
      LIGHT_GREY: 12370112,
      DARK_NAVY: 2899536,
      BLURPLE: 5793266,
      GREYPLE: 10070709,
      DARK_BUT_NOT_BLACK: 2895667,
      NOT_QUITE_BLACK: 2303786
    };
    exports2.ExplicitContentFilterLevels = createEnum(["DISABLED", "MEMBERS_WITHOUT_ROLES", "ALL_MEMBERS"]);
    exports2.VerificationLevels = createEnum(["NONE", "LOW", "MEDIUM", "HIGH", "VERY_HIGH"]);
    exports2.APIErrors = {
      UNKNOWN_ACCOUNT: 10001,
      UNKNOWN_APPLICATION: 10002,
      UNKNOWN_CHANNEL: 10003,
      UNKNOWN_GUILD: 10004,
      UNKNOWN_INTEGRATION: 10005,
      UNKNOWN_INVITE: 10006,
      UNKNOWN_MEMBER: 10007,
      UNKNOWN_MESSAGE: 10008,
      UNKNOWN_OVERWRITE: 10009,
      UNKNOWN_PROVIDER: 10010,
      UNKNOWN_ROLE: 10011,
      UNKNOWN_TOKEN: 10012,
      UNKNOWN_USER: 10013,
      UNKNOWN_EMOJI: 10014,
      UNKNOWN_WEBHOOK: 10015,
      UNKNOWN_WEBHOOK_SERVICE: 10016,
      UNKNOWN_SESSION: 10020,
      UNKNOWN_BAN: 10026,
      UNKNOWN_SKU: 10027,
      UNKNOWN_STORE_LISTING: 10028,
      UNKNOWN_ENTITLEMENT: 10029,
      UNKNOWN_BUILD: 10030,
      UNKNOWN_LOBBY: 10031,
      UNKNOWN_BRANCH: 10032,
      UNKNOWN_STORE_DIRECTORY_LAYOUT: 10033,
      UNKNOWN_REDISTRIBUTABLE: 10036,
      UNKNOWN_GIFT_CODE: 10038,
      UNKNOWN_STREAM: 10049,
      UNKNOWN_PREMIUM_SERVER_SUBSCRIBE_COOLDOWN: 10050,
      UNKNOWN_GUILD_TEMPLATE: 10057,
      UNKNOWN_DISCOVERABLE_SERVER_CATEGORY: 10059,
      UNKNOWN_STICKER: 10060,
      UNKNOWN_INTERACTION: 10062,
      UNKNOWN_APPLICATION_COMMAND: 10063,
      UNKNOWN_APPLICATION_COMMAND_PERMISSIONS: 10066,
      UNKNOWN_STAGE_INSTANCE: 10067,
      UNKNOWN_GUILD_MEMBER_VERIFICATION_FORM: 10068,
      UNKNOWN_GUILD_WELCOME_SCREEN: 10069,
      UNKNOWN_GUILD_SCHEDULED_EVENT: 10070,
      UNKNOWN_GUILD_SCHEDULED_EVENT_USER: 10071,
      BOT_PROHIBITED_ENDPOINT: 20001,
      BOT_ONLY_ENDPOINT: 20002,
      CANNOT_SEND_EXPLICIT_CONTENT: 20009,
      NOT_AUTHORIZED: 20012,
      SLOWMODE_RATE_LIMIT: 20016,
      ACCOUNT_OWNER_ONLY: 20018,
      ANNOUNCEMENT_EDIT_LIMIT_EXCEEDED: 20022,
      CHANNEL_HIT_WRITE_RATELIMIT: 20028,
      SERVER_HIT_WRITE_RATELIMIT: 20029,
      CONTENT_NOT_ALLOWED: 20031,
      GUILD_PREMIUM_LEVEL_TOO_LOW: 20035,
      MAXIMUM_GUILDS: 30001,
      MAXIMUM_FRIENDS: 30002,
      MAXIMUM_PINS: 30003,
      MAXIMUM_RECIPIENTS: 30004,
      MAXIMUM_ROLES: 30005,
      MAXIMUM_WEBHOOKS: 30007,
      MAXIMUM_EMOJIS: 30008,
      MAXIMUM_REACTIONS: 30010,
      MAXIMUM_CHANNELS: 30013,
      MAXIMUM_ATTACHMENTS: 30015,
      MAXIMUM_INVITES: 30016,
      MAXIMUM_ANIMATED_EMOJIS: 30018,
      MAXIMUM_SERVER_MEMBERS: 30019,
      MAXIMUM_NUMBER_OF_SERVER_CATEGORIES: 30030,
      GUILD_ALREADY_HAS_TEMPLATE: 30031,
      MAXIMUM_THREAD_PARTICIPANTS: 30033,
      MAXIMUM_NON_GUILD_MEMBERS_BANS: 30035,
      MAXIMUM_BAN_FETCHES: 30037,
      MAXIMUM_NUMBER_OF_UNCOMPLETED_GUILD_SCHEDULED_EVENTS_REACHED: 30038,
      MAXIMUM_NUMBER_OF_STICKERS_REACHED: 30039,
      MAXIMUM_PRUNE_REQUESTS: 30040,
      MAXIMUM_GUILD_WIDGET_SETTINGS_UPDATE: 30042,
      MAXIMUM_NUMBER_OF_PREMIUM_EMOJIS: 30056,
      UNAUTHORIZED: 40001,
      ACCOUNT_VERIFICATION_REQUIRED: 40002,
      DIRECT_MESSAGES_TOO_FAST: 40003,
      REQUEST_ENTITY_TOO_LARGE: 40005,
      FEATURE_TEMPORARILY_DISABLED: 40006,
      USER_BANNED: 40007,
      TARGET_USER_NOT_CONNECTED_TO_VOICE: 40032,
      ALREADY_CROSSPOSTED: 40033,
      MISSING_ACCESS: 50001,
      INVALID_ACCOUNT_TYPE: 50002,
      CANNOT_EXECUTE_ON_DM: 50003,
      EMBED_DISABLED: 50004,
      CANNOT_EDIT_MESSAGE_BY_OTHER: 50005,
      CANNOT_SEND_EMPTY_MESSAGE: 50006,
      CANNOT_MESSAGE_USER: 50007,
      CANNOT_SEND_MESSAGES_IN_VOICE_CHANNEL: 50008,
      CHANNEL_VERIFICATION_LEVEL_TOO_HIGH: 50009,
      OAUTH2_APPLICATION_BOT_ABSENT: 50010,
      MAXIMUM_OAUTH2_APPLICATIONS: 50011,
      INVALID_OAUTH_STATE: 50012,
      MISSING_PERMISSIONS: 50013,
      INVALID_AUTHENTICATION_TOKEN: 50014,
      NOTE_TOO_LONG: 50015,
      INVALID_BULK_DELETE_QUANTITY: 50016,
      CANNOT_PIN_MESSAGE_IN_OTHER_CHANNEL: 50019,
      INVALID_OR_TAKEN_INVITE_CODE: 50020,
      CANNOT_EXECUTE_ON_SYSTEM_MESSAGE: 50021,
      CANNOT_EXECUTE_ON_CHANNEL_TYPE: 50024,
      INVALID_OAUTH_TOKEN: 50025,
      MISSING_OAUTH_SCOPE: 50026,
      INVALID_WEBHOOK_TOKEN: 50027,
      INVALID_ROLE: 50028,
      INVALID_RECIPIENTS: 50033,
      BULK_DELETE_MESSAGE_TOO_OLD: 50034,
      INVALID_FORM_BODY: 50035,
      INVITE_ACCEPTED_TO_GUILD_NOT_CONTAINING_BOT: 50036,
      INVALID_API_VERSION: 50041,
      FILE_UPLOADED_EXCEEDS_MAXIMUM_SIZE: 50045,
      INVALID_FILE_UPLOADED: 50046,
      CANNOT_SELF_REDEEM_GIFT: 50054,
      INVALID_GUILD: 50055,
      INVALID_MESSAGE_TYPE: 50068,
      PAYMENT_SOURCE_REQUIRED: 50070,
      CANNOT_DELETE_COMMUNITY_REQUIRED_CHANNEL: 50074,
      INVALID_STICKER_SENT: 50081,
      INVALID_OPERATION_ON_ARCHIVED_THREAD: 50083,
      INVALID_THREAD_NOTIFICATION_SETTINGS: 50084,
      PARAMETER_EARLIER_THAN_CREATION: 50085,
      GUILD_NOT_AVAILABLE_IN_LOCATION: 50095,
      GUILD_MONETIZATION_REQUIRED: 50097,
      INSUFFICIENT_BOOSTS: 50101,
      INVALID_JSON: 50109,
      CANNOT_MIX_SUBSCRIPTION_AND_NON_SUBSCRIPTION_ROLES_FOR_EMOJI: 50144,
      CANNOT_CONVERT_PREMIUM_EMOJI_TO_NORMAL_EMOJI: 50145,
      VOICE_MESSAGES_DO_NOT_SUPPORT_ADDITIONAL_CONTENT: 50159,
      VOICE_MESSAGES_MUST_HAVE_A_SINGLE_AUDIO_ATTACHMENT: 50160,
      VOICE_MESSAGES_MUST_HAVE_SUPPORTING_METADATA: 50161,
      VOICE_MESSAGES_CANNOT_BE_EDITED: 50162,
      YOU_CANNOT_SEND_VOICE_MESSAGES_IN_THIS_CHANNEL: 50173,
      TWO_FACTOR_REQUIRED: 60003,
      NO_USERS_WITH_DISCORDTAG_EXIST: 80004,
      REACTION_BLOCKED: 90001,
      RESOURCE_OVERLOADED: 13e4,
      STAGE_ALREADY_OPEN: 150006,
      CANNOT_REPLY_WITHOUT_READ_MESSAGE_HISTORY_PERMISSION: 160002,
      MESSAGE_ALREADY_HAS_THREAD: 160004,
      THREAD_LOCKED: 160005,
      MAXIMUM_ACTIVE_THREADS: 160006,
      MAXIMUM_ACTIVE_ANNOUNCEMENT_THREADS: 160007,
      INVALID_JSON_FOR_UPLOADED_LOTTIE_FILE: 170001,
      UPLOADED_LOTTIES_CANNOT_CONTAIN_RASTERIZED_IMAGES: 170002,
      STICKER_MAXIMUM_FRAMERATE_EXCEEDED: 170003,
      STICKER_FRAME_COUNT_EXCEEDS_MAXIMUM_OF_1000_FRAMES: 170004,
      LOTTIE_ANIMATION_MAXIMUM_DIMENSIONS_EXCEEDED: 170005,
      STICKER_FRAME_RATE_IS_TOO_SMALL_OR_TOO_LARGE: 170006,
      STICKER_ANIMATION_DURATION_EXCEEDS_MAXIMUM_OF_5_SECONDS: 170007,
      CANNOT_UPDATE_A_FINISHED_EVENT: 18e4,
      FAILED_TO_CREATE_STAGE_NEEDED_FOR_STAGE_EVENT: 180002
    };
    exports2.DefaultMessageNotificationLevels = createEnum(["ALL_MESSAGES", "ONLY_MENTIONS"]);
    exports2.MembershipStates = createEnum([null, "INVITED", "ACCEPTED"]);
    exports2.WebhookTypes = createEnum([null, "Incoming", "Channel Follower", "Application"]);
    exports2.StickerTypes = createEnum([null, "STANDARD", "GUILD"]);
    exports2.StickerFormatTypes = createEnum([null, "PNG", "APNG", "LOTTIE", "GIF"]);
    exports2.OverwriteTypes = createEnum(["role", "member"]);
    exports2.ApplicationCommandTypes = createEnum([null, "CHAT_INPUT", "USER", "MESSAGE"]);
    exports2.ApplicationCommandOptionTypes = createEnum([
      null,
      "SUB_COMMAND",
      "SUB_COMMAND_GROUP",
      "STRING",
      "INTEGER",
      "BOOLEAN",
      "USER",
      "CHANNEL",
      "ROLE",
      "MENTIONABLE",
      "NUMBER",
      "ATTACHMENT"
    ]);
    exports2.ApplicationCommandPermissionTypes = createEnum([null, "ROLE", "USER"]);
    exports2.ApplicationRoleConnectionMetadataTypes = createEnum([
      null,
      "INTEGER_LESS_THAN_OR_EQUAL",
      "INTEGER_GREATER_THAN_OR_EQUAL",
      "INTEGER_EQUAL",
      "INTEGER_NOT_EQUAL",
      "DATATIME_LESS_THAN_OR_EQUAL",
      "DATATIME_GREATER_THAN_OR_EQUAL",
      "BOOLEAN_EQUAL",
      "BOOLEAN_NOT_EQUAL"
    ]);
    exports2.AutoModerationRuleTriggerTypes = createEnum([null, "KEYWORD", null, "SPAM", "KEYWORD_PRESET", "MENTION_SPAM"]);
    exports2.AutoModerationRuleKeywordPresetTypes = createEnum([null, "PROFANITY", "SEXUAL_CONTENT", "SLURS"]);
    exports2.AutoModerationActionTypes = createEnum([null, "BLOCK_MESSAGE", "SEND_ALERT_MESSAGE", "TIMEOUT"]);
    exports2.AutoModerationRuleEventTypes = createEnum([null, "MESSAGE_SEND"]);
    exports2.InteractionTypes = createEnum([
      null,
      "PING",
      "APPLICATION_COMMAND",
      "MESSAGE_COMPONENT",
      "APPLICATION_COMMAND_AUTOCOMPLETE",
      "MODAL_SUBMIT"
    ]);
    exports2.InteractionResponseTypes = createEnum([
      null,
      "PONG",
      null,
      null,
      "CHANNEL_MESSAGE_WITH_SOURCE",
      "DEFERRED_CHANNEL_MESSAGE_WITH_SOURCE",
      "DEFERRED_MESSAGE_UPDATE",
      "UPDATE_MESSAGE",
      "APPLICATION_COMMAND_AUTOCOMPLETE_RESULT",
      "MODAL"
    ]);
    exports2.MessageComponentTypes = createEnum([
      null,
      "ACTION_ROW",
      "BUTTON",
      "STRING_SELECT",
      "TEXT_INPUT",
      "USER_SELECT",
      "ROLE_SELECT",
      "MENTIONABLE_SELECT",
      "CHANNEL_SELECT"
    ]);
    exports2.SelectMenuComponentTypes = createEnum([
      ...new Array(3).fill(null),
      "STRING_MENU",
      null,
      "USER_SELECT",
      "ROLE_SELECT",
      "MENTIONABLE_SELECT",
      "CHANNEL_SELECT"
    ]);
    exports2.MessageButtonStyles = createEnum([null, "PRIMARY", "SECONDARY", "SUCCESS", "DANGER", "LINK"]);
    exports2.MFALevels = createEnum(["NONE", "ELEVATED"]);
    exports2.NSFWLevels = createEnum(["DEFAULT", "EXPLICIT", "SAFE", "AGE_RESTRICTED"]);
    exports2.PrivacyLevels = createEnum([null, "PUBLIC", "GUILD_ONLY"]);
    exports2.TextInputStyles = createEnum([null, "SHORT", "PARAGRAPH"]);
    exports2.GuildScheduledEventPrivacyLevels = createEnum([null, null, "GUILD_ONLY"]);
    exports2.PremiumTiers = createEnum(["NONE", "TIER_1", "TIER_2", "TIER_3"]);
    exports2.GuildScheduledEventStatuses = createEnum([null, "SCHEDULED", "ACTIVE", "COMPLETED", "CANCELED"]);
    exports2.GuildScheduledEventEntityTypes = createEnum([null, "STAGE_INSTANCE", "VOICE", "EXTERNAL"]);
    exports2.VideoQualityModes = createEnum([null, "AUTO", "FULL"]);
    exports2.ReactionTypes = createEnum(["NORMAL", "BURST"]);
    exports2.SortOrderTypes = createEnum([null, "LATEST_ACTIVITY", "CREATION_DATE"]);
    exports2.ForumLayoutTypes = createEnum(["NOT_SET", "LIST_VIEW", "GALLERY_VIEW"]);
    exports2.PollLayoutTypes = createEnum([null, "DEFAULT", "IMAGE_ONLY_ANSWERS"]);
    exports2.RelationshipTypes = createEnum([
      "NONE",
      "FRIEND",
      "BLOCKED",
      "PENDING_INCOMING",
      "PENDING_OUTGOING",
      "IMPLICIT"
    ]);
    exports2._cleanupSymbol = Symbol("djsCleanup");
    function keyMirror(arr) {
      let tmp = /* @__PURE__ */ Object.create(null);
      for (const value of arr) tmp[value] = value;
      return tmp;
    }
    function createEnum(keys) {
      const obj = {};
      for (const [index, key] of keys.entries()) {
        if (key === null) continue;
        obj[key] = index;
        obj[index] = key;
      }
      return obj;
    }
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/util/Sweepers.js
var require_Sweepers = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/util/Sweepers.js"(exports2, module2) {
    "use strict";
    var { setInterval: setInterval2 } = require_node_timers();
    var { Events: Events2, ThreadChannelTypes, SweeperKeys } = require_Constants();
    var { TypeError: TypeError2 } = require_DJSError();
    var Sweepers2 = class {
      constructor(client, options) {
        Object.defineProperty(this, "client", { value: client });
        this.options = options;
        this.intervals = Object.fromEntries(SweeperKeys.map((key) => [key, null]));
        for (const key of SweeperKeys) {
          if (!(key in options)) continue;
          this._validateProperties(key);
          const clonedOptions = { ...this.options[key] };
          if (!("filter" in clonedOptions)) {
            switch (key) {
              case "invites":
                clonedOptions.filter = this.constructor.expiredInviteSweepFilter(clonedOptions.lifetime);
                break;
              case "messages":
                clonedOptions.filter = this.constructor.outdatedMessageSweepFilter(clonedOptions.lifetime);
                break;
              case "threads":
                clonedOptions.filter = this.constructor.archivedThreadSweepFilter(clonedOptions.lifetime);
            }
          }
          this._initInterval(key, `sweep${key[0].toUpperCase()}${key.slice(1)}`, clonedOptions);
        }
      }
      /**
       * Sweeps all guild and global application commands and removes the ones which are indicated by the filter.
       * @param {Function} filter The function used to determine which commands will be removed from the caches.
       * @returns {number} Amount of commands that were removed from the caches
       */
      sweepApplicationCommands(filter) {
        var _a;
        const { guilds, items: guildCommands } = this._sweepGuildDirectProp("commands", filter, { emit: false });
        const globalCommands = ((_a = this.client.application) == null ? void 0 : _a.commands.cache.sweep(filter)) ?? 0;
        this.client.emit(
          Events2.CACHE_SWEEP,
          `Swept ${globalCommands} global application commands and ${guildCommands} guild commands in ${guilds} guilds.`
        );
        return guildCommands + globalCommands;
      }
      /**
       * Sweeps all auto moderation rules and removes the ones which are indicated by the filter.
       * @param {Function} filter The function used to determine
       * which auto moderation rules will be removed from the caches
       * @returns {number} Amount of auto moderation rules that were removed from the caches
       */
      sweepAutoModerationRules(filter) {
        return this._sweepGuildDirectProp("autoModerationRules", filter).items;
      }
      /**
       * Sweeps all guild bans and removes the ones which are indicated by the filter.
       * @param {Function} filter The function used to determine which bans will be removed from the caches.
       * @returns {number} Amount of bans that were removed from the caches
       */
      sweepBans(filter) {
        return this._sweepGuildDirectProp("bans", filter).items;
      }
      /**
       * Sweeps all guild emojis and removes the ones which are indicated by the filter.
       * @param {Function} filter The function used to determine which emojis will be removed from the caches.
       * @returns {number} Amount of emojis that were removed from the caches
       */
      sweepEmojis(filter) {
        return this._sweepGuildDirectProp("emojis", filter).items;
      }
      /**
       * Sweeps all guild invites and removes the ones which are indicated by the filter.
       * @param {Function} filter The function used to determine which invites will be removed from the caches.
       * @returns {number} Amount of invites that were removed from the caches
       */
      sweepInvites(filter) {
        return this._sweepGuildDirectProp("invites", filter).items;
      }
      /**
       * Sweeps all guild members and removes the ones which are indicated by the filter.
       * <info>It is highly recommended to keep the client guild member cached</info>
       * @param {Function} filter The function used to determine which guild members will be removed from the caches.
       * @returns {number} Amount of guild members that were removed from the caches
       */
      sweepGuildMembers(filter) {
        return this._sweepGuildDirectProp("members", filter, { outputName: "guild members" }).items;
      }
      /**
       * Sweeps all text-based channels' messages and removes the ones which are indicated by the filter.
       * @param {Function} filter The function used to determine which messages will be removed from the caches.
       * @returns {number} Amount of messages that were removed from the caches
       * @example
       * // Remove all messages older than 1800 seconds from the messages cache
       * const amount = sweepers.sweepMessages(
       *   Sweepers.filterByLifetime({
       *     lifetime: 1800,
       *     getComparisonTimestamp: m => m.editedTimestamp ?? m.createdTimestamp,
       *   })(),
       * );
       * console.log(`Successfully removed ${amount} messages from the cache.`);
       */
      sweepMessages(filter) {
        if (typeof filter !== "function") {
          throw new TypeError2("INVALID_TYPE", "filter", "function");
        }
        let channels = 0;
        let messages = 0;
        for (const channel of this.client.channels.cache.values()) {
          if (!channel.isText()) continue;
          channels++;
          messages += channel.messages.cache.sweep(filter);
        }
        this.client.emit(Events2.CACHE_SWEEP, `Swept ${messages} messages in ${channels} text-based channels.`);
        return messages;
      }
      /**
       * Sweeps all presences and removes the ones which are indicated by the filter.
       * @param {Function} filter The function used to determine which presences will be removed from the caches.
       * @returns {number} Amount of presences that were removed from the caches
       */
      sweepPresences(filter) {
        return this._sweepGuildDirectProp("presences", filter).items;
      }
      /**
       * Sweeps all message reactions and removes the ones which are indicated by the filter.
       * @param {Function} filter The function used to determine which reactions will be removed from the caches.
       * @returns {number} Amount of reactions that were removed from the caches
       */
      sweepReactions(filter) {
        if (typeof filter !== "function") {
          throw new TypeError2("INVALID_TYPE", "filter", "function");
        }
        let channels = 0;
        let messages = 0;
        let reactions = 0;
        for (const channel of this.client.channels.cache.values()) {
          if (!channel.isText()) continue;
          channels++;
          for (const message of channel.messages.cache.values()) {
            messages++;
            reactions += message.reactions.cache.sweep(filter);
          }
        }
        this.client.emit(
          Events2.CACHE_SWEEP,
          `Swept ${reactions} reactions on ${messages} messages in ${channels} text-based channels.`
        );
        return reactions;
      }
      /**
       * Sweeps all guild stage instances and removes the ones which are indicated by the filter.
       * @param {Function} filter The function used to determine which stage instances will be removed from the caches.
       * @returns {number} Amount of stage instances that were removed from the caches
       */
      sweepStageInstances(filter) {
        return this._sweepGuildDirectProp("stageInstances", filter, { outputName: "stage instances" }).items;
      }
      /**
       * Sweeps all guild stickers and removes the ones which are indicated by the filter.
       * @param {Function} filter The function used to determine which stickers will be removed from the caches.
       * @returns {number} Amount of stickers that were removed from the caches
       */
      sweepStickers(filter) {
        return this._sweepGuildDirectProp("stickers", filter).items;
      }
      /**
       * Sweeps all thread members and removes the ones which are indicated by the filter.
       * <info>It is highly recommended to keep the client thread member cached</info>
       * @param {Function} filter The function used to determine which thread members will be removed from the caches.
       * @returns {number} Amount of thread members that were removed from the caches
       */
      sweepThreadMembers(filter) {
        if (typeof filter !== "function") {
          throw new TypeError2("INVALID_TYPE", "filter", "function");
        }
        let threads = 0;
        let members = 0;
        for (const channel of this.client.channels.cache.values()) {
          if (!ThreadChannelTypes.includes(channel.type)) continue;
          threads++;
          members += channel.members.cache.sweep(filter);
        }
        this.client.emit(Events2.CACHE_SWEEP, `Swept ${members} thread members in ${threads} threads.`);
        return members;
      }
      /**
       * Sweeps all threads and removes the ones which are indicated by the filter.
       * @param {Function} filter The function used to determine which threads will be removed from the caches.
       * @returns {number} filter Amount of threads that were removed from the caches
       * @example
       * // Remove all threads archived greater than 1 day ago from all the channel caches
       * const amount = sweepers.sweepThreads(
       *   Sweepers.filterByLifetime({
       *     getComparisonTimestamp: t => t.archivedTimestamp,
       *     excludeFromSweep: t => !t.archived,
       *   })(),
       * );
       * console.log(`Successfully removed ${amount} threads from the cache.`);
       */
      sweepThreads(filter) {
        if (typeof filter !== "function") {
          throw new TypeError2("INVALID_TYPE", "filter", "function");
        }
        let threads = 0;
        for (const [key, val] of this.client.channels.cache.entries()) {
          if (!ThreadChannelTypes.includes(val.type)) continue;
          if (filter(val, key, this.client.channels.cache)) {
            threads++;
            this.client.channels._remove(key);
          }
        }
        this.client.emit(Events2.CACHE_SWEEP, `Swept ${threads} threads.`);
        return threads;
      }
      /**
       * Sweeps all users and removes the ones which are indicated by the filter.
       * @param {Function} filter The function used to determine which users will be removed from the caches.
       * @returns {number} Amount of users that were removed from the caches
       */
      sweepUsers(filter) {
        if (typeof filter !== "function") {
          throw new TypeError2("INVALID_TYPE", "filter", "function");
        }
        const users = this.client.users.cache.sweep(filter);
        this.client.emit(Events2.CACHE_SWEEP, `Swept ${users} users.`);
        return users;
      }
      /**
       * Sweeps all guild voice states and removes the ones which are indicated by the filter.
       * @param {Function} filter The function used to determine which voice states will be removed from the caches.
       * @returns {number} Amount of voice states that were removed from the caches
       */
      sweepVoiceStates(filter) {
        return this._sweepGuildDirectProp("voiceStates", filter, { outputName: "voice states" }).items;
      }
      /**
       * Cancels all sweeping intervals
       * @returns {void}
       */
      destroy() {
        for (const key of SweeperKeys) {
          if (this.intervals[key]) clearInterval(this.intervals[key]);
        }
      }
      /**
       * Options for generating a filter function based on lifetime
       * @typedef {Object} LifetimeFilterOptions
       * @property {number} [lifetime=14400] How long, in seconds, an entry should stay in the collection
       * before it is considered sweepable.
       * @property {Function} [getComparisonTimestamp=e => e?.createdTimestamp] A function that takes an entry, key,
       * and the collection and returns a timestamp to compare against in order to determine the lifetime of the entry.
       * @property {Function} [excludeFromSweep=() => false] A function that takes an entry, key, and the collection
       * and returns a boolean, `true` when the entry should not be checked for sweepability.
       */
      /**
       * Create a sweepFilter function that uses a lifetime to determine sweepability.
       * @param {LifetimeFilterOptions} [options={}] The options used to generate the filter function
       * @returns {GlobalSweepFilter}
       */
      static filterByLifetime({
        lifetime = 14400,
        getComparisonTimestamp = (e) => e == null ? void 0 : e.createdTimestamp,
        excludeFromSweep = () => false
      } = {}) {
        if (typeof lifetime !== "number") {
          throw new TypeError2("INVALID_TYPE", "lifetime", "number");
        }
        if (typeof getComparisonTimestamp !== "function") {
          throw new TypeError2("INVALID_TYPE", "getComparisonTimestamp", "function");
        }
        if (typeof excludeFromSweep !== "function") {
          throw new TypeError2("INVALID_TYPE", "excludeFromSweep", "function");
        }
        return () => {
          if (lifetime <= 0) return null;
          const lifetimeMs = lifetime * 1e3;
          const now = Date.now();
          return (entry, key, coll) => {
            if (excludeFromSweep(entry, key, coll)) {
              return false;
            }
            const comparisonTimestamp = getComparisonTimestamp(entry, key, coll);
            if (!comparisonTimestamp || typeof comparisonTimestamp !== "number") return false;
            return now - comparisonTimestamp > lifetimeMs;
          };
        };
      }
      /**
       * Creates a sweep filter that sweeps archived threads
       * @param {number} [lifetime=14400] How long a thread has to be archived to be valid for sweeping
       * @returns {GlobalSweepFilter}
       */
      static archivedThreadSweepFilter(lifetime = 14400) {
        return this.filterByLifetime({
          lifetime,
          getComparisonTimestamp: (e) => e.archiveTimestamp,
          excludeFromSweep: (e) => !e.archived
        });
      }
      /**
       * Creates a sweep filter that sweeps expired invites
       * @param {number} [lifetime=14400] How long ago an invite has to have expired to be valid for sweeping
       * @returns {GlobalSweepFilter}
       */
      static expiredInviteSweepFilter(lifetime = 14400) {
        return this.filterByLifetime({
          lifetime,
          getComparisonTimestamp: (i) => i.expiresTimestamp
        });
      }
      /**
       * Creates a sweep filter that sweeps outdated messages (edits taken into account)
       * @param {number} [lifetime=3600] How long ago a message has to have been sent or edited to be valid for sweeping
       * @returns {GlobalSweepFilter}
       */
      static outdatedMessageSweepFilter(lifetime = 3600) {
        return this.filterByLifetime({
          lifetime,
          getComparisonTimestamp: (m) => m.editedTimestamp ?? m.createdTimestamp
        });
      }
      /**
       * Configuration options for emitting the cache sweep client event
       * @typedef {Object} SweepEventOptions
       * @property {boolean} [emit=true] Whether to emit the client event in this method
       * @property {string} [outputName] A name to output in the client event if it should differ from the key
       * @private
       */
      /**
       * Sweep a direct sub property of all guilds
       * @param {string} key The name of the property
       * @param {Function} filter Filter function passed to sweep
       * @param {SweepEventOptions} [eventOptions={}] Options for the Client event emitted here
       * @returns {Object} Object containing the number of guilds swept and the number of items swept
       * @private
       */
      _sweepGuildDirectProp(key, filter, { emit = true, outputName } = {}) {
        if (typeof filter !== "function") {
          throw new TypeError2("INVALID_TYPE", "filter", "function");
        }
        let guilds = 0;
        let items = 0;
        for (const guild of this.client.guilds.cache.values()) {
          const { cache } = guild[key];
          guilds++;
          items += cache.sweep(filter);
        }
        if (emit) {
          this.client.emit(Events2.CACHE_SWEEP, `Swept ${items} ${outputName ?? key} in ${guilds} guilds.`);
        }
        return { guilds, items };
      }
      /**
       * Validates a set of properties
       * @param {string} key Key of the options object to check
       * @private
       */
      _validateProperties(key) {
        const props = this.options[key];
        if (typeof props !== "object") {
          throw new TypeError2("INVALID_TYPE", `sweepers.${key}`, "object", true);
        }
        if (typeof props.interval !== "number") {
          throw new TypeError2("INVALID_TYPE", `sweepers.${key}.interval`, "number");
        }
        if (["invites", "messages", "threads"].includes(key) && !("filter" in props)) {
          if (typeof props.lifetime !== "number") {
            throw new TypeError2("INVALID_TYPE", `sweepers.${key}.lifetime`, "number");
          }
          return;
        }
        if (typeof props.filter !== "function") {
          throw new TypeError2("INVALID_TYPE", `sweepers.${key}.filter`, "function");
        }
      }
      /**
       * Initialize an interval for sweeping
       * @param {string} intervalKey The name of the property that stores the interval for this sweeper
       * @param {string} sweepKey The name of the function that sweeps the desired caches
       * @param {Object} opts Validated options for a sweep
       * @private
       */
      _initInterval(intervalKey, sweepKey, opts) {
        if (opts.interval <= 0 || opts.interval === Infinity) return;
        this.intervals[intervalKey] = setInterval2(() => {
          const sweepFn = opts.filter();
          if (sweepFn === null) return;
          if (typeof sweepFn !== "function") throw new TypeError2("SWEEP_FILTER_RETURN");
          this[sweepKey](sweepFn);
        }, opts.interval * 1e3).unref();
      }
    };
    module2.exports = Sweepers2;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/Base.js
var require_Base = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/Base.js"(exports2, module2) {
    "use strict";
    var Util = require_Util();
    var Base = class {
      constructor(client) {
        Object.defineProperty(this, "client", { value: client });
      }
      _clone() {
        return Object.assign(Object.create(this), this);
      }
      _patch(data) {
        return data;
      }
      _update(data) {
        const clone = this._clone();
        this._patch(data);
        return clone;
      }
      toJSON(...props) {
        return Util.flatten(this, ...props);
      }
      valueOf() {
        return this.id;
      }
    };
    module2.exports = Base;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/util/BitField.js
var require_BitField = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/util/BitField.js"(exports2, module2) {
    "use strict";
    var { RangeError: RangeError2 } = require_errors2();
    var BitField = class _BitField {
      /**
       * @param {BitFieldResolvable} [bits=this.constructor.defaultBit] Bit(s) to read from
       */
      constructor(bits = this.constructor.defaultBit) {
        this.bitfield = this.constructor.resolve(bits);
      }
      /**
       * Checks whether the bitfield has a bit, or any of multiple bits.
       * @param {BitFieldResolvable} bit Bit(s) to check for
       * @returns {boolean}
       */
      any(bit) {
        return (this.bitfield & this.constructor.resolve(bit)) !== this.constructor.defaultBit;
      }
      /**
       * Checks if this bitfield equals another
       * @param {BitFieldResolvable} bit Bit(s) to check for
       * @returns {boolean}
       */
      equals(bit) {
        return this.bitfield === this.constructor.resolve(bit);
      }
      /**
       * Checks whether the bitfield has a bit, or multiple bits.
       * @param {BitFieldResolvable} bit Bit(s) to check for
       * @returns {boolean}
       */
      has(bit) {
        bit = this.constructor.resolve(bit);
        return (this.bitfield & bit) === bit;
      }
      /**
       * Gets all given bits that are missing from the bitfield.
       * @param {BitFieldResolvable} bits Bit(s) to check for
       * @param {...*} hasParams Additional parameters for the has method, if any
       * @returns {string[]}
       */
      missing(bits, ...hasParams) {
        return new this.constructor(bits).remove(this).toArray(...hasParams);
      }
      /**
       * Freezes these bits, making them immutable.
       * @returns {Readonly<BitField>}
       */
      freeze() {
        return Object.freeze(this);
      }
      /**
       * Adds bits to these ones.
       * @param {...BitFieldResolvable} [bits] Bits to add
       * @returns {BitField} These bits or new BitField if the instance is frozen.
       */
      add(...bits) {
        let total = this.constructor.defaultBit;
        for (const bit of bits) {
          total |= this.constructor.resolve(bit);
        }
        if (Object.isFrozen(this)) return new this.constructor(this.bitfield | total);
        this.bitfield |= total;
        return this;
      }
      /**
       * Removes bits from these.
       * @param {...BitFieldResolvable} [bits] Bits to remove
       * @returns {BitField} These bits or new BitField if the instance is frozen.
       */
      remove(...bits) {
        let total = this.constructor.defaultBit;
        for (const bit of bits) {
          total |= this.constructor.resolve(bit);
        }
        if (Object.isFrozen(this)) return new this.constructor(this.bitfield & ~total);
        this.bitfield &= ~total;
        return this;
      }
      /**
       * Gets an object mapping field names to a {@link boolean} indicating whether the
       * bit is available.
       * @param {...*} hasParams Additional parameters for the has method, if any
       * @returns {Object}
       */
      serialize(...hasParams) {
        const serialized = {};
        for (const [flag, bit] of Object.entries(this.constructor.FLAGS)) serialized[flag] = this.has(bit, ...hasParams);
        return serialized;
      }
      /**
       * Gets an {@link Array} of bitfield names based on the bits available.
       * @param {...*} hasParams Additional parameters for the has method, if any
       * @returns {string[]}
       */
      toArray(...hasParams) {
        return Object.keys(this.constructor.FLAGS).filter((bit) => this.has(bit, ...hasParams));
      }
      toJSON() {
        return typeof this.bitfield === "number" ? this.bitfield : this.bitfield.toString();
      }
      valueOf() {
        return this.bitfield;
      }
      *[Symbol.iterator]() {
        yield* this.toArray();
      }
      /**
       * Data that can be resolved to give a bitfield. This can be:
       * * A bit number (this can be a number literal or a value taken from {@link BitField.FLAGS})
       * * A string bit number
       * * An instance of BitField
       * * An Array of BitFieldResolvable
       * @typedef {number|string|bigint|BitField|BitFieldResolvable[]} BitFieldResolvable
       */
      /**
       * Resolves bitfields to their numeric form.
       * @param {BitFieldResolvable} [bit] bit(s) to resolve
       * @returns {number|bigint}
       */
      static resolve(bit) {
        const { defaultBit } = this;
        if (typeof defaultBit === typeof bit && bit >= defaultBit) return bit;
        if (bit instanceof _BitField) return bit.bitfield;
        if (Array.isArray(bit)) return bit.map((p) => this.resolve(p)).reduce((prev, p) => prev | p, defaultBit);
        if (typeof bit === "string") {
          if (!isNaN(bit)) return typeof defaultBit === "bigint" ? BigInt(bit) : Number(bit);
          if (this.FLAGS[bit] !== void 0) return this.FLAGS[bit];
        }
        throw new RangeError2("BITFIELD_INVALID", bit);
      }
    };
    BitField.FLAGS = {};
    BitField.defaultBit = 0;
    module2.exports = BitField;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/util/ChannelFlags.js
var require_ChannelFlags = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/util/ChannelFlags.js"(exports2, module2) {
    "use strict";
    var BitField = require_BitField();
    var ChannelFlags = class extends BitField {
    };
    ChannelFlags.FLAGS = {
      PINNED: 1 << 1,
      REQUIRE_TAG: 1 << 4
    };
    module2.exports = ChannelFlags;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/util/SnowflakeUtil.js
var require_SnowflakeUtil = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/util/SnowflakeUtil.js"(exports2, module2) {
    "use strict";
    var EPOCH = 14200704e5;
    var INCREMENT = BigInt(0);
    var SnowflakeUtil = class extends null {
      /**
       * A {@link https://developer.twitter.com/en/docs/twitter-ids Twitter snowflake},
       * except the epoch is 2015-01-01T00:00:00.000Z.
       *
       * If we have a snowflake '266241948824764416' we can represent it as binary:
       * ```
       * 64                                          22     17     12          0
       *  000000111011000111100001101001000101000000  00001  00000  000000000000
       *  number of milliseconds since Discord epoch  worker  pid    increment
       * ```
       * @typedef {string} Snowflake
       */
      /**
       * Generates a Discord snowflake.
       * <info>This hardcodes the worker's id as 1 and the process's id as 0.</info>
       * @param {number|Date} [timestamp=Date.now()] Timestamp or date of the snowflake to generate
       * @returns {Snowflake} The generated snowflake
       */
      static generate(timestamp = Date.now()) {
        if (timestamp instanceof Date) timestamp = timestamp.getTime();
        if (typeof timestamp !== "number" || isNaN(timestamp)) {
          throw new TypeError(
            `"timestamp" argument must be a number (received ${isNaN(timestamp) ? "NaN" : typeof timestamp})`
          );
        }
        if (INCREMENT >= 4095n) INCREMENT = BigInt(0);
        return (BigInt(timestamp - EPOCH) << 22n | 1n << 17n | INCREMENT++).toString();
      }
      /**
       * A deconstructed snowflake.
       * @typedef {Object} DeconstructedSnowflake
       * @property {number} timestamp Timestamp the snowflake was created
       * @property {Date} date Date the snowflake was created
       * @property {number} workerId The worker's id in the snowflake
       * @property {number} processId The process's id in the snowflake
       * @property {number} increment Increment in the snowflake
       * @property {string} binary Binary representation of the snowflake
       */
      /**
       * Deconstructs a Discord snowflake.
       * @param {Snowflake} snowflake Snowflake to deconstruct
       * @returns {DeconstructedSnowflake}
       */
      static deconstruct(snowflake) {
        const bigIntSnowflake = BigInt(snowflake);
        return {
          timestamp: Number(bigIntSnowflake >> 22n) + EPOCH,
          get date() {
            return new Date(this.timestamp);
          },
          workerId: Number(bigIntSnowflake >> 17n & 0b11111n),
          processId: Number(bigIntSnowflake >> 12n & 0b11111n),
          increment: Number(bigIntSnowflake & 0b111111111111n),
          binary: bigIntSnowflake.toString(2).padStart(64, "0")
        };
      }
      /**
       * Retrieves the timestamp field's value from a Discord snowflake.
       * @param {Snowflake} snowflake Snowflake to get the timestamp value from
       * @returns {number}
       */
      static timestampFrom(snowflake) {
        return Number(BigInt(snowflake) >> 22n) + EPOCH;
      }
      /**
       * Discord's epoch value (2015-01-01T00:00:00.000Z).
       * @type {number}
       * @readonly
       */
      static get EPOCH() {
        return EPOCH;
      }
    };
    module2.exports = SnowflakeUtil;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/CategoryChannel.js
var require_CategoryChannel = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/CategoryChannel.js"(exports2, module2) {
    "use strict";
    var GuildChannel = require_GuildChannel();
    var CategoryChannel = class extends GuildChannel {
      /**
       * The id of the parent of this channel.
       * @name CategoryChannel#parentId
       * @type {null}
       */
      /**
       * The parent of this channel.
       * @name CategoryChannel#parent
       * @type {null}
       * @readonly
       */
      /**
       * Channels that are a part of this category
       * @type {Collection<Snowflake, GuildChannel>}
       * @readonly
       */
      get children() {
        return this.guild.channels.cache.filter((c) => c.parentId === this.id);
      }
      /**
       * Sets the category parent of this channel.
       * <warn>It is not possible to set the parent of a CategoryChannel.</warn>
       * @method setParent
       * @memberof CategoryChannel
       * @instance
       * @param {?CategoryChannelResolvable} channel The channel to set as parent
       * @param {SetParentOptions} [options={}] The options for setting the parent
       * @returns {Promise<GuildChannel>}
       */
      /**
       * Options for creating a channel using {@link CategoryChannel#createChannel}.
       * @typedef {Object} CategoryCreateChannelOptions
       * @property {string} [name] The name of the new channel
       * @property {ChannelType|number} [type='GUILD_TEXT'] The type of the new channel.
       * @property {number} [position] Position of the new channel
       * @property {string} [topic] The topic for the new channel
       * @property {boolean} [nsfw] Whether the new channel is NSFW
       * @property {number} [bitrate] Bitrate of the new channel in bits (only voice)
       * @property {number} [userLimit] Maximum amount of users allowed in the new channel (only voice)
       * @property {OverwriteResolvable[]|Collection<Snowflake, OverwriteResolvable>} [permissionOverwrites]
       * Permission overwrites of the new channel
       * @property {number} [rateLimitPerUser] The rate limit per user (slowmode) for the new channel in seconds
       * @property {ThreadAutoArchiveDuration} [defaultAutoArchiveDuration]
       * The default auto archive duration for all new threads in this channel
       * @property {?string} [rtcRegion] The specific region of the new channel
       * @property {?VideoQualityMode|number} [videoQualityMode] The camera video quality mode of the new channel
       * @property {ChannelFlagsResolvable} [flags] The flags to set on the new channel
       * @property {GuildForumTagData[]} [availableTags] The tags to set as available in a forum channel
       * @property {?DefaultReactionEmoji} [defaultReactionEmoji] The emoji to set as the default reaction emoji
       * @property {number} [defaultThreadRateLimitPerUser] The rate limit per user (slowmode) to set on forum posts
       * @property {?SortOrderType} [defaultSortOrder] The default sort order mode to set on the new channel
       * @property {number} [defaultThreadRateLimitPerUser] The initial rate limit per user (slowmode)
       * to set on newly created threads in a channel.
       * @property {string} [reason] Reason for creating the new channel
       */
      /**
       * Creates a new channel within this category.
       * <info>You cannot create a channel of type `GUILD_CATEGORY` inside a CategoryChannel.</info>
       * @param {string} name The name of the new channel
       * @param {CategoryCreateChannelOptions} options Options for creating the new channel
       * @returns {Promise<GuildChannel>}
       */
      createChannel(name, options) {
        return this.guild.channels.create(name, {
          ...options,
          parent: this.id
        });
      }
    };
    module2.exports = CategoryChannel;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/interfaces/Collector.js
var require_Collector = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/interfaces/Collector.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require_node_events();
    var { setTimeout: setTimeout2 } = require_node_timers();
    var { Collection: Collection2 } = require_dist();
    var { TypeError: TypeError2 } = require_errors2();
    var Util = require_Util();
    var Collector = class extends EventEmitter {
      constructor(client, options = {}) {
        super();
        Object.defineProperty(this, "client", { value: client });
        this.filter = options.filter ?? (() => true);
        this.options = options;
        this.collected = new Collection2();
        this.ended = false;
        this._timeout = null;
        this._idletimeout = null;
        if (typeof this.filter !== "function") {
          throw new TypeError2("INVALID_TYPE", "options.filter", "function");
        }
        this.handleCollect = this.handleCollect.bind(this);
        this.handleDispose = this.handleDispose.bind(this);
        if (options.time) this._timeout = setTimeout2(() => this.stop("time"), options.time).unref();
        if (options.idle) this._idletimeout = setTimeout2(() => this.stop("idle"), options.idle).unref();
      }
      /**
       * Call this to handle an event as a collectable element. Accepts any event data as parameters.
       * @param {...*} args The arguments emitted by the listener
       * @returns {Promise<void>}
       * @emits Collector#collect
       */
      async handleCollect(...args) {
        const collect = await this.collect(...args);
        if (collect && await this.filter(...args, this.collected)) {
          this.collected.set(collect, args[0]);
          this.emit("collect", ...args);
          if (this._idletimeout) {
            clearTimeout(this._idletimeout);
            this._idletimeout = setTimeout2(() => this.stop("idle"), this.options.idle).unref();
          }
        }
        this.checkEnd();
      }
      /**
       * Call this to remove an element from the collection. Accepts any event data as parameters.
       * @param {...*} args The arguments emitted by the listener
       * @returns {Promise<void>}
       * @emits Collector#dispose
       */
      async handleDispose(...args) {
        if (!this.options.dispose) return;
        const dispose = this.dispose(...args);
        if (!dispose || !await this.filter(...args) || !this.collected.has(dispose)) return;
        this.collected.delete(dispose);
        this.emit("dispose", ...args);
        this.checkEnd();
      }
      /**
       * Returns a promise that resolves with the next collected element;
       * rejects with collected elements if the collector finishes without receiving a next element
       * @type {Promise}
       * @readonly
       */
      get next() {
        return new Promise((resolve, reject) => {
          if (this.ended) {
            reject(this.collected);
            return;
          }
          const cleanup = () => {
            this.removeListener("collect", onCollect);
            this.removeListener("end", onEnd);
          };
          const onCollect = (item) => {
            cleanup();
            resolve(item);
          };
          const onEnd = () => {
            cleanup();
            reject(this.collected);
          };
          this.on("collect", onCollect);
          this.on("end", onEnd);
        });
      }
      /**
       * Stops this collector and emits the `end` event.
       * @param {string} [reason='user'] The reason this collector is ending
       * @emits Collector#end
       */
      stop(reason = "user") {
        if (this.ended) return;
        if (this._timeout) {
          clearTimeout(this._timeout);
          this._timeout = null;
        }
        if (this._idletimeout) {
          clearTimeout(this._idletimeout);
          this._idletimeout = null;
        }
        this.ended = true;
        this.emit("end", this.collected, reason);
      }
      /**
       * Options used to reset the timeout and idle timer of a {@link Collector}.
       * @typedef {Object} CollectorResetTimerOptions
       * @property {number} [time] How long to run the collector for (in milliseconds)
       * @property {number} [idle] How long to wait to stop the collector after inactivity (in milliseconds)
       */
      /**
       * Resets the collector's timeout and idle timer.
       * @param {CollectorResetTimerOptions} [options] Options for resetting
       */
      resetTimer({ time, idle } = {}) {
        if (this._timeout) {
          clearTimeout(this._timeout);
          this._timeout = setTimeout2(() => this.stop("time"), time ?? this.options.time).unref();
        }
        if (this._idletimeout) {
          clearTimeout(this._idletimeout);
          this._idletimeout = setTimeout2(() => this.stop("idle"), idle ?? this.options.idle).unref();
        }
      }
      /**
       * Checks whether the collector should end, and if so, ends it.
       * @returns {boolean} Whether the collector ended or not
       */
      checkEnd() {
        const reason = this.endReason;
        if (reason) this.stop(reason);
        return Boolean(reason);
      }
      /**
       * Allows collectors to be consumed with for-await-of loops
       * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of}
       */
      async *[Symbol.asyncIterator]() {
        const queue = [];
        const onCollect = (item) => queue.push(item);
        this.on("collect", onCollect);
        try {
          while (queue.length || !this.ended) {
            if (queue.length) {
              yield queue.shift();
            } else {
              await new Promise((resolve) => {
                const tick = () => {
                  this.removeListener("collect", tick);
                  this.removeListener("end", tick);
                  return resolve();
                };
                this.on("collect", tick);
                this.on("end", tick);
              });
            }
          }
        } finally {
          this.removeListener("collect", onCollect);
        }
      }
      toJSON() {
        return Util.flatten(this);
      }
      /* eslint-disable no-empty-function */
      /**
       * The reason this collector has ended with, or null if it hasn't ended yet
       * @type {?string}
       * @readonly
       * @abstract
       */
      get endReason() {
      }
      /**
       * Handles incoming events from the `handleCollect` function. Returns null if the event should not
       * be collected, or returns an object describing the data that should be stored.
       * @see Collector#handleCollect
       * @param {...*} args Any args the event listener emits
       * @returns {?(*|Promise<?*>)} Data to insert into collection, if any
       * @abstract
       */
      collect() {
      }
      /**
       * Handles incoming events from the `handleDispose`. Returns null if the event should not
       * be disposed, or returns the key that should be removed.
       * @see Collector#handleDispose
       * @param {...*} args Any args the event listener emits
       * @returns {?*} Key to remove from the collection, if any
       * @abstract
       */
      dispose() {
      }
      /* eslint-enable no-empty-function */
    };
    module2.exports = Collector;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/MessageCollector.js
var require_MessageCollector = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/MessageCollector.js"(exports2, module2) {
    "use strict";
    var Collector = require_Collector();
    var { Events: Events2 } = require_Constants();
    var MessageCollector = class extends Collector {
      /**
       * @param {TextBasedChannels} channel The channel
       * @param {MessageCollectorOptions} options The options to be applied to this collector
       * @emits MessageCollector#message
       */
      constructor(channel, options = {}) {
        super(channel.client, options);
        this.channel = channel;
        this.received = 0;
        const bulkDeleteListener = (messages) => {
          for (const message of messages.values()) this.handleDispose(message);
        };
        this._handleChannelDeletion = this._handleChannelDeletion.bind(this);
        this._handleThreadDeletion = this._handleThreadDeletion.bind(this);
        this._handleGuildDeletion = this._handleGuildDeletion.bind(this);
        this.client.incrementMaxListeners();
        this.client.on(Events2.MESSAGE_CREATE, this.handleCollect);
        this.client.on(Events2.MESSAGE_DELETE, this.handleDispose);
        this.client.on(Events2.MESSAGE_BULK_DELETE, bulkDeleteListener);
        this.client.on(Events2.CHANNEL_DELETE, this._handleChannelDeletion);
        this.client.on(Events2.THREAD_DELETE, this._handleThreadDeletion);
        this.client.on(Events2.GUILD_DELETE, this._handleGuildDeletion);
        this.once("end", () => {
          this.client.removeListener(Events2.MESSAGE_CREATE, this.handleCollect);
          this.client.removeListener(Events2.MESSAGE_DELETE, this.handleDispose);
          this.client.removeListener(Events2.MESSAGE_BULK_DELETE, bulkDeleteListener);
          this.client.removeListener(Events2.CHANNEL_DELETE, this._handleChannelDeletion);
          this.client.removeListener(Events2.THREAD_DELETE, this._handleThreadDeletion);
          this.client.removeListener(Events2.GUILD_DELETE, this._handleGuildDeletion);
          this.client.decrementMaxListeners();
        });
      }
      /**
       * Handles a message for possible collection.
       * @param {Message} message The message that could be collected
       * @returns {?Snowflake}
       * @private
       */
      collect(message) {
        if (message.channelId !== this.channel.id) return null;
        this.received++;
        return message.id;
      }
      /**
       * Handles a message for possible disposal.
       * @param {Message} message The message that could be disposed of
       * @returns {?Snowflake}
       */
      dispose(message) {
        return message.channelId === this.channel.id ? message.id : null;
      }
      /**
       * The reason this collector has ended with, or null if it hasn't ended yet
       * @type {?string}
       * @readonly
       */
      get endReason() {
        if (this.options.max && this.collected.size >= this.options.max) return "limit";
        if (this.options.maxProcessed && this.received === this.options.maxProcessed) return "processedLimit";
        return null;
      }
      /**
       * Handles checking if the channel has been deleted, and if so, stops the collector with the reason 'channelDelete'.
       * @private
       * @param {GuildChannel} channel The channel that was deleted
       * @returns {void}
       */
      _handleChannelDeletion(channel) {
        if (channel.id === this.channel.id || channel.id === this.channel.parentId) {
          this.stop("channelDelete");
        }
      }
      /**
       * Handles checking if the thread has been deleted, and if so, stops the collector with the reason 'threadDelete'.
       * @private
       * @param {ThreadChannel} thread The thread that was deleted
       * @returns {void}
       */
      _handleThreadDeletion(thread) {
        if (thread.id === this.channel.id) {
          this.stop("threadDelete");
        }
      }
      /**
       * Handles checking if the guild has been deleted, and if so, stops the collector with the reason 'guildDelete'.
       * @private
       * @param {Guild} guild The guild that was deleted
       * @returns {void}
       */
      _handleGuildDeletion(guild) {
        var _a;
        if (guild.id === ((_a = this.channel.guild) == null ? void 0 : _a.id)) {
          this.stop("guildDelete");
        }
      }
    };
    module2.exports = MessageCollector;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/MessageActionRow.js
var require_MessageActionRow = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/MessageActionRow.js"(exports2, module2) {
    "use strict";
    var BaseMessageComponent = require_BaseMessageComponent();
    var { MessageComponentTypes } = require_Constants();
    var MessageActionRow = class extends BaseMessageComponent {
      /**
       * Components that can be placed in an action row
       * * MessageButton
       * * MessageSelectMenu
       * * TextInputComponent
       * @typedef {MessageButton|MessageSelectMenu|TextInputComponent} MessageActionRowComponent
       */
      /**
       * Options for components that can be placed in an action row
       * * MessageButtonOptions
       * * MessageSelectMenuOptions
       * * TextInputComponentOptions
       * @typedef {MessageButtonOptions|MessageSelectMenuOptions|TextInputComponentOptions} MessageActionRowComponentOptions
       */
      /**
       * Data that can be resolved into components that can be placed in an action row
       * * MessageActionRowComponent
       * * MessageActionRowComponentOptions
       * @typedef {MessageActionRowComponent|MessageActionRowComponentOptions} MessageActionRowComponentResolvable
       */
      /**
       * @typedef {BaseMessageComponentOptions} MessageActionRowOptions
       * @property {MessageActionRowComponentResolvable[]} [components]
       * The components to place in this action row
       */
      /**
       * @param {MessageActionRow|MessageActionRowOptions} [data={}] MessageActionRow to clone or raw data
       * @param {Client} [client] The client constructing this MessageActionRow, if provided
       */
      constructor(data = {}, client = null) {
        var _a;
        super({ type: "ACTION_ROW" });
        this.components = ((_a = data.components) == null ? void 0 : _a.map((c) => BaseMessageComponent.create(c, client))) ?? [];
      }
      /**
       * Adds components to the action row.
       * @param {...MessageActionRowComponentResolvable[]} components The components to add
       * @returns {MessageActionRow}
       */
      addComponents(...components) {
        this.components.push(...components.flat(Infinity).map((c) => BaseMessageComponent.create(c)));
        return this;
      }
      /**
       * Sets the components of the action row.
       * @param {...MessageActionRowComponentResolvable[]} components The components to set
       * @returns {MessageActionRow}
       */
      setComponents(...components) {
        this.spliceComponents(0, this.components.length, components);
        return this;
      }
      /**
       * Removes, replaces, and inserts components in the action row.
       * @param {number} index The index to start at
       * @param {number} deleteCount The number of components to remove
       * @param {...MessageActionRowComponentResolvable[]} [components] The replacing components
       * @returns {MessageActionRow}
       */
      spliceComponents(index, deleteCount, ...components) {
        this.components.splice(index, deleteCount, ...components.flat(Infinity).map((c) => BaseMessageComponent.create(c)));
        return this;
      }
      /**
       * Transforms the action row to a plain object.
       * @returns {APIMessageComponent} The raw data of this action row
       */
      toJSON() {
        return {
          components: this.components.map((c) => c.toJSON()),
          type: MessageComponentTypes[this.type]
        };
      }
    };
    module2.exports = MessageActionRow;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/MessageButton.js
var require_MessageButton = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/MessageButton.js"(exports2, module2) {
    "use strict";
    var BaseMessageComponent = require_BaseMessageComponent();
    var { RangeError: RangeError2 } = require_errors2();
    var { MessageButtonStyles, MessageComponentTypes } = require_Constants();
    var Util = require_Util();
    var MessageButton = class _MessageButton extends BaseMessageComponent {
      /**
       * @typedef {BaseMessageComponentOptions} MessageButtonOptions
       * @property {string} [label] The text to be displayed on this button
       * @property {string} [customId] A unique string to be sent in the interaction when clicked
       * @property {MessageButtonStyleResolvable} [style] The style of this button
       * @property {EmojiIdentifierResolvable} [emoji] The emoji to be displayed to the left of the text
       * @property {string} [url] Optional URL for link-style buttons
       * @property {boolean} [disabled=false] Disables the button to prevent interactions
       */
      /**
       * @param {MessageButton|MessageButtonOptions} [data={}] MessageButton to clone or raw data
       */
      constructor(data = {}) {
        super({ type: "BUTTON" });
        this.setup(data);
      }
      setup(data) {
        this.label = data.label ?? null;
        this.customId = data.custom_id ?? data.customId ?? null;
        this.style = data.style ? _MessageButton.resolveStyle(data.style) : null;
        this.emoji = data.emoji ? Util.resolvePartialEmoji(data.emoji) : null;
        this.url = data.url ?? null;
        this.disabled = data.disabled ?? false;
      }
      /**
       * Sets the custom id for this button
       * @param {string} customId A unique string to be sent in the interaction when clicked
       * @returns {MessageButton}
       */
      setCustomId(customId) {
        this.customId = Util.verifyString(customId, RangeError2, "BUTTON_CUSTOM_ID");
        return this;
      }
      /**
       * Sets the interactive status of the button
       * @param {boolean} [disabled=true] Whether this button should be disabled
       * @returns {MessageButton}
       */
      setDisabled(disabled = true) {
        this.disabled = disabled;
        return this;
      }
      /**
       * Set the emoji of this button
       * @param {EmojiIdentifierResolvable} emoji The emoji to be displayed on this button
       * @returns {MessageButton}
       */
      setEmoji(emoji) {
        this.emoji = Util.resolvePartialEmoji(emoji);
        return this;
      }
      /**
       * Sets the label of this button
       * @param {string} label The text to be displayed on this button
       * @returns {MessageButton}
       */
      setLabel(label) {
        this.label = Util.verifyString(label, RangeError2, "BUTTON_LABEL");
        return this;
      }
      /**
       * Sets the style of this button
       * @param {MessageButtonStyleResolvable} style The style of this button
       * @returns {MessageButton}
       */
      setStyle(style) {
        this.style = _MessageButton.resolveStyle(style);
        return this;
      }
      /**
       * Sets the URL of this button.
       * <info>MessageButton#style must be LINK when setting a URL</info>
       * @param {string} url The URL of this button
       * @returns {MessageButton}
       */
      setURL(url) {
        this.url = Util.verifyString(url, RangeError2, "BUTTON_URL");
        return this;
      }
      /**
       * Transforms the button to a plain object.
       * @returns {APIMessageButton} The raw data of this button
       */
      toJSON() {
        return {
          custom_id: this.customId,
          disabled: this.disabled,
          emoji: this.emoji,
          label: this.label,
          style: MessageButtonStyles[this.style],
          type: MessageComponentTypes[this.type],
          url: this.url
        };
      }
      /**
       * Data that can be resolved to a MessageButtonStyle. This can be
       * * MessageButtonStyle
       * * number
       * @typedef {number|MessageButtonStyle} MessageButtonStyleResolvable
       */
      /**
       * Resolves the style of a button
       * @param {MessageButtonStyleResolvable} style The style to resolve
       * @returns {MessageButtonStyle}
       * @private
       */
      static resolveStyle(style) {
        return typeof style === "string" ? style : MessageButtonStyles[style];
      }
    };
    module2.exports = MessageButton;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/MessageSelectMenu.js
var require_MessageSelectMenu = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/MessageSelectMenu.js"(exports2, module2) {
    "use strict";
    var BaseMessageComponent = require_BaseMessageComponent();
    var { ChannelTypes, MessageComponentTypes } = require_Constants();
    var Util = require_Util();
    var MessageSelectMenu = class extends BaseMessageComponent {
      /**
       * @typedef {BaseMessageComponentOptions} MessageSelectMenuOptions
       * @property {string} [customId] A unique string to be sent in the interaction when clicked
       * @property {string} [placeholder] Custom placeholder text to display when nothing is selected
       * @property {number} [minValues] The minimum number of selections required
       * @property {number} [maxValues] The maximum number of selections allowed
       * @property {MessageSelectOption[]} [options] Options for the select menu
       * @property {boolean} [disabled=false] Disables the select menu to prevent interactions
       * @property {ChannelType[]} [channelTypes] List of channel types to include in the ChannelSelect component
       */
      /**
       * @typedef {Object} MessageSelectOption
       * @property {string} label The text to be displayed on this option
       * @property {string} value The value to be sent for this option
       * @property {?string} description Optional description to show for this option
       * @property {?RawEmoji} emoji Emoji to display for this option
       * @property {boolean} default Render this option as the default selection
       */
      /**
       * @typedef {Object} MessageSelectOptionData
       * @property {string} label The text to be displayed on this option
       * @property {string} value The value to be sent for this option
       * @property {string} [description] Optional description to show for this option
       * @property {EmojiIdentifierResolvable} [emoji] Emoji to display for this option
       * @property {boolean} [default] Render this option as the default selection
       */
      /**
       * @param {MessageSelectMenu|MessageSelectMenuOptions} [data={}] MessageSelectMenu to clone or raw data
       */
      constructor(data = {}) {
        super({ type: BaseMessageComponent.resolveType(data.type) ?? "STRING_SELECT" });
        this.setup(data);
      }
      setup(data) {
        var _a;
        this.customId = data.custom_id ?? data.customId ?? null;
        this.placeholder = data.placeholder ?? null;
        this.minValues = data.min_values ?? data.minValues ?? null;
        this.maxValues = data.max_values ?? data.maxValues ?? null;
        this.options = this.constructor.normalizeOptions(data.options ?? []);
        this.disabled = data.disabled ?? false;
        this.channelTypes = ((_a = data.channel_types) == null ? void 0 : _a.map(
          (channelType) => typeof channelType === "string" ? channelType : ChannelTypes[channelType]
        )) ?? [];
      }
      /**
       * Transforms the select menu into a plain object
       * @returns {APIMessageSelectMenu} The raw data of this select menu
       */
      toJSON() {
        return {
          channel_types: this.channelTypes.map((type) => typeof type === "string" ? ChannelTypes[type] : type),
          custom_id: this.customId,
          disabled: this.disabled,
          placeholder: this.placeholder,
          min_values: this.minValues,
          max_values: this.maxValues ?? (this.minValues ? this.options.length : void 0),
          options: this.options,
          type: typeof this.type === "string" ? MessageComponentTypes[this.type] : this.type
        };
      }
      /**
       * Normalizes option input and resolves strings and emojis.
       * @param {MessageSelectOptionData} option The select menu option to normalize
       * @returns {MessageSelectOption}
       */
      static normalizeOption(option) {
        let { label, value, description, emoji } = option;
        label = Util.verifyString(label, RangeError, "SELECT_OPTION_LABEL");
        value = Util.verifyString(value, RangeError, "SELECT_OPTION_VALUE");
        emoji = emoji ? Util.resolvePartialEmoji(emoji) : null;
        description = description ? Util.verifyString(description, RangeError, "SELECT_OPTION_DESCRIPTION", true) : null;
        return { label, value, description, emoji, default: option.default ?? false };
      }
      /**
       * Normalizes option input and resolves strings and emojis.
       * @param {...MessageSelectOptionData|MessageSelectOptionData[]} options The select menu options to normalize
       * @returns {MessageSelectOption[]}
       */
      static normalizeOptions(...options) {
        return options.flat(Infinity).map((option) => this.normalizeOption(option));
      }
    };
    module2.exports = MessageSelectMenu;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/TextInputComponent.js
var require_TextInputComponent = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/TextInputComponent.js"(exports2, module2) {
    "use strict";
    var BaseMessageComponent = require_BaseMessageComponent();
    var { RangeError: RangeError2 } = require_errors2();
    var { TextInputStyles, MessageComponentTypes } = require_Constants();
    var Util = require_Util();
    var TextInputComponent = class _TextInputComponent extends BaseMessageComponent {
      /**
       * @typedef {BaseMessageComponentOptions} TextInputComponentOptions
       * @property {string} [customId] A unique string to be sent in the interaction when submitted
       * @property {string} [label] The text to be displayed above this text input component
       * @property {number} [maxLength] Maximum length of text that can be entered
       * @property {number} [minLength] Minimum length of text required to be entered
       * @property {string} [placeholder] Custom placeholder text to display when no text is entered
       * @property {boolean} [required] Whether or not this text input component is required
       * @property {TextInputStyleResolvable} [style] The style of this text input component
       * @property {string} [value] Value of this text input component
       */
      /**
       * @param {TextInputComponent|TextInputComponentOptions} [data={}] TextInputComponent to clone or raw data
       */
      constructor(data = {}) {
        super({ type: "TEXT_INPUT" });
        this.setup(data);
      }
      setup(data) {
        this.customId = data.custom_id ?? data.customId ?? null;
        this.label = data.label ?? null;
        this.maxLength = data.max_length ?? data.maxLength ?? null;
        this.minLength = data.min_length ?? data.minLength ?? null;
        this.placeholder = data.placeholder ?? null;
        this.required = data.required ?? false;
        this.style = data.style ? _TextInputComponent.resolveStyle(data.style) : null;
        this.value = data.value ?? null;
      }
      /**
       * Sets the value of this text input component
       * @param {string} value Value of this text input component
       * @returns {TextInputComponent}
       */
      setValue(value) {
        this.value = Util.verifyString(value, RangeError2, "TEXT_INPUT_VALUE");
        return this;
      }
      /**
       * Transforms the text input component into a plain object
       * @returns {APITextInput} The raw data of this text input component
       */
      toJSON() {
        return {
          custom_id: this.customId,
          label: this.label,
          max_length: this.maxLength,
          min_length: this.minLength,
          placeholder: this.placeholder,
          required: this.required,
          style: TextInputStyles[this.style],
          type: MessageComponentTypes[this.type],
          value: this.value
        };
      }
      /**
       * Data that can be resolved to a TextInputStyle. This can be
       * * TextInputStyle
       * * number
       * @typedef {number|TextInputStyle} TextInputStyleResolvable
       */
      /**
       * Resolves the style of a text input component
       * @param {TextInputStyleResolvable} style The style to resolve
       * @returns {TextInputStyle}
       * @private
       */
      static resolveStyle(style) {
        return typeof style === "string" ? style : TextInputStyles[style];
      }
    };
    module2.exports = TextInputComponent;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/BaseMessageComponent.js
var require_BaseMessageComponent = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/BaseMessageComponent.js"(exports2, module2) {
    "use strict";
    var { TypeError: TypeError2 } = require_errors2();
    var { MessageComponentTypes, Events: Events2 } = require_Constants();
    var BaseMessageComponent = class _BaseMessageComponent {
      /**
       * Options for a BaseMessageComponent
       * @typedef {Object} BaseMessageComponentOptions
       * @property {MessageComponentTypeResolvable} type The type of this component
       */
      /**
       * Data that can be resolved into options for a component. This can be:
       * * MessageActionRowOptions
       * * MessageButtonOptions
       * * MessageSelectMenuOptions
       * * TextInputComponentOptions
       * @typedef {MessageActionRowOptions|MessageButtonOptions|MessageSelectMenuOptions} MessageComponentOptions
       */
      /**
       * Components that can be sent in a payload. These can be:
       * * MessageActionRow
       * * MessageButton
       * * MessageSelectMenu
       * * TextInputComponent
       * @typedef {MessageActionRow|MessageButton|MessageSelectMenu} MessageComponent
       * @see {@link https://discord.com/developers/docs/interactions/message-components#component-object-component-types}
       */
      /**
       * Data that can be resolved to a MessageComponentType. This can be:
       * * MessageComponentType
       * * string
       * * number
       * @typedef {string|number|MessageComponentType} MessageComponentTypeResolvable
       */
      /**
       * @param {BaseMessageComponent|BaseMessageComponentOptions} [data={}] The options for this component
       */
      constructor(data) {
        this.type = "type" in data ? _BaseMessageComponent.resolveType(data.type) : null;
      }
      /**
       * Constructs a component based on the type of the incoming data
       * @param {MessageComponentOptions} data Data for a MessageComponent
       * @param {Client|WebhookClient} [client] Client constructing this component
       * @returns {?(MessageComponent|ModalComponent)}
       * @private
       */
      static create(data, client) {
        let component;
        let type = data.type;
        if (typeof type === "string") type = MessageComponentTypes[type];
        switch (type) {
          case MessageComponentTypes.ACTION_ROW: {
            const MessageActionRow = require_MessageActionRow();
            component = data instanceof MessageActionRow ? data : new MessageActionRow(data, client);
            break;
          }
          case MessageComponentTypes.BUTTON: {
            const MessageButton = require_MessageButton();
            component = data instanceof MessageButton ? data : new MessageButton(data);
            break;
          }
          case MessageComponentTypes.STRING_SELECT:
          case MessageComponentTypes.USER_SELECT:
          case MessageComponentTypes.ROLE_SELECT:
          case MessageComponentTypes.MENTIONABLE_SELECT:
          case MessageComponentTypes.CHANNEL_SELECT: {
            const MessageSelectMenu = require_MessageSelectMenu();
            component = data instanceof MessageSelectMenu ? data : new MessageSelectMenu(data);
            break;
          }
          case MessageComponentTypes.TEXT_INPUT: {
            const TextInputComponent = require_TextInputComponent();
            component = data instanceof TextInputComponent ? data : new TextInputComponent(data);
            break;
          }
          default:
            if (client) {
              client.emit(Events2.DEBUG, `[BaseMessageComponent] Received component with unknown type: ${data.type}`);
            } else {
              throw new TypeError2("INVALID_TYPE", "data.type", "valid MessageComponentType");
            }
        }
        return component;
      }
      /**
       * Resolves the type of a component
       * @param {MessageComponentTypeResolvable} type The type to resolve
       * @returns {MessageComponentType}
       * @private
       */
      static resolveType(type) {
        return typeof type === "string" ? type : MessageComponentTypes[type];
      }
    };
    module2.exports = BaseMessageComponent;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/MessageEmbed.js
var require_MessageEmbed = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/MessageEmbed.js"(exports2, module2) {
    "use strict";
    var process2 = require_node_process();
    var { RangeError: RangeError2 } = require_errors2();
    var Util = require_Util();
    var deprecationEmittedForSetAuthor = false;
    var deprecationEmittedForSetFooter = false;
    var deprecationEmittedForAddField = false;
    var MessageEmbed = class {
      /**
       * A `Partial` object is a representation of any existing object.
       * This object contains between 0 and all of the original objects parameters.
       * This is true regardless of whether the parameters are optional in the base object.
       * @typedef {Object} Partial
       */
      /**
       * Represents the possible options for a MessageEmbed
       * @typedef {Object} MessageEmbedOptions
       * @property {string} [title] The title of this embed
       * @property {string} [description] The description of this embed
       * @property {string} [url] The URL of this embed
       * @property {Date|number} [timestamp] The timestamp of this embed
       * @property {ColorResolvable} [color] The color of this embed
       * @property {EmbedFieldData[]} [fields] The fields of this embed
       * @property {Partial<MessageEmbedAuthor>} [author] The author of this embed
       * @property {Partial<MessageEmbedThumbnail>} [thumbnail] The thumbnail of this embed
       * @property {Partial<MessageEmbedImage>} [image] The image of this embed
       * @property {Partial<MessageEmbedVideo>} [video] The video of this embed
       * @property {Partial<MessageEmbedFooter>} [footer] The footer of this embed
       */
      // eslint-disable-next-line valid-jsdoc
      /**
       * @param {MessageEmbed|MessageEmbedOptions|APIEmbed} [data={}] MessageEmbed to clone or raw embed data
       */
      constructor(data = {}, skipValidation = false) {
        this.setup(data, skipValidation);
      }
      setup(data, skipValidation) {
        this.type = data.type ?? "rich";
        this.title = data.title ?? null;
        this.description = data.description ?? null;
        this.url = data.url ?? null;
        this.color = "color" in data ? Util.resolveColor(data.color) : null;
        this.timestamp = "timestamp" in data ? new Date(data.timestamp).getTime() : null;
        this.fields = [];
        if (data.fields) {
          this.fields = skipValidation ? data.fields.map(Util.cloneObject) : this.constructor.normalizeFields(data.fields);
        }
        this.thumbnail = data.thumbnail ? {
          url: data.thumbnail.url,
          proxyURL: data.thumbnail.proxyURL ?? data.thumbnail.proxy_url,
          height: data.thumbnail.height,
          width: data.thumbnail.width
        } : null;
        this.image = data.image ? {
          url: data.image.url,
          proxyURL: data.image.proxyURL ?? data.image.proxy_url,
          height: data.image.height,
          width: data.image.width
        } : null;
        this.video = data.video ? {
          url: data.video.url,
          proxyURL: data.video.proxyURL ?? data.video.proxy_url,
          height: data.video.height,
          width: data.video.width
        } : null;
        this.author = data.author ? {
          name: data.author.name,
          url: data.author.url,
          iconURL: data.author.iconURL ?? data.author.icon_url,
          proxyIconURL: data.author.proxyIconURL ?? data.author.proxy_icon_url
        } : null;
        this.provider = data.provider ? {
          name: data.provider.name,
          url: data.provider.url
        } : null;
        this.footer = data.footer ? {
          text: data.footer.text,
          iconURL: data.footer.iconURL ?? data.footer.icon_url,
          proxyIconURL: data.footer.proxyIconURL ?? data.footer.proxy_icon_url
        } : null;
      }
      /**
       * The date displayed on this embed
       * @type {?Date}
       * @readonly
       */
      get createdAt() {
        return this.timestamp ? new Date(this.timestamp) : null;
      }
      /**
       * The hexadecimal version of the embed color, with a leading hash
       * @type {?string}
       * @readonly
       */
      get hexColor() {
        return this.color ? `#${this.color.toString(16).padStart(6, "0")}` : null;
      }
      /**
       * The accumulated length for the embed title, description, fields, footer text, and author name
       * @type {number}
       * @readonly
       */
      get length() {
        var _a, _b, _c, _d;
        return (((_a = this.title) == null ? void 0 : _a.length) ?? 0) + (((_b = this.description) == null ? void 0 : _b.length) ?? 0) + (this.fields.length >= 1 ? this.fields.reduce((prev, curr) => prev + curr.name.length + curr.value.length, 0) : 0) + (((_c = this.footer) == null ? void 0 : _c.text.length) ?? 0) + (((_d = this.author) == null ? void 0 : _d.name.length) ?? 0);
      }
      /**
       * Checks if this embed is equal to another one by comparing every single one of their properties.
       * @param {MessageEmbed|APIEmbed} embed The embed to compare with
       * @returns {boolean}
       */
      equals(embed) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v;
        return this.type === embed.type && ((_a = this.author) == null ? void 0 : _a.name) === ((_b = embed.author) == null ? void 0 : _b.name) && ((_c = this.author) == null ? void 0 : _c.url) === ((_d = embed.author) == null ? void 0 : _d.url) && ((_e = this.author) == null ? void 0 : _e.iconURL) === (((_f = embed.author) == null ? void 0 : _f.iconURL) ?? ((_g = embed.author) == null ? void 0 : _g.icon_url)) && this.color === embed.color && this.title === embed.title && this.description === embed.description && this.url === embed.url && this.timestamp === embed.timestamp && this.fields.length === embed.fields.length && this.fields.every((field, i) => this._fieldEquals(field, embed.fields[i])) && ((_h = this.footer) == null ? void 0 : _h.text) === ((_i = embed.footer) == null ? void 0 : _i.text) && ((_j = this.footer) == null ? void 0 : _j.iconURL) === (((_k = embed.footer) == null ? void 0 : _k.iconURL) ?? ((_l = embed.footer) == null ? void 0 : _l.icon_url)) && ((_m = this.image) == null ? void 0 : _m.url) === ((_n = embed.image) == null ? void 0 : _n.url) && ((_o = this.thumbnail) == null ? void 0 : _o.url) === ((_p = embed.thumbnail) == null ? void 0 : _p.url) && ((_q = this.video) == null ? void 0 : _q.url) === ((_r = embed.video) == null ? void 0 : _r.url) && ((_s = this.provider) == null ? void 0 : _s.name) === ((_t = embed.provider) == null ? void 0 : _t.name) && ((_u = this.provider) == null ? void 0 : _u.url) === ((_v = embed.provider) == null ? void 0 : _v.url);
      }
      /**
       * Compares two given embed fields to see if they are equal
       * @param {EmbedFieldData} field The first field to compare
       * @param {EmbedFieldData} other The second field to compare
       * @returns {boolean}
       * @private
       */
      _fieldEquals(field, other) {
        return field.name === other.name && field.value === other.value && field.inline === other.inline;
      }
      /**
       * Adds a field to the embed (max 25).
       * @param {string} name The name of this field
       * @param {string} value The value of this field
       * @param {boolean} [inline=false] If this field will be displayed inline
       * @returns {MessageEmbed}
       * @deprecated This method is a wrapper for {@link MessageEmbed#addFields}. Use that instead.
       */
      addField(name, value, inline) {
        if (!deprecationEmittedForAddField) {
          process2.emitWarning(
            // eslint-disable-next-line max-len
            "MessageEmbed#addField is deprecated and will be removed in the next major update. Use MessageEmbed#addFields instead.",
            "DeprecationWarning"
          );
          deprecationEmittedForAddField = true;
        }
        return this.addFields({ name, value, inline });
      }
      /**
       * Adds fields to the embed (max 25).
       * @param {...EmbedFieldData|EmbedFieldData[]} fields The fields to add
       * @returns {MessageEmbed}
       */
      addFields(...fields) {
        this.fields.push(...this.constructor.normalizeFields(fields));
        return this;
      }
      /**
       * Removes, replaces, and inserts fields in the embed (max 25).
       * @param {number} index The index to start at
       * @param {number} deleteCount The number of fields to remove
       * @param {...EmbedFieldData|EmbedFieldData[]} [fields] The replacing field objects
       * @returns {MessageEmbed}
       */
      spliceFields(index, deleteCount, ...fields) {
        this.fields.splice(index, deleteCount, ...this.constructor.normalizeFields(...fields));
        return this;
      }
      /**
       * Sets the embed's fields (max 25).
       * @param {...EmbedFieldData|EmbedFieldData[]} fields The fields to set
       * @returns {MessageEmbed}
       */
      setFields(...fields) {
        this.spliceFields(0, this.fields.length, fields);
        return this;
      }
      /**
       * The options to provide for setting an author for a {@link MessageEmbed}.
       * @typedef {Object} EmbedAuthorData
       * @property {string} name The name of this author.
       * @property {string} [url] The URL of this author.
       * @property {string} [iconURL] The icon URL of this author.
       */
      /**
       * Sets the author of this embed.
       * @param {string|EmbedAuthorData|null} options The options to provide for the author.
       * Provide `null` to remove the author data.
       * @param {string} [deprecatedIconURL] The icon URL of this author.
       * <warn>This parameter is **deprecated**. Use the `options` parameter instead.</warn>
       * @param {string} [deprecatedURL] The URL of this author.
       * <warn>This parameter is **deprecated**. Use the `options` parameter instead.</warn>
       * @returns {MessageEmbed}
       */
      setAuthor(options, deprecatedIconURL, deprecatedURL) {
        if (options === null) {
          this.author = {};
          return this;
        }
        if (typeof options === "string") {
          if (!deprecationEmittedForSetAuthor) {
            process2.emitWarning(
              "Passing strings for MessageEmbed#setAuthor is deprecated. Pass a sole object instead.",
              "DeprecationWarning"
            );
            deprecationEmittedForSetAuthor = true;
          }
          options = { name: options, url: deprecatedURL, iconURL: deprecatedIconURL };
        }
        const { name, url, iconURL } = options;
        this.author = { name: Util.verifyString(name, RangeError2, "EMBED_AUTHOR_NAME"), url, iconURL };
        return this;
      }
      /**
       * Sets the color of this embed.
       * @param {ColorResolvable} color The color of the embed
       * @returns {MessageEmbed}
       */
      setColor(color) {
        this.color = Util.resolveColor(color);
        return this;
      }
      /**
       * Sets the description of this embed.
       * @param {string} description The description
       * @returns {MessageEmbed}
       */
      setDescription(description) {
        this.description = Util.verifyString(description, RangeError2, "EMBED_DESCRIPTION");
        return this;
      }
      /**
       * The options to provide for setting a footer for a {@link MessageEmbed}.
       * @typedef {Object} EmbedFooterData
       * @property {string} text The text of the footer.
       * @property {string} [iconURL] The icon URL of the footer.
       */
      /**
       * Sets the footer of this embed.
       * @param {string|EmbedFooterData|null} options The options to provide for the footer.
       * Provide `null` to remove the footer data.
       * @param {string} [deprecatedIconURL] The icon URL of this footer.
       * <warn>This parameter is **deprecated**. Use the `options` parameter instead.</warn>
       * @returns {MessageEmbed}
       */
      setFooter(options, deprecatedIconURL) {
        if (options === null) {
          this.footer = void 0;
          return this;
        }
        if (typeof options === "string") {
          if (!deprecationEmittedForSetFooter) {
            process2.emitWarning(
              "Passing strings for MessageEmbed#setFooter is deprecated. Pass a sole object instead.",
              "DeprecationWarning"
            );
            deprecationEmittedForSetFooter = true;
          }
          options = { text: options, iconURL: deprecatedIconURL };
        }
        const { text, iconURL } = options;
        this.footer = { text: Util.verifyString(text, RangeError2, "EMBED_FOOTER_TEXT"), iconURL };
        return this;
      }
      /**
       * Sets the image of this embed.
       * @param {string} url The URL of the image
       * @returns {MessageEmbed}
       */
      setImage(url) {
        this.image = { url };
        return this;
      }
      /**
       * Sets the thumbnail of this embed.
       * @param {string} url The URL of the thumbnail
       * @returns {MessageEmbed}
       */
      setThumbnail(url) {
        this.thumbnail = { url };
        return this;
      }
      /**
       * Sets the timestamp of this embed.
       * @param {Date|number|null} [timestamp=Date.now()] The timestamp or date.
       * If `null` then the timestamp will be unset (i.e. when editing an existing {@link MessageEmbed})
       * @returns {MessageEmbed}
       */
      setTimestamp(timestamp = Date.now()) {
        if (timestamp instanceof Date) timestamp = timestamp.getTime();
        this.timestamp = timestamp;
        return this;
      }
      /**
       * Sets the title of this embed.
       * @param {string} title The title
       * @returns {MessageEmbed}
       */
      setTitle(title) {
        this.title = Util.verifyString(title, RangeError2, "EMBED_TITLE");
        return this;
      }
      /**
       * Sets the URL of this embed.
       * @param {string} url The URL
       * @returns {MessageEmbed}
       */
      setURL(url) {
        this.url = url;
        return this;
      }
      /**
       * Transforms the embed to a plain object.
       * @returns {APIEmbed} The raw data of this embed
       */
      toJSON() {
        return {
          title: this.title,
          type: "rich",
          description: this.description,
          url: this.url,
          timestamp: this.timestamp && new Date(this.timestamp),
          color: this.color,
          fields: this.fields,
          thumbnail: this.thumbnail,
          image: this.image,
          author: this.author && {
            name: this.author.name,
            url: this.author.url,
            icon_url: this.author.iconURL
          },
          footer: this.footer && {
            text: this.footer.text,
            icon_url: this.footer.iconURL
          }
        };
      }
      /**
       * Normalizes field input and verifies strings.
       * @param {string} name The name of the field
       * @param {string} value The value of the field
       * @param {boolean} [inline=false] Set the field to display inline
       * @returns {EmbedField}
       */
      static normalizeField(name, value, inline = false) {
        return {
          name: Util.verifyString(name, RangeError2, "EMBED_FIELD_NAME", false),
          value: Util.verifyString(value, RangeError2, "EMBED_FIELD_VALUE", false),
          inline
        };
      }
      /**
       * @typedef {Object} EmbedFieldData
       * @property {string} name The name of this field
       * @property {string} value The value of this field
       * @property {boolean} [inline] If this field will be displayed inline
       */
      /**
       * Normalizes field input and resolves strings.
       * @param {...EmbedFieldData|EmbedFieldData[]} fields Fields to normalize
       * @returns {EmbedField[]}
       */
      static normalizeFields(...fields) {
        return fields.flat(2).map(
          (field) => this.normalizeField(field.name, field.value, typeof field.inline === "boolean" ? field.inline : false)
        );
      }
    };
    module2.exports = MessageEmbed;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/util/ActivityFlags.js
var require_ActivityFlags = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/util/ActivityFlags.js"(exports2, module2) {
    "use strict";
    var BitField = require_BitField();
    var ActivityFlags = class extends BitField {
    };
    ActivityFlags.FLAGS = {
      INSTANCE: 1 << 0,
      JOIN: 1 << 1,
      SPECTATE: 1 << 2,
      JOIN_REQUEST: 1 << 3,
      SYNC: 1 << 4,
      PLAY: 1 << 5,
      PARTY_PRIVACY_FRIENDS: 1 << 6,
      PARTY_PRIVACY_VOICE_CHANNEL: 1 << 7,
      EMBEDDED: 1 << 8
    };
    module2.exports = ActivityFlags;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/GuildScheduledEvent.js
var require_GuildScheduledEvent = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/GuildScheduledEvent.js"(exports2) {
    "use strict";
    var Base = require_Base();
    var { Error: Error2 } = require_errors2();
    var {
      GuildScheduledEventEntityTypes,
      GuildScheduledEventStatuses,
      GuildScheduledEventPrivacyLevels,
      Endpoints
    } = require_Constants();
    var SnowflakeUtil = require_SnowflakeUtil();
    var GuildScheduledEvent = class extends Base {
      constructor(client, data) {
        super(client);
        this.id = data.id;
        this.guildId = data.guild_id;
        this._patch(data);
      }
      _patch(data) {
        var _a;
        if ("channel_id" in data) {
          this.channelId = data.channel_id;
        } else {
          this.channelId ?? (this.channelId = null);
        }
        if ("creator_id" in data) {
          this.creatorId = data.creator_id;
        } else {
          this.creatorId ?? (this.creatorId = null);
        }
        if ("name" in data) {
          this.name = data.name;
        } else {
          this.name ?? (this.name = null);
        }
        if ("description" in data) {
          this.description = data.description;
        } else {
          this.description ?? (this.description = null);
        }
        if ("scheduled_start_time" in data) {
          this.scheduledStartTimestamp = Date.parse(data.scheduled_start_time);
        } else {
          this.scheduledStartTimestamp ?? (this.scheduledStartTimestamp = null);
        }
        if ("scheduled_end_time" in data) {
          this.scheduledEndTimestamp = data.scheduled_end_time ? Date.parse(data.scheduled_end_time) : null;
        } else {
          this.scheduledEndTimestamp ?? (this.scheduledEndTimestamp = null);
        }
        if ("privacy_level" in data) {
          this.privacyLevel = GuildScheduledEventPrivacyLevels[data.privacy_level];
        } else {
          this.privacyLevel ?? (this.privacyLevel = null);
        }
        if ("status" in data) {
          this.status = GuildScheduledEventStatuses[data.status];
        } else {
          this.status ?? (this.status = null);
        }
        if ("entity_type" in data) {
          this.entityType = GuildScheduledEventEntityTypes[data.entity_type];
        } else {
          this.entityType ?? (this.entityType = null);
        }
        if ("entity_id" in data) {
          this.entityId = data.entity_id;
        } else {
          this.entityId ?? (this.entityId = null);
        }
        if ("user_count" in data) {
          this.userCount = data.user_count;
        } else {
          this.userCount ?? (this.userCount = null);
        }
        if ("creator" in data) {
          this.creator = this.client.users._add(data.creator);
        } else {
          this.creator ?? (this.creator = this.client.users.resolve(this.creatorId));
        }
        if ("entity_metadata" in data) {
          if (data.entity_metadata) {
            this.entityMetadata = {
              location: data.entity_metadata.location ?? ((_a = this.entityMetadata) == null ? void 0 : _a.location) ?? null
            };
          } else {
            this.entityMetadata = null;
          }
        } else {
          this.entityMetadata ?? (this.entityMetadata = null);
        }
        if ("image" in data) {
          this.image = data.image;
        } else {
          this.image ?? (this.image = null);
        }
      }
      /**
       * The URL of this scheduled event's cover image
       * @param {StaticImageURLOptions} [options={}] Options for image URL
       * @returns {?string}
       */
      coverImageURL({ format, size } = {}) {
        return this.image && this.client.rest.cdn.GuildScheduledEventCover(this.id, this.image, format, size);
      }
      /**
       * Whether this guild scheduled event is partial.
       * @type {boolean}
       * @readonly
       */
      get partial() {
        return this.name === null;
      }
      /**
       * The timestamp the guild scheduled event was created at
       * @type {number}
       * @readonly
       */
      get createdTimestamp() {
        return SnowflakeUtil.timestampFrom(this.id);
      }
      /**
       * The time the guild scheduled event was created at
       * @type {Date}
       * @readonly
       */
      get createdAt() {
        return new Date(this.createdTimestamp);
      }
      /**
       * The time the guild scheduled event will start at
       * @type {Date}
       * @readonly
       */
      get scheduledStartAt() {
        return new Date(this.scheduledStartTimestamp);
      }
      /**
       * The time the guild scheduled event will end at,
       * or `null` if the event does not have a scheduled time to end
       * @type {?Date}
       * @readonly
       */
      get scheduledEndAt() {
        return this.scheduledEndTimestamp && new Date(this.scheduledEndTimestamp);
      }
      /**
       * The channel associated with this scheduled event
       * @type {?(VoiceChannel|StageChannel)}
       * @readonly
       */
      get channel() {
        return this.client.channels.resolve(this.channelId);
      }
      /**
       * The guild this scheduled event belongs to
       * @type {?Guild}
       * @readonly
       */
      get guild() {
        return this.client.guilds.resolve(this.guildId);
      }
      /**
       * The URL to the guild scheduled event
       * @type {string}
       * @readonly
       */
      get url() {
        return Endpoints.scheduledEvent(this.client.options.http.scheduledEvent, this.guildId, this.id);
      }
      /**
       * Fetches this guild scheduled event.
       * @param {boolean} [force=true] Whether to skip the cache check and request the API
       * @returns {Promise<GuildScheduledEvent>}
       */
      fetch(force = true) {
        return this.guild.scheduledEvents.fetch({ guildScheduledEvent: this.id, force });
      }
      /**
       * Options used to create an invite URL to a {@link GuildScheduledEvent}
       * @typedef {CreateInviteOptions} CreateGuildScheduledEventInviteURLOptions
       * @property {GuildInvitableChannelResolvable} [channel] The channel to create the invite in.
       * <warn>This is required when the `entityType` of `GuildScheduledEvent` is `EXTERNAL`, gets ignored otherwise</warn>
       */
      /**
       * Creates an invite URL to this guild scheduled event.
       * @param {CreateGuildScheduledEventInviteURLOptions} [options] The options to create the invite
       * @returns {Promise<string>}
       */
      async createInviteURL(options) {
        let channelId = this.channelId;
        if (this.entityType === "EXTERNAL") {
          if (!(options == null ? void 0 : options.channel)) throw new Error2("INVITE_OPTIONS_MISSING_CHANNEL");
          channelId = this.guild.channels.resolveId(options.channel);
          if (!channelId) throw new Error2("GUILD_CHANNEL_RESOLVE");
        }
        const invite = await this.guild.invites.create(channelId, options);
        return Endpoints.invite(this.client.options.http.invite, invite.code, this.id);
      }
      /**
       * Edits this guild scheduled event.
       * @param {GuildScheduledEventEditOptions} options The options to edit the guild scheduled event
       * @returns {Promise<GuildScheduledEvent>}
       * @example
       * // Edit a guild scheduled event
       * guildScheduledEvent.edit({ name: 'Party' })
       *  .then(guildScheduledEvent => console.log(guildScheduledEvent))
       *  .catch(console.error);
       */
      edit(options) {
        return this.guild.scheduledEvents.edit(this.id, options);
      }
      /**
       * Deletes this guild scheduled event.
       * @returns {Promise<GuildScheduledEvent>}
       * @example
       * // Delete a guild scheduled event
       * guildScheduledEvent.delete()
       *  .then(guildScheduledEvent => console.log(guildScheduledEvent))
       *  .catch(console.error);
       */
      async delete() {
        await this.guild.scheduledEvents.delete(this.id);
        return this;
      }
      /**
       * Sets a new name for the guild scheduled event.
       * @param {string} name The new name of the guild scheduled event
       * @param {string} [reason] The reason for changing the name
       * @returns {Promise<GuildScheduledEvent>}
       * @example
       * // Set name of a guild scheduled event
       * guildScheduledEvent.setName('Birthday Party')
       *  .then(guildScheduledEvent => console.log(`Set the name to: ${guildScheduledEvent.name}`))
       *  .catch(console.error);
       */
      setName(name, reason) {
        return this.edit({ name, reason });
      }
      /**
       * Sets a new time to schedule the event at.
       * @param {DateResolvable} scheduledStartTime The time to schedule the event at
       * @param {string} [reason] The reason for changing the scheduled start time
       * @returns {Promise<GuildScheduledEvent>}
       * @example
       * // Set start time of a guild scheduled event
       * guildScheduledEvent.setScheduledStartTime('2022-09-24T00:00:00+05:30')
       *  .then(guildScheduledEvent => console.log(`Set the start time to: ${guildScheduledEvent.scheduledStartTime}`))
       *  .catch(console.error);
       */
      setScheduledStartTime(scheduledStartTime, reason) {
        return this.edit({ scheduledStartTime, reason });
      }
      // TODO: scheduledEndTime gets reset on passing null but it hasn't been documented
      /**
       * Sets a new time to end the event at.
       * @param {DateResolvable} scheduledEndTime The time to end the event at
       * @param {string} [reason] The reason for changing the scheduled end time
       * @returns {Promise<GuildScheduledEvent>}
       * @example
       * // Set end time of a guild scheduled event
       * guildScheduledEvent.setScheduledEndTime('2022-09-25T00:00:00+05:30')
       *  .then(guildScheduledEvent => console.log(`Set the end time to: ${guildScheduledEvent.scheduledEndTime}`))
       *  .catch(console.error);
       */
      setScheduledEndTime(scheduledEndTime, reason) {
        return this.edit({ scheduledEndTime, reason });
      }
      /**
       * Sets the new description of the guild scheduled event.
       * @param {string} description The description of the guild scheduled event
       * @param {string} [reason] The reason for changing the description
       * @returns {Promise<GuildScheduledEvent>}
       * @example
       * // Set description of a guild scheduled event
       * guildScheduledEvent.setDescription('A virtual birthday party')
       *  .then(guildScheduledEvent => console.log(`Set the description to: ${guildScheduledEvent.description}`))
       *  .catch(console.error);
       */
      setDescription(description, reason) {
        return this.edit({ description, reason });
      }
      /**
       * Sets the new status of the guild scheduled event.
       * <info>If you're working with TypeScript, use this method in conjunction with status type-guards
       * like {@link GuildScheduledEvent#isScheduled} to get only valid status as suggestion</info>
       * @param {GuildScheduledEventStatus|number} status The status of the guild scheduled event
       * @param {string} [reason] The reason for changing the status
       * @returns {Promise<GuildScheduledEvent>}
       * @example
       * // Set status of a guild scheduled event
       * guildScheduledEvent.setStatus('ACTIVE')
       *  .then(guildScheduledEvent => console.log(`Set the status to: ${guildScheduledEvent.status}`))
       *  .catch(console.error);
       */
      setStatus(status, reason) {
        return this.edit({ status, reason });
      }
      /**
       * Sets the new location of the guild scheduled event.
       * @param {string} location The location of the guild scheduled event
       * @param {string} [reason] The reason for changing the location
       * @returns {Promise<GuildScheduledEvent>}
       * @example
       * // Set location of a guild scheduled event
       * guildScheduledEvent.setLocation('Earth')
       *  .then(guildScheduledEvent => console.log(`Set the location to: ${guildScheduledEvent.entityMetadata.location}`))
       *  .catch(console.error);
       */
      setLocation(location, reason) {
        return this.edit({ entityMetadata: { location }, reason });
      }
      /**
       * Fetches subscribers of this guild scheduled event.
       * @param {FetchGuildScheduledEventSubscribersOptions} [options] Options for fetching the subscribers
       * @returns {Promise<Collection<Snowflake, GuildScheduledEventUser>>}
       */
      fetchSubscribers(options) {
        return this.guild.scheduledEvents.fetchSubscribers(this.id, options);
      }
      /**
       * When concatenated with a string, this automatically concatenates the event's URL instead of the object.
       * @returns {string}
       * @example
       * // Logs: Event: https://discord.com/events/412345678901234567/499876543211234567
       * console.log(`Event: ${guildScheduledEvent}`);
       */
      toString() {
        return this.url;
      }
      /**
       * Indicates whether this guild scheduled event has an `ACTIVE` status.
       * @returns {boolean}
       */
      isActive() {
        return GuildScheduledEventStatuses[this.status] === GuildScheduledEventStatuses.ACTIVE;
      }
      /**
       * Indicates whether this guild scheduled event has a `CANCELED` status.
       * @returns {boolean}
       */
      isCanceled() {
        return GuildScheduledEventStatuses[this.status] === GuildScheduledEventStatuses.CANCELED;
      }
      /**
       * Indicates whether this guild scheduled event has a `COMPLETED` status.
       * @returns {boolean}
       */
      isCompleted() {
        return GuildScheduledEventStatuses[this.status] === GuildScheduledEventStatuses.COMPLETED;
      }
      /**
       * Indicates whether this guild scheduled event has a `SCHEDULED` status.
       * @returns {boolean}
       */
      isScheduled() {
        return GuildScheduledEventStatuses[this.status] === GuildScheduledEventStatuses.SCHEDULED;
      }
    };
    exports2.GuildScheduledEvent = GuildScheduledEvent;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/util/ApplicationFlags.js
var require_ApplicationFlags = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/util/ApplicationFlags.js"(exports2, module2) {
    "use strict";
    var BitField = require_BitField();
    var ApplicationFlags = class extends BitField {
    };
    ApplicationFlags.FLAGS = {
      EMBEDDED_RELEASED: 1 << 1,
      MANAGED_EMOJI: 1 << 2,
      EMBEDDED_IAP: 1 << 3,
      GROUP_DM_CREATE: 1 << 4,
      RPC_PRIVATE_BETA: 1 << 5,
      APPLICATION_AUTO_MODERATION_RULE_CREATE_BADGE: 1 << 6,
      ALLOW_ASSETS: 1 << 8,
      ALLOW_ACTIVITY_ACTION_SPECTATE: 1 << 9,
      ALLOW_ACTIVITY_ACTION_JOIN_REQUEST: 1 << 10,
      RPC_HAS_CONNECTED: 1 << 11,
      GATEWAY_PRESENCE: 1 << 12,
      GATEWAY_PRESENCE_LIMITED: 1 << 13,
      GATEWAY_GUILD_MEMBERS: 1 << 14,
      GATEWAY_GUILD_MEMBERS_LIMITED: 1 << 15,
      VERIFICATION_PENDING_GUILD_LIMIT: 1 << 16,
      EMBEDDED: 1 << 17,
      GATEWAY_MESSAGE_CONTENT: 1 << 18,
      GATEWAY_MESSAGE_CONTENT_LIMITED: 1 << 19,
      EMBEDDED_FIRST_PARTY: 1 << 20,
      APPLICATION_COMMAND_BADGE: 1 << 23,
      ACTIVE: 1 << 24,
      IFRAME_MODAL: 1 << 26
    };
    module2.exports = ApplicationFlags;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/util/Permissions.js
var require_Permissions = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/util/Permissions.js"(exports2, module2) {
    "use strict";
    var BitField = require_BitField();
    var Permissions2 = class extends BitField {
      /**
       * Bitfield of the packed bits
       * @type {bigint}
       * @name Permissions#bitfield
       */
      /**
       * Data that can be resolved to give a permission number. This can be:
       * * A string (see {@link Permissions.FLAGS})
       * * A permission number
       * * An instance of Permissions
       * * An Array of PermissionResolvable
       * @typedef {string|bigint|Permissions|PermissionResolvable[]} PermissionResolvable
       */
      /**
       * Gets all given bits that are missing from the bitfield.
       * @param {BitFieldResolvable} bits Bit(s) to check for
       * @param {boolean} [checkAdmin=true] Whether to allow the administrator permission to override
       * @returns {string[]}
       */
      missing(bits, checkAdmin = true) {
        return checkAdmin && this.has(this.constructor.FLAGS.ADMINISTRATOR) ? [] : super.missing(bits);
      }
      /**
       * Checks whether the bitfield has a permission, or any of multiple permissions.
       * @param {PermissionResolvable} permission Permission(s) to check for
       * @param {boolean} [checkAdmin=true] Whether to allow the administrator permission to override
       * @returns {boolean}
       */
      any(permission, checkAdmin = true) {
        return checkAdmin && super.has(this.constructor.FLAGS.ADMINISTRATOR) || super.any(permission);
      }
      /**
       * Checks whether the bitfield has a permission, or multiple permissions.
       * @param {PermissionResolvable} permission Permission(s) to check for
       * @param {boolean} [checkAdmin=true] Whether to allow the administrator permission to override
       * @returns {boolean}
       */
      has(permission, checkAdmin = true) {
        return checkAdmin && super.has(this.constructor.FLAGS.ADMINISTRATOR) || super.has(permission);
      }
      /**
       * Gets an {@link Array} of bitfield names based on the permissions available.
       * @returns {string[]}
       */
      toArray() {
        return super.toArray(false);
      }
    };
    Permissions2.FLAGS = {
      CREATE_INSTANT_INVITE: 1n << 0n,
      KICK_MEMBERS: 1n << 1n,
      BAN_MEMBERS: 1n << 2n,
      ADMINISTRATOR: 1n << 3n,
      MANAGE_CHANNELS: 1n << 4n,
      MANAGE_GUILD: 1n << 5n,
      ADD_REACTIONS: 1n << 6n,
      VIEW_AUDIT_LOG: 1n << 7n,
      PRIORITY_SPEAKER: 1n << 8n,
      STREAM: 1n << 9n,
      VIEW_CHANNEL: 1n << 10n,
      SEND_MESSAGES: 1n << 11n,
      SEND_TTS_MESSAGES: 1n << 12n,
      MANAGE_MESSAGES: 1n << 13n,
      EMBED_LINKS: 1n << 14n,
      ATTACH_FILES: 1n << 15n,
      READ_MESSAGE_HISTORY: 1n << 16n,
      MENTION_EVERYONE: 1n << 17n,
      USE_EXTERNAL_EMOJIS: 1n << 18n,
      VIEW_GUILD_INSIGHTS: 1n << 19n,
      CONNECT: 1n << 20n,
      SPEAK: 1n << 21n,
      MUTE_MEMBERS: 1n << 22n,
      DEAFEN_MEMBERS: 1n << 23n,
      MOVE_MEMBERS: 1n << 24n,
      USE_VAD: 1n << 25n,
      CHANGE_NICKNAME: 1n << 26n,
      MANAGE_NICKNAMES: 1n << 27n,
      MANAGE_ROLES: 1n << 28n,
      MANAGE_WEBHOOKS: 1n << 29n,
      MANAGE_EMOJIS_AND_STICKERS: 1n << 30n,
      USE_APPLICATION_COMMANDS: 1n << 31n,
      REQUEST_TO_SPEAK: 1n << 32n,
      MANAGE_EVENTS: 1n << 33n,
      MANAGE_THREADS: 1n << 34n,
      // TODO: Remove deprecated USE_*_THREADS flags in v14
      USE_PUBLIC_THREADS: 1n << 35n,
      CREATE_PUBLIC_THREADS: 1n << 35n,
      USE_PRIVATE_THREADS: 1n << 36n,
      CREATE_PRIVATE_THREADS: 1n << 36n,
      USE_EXTERNAL_STICKERS: 1n << 37n,
      SEND_MESSAGES_IN_THREADS: 1n << 38n,
      START_EMBEDDED_ACTIVITIES: 1n << 39n,
      MODERATE_MEMBERS: 1n << 40n,
      VIEW_CREATOR_MONETIZATION_ANALYTICS: 1n << 41n,
      USE_SOUNDBOARD: 1n << 42n,
      CREATE_GUILD_EXPRESSIONS: 1n << 43n,
      CREATE_EVENTS: 1n << 44n,
      USE_EXTERNAL_SOUNDS: 1n << 45n,
      SEND_VOICE_MESSAGES: 1n << 46n,
      USE_CLYDE_AI: 1n << 47n,
      SET_VOICE_CHANNEL_STATUS: 1n << 48n,
      SEND_POLLS: 1n << 49n,
      USE_EXTERNAL_APPS: 1n << 50n
    };
    Permissions2.ALL = Object.values(Permissions2.FLAGS).reduce((all, p) => all | p, 0n);
    Permissions2.DEFAULT = BigInt(104324673);
    Permissions2.STAGE_MODERATOR = Permissions2.FLAGS.MANAGE_CHANNELS | Permissions2.FLAGS.MUTE_MEMBERS | Permissions2.FLAGS.MOVE_MEMBERS;
    Permissions2.defaultBit = BigInt(0);
    module2.exports = Permissions2;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/ApplicationRoleConnectionMetadata.js
var require_ApplicationRoleConnectionMetadata = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/ApplicationRoleConnectionMetadata.js"(exports2) {
    "use strict";
    var { ApplicationRoleConnectionMetadataTypes } = require_Constants();
    var ApplicationRoleConnectionMetadata = class {
      constructor(data) {
        this.name = data.name;
        this.nameLocalizations = data.name_localizations ?? null;
        this.description = data.description;
        this.descriptionLocalizations = data.description_localizations ?? null;
        this.key = data.key;
        this.type = typeof data.type === "number" ? ApplicationRoleConnectionMetadataTypes[data.type] : data.type;
      }
    };
    exports2.ApplicationRoleConnectionMetadata = ApplicationRoleConnectionMetadata;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/TeamMember.js
var require_TeamMember = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/TeamMember.js"(exports2, module2) {
    "use strict";
    var Base = require_Base();
    var { MembershipStates } = require_Constants();
    var TeamMember = class extends Base {
      constructor(team, data) {
        super(team.client);
        this.team = team;
        this._patch(data);
      }
      _patch(data) {
        if ("permissions" in data) {
          this.permissions = data.permissions;
        }
        if ("role" in data) {
          this.role = data.role;
        }
        if ("membership_state" in data) {
          this.membershipState = MembershipStates[data.membership_state];
        }
        if ("user" in data) {
          this.user = this.client.users._add(data.user);
        }
      }
      /**
       * The Team Member's id
       * @type {Snowflake}
       * @readonly
       */
      get id() {
        return this.user.id;
      }
      /**
       * When concatenated with a string, this automatically returns the team member's mention instead of the
       * TeamMember object.
       * @returns {string}
       * @example
       * // Logs: Team Member's mention: <@123456789012345678>
       * console.log(`Team Member's mention: ${teamMember}`);
       */
      toString() {
        return this.user.toString();
      }
    };
    module2.exports = TeamMember;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/Team.js
var require_Team = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/Team.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var Base = require_Base();
    var TeamMember = require_TeamMember();
    var SnowflakeUtil = require_SnowflakeUtil();
    var Team = class extends Base {
      constructor(client, data) {
        super(client);
        this._patch(data);
      }
      _patch(data) {
        this.id = data.id;
        if ("name" in data) {
          this.name = data.name;
        }
        if ("icon" in data) {
          this.icon = data.icon;
        } else {
          this.icon ?? (this.icon = null);
        }
        if ("owner_user_id" in data) {
          this.ownerId = data.owner_user_id;
        } else {
          this.ownerId ?? (this.ownerId = null);
        }
        this.members = new Collection2();
        for (const memberData of data.members) {
          const member = new TeamMember(this, memberData);
          this.members.set(member.id, member);
        }
      }
      /**
       * The owner of this team
       * @type {?TeamMember}
       * @readonly
       */
      get owner() {
        return this.members.get(this.ownerId) ?? null;
      }
      /**
       * The timestamp the team was created at
       * @type {number}
       * @readonly
       */
      get createdTimestamp() {
        return SnowflakeUtil.timestampFrom(this.id);
      }
      /**
       * The time the team was created at
       * @type {Date}
       * @readonly
       */
      get createdAt() {
        return new Date(this.createdTimestamp);
      }
      /**
       * A link to the team's icon.
       * @param {StaticImageURLOptions} [options={}] Options for the Image URL
       * @returns {?string}
       */
      iconURL({ format, size } = {}) {
        if (!this.icon) return null;
        return this.client.rest.cdn.TeamIcon(this.id, this.icon, { format, size });
      }
      /**
       * When concatenated with a string, this automatically returns the Team's name instead of the
       * Team object.
       * @returns {string}
       * @example
       * // Logs: Team name: My Team
       * console.log(`Team name: ${team}`);
       */
      toString() {
        return this.name;
      }
      toJSON() {
        return super.toJSON({ createdTimestamp: true });
      }
    };
    module2.exports = Team;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/interfaces/Application.js
var require_Application = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/interfaces/Application.js"(exports2, module2) {
    "use strict";
    var process2 = require_node_process();
    var { ApplicationFlags } = require_ApplicationFlags();
    var { ClientApplicationAssetTypes, Endpoints } = require_Constants();
    var Permissions2 = require_Permissions();
    var SnowflakeUtil = require_SnowflakeUtil();
    var { ApplicationRoleConnectionMetadata } = require_ApplicationRoleConnectionMetadata();
    var Base = require_Base();
    var Team = require_Team();
    var AssetTypes = Object.keys(ClientApplicationAssetTypes);
    var deprecationEmittedForFetchAssets = false;
    var Application = class extends Base {
      constructor(client, data) {
        super(client);
        this._patch(data);
      }
      _patch(data) {
        this.id = data.id;
        if ("name" in data) {
          this.name = data.name;
        } else {
          this.name ?? (this.name = null);
        }
        if ("description" in data) {
          this.description = data.description;
        } else {
          this.description ?? (this.description = null);
        }
        if ("icon" in data) {
          this.icon = data.icon;
        } else {
          this.icon ?? (this.icon = null);
        }
        if ("role_connections_verification_url" in data) {
          this.roleConnectionsVerificationURL = data.role_connections_verification_url;
        } else {
          this.roleConnectionsVerificationURL ?? (this.roleConnectionsVerificationURL = null);
        }
        this.tags = data.tags ?? [];
        if ("install_params" in data) {
          this.installParams = {
            scopes: data.install_params.scopes,
            permissions: new Permissions2(data.install_params.permissions).freeze()
          };
        } else {
          this.installParams ?? (this.installParams = null);
        }
        if ("custom_install_url" in data) {
          this.customInstallURL = data.custom_install_url;
        } else {
          this.customInstallURL = null;
        }
        if ("flags" in data) {
          this.flags = new ApplicationFlags(data.flags).freeze();
        }
        if ("approximate_guild_count" in data) {
          this.approximateGuildCount = data.approximate_guild_count;
        } else {
          this.approximateGuildCount ?? (this.approximateGuildCount = null);
        }
        if ("guild_id" in data) {
          this.guildId = data.guild_id;
        } else {
          this.guildId ?? (this.guildId = null);
        }
        if ("cover_image" in data) {
          this.cover = data.cover_image;
        } else {
          this.cover ?? (this.cover = null);
        }
        if ("rpc_origins" in data) {
          this.rpcOrigins = data.rpc_origins;
        } else {
          this.rpcOrigins ?? (this.rpcOrigins = []);
        }
        if ("bot_require_code_grant" in data) {
          this.botRequireCodeGrant = data.bot_require_code_grant;
        } else {
          this.botRequireCodeGrant ?? (this.botRequireCodeGrant = null);
        }
        if ("bot_public" in data) {
          this.botPublic = data.bot_public;
        } else {
          this.botPublic ?? (this.botPublic = null);
        }
        this.owner = data.team ? new Team(this.client, data.team) : data.owner ? this.client.users._add(data.owner) : this.owner ?? null;
      }
      /**
       * The guild associated with this application.
       * @type {?Guild}
       * @readonly
       */
      get guild() {
        return this.client.guilds.cache.get(this.guildId) ?? null;
      }
      /**
       * Whether this application is partial
       * @type {boolean}
       * @readonly
       */
      get partial() {
        return !this.name;
      }
      /**
       * The timestamp the application was created at
       * @type {number}
       * @readonly
       */
      get createdTimestamp() {
        return SnowflakeUtil.timestampFrom(this.id);
      }
      /**
       * The time the application was created at
       * @type {Date}
       * @readonly
       */
      get createdAt() {
        return new Date(this.createdTimestamp);
      }
      /**
       * Obtains this application from Discord.
       * @returns {Promise<Application>}
       */
      async fetch() {
        const app = await this.client.api.oauth2.authorize.get({
          query: {
            client_id: this.id,
            scope: "bot applications.commands"
          }
        });
        const user = this.client.users._add(app.bot);
        user._partial = false;
        this._patch(app.application);
        return this;
      }
      /**
       * Gets this application's role connection metadata records
       * @returns {Promise<ApplicationRoleConnectionMetadata[]>}
       */
      async fetchRoleConnectionMetadataRecords() {
        const metadata = await this.client.api.applications(this.id)("role-connections").metadata.get();
        return metadata.map((data) => new ApplicationRoleConnectionMetadata(data));
      }
      /**
       * A link to the application's icon.
       * @param {StaticImageURLOptions} [options={}] Options for the Image URL
       * @returns {?string}
       */
      iconURL({ format, size } = {}) {
        if (!this.icon) return null;
        return this.client.rest.cdn.AppIcon(this.id, this.icon, { format, size });
      }
      /**
       * A link to this application's cover image.
       * @param {StaticImageURLOptions} [options={}] Options for the Image URL
       * @returns {?string}
       */
      coverURL({ format, size } = {}) {
        if (!this.cover) return null;
        return Endpoints.CDN(this.client.options.http.cdn).AppIcon(this.id, this.cover, { format, size });
      }
      /**
       * Asset data.
       * @typedef {Object} ApplicationAsset
       * @property {Snowflake} id The asset's id
       * @property {string} name The asset's name
       * @property {string} type The asset's type
       */
      /**
       * Gets the application's rich presence assets.
       * @returns {Promise<Array<ApplicationAsset>>}
       * @deprecated This will be removed in the next major as it is unsupported functionality.
       */
      async fetchAssets() {
        if (!deprecationEmittedForFetchAssets) {
          process2.emitWarning(
            "Application#fetchAssets is deprecated as it is unsupported and will be removed in the next major version.",
            "DeprecationWarning"
          );
          deprecationEmittedForFetchAssets = true;
        }
        const assets = await this.client.api.oauth2.applications(this.id).assets.get();
        return assets.map((a) => ({
          id: a.id,
          name: a.name,
          type: AssetTypes[a.type - 1]
        }));
      }
      /**
       * When concatenated with a string, this automatically returns the application's name instead of the
       * Application object.
       * @returns {?string}
       * @example
       * // Logs: Application name: My App
       * console.log(`Application name: ${application}`);
       */
      toString() {
        return this.name;
      }
      toJSON() {
        return super.toJSON({ createdTimestamp: true });
      }
    };
    module2.exports = Application;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/IntegrationApplication.js
var require_IntegrationApplication = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/IntegrationApplication.js"(exports2, module2) {
    "use strict";
    var Application = require_Application();
    var IntegrationApplication = class extends Application {
      _patch(data) {
        super._patch(data);
        if ("bot" in data) {
          this.bot = this.client.users._add(data.bot);
        } else {
          this.bot ?? (this.bot = null);
        }
        if ("terms_of_service_url" in data) {
          this.termsOfServiceURL = data.terms_of_service_url;
        } else {
          this.termsOfServiceURL ?? (this.termsOfServiceURL = null);
        }
        if ("privacy_policy_url" in data) {
          this.privacyPolicyURL = data.privacy_policy_url;
        } else {
          this.privacyPolicyURL ?? (this.privacyPolicyURL = null);
        }
        if ("rpc_origins" in data) {
          this.rpcOrigins = data.rpc_origins;
        } else {
          this.rpcOrigins ?? (this.rpcOrigins = []);
        }
        if ("summary" in data) {
          this.summary = data.summary;
        } else {
          this.summary ?? (this.summary = null);
        }
        if ("hook" in data) {
          this.hook = data.hook;
        } else {
          this.hook ?? (this.hook = null);
        }
        if ("cover_image" in data) {
          this.cover = data.cover_image;
        } else {
          this.cover ?? (this.cover = null);
        }
        if ("verify_key" in data) {
          this.verifyKey = data.verify_key;
        } else {
          this.verifyKey ?? (this.verifyKey = null);
        }
      }
    };
    module2.exports = IntegrationApplication;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/InviteStageInstance.js
var require_InviteStageInstance = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/InviteStageInstance.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var Base = require_Base();
    var InviteStageInstance = class extends Base {
      constructor(client, data, channelId, guildId) {
        super(client);
        this.channelId = channelId;
        this.guildId = guildId;
        this.members = new Collection2();
        this._patch(data);
      }
      _patch(data) {
        if ("topic" in data) {
          this.topic = data.topic;
        }
        if ("participant_count" in data) {
          this.participantCount = data.participant_count;
        }
        if ("speaker_count" in data) {
          this.speakerCount = data.speaker_count;
        }
        this.members.clear();
        for (const rawMember of data.members) {
          const member = this.guild.members._add(rawMember);
          this.members.set(member.id, member);
        }
      }
      /**
       * The stage channel this invite is for
       * @type {?StageChannel}
       * @readonly
       */
      get channel() {
        return this.client.channels.resolve(this.channelId);
      }
      /**
       * The guild of the stage channel this invite is for
       * @type {?Guild}
       * @readonly
       */
      get guild() {
        return this.client.guilds.resolve(this.guildId);
      }
    };
    module2.exports = InviteStageInstance;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/util/InviteFlags.js
var require_InviteFlags = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/util/InviteFlags.js"(exports2, module2) {
    "use strict";
    var BitField = require_BitField();
    var InviteFlags = class extends BitField {
    };
    InviteFlags.FLAGS = {
      GUEST: 1 << 0,
      VIEWED: 1 << 1
    };
    module2.exports = InviteFlags;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/BaseGuild.js
var require_BaseGuild = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/BaseGuild.js"(exports2, module2) {
    "use strict";
    var Base = require_Base();
    var SnowflakeUtil = require_SnowflakeUtil();
    var BaseGuild = class extends Base {
      constructor(client, data) {
        super(client);
        this.id = data.id;
        this.name = data.name;
        this.icon = data.icon;
        this.features = data.features;
      }
      /**
       * The timestamp this guild was created at
       * @type {number}
       * @readonly
       */
      get createdTimestamp() {
        return SnowflakeUtil.timestampFrom(this.id);
      }
      /**
       * The time this guild was created at
       * @type {Date}
       * @readonly
       */
      get createdAt() {
        return new Date(this.createdTimestamp);
      }
      /**
       * The acronym that shows up in place of a guild icon
       * @type {string}
       * @readonly
       */
      get nameAcronym() {
        return this.name.replace(/'s /g, " ").replace(/\w+/g, (e) => e[0]).replace(/\s/g, "");
      }
      /**
       * Whether this guild is partnered
       * @type {boolean}
       * @readonly
       */
      get partnered() {
        return this.features.includes("PARTNERED");
      }
      /**
       * Whether this guild is verified
       * @type {boolean}
       * @readonly
       */
      get verified() {
        return this.features.includes("VERIFIED");
      }
      /**
       * The URL to this guild's icon.
       * @param {ImageURLOptions} [options={}] Options for the Image URL
       * @returns {?string}
       */
      iconURL({ format, size, dynamic } = {}) {
        if (!this.icon) return null;
        return this.client.rest.cdn.Icon(this.id, this.icon, format, size, dynamic);
      }
      /**
       * Fetches this guild.
       * @returns {Promise<Guild>}
       */
      async fetch() {
        const data = await this.client.api.guilds(this.id).get({ query: { with_counts: true } });
        return this.client.guilds._add(data);
      }
      /**
       * When concatenated with a string, this automatically returns the guild's name instead of the Guild object.
       * @returns {string}
       */
      toString() {
        return this.name;
      }
    };
    module2.exports = BaseGuild;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/AnonymousGuild.js
var require_AnonymousGuild = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/AnonymousGuild.js"(exports2, module2) {
    "use strict";
    var BaseGuild = require_BaseGuild();
    var { VerificationLevels, NSFWLevels } = require_Constants();
    var AnonymousGuild = class extends BaseGuild {
      constructor(client, data, immediatePatch = true) {
        super(client, data);
        if (immediatePatch) this._patch(data);
      }
      _patch(data) {
        if ("features" in data) this.features = data.features;
        if ("splash" in data) {
          this.splash = data.splash;
        }
        if ("banner" in data) {
          this.banner = data.banner;
        }
        if ("description" in data) {
          this.description = data.description;
        }
        if ("verification_level" in data) {
          this.verificationLevel = VerificationLevels[data.verification_level];
        }
        if ("vanity_url_code" in data) {
          this.vanityURLCode = data.vanity_url_code;
        }
        if ("nsfw_level" in data) {
          this.nsfwLevel = NSFWLevels[data.nsfw_level];
        }
        if ("premium_subscription_count" in data) {
          this.premiumSubscriptionCount = data.premium_subscription_count;
        } else {
          this.premiumSubscriptionCount ?? (this.premiumSubscriptionCount = null);
        }
      }
      /**
       * The URL to this guild's banner.
       * @param {StaticImageURLOptions} [options={}] Options for the Image URL
       * @returns {?string}
       */
      bannerURL({ format, size } = {}) {
        return this.banner && this.client.rest.cdn.Banner(this.id, this.banner, format, size);
      }
      /**
       * The URL to this guild's invite splash image.
       * @param {StaticImageURLOptions} [options={}] Options for the Image URL
       * @returns {?string}
       */
      splashURL({ format, size } = {}) {
        return this.splash && this.client.rest.cdn.Splash(this.id, this.splash, format, size);
      }
    };
    module2.exports = AnonymousGuild;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/Emoji.js
var require_Emoji = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/Emoji.js"(exports2) {
    "use strict";
    var process2 = require_node_process();
    var Base = require_Base();
    var SnowflakeUtil = require_SnowflakeUtil();
    var deletedEmojis = /* @__PURE__ */ new WeakSet();
    var deprecationEmittedForDeleted = false;
    var Emoji = class extends Base {
      constructor(client, emoji) {
        super(client);
        this.animated = emoji.animated ?? null;
        this.name = emoji.name ?? null;
        this.id = emoji.id ?? null;
      }
      /**
       * Whether or not the structure has been deleted
       * @type {boolean}
       * @deprecated This will be removed in the next major version, see https://github.com/discordjs/discord.js/issues/7091
       */
      get deleted() {
        if (!deprecationEmittedForDeleted) {
          deprecationEmittedForDeleted = true;
          process2.emitWarning(
            "Emoji#deleted is deprecated, see https://github.com/discordjs/discord.js/issues/7091.",
            "DeprecationWarning"
          );
        }
        return deletedEmojis.has(this);
      }
      set deleted(value) {
        if (!deprecationEmittedForDeleted) {
          deprecationEmittedForDeleted = true;
          process2.emitWarning(
            "Emoji#deleted is deprecated, see https://github.com/discordjs/discord.js/issues/7091.",
            "DeprecationWarning"
          );
        }
        if (value) deletedEmojis.add(this);
        else deletedEmojis.delete(this);
      }
      /**
       * The identifier of this emoji, used for message reactions
       * @type {string}
       * @readonly
       */
      get identifier() {
        if (this.id) return `${this.animated ? "a:" : ""}${this.name}:${this.id}`;
        return encodeURIComponent(this.name);
      }
      /**
       * The URL to the emoji file if it's a custom emoji
       * @type {?string}
       * @readonly
       */
      get url() {
        return this.id && this.client.rest.cdn.Emoji(this.id, this.animated ? "gif" : "png");
      }
      /**
       * The timestamp the emoji was created at, or null if unicode
       * @type {?number}
       * @readonly
       */
      get createdTimestamp() {
        return this.id && SnowflakeUtil.timestampFrom(this.id);
      }
      /**
       * The time the emoji was created at, or null if unicode
       * @type {?Date}
       * @readonly
       */
      get createdAt() {
        return this.id && new Date(this.createdTimestamp);
      }
      /**
       * When concatenated with a string, this automatically returns the text required to form a graphical emoji on Discord
       * instead of the Emoji object.
       * @returns {string}
       * @example
       * // Send a custom emoji from a guild:
       * const emoji = guild.emojis.cache.first();
       * msg.channel.send(`Hello! ${emoji}`);
       * @example
       * // Send the emoji used in a reaction to the channel the reaction is part of
       * reaction.message.channel.send(`The emoji used was: ${reaction.emoji}`);
       */
      toString() {
        return this.id ? `<${this.animated ? "a" : ""}:${this.name}:${this.id}>` : this.name;
      }
      toJSON() {
        return super.toJSON({
          guild: "guildId",
          createdTimestamp: true,
          url: true,
          identifier: true
        });
      }
    };
    exports2.Emoji = Emoji;
    exports2.deletedEmojis = deletedEmojis;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/WelcomeChannel.js
var require_WelcomeChannel = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/WelcomeChannel.js"(exports2, module2) {
    "use strict";
    var Base = require_Base();
    var { Emoji } = require_Emoji();
    var WelcomeChannel = class extends Base {
      constructor(guild, data) {
        super(guild.client);
        this.guild = guild;
        this.description = data.description;
        this._emoji = {
          name: data.emoji_name,
          id: data.emoji_id
        };
        this.channelId = data.channel_id;
      }
      /**
       * The channel of this welcome channel
       * @type {?(TextChannel|NewsChannel|StoreChannel|ForumChannel|MediaChannel)}
       */
      get channel() {
        return this.client.channels.resolve(this.channelId);
      }
      /**
       * The emoji of this welcome channel
       * @type {GuildEmoji|Emoji}
       */
      get emoji() {
        return this.client.emojis.resolve(this._emoji.id) ?? new Emoji(this.client, this._emoji);
      }
    };
    module2.exports = WelcomeChannel;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/WelcomeScreen.js
var require_WelcomeScreen = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/WelcomeScreen.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var Base = require_Base();
    var WelcomeChannel = require_WelcomeChannel();
    var WelcomeScreen = class extends Base {
      constructor(guild, data) {
        super(guild.client);
        this.guild = guild;
        this.description = data.description ?? null;
        this.welcomeChannels = new Collection2();
        for (const channel of data.welcome_channels) {
          const welcomeChannel = new WelcomeChannel(this.guild, channel);
          this.welcomeChannels.set(welcomeChannel.channelId, welcomeChannel);
        }
      }
      /**
       * Whether the welcome screen is enabled on the guild or not
       * @type {boolean}
       */
      get enabled() {
        return this.guild.features.includes("WELCOME_SCREEN_ENABLED");
      }
    };
    module2.exports = WelcomeScreen;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/InviteGuild.js
var require_InviteGuild = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/InviteGuild.js"(exports2, module2) {
    "use strict";
    var AnonymousGuild = require_AnonymousGuild();
    var WelcomeScreen = require_WelcomeScreen();
    var InviteGuild = class extends AnonymousGuild {
      constructor(client, data) {
        super(client, data);
        this.welcomeScreen = typeof data.welcome_screen !== "undefined" ? new WelcomeScreen(this, data.welcome_screen) : null;
      }
    };
    module2.exports = InviteGuild;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/Invite.js
var require_Invite = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/Invite.js"(exports2, module2) {
    "use strict";
    var Base = require_Base();
    var { GuildScheduledEvent } = require_GuildScheduledEvent();
    var IntegrationApplication = require_IntegrationApplication();
    var InviteStageInstance = require_InviteStageInstance();
    var { Error: Error2 } = require_errors2();
    var { Endpoints } = require_Constants();
    var InviteFlags = require_InviteFlags();
    var Permissions2 = require_Permissions();
    var Invite2 = class extends Base {
      constructor(client, data) {
        super(client);
        this._patch(data);
      }
      _patch(data) {
        const InviteGuild = require_InviteGuild();
        this.guild ?? (this.guild = null);
        if (data.guild) {
          this.guild = this.client.guilds.resolve(data.guild.id) ?? new InviteGuild(this.client, data.guild);
        }
        if ("code" in data) {
          this.code = data.code;
        }
        if ("approximate_presence_count" in data) {
          this.presenceCount = data.approximate_presence_count;
        } else {
          this.presenceCount ?? (this.presenceCount = null);
        }
        if ("approximate_member_count" in data) {
          this.memberCount = data.approximate_member_count;
        } else {
          this.memberCount ?? (this.memberCount = null);
        }
        if ("temporary" in data) {
          this.temporary = data.temporary ?? null;
        } else {
          this.temporary ?? (this.temporary = null);
        }
        if ("max_age" in data) {
          this.maxAge = data.max_age;
        } else {
          this.maxAge ?? (this.maxAge = null);
        }
        if ("uses" in data) {
          this.uses = data.uses;
        } else {
          this.uses ?? (this.uses = null);
        }
        if ("max_uses" in data) {
          this.maxUses = data.max_uses;
        } else {
          this.maxUses ?? (this.maxUses = null);
        }
        if ("inviter_id" in data) {
          this.inviterId = data.inviter_id;
          this.inviter = this.client.users.resolve(data.inviter_id);
        } else {
          this.inviterId ?? (this.inviterId = null);
        }
        if ("inviter" in data) {
          this.inviter ?? (this.inviter = this.client.users._add(data.inviter));
          this.inviterId = data.inviter.id;
        } else {
          this.inviter ?? (this.inviter = null);
        }
        if ("target_user" in data) {
          this.targetUser = this.client.users._add(data.target_user);
        } else {
          this.targetUser ?? (this.targetUser = null);
        }
        if ("target_application" in data) {
          this.targetApplication = new IntegrationApplication(this.client, data.target_application);
        } else {
          this.targetApplication ?? (this.targetApplication = null);
        }
        if ("target_type" in data) {
          this.targetType = data.target_type;
        } else {
          this.targetType ?? (this.targetType = null);
        }
        if ("type" in data) {
          this.type = data.type;
        } else {
          this.type ?? (this.type = null);
        }
        if ("channel_id" in data) {
          this.channelId = data.channel_id;
          this.channel = this.client.channels.cache.get(data.channel_id);
        }
        if ("channel" in data && data.channel !== null) {
          this.channel ?? (this.channel = this.client.channels._add(data.channel, this.guild, { cache: false }));
          this.channelId ?? (this.channelId = data.channel.id);
        }
        if ("created_at" in data) {
          this.createdTimestamp = new Date(data.created_at).getTime();
        } else {
          this.createdTimestamp ?? (this.createdTimestamp = null);
        }
        if ("expires_at" in data) {
          this._expiresTimestamp = data.expires_at && Date.parse(data.expires_at);
        } else {
          this._expiresTimestamp ?? (this._expiresTimestamp = null);
        }
        if ("stage_instance" in data) {
          this.stageInstance = new InviteStageInstance(this.client, data.stage_instance, this.channel.id, this.guild.id);
        } else {
          this.stageInstance ?? (this.stageInstance = null);
        }
        if ("guild_scheduled_event" in data) {
          this.guildScheduledEvent = new GuildScheduledEvent(this.client, data.guild_scheduled_event);
        } else {
          this.guildScheduledEvent ?? (this.guildScheduledEvent = null);
        }
        if ("flags" in data) {
          this.flags = new InviteFlags(data.flags).freeze();
        } else {
          this.flags ?? (this.flags = new InviteFlags().freeze());
        }
      }
      /**
       * The time the invite was created at
       * @type {?Date}
       * @readonly
       */
      get createdAt() {
        return this.createdTimestamp ? new Date(this.createdTimestamp) : null;
      }
      /**
       * Whether the invite is deletable by the client user
       * @type {boolean}
       * @readonly
       */
      get deletable() {
        const guild = this.guild;
        if (!guild || !this.client.guilds.cache.has(guild.id)) return false;
        if (!guild.members.me) throw new Error2("GUILD_UNCACHED_ME");
        return this.channel.permissionsFor(this.client.user).has(Permissions2.FLAGS.MANAGE_CHANNELS, false) || guild.members.me.permissions.has(Permissions2.FLAGS.MANAGE_GUILD);
      }
      /**
       * The timestamp the invite will expire at
       * @type {?number}
       * @readonly
       */
      get expiresTimestamp() {
        return this._expiresTimestamp ?? (this.createdTimestamp && this.maxAge ? this.createdTimestamp + this.maxAge * 1e3 : null);
      }
      /**
       * The time the invite will expire at
       * @type {?Date}
       * @readonly
       */
      get expiresAt() {
        const { expiresTimestamp } = this;
        return expiresTimestamp ? new Date(expiresTimestamp) : null;
      }
      /**
       * The URL to the invite
       * @type {string}
       * @readonly
       */
      get url() {
        return Endpoints.invite(this.client.options.http.invite, this.code);
      }
      /**
       * Deletes this invite.
       * @param {string} [reason] Reason for deleting this invite
       * @returns {Promise<Invite>}
       */
      async delete(reason) {
        await this.client.api.invites[this.code].delete({ reason });
        return this;
      }
      /**
       * When concatenated with a string, this automatically concatenates the invite's URL instead of the object.
       * @returns {string}
       * @example
       * // Logs: Invite: https://discord.gg/A1b2C3
       * console.log(`Invite: ${invite}`);
       */
      toString() {
        return this.url;
      }
      toJSON() {
        return super.toJSON({
          url: true,
          expiresTimestamp: true,
          presenceCount: false,
          memberCount: false,
          uses: false,
          channel: "channelId",
          inviter: "inviterId",
          guild: "guildId"
        });
      }
      valueOf() {
        return this.code;
      }
    };
    Invite2.INVITES_PATTERN = /discord(?:(?:app)?\.com\/invite|\.gg(?:\/invite)?)\/([\w-]{2,255})/gi;
    module2.exports = Invite2;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/GuildTemplate.js
var require_GuildTemplate = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/GuildTemplate.js"(exports2, module2) {
    "use strict";
    var { setTimeout: setTimeout2 } = require_node_timers();
    var Base = require_Base();
    var { Events: Events2 } = require_Constants();
    var DataResolver2 = require_DataResolver();
    var GuildTemplate2 = class extends Base {
      constructor(client, data) {
        super(client);
        this._patch(data);
      }
      _patch(data) {
        if ("code" in data) {
          this.code = data.code;
        }
        if ("name" in data) {
          this.name = data.name;
        }
        if ("description" in data) {
          this.description = data.description;
        }
        if ("usage_count" in data) {
          this.usageCount = data.usage_count;
        }
        if ("creator_id" in data) {
          this.creatorId = data.creator_id;
        }
        if ("creator" in data) {
          this.creator = this.client.users._add(data.creator);
        }
        if ("created_at" in data) {
          this.createdAt = new Date(data.created_at);
        }
        if ("updated_at" in data) {
          this.updatedAt = new Date(data.updated_at);
        }
        if ("source_guild_id" in data) {
          this.guildId = data.source_guild_id;
        }
        if ("serialized_source_guild" in data) {
          this.serializedGuild = data.serialized_source_guild;
        }
        this.unSynced = "is_dirty" in data ? Boolean(data.is_dirty) : null;
        return this;
      }
      /**
       * Creates a guild based on this template.
       * <warn>This is only available to bots in fewer than 10 guilds.</warn>
       * @param {string} name The name of the guild
       * @param {BufferResolvable|Base64Resolvable} [icon] The icon for the guild
       * @returns {Promise<Guild>}
       */
      async createGuild(name, icon) {
        const { client } = this;
        const data = await client.api.guilds.templates(this.code).post({
          data: {
            name,
            icon: await DataResolver2.resolveImage(icon)
          }
        });
        if (client.guilds.cache.has(data.id)) return client.guilds.cache.get(data.id);
        return new Promise((resolve) => {
          const resolveGuild = (guild) => {
            client.off(Events2.GUILD_CREATE, handleGuild);
            client.decrementMaxListeners();
            resolve(guild);
          };
          const handleGuild = (guild) => {
            if (guild.id === data.id) {
              clearTimeout(timeout);
              resolveGuild(guild);
            }
          };
          client.incrementMaxListeners();
          client.on(Events2.GUILD_CREATE, handleGuild);
          const timeout = setTimeout2(() => resolveGuild(client.guilds._add(data)), 1e4).unref();
        });
      }
      /**
       * Options used to edit a guild template.
       * @typedef {Object} EditGuildTemplateOptions
       * @property {string} [name] The name of this template
       * @property {string} [description] The description of this template
       */
      /**
       * Updates the metadata of this template.
       * @param {EditGuildTemplateOptions} [options] Options for editing the template
       * @returns {Promise<GuildTemplate>}
       */
      async edit({ name, description } = {}) {
        const data = await this.client.api.guilds(this.guildId).templates(this.code).patch({ data: { name, description } });
        return this._patch(data);
      }
      /**
       * Deletes this template.
       * @returns {Promise<GuildTemplate>}
       */
      async delete() {
        await this.client.api.guilds(this.guildId).templates(this.code).delete();
        return this;
      }
      /**
       * Syncs this template to the current state of the guild.
       * @returns {Promise<GuildTemplate>}
       */
      async sync() {
        const data = await this.client.api.guilds(this.guildId).templates(this.code).put();
        return this._patch(data);
      }
      /**
       * The timestamp of when this template was created at
       * @type {number}
       * @readonly
       */
      get createdTimestamp() {
        return this.createdAt.getTime();
      }
      /**
       * The timestamp of when this template was last synced to the guild
       * @type {number}
       * @readonly
       */
      get updatedTimestamp() {
        return this.updatedAt.getTime();
      }
      /**
       * The guild that this template belongs to
       * @type {?Guild}
       * @readonly
       */
      get guild() {
        return this.client.guilds.resolve(this.guildId);
      }
      /**
       * The URL of this template
       * @type {string}
       * @readonly
       */
      get url() {
        return `${this.client.options.http.template}/${this.code}`;
      }
      /**
       * When concatenated with a string, this automatically returns the template's code instead of the template object.
       * @returns {string}
       * @example
       * // Logs: Template: FKvmczH2HyUf
       * console.log(`Template: ${guildTemplate}!`);
       */
      toString() {
        return this.code;
      }
    };
    GuildTemplate2.GUILD_TEMPLATES_PATTERN = /discord(?:app)?\.(?:com\/template|new)\/([\w-]{2,255})/gi;
    module2.exports = GuildTemplate2;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/util/DataResolver.js
var require_DataResolver = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/util/DataResolver.js"(exports2, module2) {
    "use strict";
    var { Buffer: Buffer2 } = require_node_buffer();
    var fs = require_node_fs();
    var path = require_node_path();
    var stream = require_node_stream();
    var { fetch } = require_undici();
    var { Error: DiscordError, TypeError: TypeError2 } = require_errors2();
    var Invite2 = require_Invite();
    var DataResolver2 = class _DataResolver extends null {
      /**
       * Data that can be resolved to give an invite code. This can be:
       * * An invite code
       * * An invite URL
       * @typedef {string} InviteResolvable
       */
      /**
       * Data that can be resolved to give a template code. This can be:
       * * A template code
       * * A template URL
       * @typedef {string} GuildTemplateResolvable
       */
      /**
       * Resolves the string to a code based on the passed regex.
       * @param {string} data The string to resolve
       * @param {RegExp} regex The RegExp used to extract the code
       * @returns {string}
       */
      static resolveCode(data, regex) {
        var _a;
        return ((_a = new RegExp(regex.source).exec(data)) == null ? void 0 : _a[1]) ?? data;
      }
      /**
       * Resolves InviteResolvable to an invite code.
       * @param {InviteResolvable} data The invite resolvable to resolve
       * @returns {string}
       */
      static resolveInviteCode(data) {
        return this.resolveCode(data, Invite2.INVITES_PATTERN);
      }
      /**
       * Resolves GuildTemplateResolvable to a template code.
       * @param {GuildTemplateResolvable} data The template resolvable to resolve
       * @returns {string}
       */
      static resolveGuildTemplateCode(data) {
        const GuildTemplate2 = require_GuildTemplate();
        return this.resolveCode(data, GuildTemplate2.GUILD_TEMPLATES_PATTERN);
      }
      /**
       * Resolves a Base64Resolvable, a string, or a BufferResolvable to a Base 64 image.
       * @param {BufferResolvable|Base64Resolvable} image The image to be resolved
       * @returns {Promise<?string>}
       */
      static async resolveImage(image) {
        if (!image) return null;
        if (typeof image === "string" && image.startsWith("data:")) {
          return image;
        }
        const file = await this.resolveFileAsBuffer(image);
        return _DataResolver.resolveBase64(file);
      }
      /**
       * Data that resolves to give a Base64 string, typically for image uploading. This can be:
       * * A Buffer
       * * A base64 string
       * @typedef {Buffer|string} Base64Resolvable
       */
      /**
       * Resolves a Base64Resolvable to a Base 64 image.
       * @param {Base64Resolvable} data The base 64 resolvable you want to resolve
       * @returns {?string}
       */
      static resolveBase64(data) {
        if (Buffer2.isBuffer(data)) return `data:image/jpg;base64,${data.toString("base64")}`;
        return data;
      }
      /**
       * Data that can be resolved to give a Buffer. This can be:
       * * A Buffer
       * * The path to a local file
       * * A URL <warn>When provided a URL, discord.js will fetch the URL internally in order to create a Buffer.
       * This can pose a security risk when the URL has not been sanitized</warn>
       * @typedef {string|Buffer} BufferResolvable
       */
      /**
       * @external Stream
       * @see {@link https://nodejs.org/api/stream.html}
       */
      /**
       * Resolves a BufferResolvable to a Buffer or a Stream.
       * @param {BufferResolvable|Stream} resource The buffer or stream resolvable to resolve
       * @returns {Promise<Buffer|Stream>}
       */
      static async resolveFile(resource) {
        if (Buffer2.isBuffer(resource) || resource instanceof stream.Readable) return resource;
        if (typeof resource === "string") {
          if (/^https?:\/\//.test(resource)) {
            const res = await fetch(resource);
            if (res.ok) return res.body;
            else throw new DiscordError("FILE_NOT_FOUND", resource);
          }
          return new Promise((resolve, reject) => {
            const file = path.resolve(resource);
            fs.stat(file, (err, stats) => {
              if (err) return reject(err);
              if (!stats.isFile()) return reject(new DiscordError("FILE_NOT_FOUND", file));
              return resolve(fs.createReadStream(file));
            });
          });
        }
        throw new TypeError2("REQ_RESOURCE_TYPE");
      }
      /**
       * Resolves a BufferResolvable to a Buffer.
       * @param {BufferResolvable|Stream} resource The buffer or stream resolvable to resolve
       * @returns {Promise<Buffer>}
       */
      static async resolveFileAsBuffer(resource) {
        const file = await this.resolveFile(resource);
        if (Buffer2.isBuffer(file)) return file;
        const buffers = [];
        for await (const data of file) buffers.push(data);
        return Buffer2.concat(buffers);
      }
    };
    module2.exports = DataResolver2;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/util/MessageFlags.js
var require_MessageFlags = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/util/MessageFlags.js"(exports2, module2) {
    "use strict";
    var BitField = require_BitField();
    var MessageFlags = class extends BitField {
    };
    MessageFlags.FLAGS = {
      CROSSPOSTED: 1 << 0,
      IS_CROSSPOST: 1 << 1,
      SUPPRESS_EMBEDS: 1 << 2,
      SOURCE_MESSAGE_DELETED: 1 << 3,
      URGENT: 1 << 4,
      HAS_THREAD: 1 << 5,
      EPHEMERAL: 1 << 6,
      LOADING: 1 << 7,
      FAILED_TO_MENTION_SOME_ROLES_IN_THREAD: 1 << 8,
      GUILD_FEED_HIDDEN: 1 << 9,
      SHOULD_SHOW_LINK_NOT_DISCORD_WARNING: 1 << 10,
      SUPPRESS_NOTIFICATIONS: 1 << 12,
      IS_VOICE_MESSAGE: 1 << 13,
      HAS_SNAPSHOT: 1 << 14,
      IS_UIKIT_COMPONENTS: 1 << 15
    };
    module2.exports = MessageFlags;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/Webhook.js
var require_Webhook = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/Webhook.js"(exports2, module2) {
    "use strict";
    var process2 = require_node_process();
    var MessagePayload = require_MessagePayload();
    var { Error: Error2 } = require_errors2();
    var { WebhookTypes } = require_Constants();
    var DataResolver2 = require_DataResolver();
    var SnowflakeUtil = require_SnowflakeUtil();
    var deprecationEmittedForFetchMessage = false;
    var Webhook2 = class _Webhook {
      constructor(client, data) {
        Object.defineProperty(this, "client", { value: client });
        if (data) this._patch(data);
      }
      _patch(data) {
        var _a, _b, _c, _d;
        if ("name" in data) {
          this.name = data.name;
        }
        Object.defineProperty(this, "token", { value: data.token ?? null, writable: true, configurable: true });
        if ("avatar" in data) {
          this.avatar = data.avatar;
        }
        this.id = data.id;
        if ("type" in data) {
          this.type = WebhookTypes[data.type];
        }
        if ("guild_id" in data) {
          this.guildId = data.guild_id;
        }
        if ("channel_id" in data) {
          this.channelId = data.channel_id;
        }
        if ("user" in data) {
          this.owner = ((_a = this.client.users) == null ? void 0 : _a._add(data.user)) ?? data.user;
        } else {
          this.owner ?? (this.owner = null);
        }
        if ("source_guild" in data) {
          this.sourceGuild = ((_b = this.client.guilds) == null ? void 0 : _b.resolve(data.source_guild.id)) ?? data.source_guild;
        } else {
          this.sourceGuild ?? (this.sourceGuild = null);
        }
        if ("source_channel" in data) {
          this.sourceChannel = ((_d = this.client.channels) == null ? void 0 : _d.resolve((_c = data.source_channel) == null ? void 0 : _c.id)) ?? data.source_channel;
        } else {
          this.sourceChannel ?? (this.sourceChannel = null);
        }
      }
      /**
       * Options that can be passed into send.
       * @typedef {BaseMessageOptionsWithPoll} WebhookMessageOptions
       * @property {string} [username=this.name] Username override for the message
       * @property {string} [avatarURL] Avatar URL override for the message
       * @property {Snowflake} [threadId] The id of the thread in the channel to send to.
       * <info>For interaction webhooks, this property is ignored</info>
       * @property {string} [threadName] Name of the thread to create (only available if webhook is in a forum channel)
       * @property {MessageFlags} [flags] Which flags to set for the message. Only `SUPPRESS_EMBEDS` can be set.
       * @property {Snowflake[]} [appliedTags]
       * The tags to apply to the created thread (only available if the webhook is in a forum channel)
       */
      /**
       * Options that can be passed into editMessage.
       * @typedef {Object} WebhookEditMessageOptions
       * @property {MessageEmbed[]|APIEmbed[]} [embeds] See {@link WebhookMessageOptions#embeds}
       * @property {string} [content] See {@link BaseMessageOptions#content}
       * @property {FileOptions[]|BufferResolvable[]|MessageAttachment[]} [files] See {@link BaseMessageOptions#files}
       * @property {MessageMentionOptions} [allowedMentions] See {@link BaseMessageOptions#allowedMentions}
       * @property {MessageAttachment[]} [attachments] Attachments to send with the message
       * @property {MessageActionRow[]|MessageActionRowOptions[]} [components]
       * Action rows containing interactive components for the message (buttons, select menus)
       * @property {Snowflake} [threadId] The id of the thread this message belongs to
       * <info>For interaction webhooks, this property is ignored</info>
       */
      /**
       * Sends a message with this webhook.
       * @param {string|MessagePayload|WebhookMessageOptions} options The options to provide
       * @returns {Promise<Message|APIMessage>}
       * @example
       * // Send a basic message
       * webhook.send('hello!')
       *   .then(message => console.log(`Sent message: ${message.content}`))
       *   .catch(console.error);
       * @example
       * // Send a basic message in a thread
       * webhook.send({ content: 'hello!', threadId: '836856309672348295' })
       *   .then(message => console.log(`Sent message: ${message.content}`))
       *   .catch(console.error);
       * @example
       * // Send a remote file
       * webhook.send({
       *   files: ['https://cdn.discordapp.com/icons/222078108977594368/6e1019b3179d71046e463a75915e7244.png?size=2048']
       * })
       *   .then(console.log)
       *   .catch(console.error);
       * @example
       * // Send a local file
       * webhook.send({
       *   files: [{
       *     attachment: 'entire/path/to/file.jpg',
       *     name: 'file.jpg'
       *   }]
       * })
       *   .then(console.log)
       *   .catch(console.error);
       * @example
       * // Send an embed with a local image inside
       * webhook.send({
       *   content: 'This is an embed',
       *   embeds: [{
       *     thumbnail: {
       *          url: 'attachment://file.jpg'
       *       }
       *    }],
       *    files: [{
       *       attachment: 'entire/path/to/file.jpg',
       *       name: 'file.jpg'
       *    }]
       * })
       *   .then(console.log)
       *   .catch(console.error);
       */
      async send(options) {
        var _a, _b;
        if (!this.token) throw new Error2("WEBHOOK_TOKEN_UNAVAILABLE");
        let messagePayload;
        if (options instanceof MessagePayload) {
          messagePayload = options.resolveData();
        } else {
          messagePayload = MessagePayload.create(this, options).resolveData();
        }
        const { data, files } = await messagePayload.resolveFiles();
        const d = await this.client.api.webhooks(this.id, this.token).post({
          data,
          files,
          query: { thread_id: messagePayload.options.threadId, wait: true },
          auth: false,
          webhook: true
        });
        return ((_b = (_a = this.client.channels) == null ? void 0 : _a.cache.get(d.channel_id)) == null ? void 0 : _b.messages._add(d, false)) ?? d;
      }
      /**
       * Sends a raw slack message with this webhook.
       * @param {Object} body The raw body to send
       * @returns {Promise<boolean>}
       * @example
       * // Send a slack message
       * webhook.sendSlackMessage({
       *   'username': 'Wumpus',
       *   'attachments': [{
       *     'pretext': 'this looks pretty cool',
       *     'color': '#F0F',
       *     'footer_icon': 'http://snek.s3.amazonaws.com/topSnek.png',
       *     'footer': 'Powered by sneks',
       *     'ts': Date.now() / 1_000
       *   }]
       * }).catch(console.error);
       * @see {@link https://api.slack.com/messaging/webhooks}
       */
      async sendSlackMessage(body) {
        if (!this.token) throw new Error2("WEBHOOK_TOKEN_UNAVAILABLE");
        const data = await this.client.api.webhooks(this.id, this.token).slack.post({
          query: { wait: true },
          auth: false,
          data: body,
          webhook: true
        });
        return data.toString() === "ok";
      }
      /**
       * Options used to edit a {@link Webhook}.
       * @typedef {Object} WebhookEditData
       * @property {string} [name=this.name] The new name for the webhook
       * @property {?(BufferResolvable)} [avatar] The new avatar for the webhook
       * @property {GuildTextChannelResolvable|VoiceChannel|StageChannel|ForumChannel|MediaChannel} [channel]
       * The new channel for the webhook
       */
      /**
       * Edits this webhook.
       * @param {WebhookEditData} options Options for editing the webhook
       * @param {string} [reason] Reason for editing the webhook
       * @returns {Promise<Webhook>}
       */
      async edit({ name = this.name, avatar, channel }, reason) {
        if (avatar && !(typeof avatar === "string" && avatar.startsWith("data:"))) {
          avatar = await DataResolver2.resolveImage(avatar);
        }
        channel && (channel = channel.id ?? channel);
        const data = await this.client.api.webhooks(this.id, channel ? void 0 : this.token).patch({
          data: { name, avatar, channel_id: channel },
          reason,
          auth: !this.token || Boolean(channel),
          webhook: true
        });
        this.name = data.name;
        this.avatar = data.avatar;
        this.channelId = data.channel_id;
        return this;
      }
      /**
       * Options that can be passed into fetchMessage.
       * @typedef {options} WebhookFetchMessageOptions
       * @property {boolean} [cache=true] Whether to cache the message.
       * @property {Snowflake} [threadId] The id of the thread this message belongs to.
       * <info>For interaction webhooks, this property is ignored</info>
       */
      /**
       * Gets a message that was sent by this webhook.
       * @param {Snowflake|'@original'} message The id of the message to fetch
       * @param {WebhookFetchMessageOptions|boolean} [cacheOrOptions={}] The options to provide to fetch the message.
       * <warn>A **deprecated** boolean may be passed instead to specify whether to cache the message.</warn>
       * @returns {Promise<Message|APIMessage>} Returns the raw message data if the webhook was instantiated as a
       * {@link WebhookClient} or if the channel is uncached, otherwise a {@link Message} will be returned
       */
      async fetchMessage(message, cacheOrOptions = { cache: true }) {
        var _a, _b;
        if (typeof cacheOrOptions === "boolean") {
          if (!deprecationEmittedForFetchMessage) {
            process2.emitWarning(
              "Passing a boolean to cache the message in Webhook#fetchMessage is deprecated. Pass an object instead.",
              "DeprecationWarning"
            );
            deprecationEmittedForFetchMessage = true;
          }
          cacheOrOptions = { cache: cacheOrOptions };
        }
        if (!this.token) throw new Error2("WEBHOOK_TOKEN_UNAVAILABLE");
        const data = await this.client.api.webhooks(this.id, this.token).messages(message).get({
          query: {
            thread_id: cacheOrOptions.threadId
          },
          auth: false,
          webhook: true
        });
        return ((_b = (_a = this.client.channels) == null ? void 0 : _a.cache.get(data.channel_id)) == null ? void 0 : _b.messages._add(data, cacheOrOptions.cache)) ?? data;
      }
      /**
       * Edits a message that was sent by this webhook.
       * @param {MessageResolvable|'@original'} message The message to edit
       * @param {string|MessagePayload|WebhookEditMessageOptions} options The options to provide
       * @returns {Promise<Message|APIMessage>} Returns the raw message data if the webhook was instantiated as a
       * {@link WebhookClient} or if the channel is uncached, otherwise a {@link Message} will be returned
       */
      async editMessage(message, options) {
        var _a, _b;
        if (!this.token) throw new Error2("WEBHOOK_TOKEN_UNAVAILABLE");
        let messagePayload;
        if (options instanceof MessagePayload) messagePayload = options;
        else messagePayload = MessagePayload.create(this, options);
        const { data, files } = await messagePayload.resolveData().resolveFiles();
        const d = await this.client.api.webhooks(this.id, this.token).messages(typeof message === "string" ? message : message.id).patch({
          data,
          files,
          query: {
            thread_id: messagePayload.options.threadId
          },
          auth: false,
          webhook: true
        });
        const messageManager = (_b = (_a = this.client.channels) == null ? void 0 : _a.cache.get(d.channel_id)) == null ? void 0 : _b.messages;
        if (!messageManager) return d;
        const existing = messageManager.cache.get(d.id);
        if (!existing) return messageManager._add(d);
        const clone = existing._clone();
        clone._patch(d);
        return clone;
      }
      /**
       * Deletes the webhook.
       * @param {string} [reason] Reason for deleting this webhook
       * @returns {Promise<void>}
       */
      async delete(reason) {
        await this.client.api.webhooks(this.id, this.token).delete({ reason, auth: !this.token, webhook: true });
      }
      /**
       * Delete a message that was sent by this webhook.
       * @param {MessageResolvable|'@original'} message The message to delete
       * @param {Snowflake} [threadId] The id of the thread this message belongs to
       * @returns {Promise<void>}
       */
      async deleteMessage(message, threadId) {
        if (!this.token) throw new Error2("WEBHOOK_TOKEN_UNAVAILABLE");
        await this.client.api.webhooks(this.id, this.token).messages(typeof message === "string" ? message : message.id).delete({
          query: {
            thread_id: threadId
          },
          auth: false,
          webhook: true
        });
      }
      /**
       * The channel the webhook belongs to
       * @type {?(TextChannel|VoiceChannel|NewsChannel|ForumChannel|MediaChannel)}
       * @readonly
       */
      get channel() {
        return this.client.channels.resolve(this.channelId);
      }
      /**
       * The timestamp the webhook was created at
       * @type {number}
       * @readonly
       */
      get createdTimestamp() {
        return SnowflakeUtil.timestampFrom(this.id);
      }
      /**
       * The time the webhook was created at
       * @type {Date}
       * @readonly
       */
      get createdAt() {
        return new Date(this.createdTimestamp);
      }
      /**
       * The URL of this webhook
       * @type {string}
       * @readonly
       */
      get url() {
        return this.client.options.http.api + this.client.api.webhooks(this.id, this.token);
      }
      /**
       * A link to the webhook's avatar.
       * @param {StaticImageURLOptions} [options={}] Options for the Image URL
       * @returns {?string}
       */
      avatarURL({ format, size } = {}) {
        if (!this.avatar) return null;
        return this.client.rest.cdn.Avatar(this.id, this.avatar, format, size);
      }
      /**
       * Whether or not this webhook is a channel follower webhook.
       * @returns {boolean}
       */
      isChannelFollower() {
        return this.type === "Channel Follower";
      }
      /**
       * Whether or not this webhook is an incoming webhook.
       * @returns {boolean}
       */
      isIncoming() {
        return this.type === "Incoming";
      }
      static applyToClass(structure, ignore = []) {
        for (const prop of [
          "send",
          "sendSlackMessage",
          "fetchMessage",
          "edit",
          "editMessage",
          "delete",
          "deleteMessage",
          "createdTimestamp",
          "createdAt",
          "url"
        ]) {
          if (ignore.includes(prop)) continue;
          Object.defineProperty(structure.prototype, prop, Object.getOwnPropertyDescriptor(_Webhook.prototype, prop));
        }
      }
    };
    module2.exports = Webhook2;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/WebhookClient.js
var require_WebhookClient = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/WebhookClient.js"(exports2, module2) {
    "use strict";
    var BaseClient2 = require_BaseClient();
    var { Error: Error2 } = require_errors2();
    var Webhook2 = require_Webhook();
    var WebhookClient = class extends BaseClient2 {
      /**
       * The data for the webhook client containing either an id and token or just a URL
       * @typedef {Object} WebhookClientData
       * @property {Snowflake} [id] The id of the webhook
       * @property {string} [token] The token of the webhook
       * @property {string} [url] The full URL for the webhook client
       */
      /**
       * @param {WebhookClientData} data The data of the webhook
       * @param {ClientOptions} [options] Options for the client
       */
      constructor(data, options) {
        super(options);
        Object.defineProperty(this, "client", { value: this });
        let { id, token } = data;
        if ("url" in data) {
          const url = data.url.match(
            // eslint-disable-next-line no-useless-escape
            /^https?:\/\/(?:canary|ptb)?\.?discord\.com\/api\/webhooks(?:\/v[0-9]\d*)?\/([^\/]+)\/([^\/]+)/i
          );
          if (!url || url.length <= 1) throw new Error2("WEBHOOK_URL_INVALID");
          [, id, token] = url;
        }
        this.id = id;
        Object.defineProperty(this, "token", { value: token, writable: true, configurable: true });
      }
      // These are here only for documentation purposes - they are implemented by Webhook
      /* eslint-disable no-empty-function */
      send() {
      }
      sendSlackMessage() {
      }
      fetchMessage() {
      }
      edit() {
      }
      editMessage() {
      }
      delete() {
      }
      deleteMessage() {
      }
      get createdTimestamp() {
      }
      get createdAt() {
      }
      get url() {
      }
    };
    Webhook2.applyToClass(WebhookClient);
    module2.exports = WebhookClient;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/VoiceState.js
var require_VoiceState = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/VoiceState.js"(exports2, module2) {
    "use strict";
    var Base = require_Base();
    var { Error: Error2, TypeError: TypeError2 } = require_errors2();
    var VoiceState = class extends Base {
      constructor(guild, data) {
        super(guild.client);
        this.guild = guild;
        this.id = data.user_id;
        this._patch(data);
      }
      _patch(data) {
        if ("deaf" in data) {
          this.serverDeaf = data.deaf;
        } else {
          this.serverDeaf ?? (this.serverDeaf = null);
        }
        if ("mute" in data) {
          this.serverMute = data.mute;
        } else {
          this.serverMute ?? (this.serverMute = null);
        }
        if ("self_deaf" in data) {
          this.selfDeaf = data.self_deaf;
        } else {
          this.selfDeaf ?? (this.selfDeaf = null);
        }
        if ("self_mute" in data) {
          this.selfMute = data.self_mute;
        } else {
          this.selfMute ?? (this.selfMute = null);
        }
        if ("self_video" in data) {
          this.selfVideo = data.self_video;
        } else {
          this.selfVideo ?? (this.selfVideo = null);
        }
        if ("session_id" in data) {
          this.sessionId = data.session_id;
        } else {
          this.sessionId ?? (this.sessionId = null);
        }
        if ("self_video" in data) {
          this.streaming = data.self_stream ?? false;
        } else {
          this.streaming ?? (this.streaming = null);
        }
        if ("channel_id" in data) {
          this.channelId = data.channel_id;
        } else {
          this.channelId ?? (this.channelId = null);
        }
        if ("suppress" in data) {
          this.suppress = data.suppress;
        }
        if ("request_to_speak_timestamp" in data) {
          this.requestToSpeakTimestamp = data.request_to_speak_timestamp && Date.parse(data.request_to_speak_timestamp);
        } else {
          this.requestToSpeakTimestamp ?? (this.requestToSpeakTimestamp = null);
        }
        return this;
      }
      /**
       * The member that this voice state belongs to
       * @type {?GuildMember}
       * @readonly
       */
      get member() {
        var _a;
        if (!((_a = this.guild) == null ? void 0 : _a.id)) return null;
        return this.guild.members.cache.get(this.id) ?? null;
      }
      /**
       * The user that this voice state belongs to
       * @type {?User}
       * @readonly
       */
      get user() {
        return this.guild.client.users.cache.get(this.id) ?? null;
      }
      /**
       * The channel that the member is connected to
       * @type {?(VoiceChannel|StageChannel|DMChannel|GroupDMChannel)}
       * @readonly
       */
      get channel() {
        return (this.guild || this.client).channels.cache.get(this.channelId) ?? null;
      }
      /**
       * Whether this member is either self-deafened or server-deafened
       * @type {?boolean}
       * @readonly
       */
      get deaf() {
        return this.serverDeaf || this.selfDeaf;
      }
      /**
       * Whether this member is either self-muted or server-muted
       * @type {?boolean}
       * @readonly
       */
      get mute() {
        return this.serverMute || this.selfMute;
      }
      /**
       * Mutes/unmutes the member of this voice state.
       * @param {boolean} [mute=true] Whether or not the member should be muted
       * @param {string} [reason] Reason for muting or unmuting
       * @returns {Promise<GuildMember>}
       */
      setMute(mute = true, reason) {
        var _a;
        if (!((_a = this.guild) == null ? void 0 : _a.id)) return null;
        return this.guild.members.edit(this.id, { mute }, reason);
      }
      /**
       * Deafens/undeafens the member of this voice state.
       * @param {boolean} [deaf=true] Whether or not the member should be deafened
       * @param {string} [reason] Reason for deafening or undeafening
       * @returns {Promise<GuildMember>}
       */
      setDeaf(deaf = true, reason) {
        var _a;
        if (!((_a = this.guild) == null ? void 0 : _a.id)) return null;
        return this.guild.members.edit(this.id, { deaf }, reason);
      }
      /**
       * Disconnects the member from the channel.
       * @param {string} [reason] Reason for disconnecting the member from the channel
       * @returns {Promise<GuildMember>}
       */
      disconnect(reason) {
        return this.setChannel(null, reason);
      }
      /**
       * Moves the member to a different channel, or disconnects them from the one they're in.
       * @param {GuildVoiceChannelResolvable|null} channel Channel to move the member to, or `null` if you want to
       * disconnect them from voice.
       * @param {string} [reason] Reason for moving member to another channel or disconnecting
       * @returns {Promise<GuildMember>}
       */
      setChannel(channel, reason) {
        var _a;
        if (!((_a = this.guild) == null ? void 0 : _a.id)) return null;
        return this.guild.members.edit(this.id, { channel }, reason);
      }
      /**
       * Toggles the request to speak in the channel.
       * Only applicable for stage channels and for the client's own voice state.
       * @param {boolean} [request=true] Whether or not the client is requesting to become a speaker.
       * @example
       * // Making the client request to speak in a stage channel (raise its hand)
       * guild.members.me.voice.setRequestToSpeak(true);
       * @example
       * // Making the client cancel a request to speak
       * guild.members.me.voice.setRequestToSpeak(false);
       * @returns {Promise<void>}
       */
      async setRequestToSpeak(request = true) {
        var _a;
        if (((_a = this.channel) == null ? void 0 : _a.type) !== "GUILD_STAGE_VOICE") throw new Error2("VOICE_NOT_STAGE_CHANNEL");
        if (this.client.user.id !== this.id) throw new Error2("VOICE_STATE_NOT_OWN");
        await this.client.api.guilds(this.guild.id, "voice-states", "@me").patch({
          data: {
            channel_id: this.channelId,
            request_to_speak_timestamp: request ? (/* @__PURE__ */ new Date()).toISOString() : null
          }
        });
      }
      /**
       * Suppress/unsuppress the user. Only applicable for stage channels.
       * @param {boolean} [suppressed=true] Whether or not the user should be suppressed.
       * @example
       * // Making the client a speaker
       * guild.members.me.voice.setSuppressed(false);
       * @example
       * // Making the client an audience member
       * guild.members.me.voice.setSuppressed(true);
       * @example
       * // Inviting another user to speak
       * voiceState.setSuppressed(false);
       * @example
       * // Moving another user to the audience, or cancelling their invite to speak
       * voiceState.setSuppressed(true);
       * @returns {Promise<void>}
       */
      async setSuppressed(suppressed = true) {
        var _a;
        if (typeof suppressed !== "boolean") throw new TypeError2("VOICE_STATE_INVALID_TYPE", "suppressed");
        if (((_a = this.channel) == null ? void 0 : _a.type) !== "GUILD_STAGE_VOICE") throw new Error2("VOICE_NOT_STAGE_CHANNEL");
        const target = this.client.user.id === this.id ? "@me" : this.id;
        await this.client.api.guilds(this.guild.id, "voice-states", target).patch({
          data: {
            channel_id: this.channelId,
            suppress: suppressed,
            request_to_speak_timestamp: null
          }
        });
      }
      /**
       * Sets the status of the voice channel
       * @param {string} [status=""] The message to set the channel status to
       * @example
       * // Setting the status to something
       * guild.members.me.voice.setStatus("something")
       * @example
       * // Removing the status
       * guild.members.me.voice.setStatus()
       * @returns {Promise<void>}
       */
      setStatus(status = "") {
        return this.client.api.channels(this.channel.id, "voice-status").put({
          data: {
            status
          }
        });
      }
      /**
       * Get URL Image of the user's streaming video (NOT STREAMING !!!)
       * @returns {Promise<string>} URL Image of the user's streaming video
       */
      async getPreview() {
        if (!this.streaming) throw new Error2("USER_NOT_STREAMING");
        const streamKey = this.guild.id ? `guild:${this.guild.id}:${this.channelId}:${this.id}` : `call:${this.channelId}:${this.id}`;
        const data = await this.client.api.streams[encodeURIComponent(streamKey)].preview.get();
        return data.url;
      }
      /**
       * Post Preview Image to the client user's streaming video
       * @param {string} base64Image Base64 URI (data:image/jpeg;base64,data)
       * @returns {Promise<void>}
       */
      postPreview(base64Image) {
        if (!this.client.user.id === this.id || !this.streaming) throw new Error2("USER_NOT_STREAMING");
        const streamKey = this.guild.id ? `guild:${this.guild.id}:${this.channelId}:${this.id}` : `call:${this.channelId}:${this.id}`;
        return this.client.api.streams[encodeURIComponent(streamKey)].preview.post({
          data: {
            thumbnail: base64Image
          }
        });
      }
      /**
       * Fetches this voice state.
       * @param {boolean} [force=true] Whether to skip the cache check and request the API
       * @returns {Promise<VoiceState>}
       */
      fetch(force = true) {
        var _a, _b;
        return (_b = (_a = this.guild) == null ? void 0 : _a.voiceStates) == null ? void 0 : _b.fetch(this.id, { force });
      }
      toJSON() {
        return super.toJSON({
          id: true,
          serverDeaf: true,
          serverMute: true,
          selfDeaf: true,
          selfMute: true,
          selfVideo: true,
          sessionId: true,
          channelId: "channel"
        });
      }
    };
    module2.exports = VoiceState;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/util/UserFlags.js
var require_UserFlags = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/util/UserFlags.js"(exports2, module2) {
    "use strict";
    var BitField = require_BitField();
    var UserFlags = class extends BitField {
    };
    UserFlags.FLAGS = {
      DISCORD_EMPLOYEE: 1 << 0,
      PARTNERED_SERVER_OWNER: 1 << 1,
      HYPESQUAD_EVENTS: 1 << 2,
      BUGHUNTER_LEVEL_1: 1 << 3,
      MFA_SMS: 1 << 4,
      // [Undocumented] User has SMS 2FA enabled.
      PREMIUM_PROMO_DISMISSED: 1 << 5,
      // [Undocumented] Presumably some sort of Discord Nitro promotion that the user dismissed.
      HOUSE_BRAVERY: 1 << 6,
      HOUSE_BRILLIANCE: 1 << 7,
      HOUSE_BALANCE: 1 << 8,
      EARLY_SUPPORTER: 1 << 9,
      TEAM_USER: 1 << 10,
      INTERNAL_APPLICATION: 1 << 11,
      // [Undocumented] An internal flag accidentally leaked to the client's private flags. Relates to partner/verification applications but nothing else is known.
      SYSTEM: 1 << 12,
      // [Undocumented] Account is a Discord system account.
      HAS_UNREAD_URGENT_MESSAGES: 1 << 13,
      // [Undocumented] User has unread messages from Discord.
      BUGHUNTER_LEVEL_2: 1 << 14,
      UNDERAGE_DELETED: 1 << 15,
      // [Undocumented] Unused. User was deleted for being underage.
      VERIFIED_BOT: 1 << 16,
      EARLY_VERIFIED_BOT_DEVELOPER: 1 << 17,
      DISCORD_CERTIFIED_MODERATOR: 1 << 18,
      BOT_HTTP_INTERACTIONS: 1 << 19,
      SPAMMER: 1 << 20,
      // [Undocumented] User is marked as a spammer.
      DISABLE_PREMIUM: 1 << 21,
      // [Undocumented] Forcefully disables Nitro features.
      ACTIVE_DEVELOPER: 1 << 22,
      // User is an active developer.
      HIGH_GLOBAL_RATE_LIMIT: Math.pow(2, 33),
      // [Undocumented] User is a high global rate limit.
      DELETED: Math.pow(2, 34),
      // [Undocumented] Account has been deleted.
      DISABLED_SUSPICIOUS_ACTIVITY: Math.pow(2, 35),
      // [Undocumented] Account has been disabled for suspicious activity.
      SELF_DELETED: Math.pow(2, 36),
      // [Undocumented] Account was deleted by the user.
      PREMIUM_DISCRIMINATOR: Math.pow(2, 37),
      // [Undocumented] User has a premium discriminator.
      USED_DESKTOP_CLIENT: Math.pow(2, 38),
      // [Undocumented] User has used the desktop client.
      USED_WEB_CLIENT: Math.pow(2, 39),
      // [Undocumented] User has used the web client.
      USED_MOBILE_CLIENT: Math.pow(2, 40),
      // [Undocumented] User has used the mobile client.
      DISABLED: Math.pow(2, 41),
      // [Undocumented] User is currently temporarily or permanently disabled.
      VERIFIED_EMAIL: Math.pow(2, 43),
      // [Undocumented] User has a verified email on their account.
      QUARANTINED: Math.pow(2, 44),
      // [Undocumented] User is quarantined.
      COLLABORATOR: Math.pow(2, 50),
      // [Undocumented] User is a collaborator and has staff permissions.
      RESTRICTED_COLLABORATOR: Math.pow(2, 51)
      // [Undocumented] User is a restricted collaborator and has staff permissions.
    };
    module2.exports = UserFlags;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/User.js
var require_User = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/User.js"(exports2, module2) {
    "use strict";
    var Base = require_Base();
    var VoiceState = require_VoiceState();
    var TextBasedChannel = require_TextBasedChannel();
    var { Error: Error2 } = require_errors2();
    var { RelationshipTypes } = require_Constants();
    var SnowflakeUtil = require_SnowflakeUtil();
    var UserFlags = require_UserFlags();
    var Util = require_Util();
    var User = class extends Base {
      constructor(client, data) {
        super(client);
        this.id = data.id;
        this.bot = null;
        this.system = null;
        this.flags = null;
        this._patch(data);
      }
      _patch(data) {
        if ("username" in data) {
          this.username = data.username;
        } else {
          this.username ?? (this.username = null);
        }
        if ("global_name" in data) {
          this.globalName = data.global_name;
        } else {
          this.globalName ?? (this.globalName = null);
        }
        if ("bot" in data) {
          this.bot = Boolean(data.bot);
        } else if (!this.partial && typeof this.bot !== "boolean") {
          this.bot = false;
        }
        if ("discriminator" in data) {
          this.discriminator = data.discriminator;
        } else {
          this.discriminator ?? (this.discriminator = null);
        }
        if ("avatar" in data) {
          this.avatar = data.avatar;
        } else {
          this.avatar ?? (this.avatar = null);
        }
        if ("banner" in data) {
          this.banner = data.banner;
        } else if (this.banner !== null) {
          this.banner ?? (this.banner = void 0);
        }
        if ("banner_color" in data) {
          this.bannerColor = data.banner_color;
        } else if (this.bannerColor !== null) {
          this.bannerColor ?? (this.bannerColor = void 0);
        }
        if ("accent_color" in data) {
          this.accentColor = data.accent_color;
        } else if (this.accentColor !== null) {
          this.accentColor ?? (this.accentColor = void 0);
        }
        if ("system" in data) {
          this.system = Boolean(data.system);
        } else if (!this.partial && typeof this.system !== "boolean") {
          this.system = false;
        }
        if ("public_flags" in data) {
          this.flags = new UserFlags(data.public_flags);
        }
        if (data.avatar_decoration_data) {
          this.avatarDecorationData = {
            asset: data.avatar_decoration_data.asset,
            skuId: data.avatar_decoration_data.sku_id
          };
        } else {
          this.avatarDecorationData = null;
        }
        if ("clan" in data && data.clan) {
          this.clan = {
            identityGuildId: data.clan.identity_guild_id,
            identityEnabled: data.clan.identity_enabled,
            tag: data.clan.tag,
            badge: data.clan.badge
          };
        } else {
          this.clan ?? (this.clan = null);
        }
      }
      /**
       * The user avatar decoration's hash
       * @type {?string}
       * @deprecated Use `avatarDecorationData` instead
       * Removed in v4
       */
      get avatarDecoration() {
        var _a;
        return ((_a = this.avatarDecorationData) == null ? void 0 : _a.asset) || null;
      }
      /**
       * Whether this User is a partial
       * @type {boolean}
       * @readonly
       */
      get partial() {
        return typeof this.username !== "string";
      }
      /**
       * The timestamp the user was created at
       * @type {number}
       * @readonly
       */
      get createdTimestamp() {
        return SnowflakeUtil.timestampFrom(this.id);
      }
      /**
       * The time the user was created at
       * @type {Date}
       * @readonly
       */
      get createdAt() {
        return new Date(this.createdTimestamp);
      }
      /**
       * A link to the user's avatar.
       * @param {ImageURLOptions} [options={}] Options for the Image URL
       * @returns {?string}
       */
      avatarURL({ format, size, dynamic } = {}) {
        if (!this.avatar) return null;
        return this.client.rest.cdn.Avatar(this.id, this.avatar, format, size, dynamic);
      }
      /**
       * A link to the user's avatar decoration.
       * @param {StaticImageURLOptions} [options={}] Options for the image URL
       * <info> The `format` option is not supported for this image URL</info>
       * @returns {?string}
       */
      avatarDecorationURL({ size } = {}) {
        if (!this.avatarDecorationData) return null;
        return this.client.rest.cdn.AvatarDecoration(this.avatarDecorationData.asset, size);
      }
      /**
       * A link to the user's clan badge.
       * @returns {?string}
       */
      clanBadgeURL() {
        if (!this.clan || !this.clan.identityGuildId || !this.clan.badge) return null;
        return this.client.rest.cdn.ClanBadge(this.clan.identityGuildId, this.clan.badge);
      }
      /**
       * A link to the user's default avatar
       * @type {string}
       * @readonly
       */
      get defaultAvatarURL() {
        const index = this.discriminator === "0" ? Util.calculateUserDefaultAvatarIndex(this.id) : this.discriminator % 5;
        return this.client.rest.cdn.DefaultAvatar(index);
      }
      /**
       * A link to the user's avatar if they have one.
       * Otherwise a link to their default avatar will be returned.
       * @param {ImageURLOptions} [options={}] Options for the Image URL
       * @returns {string}
       */
      displayAvatarURL(options) {
        return this.avatarURL(options) ?? this.defaultAvatarURL;
      }
      /**
       * The hexadecimal version of the user accent color, with a leading hash
       * <info>The user must be force fetched for this property to be present</info>
       * @type {?string}
       * @readonly
       */
      get hexAccentColor() {
        if (typeof this.accentColor !== "number") return this.accentColor;
        return `#${this.accentColor.toString(16).padStart(6, "0")}`;
      }
      /**
       * A link to the user's banner.
       * <info>This method will throw an error if called before the user is force fetched.
       * See {@link User#banner} for more info</info>
       * @param {ImageURLOptions} [options={}] Options for the Image URL
       * @returns {?string}
       */
      bannerURL({ format, size, dynamic } = {}) {
        if (typeof this.banner === "undefined") throw new Error2("USER_BANNER_NOT_FETCHED");
        if (!this.banner) return null;
        return this.client.rest.cdn.Banner(this.id, this.banner, format, size, dynamic);
      }
      /**
       * The tag of this user
       * <info>This user's username, or their legacy tag (e.g. `hydrabolt#0001`)
       * if they're using the legacy username system</info>
       * @type {?string}
       * @readonly
       */
      get tag() {
        return typeof this.username === "string" ? this.discriminator === "0" ? this.username : `${this.username}#${this.discriminator}` : null;
      }
      /**
       * The global name of this user, or their username if they don't have one
       * @type {?string}
       * @readonly
       */
      get displayName() {
        return this.globalName ?? this.username;
      }
      /**
       * The DM between the client's user and this user
       * @type {?DMChannel}
       * @readonly
       */
      get dmChannel() {
        return this.client.users.dmChannel(this.id);
      }
      /**
       * Creates a DM channel between the client and the user.
       * @param {boolean} [force=false] Whether to skip the cache check and request the API
       * @returns {Promise<DMChannel>}
       */
      createDM(force = false) {
        return this.client.users.createDM(this.id, force);
      }
      /**
       * Deletes a DM channel (if one exists) between the client and the user. Resolves with the channel if successful.
       * @returns {Promise<DMChannel>}
       */
      deleteDM() {
        return this.client.users.deleteDM(this.id);
      }
      /**
       * Checks if the user is equal to another.
       * It compares id, username, discriminator, avatar, banner, accent color, and bot flags.
       * It is recommended to compare equality by using `user.id === user2.id` unless you want to compare all properties.
       * @param {User} user User to compare with
       * @returns {boolean}
       */
      equals(user) {
        var _a, _b, _c, _d, _e, _f;
        return user && this.id === user.id && this.username === user.username && this.discriminator === user.discriminator && this.globalName === user.globalName && this.avatar === user.avatar && ((_a = this.flags) == null ? void 0 : _a.bitfield) === ((_b = user.flags) == null ? void 0 : _b.bitfield) && this.banner === user.banner && this.accentColor === user.accentColor && ((_c = this.avatarDecorationData) == null ? void 0 : _c.asset) === ((_d = user.avatarDecorationData) == null ? void 0 : _d.asset) && ((_e = this.avatarDecorationData) == null ? void 0 : _e.skuId) === ((_f = user.avatarDecorationData) == null ? void 0 : _f.skuId);
      }
      /**
       * Compares the user with an API user object
       * @param {APIUser} user The API user object to compare
       * @returns {boolean}
       * @private
       */
      _equals(user) {
        var _a, _b, _c, _d, _e;
        return user && this.id === user.id && this.username === user.username && this.discriminator === user.discriminator && this.globalName === user.global_name && this.avatar === user.avatar && ((_a = this.flags) == null ? void 0 : _a.bitfield) === user.public_flags && ("banner" in user ? this.banner === user.banner : true) && ("accent_color" in user ? this.accentColor === user.accent_color : true) && ("avatar_decoration_data" in user ? ((_b = this.avatarDecorationData) == null ? void 0 : _b.asset) === ((_c = user.avatar_decoration_data) == null ? void 0 : _c.asset) && ((_d = this.avatarDecorationData) == null ? void 0 : _d.skuId) === ((_e = user.avatar_decoration_data) == null ? void 0 : _e.sku_id) : true);
      }
      /**
       * Fetches this user.
       * @param {boolean} [force=true] Whether to skip the cache check and request the API
       * @returns {Promise<User>}
       */
      fetch(force = true) {
        return this.client.users.fetch(this.id, { force });
      }
      /**
       * Returns a user profile object for a given user ID.
       * <info>This endpoint requires one of the following:
       * - The user is a bot
       * - The user shares a mutual guild with the current user
       * - The user is a friend of the current user
       * - The user is a friend suggestion of the current user
       * - The user has an outgoing friend request to the current user</info>
       * @param {Snowflake} [guildId] The guild ID to get the user's member profile in
       * @returns {Promise<Object>}
       * @see {@link https://discord-userdoccers.vercel.app/resources/user#response-body}
       */
      getProfile(guildId) {
        return this.client.api.users(this.id).profile.get({
          query: {
            with_mutual_guilds: true,
            with_mutual_friends: true,
            with_mutual_friends_count: true,
            guild_id: guildId
          }
        });
      }
      /**
       * When concatenated with a string, this automatically returns the user's mention instead of the User object.
       * @returns {string}
       * @example
       * // Logs: Hello from <@123456789012345678>!
       * console.log(`Hello from ${user}!`);
       */
      toString() {
        return `<@${this.id}>`;
      }
      toJSON(...props) {
        const json = super.toJSON(
          {
            createdTimestamp: true,
            defaultAvatarURL: true,
            hexAccentColor: true,
            tag: true
          },
          ...props
        );
        json.avatarURL = this.avatarURL();
        json.displayAvatarURL = this.displayAvatarURL();
        json.bannerURL = this.banner ? this.bannerURL() : this.banner;
        return json;
      }
      /**
       * The function updates the note of a user and returns the updated user.
       * @param {string|null|undefined} [note=null] - The `note` parameter is the new value that you want to set for the note of the
       * user. It is an optional parameter and its default value is `null`.
       * @returns {Promise<User>} The `setNote` method is returning the `User` object.
       */
      async setNote(note = null) {
        await this.client.notes.updateNote(this.id, note);
        return this;
      }
      /**
       * The function returns the note associated with a specific client ID from a cache.
       * @type {?string} The note that corresponds to the given id.
       */
      get note() {
        return this.client.notes.cache.get(this.id);
      }
      /**
       * The voice state of this member
       * @type {VoiceState}
       * @readonly
       */
      get voice() {
        var _a, _b, _c;
        return this.client.voiceStates.cache.get(this.id) ?? ((_c = (_b = (_a = this.client.guilds.cache.find((g) => {
          var _a2, _b2;
          return (_b2 = (_a2 = g == null ? void 0 : g.voiceStates) == null ? void 0 : _a2.cache) == null ? void 0 : _b2.get(this.id);
        })) == null ? void 0 : _a.voiceStates) == null ? void 0 : _b.cache) == null ? void 0 : _c.get(this.id)) ?? new VoiceState({ client: this.client }, { user_id: this.id });
      }
      /**
       * Send Friend Request to the user
       * @type {boolean}
       * @returns {Promise<boolean>}
       */
      sendFriendRequest() {
        return this.client.relationships.sendFriendRequest({ user: this });
      }
      /**
       * Unblock / Unfriend / Cancels a friend request
       * @type {boolean}
       * @returns {Promise<boolean>}
       */
      deleteRelationship() {
        return this.client.relationships.deleteRelationship(this);
      }
      /**
       * Check relationship status (Client -> User)
       * @type {RelationshipType}
       * @readonly
       */
      get relationship() {
        const i = this.client.relationships.cache.get(this.id) ?? 0;
        return RelationshipTypes[parseInt(i)];
      }
      /**
       * Get friend nickname
       * @type {?string}
       * @readonly
       */
      get friendNickname() {
        return this.client.relationships.friendNicknames.get(this.id);
      }
    };
    TextBasedChannel.applyToClass(User);
    module2.exports = User;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/managers/BaseManager.js
var require_BaseManager = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/managers/BaseManager.js"(exports2, module2) {
    "use strict";
    var BaseManager = class {
      constructor(client) {
        Object.defineProperty(this, "client", { value: client });
      }
    };
    module2.exports = BaseManager;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/managers/DataManager.js
var require_DataManager = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/managers/DataManager.js"(exports2, module2) {
    "use strict";
    var BaseManager = require_BaseManager();
    var { Error: Error2 } = require_errors2();
    var DataManager = class extends BaseManager {
      constructor(client, holds) {
        super(client);
        Object.defineProperty(this, "holds", { value: holds });
      }
      /**
       * The cache of items for this manager.
       * @type {Collection}
       * @abstract
       */
      get cache() {
        throw new Error2("NOT_IMPLEMENTED", "get cache", this.constructor.name);
      }
      /**
       * Resolves a data entry to a data Object.
       * @param {string|Object} idOrInstance The id or instance of something in this Manager
       * @returns {?Object} An instance from this Manager
       */
      resolve(idOrInstance) {
        if (idOrInstance instanceof this.holds) return idOrInstance;
        if (typeof idOrInstance === "string") return this.cache.get(idOrInstance) ?? null;
        return null;
      }
      /**
       * Resolves a data entry to an instance id.
       * @param {string|Object} idOrInstance The id or instance of something in this Manager
       * @returns {?Snowflake}
       */
      resolveId(idOrInstance) {
        if (idOrInstance instanceof this.holds) return idOrInstance.id;
        if (typeof idOrInstance === "string") return idOrInstance;
        return null;
      }
      valueOf() {
        return this.cache;
      }
    };
    module2.exports = DataManager;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/util/RoleFlags.js
var require_RoleFlags = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/util/RoleFlags.js"(exports2, module2) {
    "use strict";
    var BitField = require_BitField();
    var RoleFlags = class extends BitField {
    };
    RoleFlags.FLAGS = {
      IN_PROMPT: 1 << 0
    };
    module2.exports = RoleFlags;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/Role.js
var require_Role = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/Role.js"(exports2) {
    "use strict";
    var process2 = require_node_process();
    var Base = require_Base();
    var { Error: Error2 } = require_errors2();
    var Permissions2 = require_Permissions();
    var RoleFlags = require_RoleFlags();
    var SnowflakeUtil = require_SnowflakeUtil();
    var deprecationEmittedForComparePositions = false;
    var deletedRoles = /* @__PURE__ */ new WeakSet();
    var deprecationEmittedForDeleted = false;
    var Role = class extends Base {
      constructor(client, data, guild) {
        super(client);
        this.guild = guild;
        this.icon = null;
        this.unicodeEmoji = null;
        if (data) this._patch(data);
      }
      _patch(data) {
        this.id = data.id;
        if ("name" in data) {
          this.name = data.name;
        }
        if ("color" in data) {
          this.color = data.color;
        }
        if ("hoist" in data) {
          this.hoist = data.hoist;
        }
        if ("position" in data) {
          this.rawPosition = data.position;
        }
        if ("permissions" in data) {
          this.permissions = new Permissions2(BigInt(data.permissions)).freeze();
        }
        if ("managed" in data) {
          this.managed = data.managed;
        }
        if ("mentionable" in data) {
          this.mentionable = data.mentionable;
        }
        if ("icon" in data) this.icon = data.icon;
        if ("unicode_emoji" in data) this.unicodeEmoji = data.unicode_emoji;
        this.tags = data.tags ? {} : null;
        if (data.tags) {
          if ("bot_id" in data.tags) {
            this.tags.botId = data.tags.bot_id;
          }
          if ("integration_id" in data.tags) {
            this.tags.integrationId = data.tags.integration_id;
          }
          if ("premium_subscriber" in data.tags) {
            this.tags.premiumSubscriberRole = true;
          }
          if ("subscription_listing_id" in data.tags) {
            this.tags.subscriptionListingId = data.tags.subscription_listing_id;
          }
          if ("available_for_purchase" in data.tags) {
            this.tags.availableForPurchase = true;
          }
          if ("guild_connections" in data.tags) {
            this.tags.guildConnections = true;
          }
        }
        if ("flags" in data) {
          this.flags = new RoleFlags(data.flags).freeze();
        } else {
          this.flags ?? (this.flags = new RoleFlags().freeze());
        }
      }
      /**
       * The timestamp the role was created at
       * @type {number}
       * @readonly
       */
      get createdTimestamp() {
        return SnowflakeUtil.timestampFrom(this.id);
      }
      /**
       * The time the role was created at
       * @type {Date}
       * @readonly
       */
      get createdAt() {
        return new Date(this.createdTimestamp);
      }
      /**
       * Whether or not the role has been deleted
       * @type {boolean}
       * @deprecated This will be removed in the next major version, see https://github.com/discordjs/discord.js/issues/7091
       */
      get deleted() {
        if (!deprecationEmittedForDeleted) {
          deprecationEmittedForDeleted = true;
          process2.emitWarning(
            "Role#deleted is deprecated, see https://github.com/discordjs/discord.js/issues/7091.",
            "DeprecationWarning"
          );
        }
        return deletedRoles.has(this);
      }
      set deleted(value) {
        if (!deprecationEmittedForDeleted) {
          deprecationEmittedForDeleted = true;
          process2.emitWarning(
            "Role#deleted is deprecated, see https://github.com/discordjs/discord.js/issues/7091.",
            "DeprecationWarning"
          );
        }
        if (value) deletedRoles.add(this);
        else deletedRoles.delete(this);
      }
      /**
       * The hexadecimal version of the role color, with a leading hashtag
       * @type {string}
       * @readonly
       */
      get hexColor() {
        return `#${this.color.toString(16).padStart(6, "0")}`;
      }
      /**
       * The cached guild members that have this role
       * @type {Collection<Snowflake, GuildMember>}
       * @readonly
       */
      get members() {
        return this.guild.members.cache.filter((m) => m.roles.cache.has(this.id));
      }
      /**
       * Whether the role is editable by the client user
       * @type {boolean}
       * @readonly
       */
      get editable() {
        if (this.managed) return false;
        const clientMember = this.guild.members.resolve(this.client.user);
        if (!clientMember.permissions.has(Permissions2.FLAGS.MANAGE_ROLES)) return false;
        return clientMember.roles.highest.comparePositionTo(this) > 0;
      }
      /**
       * The position of the role in the role manager
       * @type {number}
       * @readonly
       */
      get position() {
        let count = 0;
        for (const role of this.guild.roles.cache.values()) {
          if (this.rawPosition > role.rawPosition) count++;
          else if (this.rawPosition === role.rawPosition && BigInt(this.id) < BigInt(role.id)) count++;
        }
        return count;
      }
      /**
       * Compares this role's position to another role's.
       * @param {RoleResolvable} role Role to compare to this one
       * @returns {number} Negative number if this role's position is lower (other role's is higher),
       * positive number if this one is higher (other's is lower), 0 if equal
       * @example
       * // Compare the position of a role to another
       * const roleCompare = role.comparePositionTo(otherRole);
       * if (roleCompare >= 1) console.log(`${role.name} is higher than ${otherRole.name}`);
       */
      comparePositionTo(role) {
        return this.guild.roles.comparePositions(this, role);
      }
      /**
       * The data for a role.
       * @typedef {Object} RoleData
       * @property {string} [name] The name of the role
       * @property {ColorResolvable} [color] The color of the role, either a hex string or a base 10 number
       * @property {boolean} [hoist] Whether or not the role should be hoisted
       * @property {number} [position] The position of the role
       * @property {PermissionResolvable} [permissions] The permissions of the role
       * @property {boolean} [mentionable] Whether or not the role should be mentionable
       * @property {?(BufferResolvable|Base64Resolvable|EmojiResolvable)} [icon] The icon for the role
       * <warn>The `EmojiResolvable` should belong to the same guild as the role.
       * If not, pass the emoji's URL directly</warn>
       * @property {?string} [unicodeEmoji] The unicode emoji for the role
       */
      /**
       * Edits the role.
       * @param {RoleData} data The new data for the role
       * @param {string} [reason] Reason for editing this role
       * @returns {Promise<Role>}
       * @example
       * // Edit a role
       * role.edit({ name: 'new role' })
       *   .then(updated => console.log(`Edited role name to ${updated.name}`))
       *   .catch(console.error);
       */
      edit(data, reason) {
        return this.guild.roles.edit(this, data, reason);
      }
      /**
       * Returns `channel.permissionsFor(role)`. Returns permissions for a role in a guild channel,
       * taking into account permission overwrites.
       * @param {GuildChannel|Snowflake} channel The guild channel to use as context
       * @param {boolean} [checkAdmin=true] Whether having `ADMINISTRATOR` will return all permissions
       * @returns {Readonly<Permissions>}
       */
      permissionsIn(channel, checkAdmin = true) {
        channel = this.guild.channels.resolve(channel);
        if (!channel) throw new Error2("GUILD_CHANNEL_RESOLVE");
        return channel.rolePermissions(this, checkAdmin);
      }
      /**
       * Sets a new name for the role.
       * @param {string} name The new name of the role
       * @param {string} [reason] Reason for changing the role's name
       * @returns {Promise<Role>}
       * @example
       * // Set the name of the role
       * role.setName('new role')
       *   .then(updated => console.log(`Updated role name to ${updated.name}`))
       *   .catch(console.error);
       */
      setName(name, reason) {
        return this.edit({ name }, reason);
      }
      /**
       * Sets a new color for the role.
       * @param {ColorResolvable} color The color of the role
       * @param {string} [reason] Reason for changing the role's color
       * @returns {Promise<Role>}
       * @example
       * // Set the color of a role
       * role.setColor('#FF0000')
       *   .then(updated => console.log(`Set color of role to ${updated.color}`))
       *   .catch(console.error);
       */
      setColor(color, reason) {
        return this.edit({ color }, reason);
      }
      /**
       * Sets whether or not the role should be hoisted.
       * @param {boolean} [hoist=true] Whether or not to hoist the role
       * @param {string} [reason] Reason for setting whether or not the role should be hoisted
       * @returns {Promise<Role>}
       * @example
       * // Set the hoist of the role
       * role.setHoist(true)
       *   .then(updated => console.log(`Role hoisted: ${updated.hoist}`))
       *   .catch(console.error);
       */
      setHoist(hoist = true, reason) {
        return this.edit({ hoist }, reason);
      }
      /**
       * Sets the permissions of the role.
       * @param {PermissionResolvable} permissions The permissions of the role
       * @param {string} [reason] Reason for changing the role's permissions
       * @returns {Promise<Role>}
       * @example
       * // Set the permissions of the role
       * role.setPermissions([Permissions.FLAGS.KICK_MEMBERS, Permissions.FLAGS.BAN_MEMBERS])
       *   .then(updated => console.log(`Updated permissions to ${updated.permissions.bitfield}`))
       *   .catch(console.error);
       * @example
       * // Remove all permissions from a role
       * role.setPermissions(0n)
       *   .then(updated => console.log(`Updated permissions to ${updated.permissions.bitfield}`))
       *   .catch(console.error);
       */
      setPermissions(permissions, reason) {
        return this.edit({ permissions }, reason);
      }
      /**
       * Sets whether this role is mentionable.
       * @param {boolean} [mentionable=true] Whether this role should be mentionable
       * @param {string} [reason] Reason for setting whether or not this role should be mentionable
       * @returns {Promise<Role>}
       * @example
       * // Make the role mentionable
       * role.setMentionable(true)
       *   .then(updated => console.log(`Role updated ${updated.name}`))
       *   .catch(console.error);
       */
      setMentionable(mentionable = true, reason) {
        return this.edit({ mentionable }, reason);
      }
      /**
       * Sets a new icon for the role.
       * @param {?(BufferResolvable|Base64Resolvable|EmojiResolvable)} icon The icon for the role
       * <warn>The `EmojiResolvable` should belong to the same guild as the role.
       * If not, pass the emoji's URL directly</warn>
       * @param {string} [reason] Reason for changing the role's icon
       * @returns {Promise<Role>}
       */
      setIcon(icon, reason) {
        return this.edit({ icon }, reason);
      }
      /**
       * Sets a new unicode emoji for the role.
       * @param {?string} unicodeEmoji The new unicode emoji for the role
       * @param {string} [reason] Reason for changing the role's unicode emoji
       * @returns {Promise<Role>}
       * @example
       * // Set a new unicode emoji for the role
       * role.setUnicodeEmoji('🤖')
       *   .then(updated => console.log(`Set unicode emoji for the role to ${updated.unicodeEmoji}`))
       *   .catch(console.error);
       */
      setUnicodeEmoji(unicodeEmoji, reason) {
        return this.edit({ unicodeEmoji }, reason);
      }
      /**
       * Options used to set the position of a role.
       * @typedef {Object} SetRolePositionOptions
       * @property {boolean} [relative=false] Whether to change the position relative to its current value or not
       * @property {string} [reason] The reason for changing the position
       */
      /**
       * Sets the new position of the role.
       * @param {number} position The new position for the role
       * @param {SetRolePositionOptions} [options] Options for setting the position
       * @returns {Promise<Role>}
       * @example
       * // Set the position of the role
       * role.setPosition(1)
       *   .then(updated => console.log(`Role position: ${updated.position}`))
       *   .catch(console.error);
       */
      setPosition(position, options = {}) {
        return this.guild.roles.setPosition(this, position, options);
      }
      /**
       * Deletes the role.
       * @param {string} [reason] Reason for deleting this role
       * @returns {Promise<Role>}
       * @example
       * // Delete a role
       * role.delete('The role needed to go')
       *   .then(deleted => console.log(`Deleted role ${deleted.name}`))
       *   .catch(console.error);
       */
      async delete(reason) {
        await this.guild.roles.delete(this.id, reason);
        return this;
      }
      /**
       * A link to the role's icon
       * @param {StaticImageURLOptions} [options={}] Options for the image URL
       * @returns {?string}
       */
      iconURL({ format, size } = {}) {
        if (!this.icon) return null;
        return this.client.rest.cdn.RoleIcon(this.id, this.icon, format, size);
      }
      /**
       * Whether this role equals another role. It compares all properties, so for most operations
       * it is advisable to just compare `role.id === role2.id` as it is much faster and is often
       * what most users need.
       * @param {Role} role Role to compare with
       * @returns {boolean}
       */
      equals(role) {
        return role && this.id === role.id && this.name === role.name && this.color === role.color && this.hoist === role.hoist && this.position === role.position && this.permissions.bitfield === role.permissions.bitfield && this.managed === role.managed && this.icon === role.icon && this.unicodeEmoji === role.unicodeEmoji;
      }
      /**
       * When concatenated with a string, this automatically returns the role's mention instead of the Role object.
       * @returns {string}
       * @example
       * // Logs: Role: <@&123456789012345678>
       * console.log(`Role: ${role}`);
       */
      toString() {
        if (this.id === this.guild.id) return "@everyone";
        return `<@&${this.id}>`;
      }
      toJSON() {
        return {
          ...super.toJSON({ createdTimestamp: true }),
          permissions: this.permissions.toJSON()
        };
      }
      /**
       * Compares the positions of two roles.
       * @param {Role} role1 First role to compare
       * @param {Role} role2 Second role to compare
       * @returns {number} Negative number if the first role's position is lower (second role's is higher),
       * positive number if the first's is higher (second's is lower), 0 if equal
       * @deprecated Use {@link RoleManager#comparePositions} instead.
       */
      static comparePositions(role1, role2) {
        if (!deprecationEmittedForComparePositions) {
          process2.emitWarning(
            "The Role.comparePositions method is deprecated. Use RoleManager#comparePositions instead.",
            "DeprecationWarning"
          );
          deprecationEmittedForComparePositions = true;
        }
        return role1.guild.roles.comparePositions(role1, role2);
      }
    };
    exports2.Role = Role;
    exports2.deletedRoles = deletedRoles;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/managers/GuildMemberRoleManager.js
var require_GuildMemberRoleManager = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/managers/GuildMemberRoleManager.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var DataManager = require_DataManager();
    var { TypeError: TypeError2 } = require_errors2();
    var { Role } = require_Role();
    var GuildMemberRoleManager = class extends DataManager {
      constructor(member) {
        super(member.client, Role);
        this.member = member;
        this.guild = member.guild;
      }
      /**
       * The roles of this member
       * @type {Collection<Snowflake, Role>}
       * @readonly
       */
      get cache() {
        const everyone = this.guild.roles.everyone;
        return this.guild.roles.cache.filter((role) => this.member._roles.includes(role.id)).set(everyone.id, everyone);
      }
      /**
       * The role of the member used to hoist them in a separate category in the users list
       * @type {?Role}
       * @readonly
       */
      get hoist() {
        const hoistedRoles = this.cache.filter((role) => role.hoist);
        if (!hoistedRoles.size) return null;
        return hoistedRoles.reduce((prev, role) => role.comparePositionTo(prev) > 0 ? role : prev);
      }
      /**
       * The role of the member used to set their role icon
       * @type {?Role}
       * @readonly
       */
      get icon() {
        const iconRoles = this.cache.filter((role) => role.icon || role.unicodeEmoji);
        if (!iconRoles.size) return null;
        return iconRoles.reduce((prev, role) => role.comparePositionTo(prev) > 0 ? role : prev);
      }
      /**
       * The role of the member used to set their color
       * @type {?Role}
       * @readonly
       */
      get color() {
        const coloredRoles = this.cache.filter((role) => role.color);
        if (!coloredRoles.size) return null;
        return coloredRoles.reduce((prev, role) => role.comparePositionTo(prev) > 0 ? role : prev);
      }
      /**
       * The role of the member with the highest position
       * @type {Role}
       * @readonly
       */
      get highest() {
        return this.cache.reduce((prev, role) => role.comparePositionTo(prev) > 0 ? role : prev, this.cache.first());
      }
      /**
       * The premium subscriber role of the guild, if present on the member
       * @type {?Role}
       * @readonly
       */
      get premiumSubscriberRole() {
        return this.cache.find((role) => {
          var _a;
          return (_a = role.tags) == null ? void 0 : _a.premiumSubscriberRole;
        }) ?? null;
      }
      /**
       * The managed role this member created when joining the guild, if any
       * <info>Only ever available on bots</info>
       * @type {?Role}
       * @readonly
       */
      get botRole() {
        if (!this.member.user.bot) return null;
        return this.cache.find((role) => {
          var _a;
          return ((_a = role.tags) == null ? void 0 : _a.botId) === this.member.user.id;
        }) ?? null;
      }
      /**
       * Adds a role (or multiple roles) to the member.
       * @param {RoleResolvable|RoleResolvable[]|Collection<Snowflake, Role>} roleOrRoles The role or roles to add
       * @param {string} [reason] Reason for adding the role(s)
       * @returns {Promise<GuildMember>}
       */
      async add(roleOrRoles, reason) {
        if (roleOrRoles instanceof Collection2 || Array.isArray(roleOrRoles)) {
          const resolvedRoles = [];
          for (const role of roleOrRoles.values()) {
            const resolvedRole = this.guild.roles.resolveId(role);
            if (!resolvedRole) throw new TypeError2("INVALID_ELEMENT", "Array or Collection", "roles", role);
            resolvedRoles.push(resolvedRole);
          }
          const newRoles = [...new Set(resolvedRoles.concat(...this.cache.keys()))];
          return this.set(newRoles, reason);
        } else {
          roleOrRoles = this.guild.roles.resolveId(roleOrRoles);
          if (roleOrRoles === null) {
            throw new TypeError2("INVALID_TYPE", "roles", "Role, Snowflake or Array or Collection of Roles or Snowflakes");
          }
          await this.client.api.guilds[this.guild.id].members[this.member.id].roles[roleOrRoles].put({ reason });
          const clone = this.member._clone();
          clone._roles = [...this.cache.keys(), roleOrRoles];
          return clone;
        }
      }
      /**
       * Removes a role (or multiple roles) from the member.
       * @param {RoleResolvable|RoleResolvable[]|Collection<Snowflake, Role>} roleOrRoles The role or roles to remove
       * @param {string} [reason] Reason for removing the role(s)
       * @returns {Promise<GuildMember>}
       */
      async remove(roleOrRoles, reason) {
        if (roleOrRoles instanceof Collection2 || Array.isArray(roleOrRoles)) {
          const resolvedRoles = [];
          for (const role of roleOrRoles.values()) {
            const resolvedRole = this.guild.roles.resolveId(role);
            if (!resolvedRole) throw new TypeError2("INVALID_ELEMENT", "Array or Collection", "roles", role);
            resolvedRoles.push(resolvedRole);
          }
          const newRoles = this.cache.filter((role) => !resolvedRoles.includes(role.id));
          return this.set(newRoles, reason);
        } else {
          roleOrRoles = this.guild.roles.resolveId(roleOrRoles);
          if (roleOrRoles === null) {
            throw new TypeError2("INVALID_TYPE", "roles", "Role, Snowflake or Array or Collection of Roles or Snowflakes");
          }
          await this.client.api.guilds[this.guild.id].members[this.member.id].roles[roleOrRoles].delete({ reason });
          const clone = this.member._clone();
          const newRoles = this.cache.filter((role) => role.id !== roleOrRoles);
          clone._roles = [...newRoles.keys()];
          return clone;
        }
      }
      /**
       * Sets the roles applied to the member.
       * @param {Collection<Snowflake, Role>|RoleResolvable[]} roles The roles or role ids to apply
       * @param {string} [reason] Reason for applying the roles
       * @returns {Promise<GuildMember>}
       * @example
       * // Set the member's roles to a single role
       * guildMember.roles.set(['391156570408615936'])
       *   .then(console.log)
       *   .catch(console.error);
       * @example
       * // Remove all the roles from a member
       * guildMember.roles.set([])
       *   .then(member => console.log(`Member roles is now of ${member.roles.cache.size} size`))
       *   .catch(console.error);
       */
      set(roles, reason) {
        return this.member.edit({ roles }, reason);
      }
      clone() {
        const clone = new this.constructor(this.member);
        clone.member._roles = [...this.cache.keys()];
        return clone;
      }
    };
    module2.exports = GuildMemberRoleManager;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/util/GuildMemberFlags.js
var require_GuildMemberFlags = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/util/GuildMemberFlags.js"(exports2, module2) {
    "use strict";
    var BitField = require_BitField();
    var GuildMemberFlags = class extends BitField {
    };
    GuildMemberFlags.FLAGS = {
      DID_REJOIN: 1 << 0,
      COMPLETED_ONBOARDING: 1 << 1,
      BYPASSES_VERIFICATION: 1 << 2,
      STARTED_ONBOARDING: 1 << 3
    };
    module2.exports = GuildMemberFlags;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/GuildMember.js
var require_GuildMember = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/GuildMember.js"(exports2) {
    "use strict";
    var process2 = require_node_process();
    var Base = require_Base();
    var VoiceState = require_VoiceState();
    var TextBasedChannel = require_TextBasedChannel();
    var { Error: Error2 } = require_errors2();
    var GuildMemberRoleManager = require_GuildMemberRoleManager();
    var GuildMemberFlags = require_GuildMemberFlags();
    var Permissions2 = require_Permissions();
    var deletedGuildMembers = /* @__PURE__ */ new WeakSet();
    var deprecationEmittedForDeleted = false;
    var GuildMember = class extends Base {
      constructor(client, data, guild) {
        super(client);
        this.guild = guild;
        this.joinedTimestamp = null;
        this.premiumSinceTimestamp = null;
        this.nickname = null;
        this.pending = false;
        this.communicationDisabledUntilTimestamp = null;
        this._roles = [];
        if (data) this._patch(data);
      }
      _patch(data) {
        if ("user" in data) {
          this.user = this.client.users._add(data.user, true);
        }
        if ("nick" in data) this.nickname = data.nick;
        if ("avatar" in data) {
          this.avatar = data.avatar;
        } else if (typeof this.avatar !== "string") {
          this.avatar = null;
        }
        if ("joined_at" in data) this.joinedTimestamp = new Date(data.joined_at).getTime();
        if ("premium_since" in data) {
          this.premiumSinceTimestamp = data.premium_since ? new Date(data.premium_since).getTime() : null;
        }
        if ("roles" in data) this._roles = data.roles;
        this.pending = data.pending ?? false;
        if ("communication_disabled_until" in data) {
          this.communicationDisabledUntilTimestamp = data.communication_disabled_until && Date.parse(data.communication_disabled_until);
        }
        if ("flags" in data) {
          this.flags = new GuildMemberFlags(data.flags).freeze();
        } else {
          this.flags ?? (this.flags = new GuildMemberFlags().freeze());
        }
      }
      _clone() {
        const clone = super._clone();
        clone._roles = this._roles.slice();
        return clone;
      }
      /**
       * Whether or not the structure has been deleted
       * @type {boolean}
       * @deprecated This will be removed in the next major version, see https://github.com/discordjs/discord.js/issues/7091
       */
      get deleted() {
        if (!deprecationEmittedForDeleted) {
          deprecationEmittedForDeleted = true;
          process2.emitWarning(
            "GuildMember#deleted is deprecated, see https://github.com/discordjs/discord.js/issues/7091.",
            "DeprecationWarning"
          );
        }
        return deletedGuildMembers.has(this);
      }
      set deleted(value) {
        if (!deprecationEmittedForDeleted) {
          deprecationEmittedForDeleted = true;
          process2.emitWarning(
            "GuildMember#deleted is deprecated, see https://github.com/discordjs/discord.js/issues/7091.",
            "DeprecationWarning"
          );
        }
        if (value) deletedGuildMembers.add(this);
        else deletedGuildMembers.delete(this);
      }
      /**
       * Whether this GuildMember is a partial
       * @type {boolean}
       * @readonly
       */
      get partial() {
        return this.joinedTimestamp === null;
      }
      /**
       * A manager for the roles belonging to this member
       * @type {GuildMemberRoleManager}
       * @readonly
       */
      get roles() {
        return new GuildMemberRoleManager(this);
      }
      /**
       * The voice state of this member
       * @type {VoiceState}
       * @readonly
       */
      get voice() {
        return this.guild.voiceStates.cache.get(this.id) ?? new VoiceState(this.guild, { user_id: this.id });
      }
      /**
       * A link to the member's guild avatar.
       * @param {ImageURLOptions} [options={}] Options for the Image URL
       * @returns {?string}
       */
      avatarURL({ format, size, dynamic } = {}) {
        if (!this.avatar) return null;
        return this.client.rest.cdn.GuildMemberAvatar(this.guild.id, this.id, this.avatar, format, size, dynamic);
      }
      /**
       * A link to the member's guild avatar if they have one.
       * Otherwise, a link to their {@link User#displayAvatarURL} will be returned.
       * @param {ImageURLOptions} [options={}] Options for the Image URL
       * @returns {string}
       */
      displayAvatarURL(options) {
        return this.avatarURL(options) ?? this.user.displayAvatarURL(options);
      }
      /**
       * The time this member joined the guild
       * @type {?Date}
       * @readonly
       */
      get joinedAt() {
        return this.joinedTimestamp ? new Date(this.joinedTimestamp) : null;
      }
      /**
       * The time this member's timeout will be removed
       * @type {?Date}
       * @readonly
       */
      get communicationDisabledUntil() {
        return this.communicationDisabledUntilTimestamp && new Date(this.communicationDisabledUntilTimestamp);
      }
      /**
       * The last time this member started boosting the guild
       * @type {?Date}
       * @readonly
       */
      get premiumSince() {
        return this.premiumSinceTimestamp ? new Date(this.premiumSinceTimestamp) : null;
      }
      /**
       * The presence of this guild member
       * @type {?Presence}
       * @readonly
       */
      get presence() {
        return this.guild.presences.resolve(this.id);
      }
      /**
       * The displayed color of this member in base 10
       * @type {number}
       * @readonly
       */
      get displayColor() {
        var _a;
        return ((_a = this.roles.color) == null ? void 0 : _a.color) ?? 0;
      }
      /**
       * The displayed color of this member in hexadecimal
       * @type {string}
       * @readonly
       */
      get displayHexColor() {
        var _a;
        return ((_a = this.roles.color) == null ? void 0 : _a.hexColor) ?? "#000000";
      }
      /**
       * The member's id
       * @type {Snowflake}
       * @readonly
       */
      get id() {
        return this.user.id;
      }
      /**
       * The nickname of this member, or their user display name if they don't have one
       * @type {?string}
       * @readonly
       */
      get displayName() {
        return this.nickname ?? this.user.displayName;
      }
      /**
       * The overall set of permissions for this member, taking only roles and owner status into account
       * @type {Readonly<Permissions>}
       * @readonly
       */
      get permissions() {
        if (this.user.id === this.guild.ownerId) return new Permissions2(Permissions2.ALL).freeze();
        return new Permissions2(this.roles.cache.map((role) => role.permissions)).freeze();
      }
      /**
       * Whether the client user is above this user in the hierarchy, according to role position and guild ownership.
       * This is a prerequisite for many moderative actions.
       * @type {boolean}
       * @readonly
       */
      get manageable() {
        if (this.user.id === this.guild.ownerId) return false;
        if (this.user.id === this.client.user.id) return false;
        if (this.client.user.id === this.guild.ownerId) return true;
        if (!this.guild.members.me) throw new Error2("GUILD_UNCACHED_ME");
        return this.guild.members.me.roles.highest.comparePositionTo(this.roles.highest) > 0;
      }
      /**
       * Whether this member is kickable by the client user
       * @type {boolean}
       * @readonly
       */
      get kickable() {
        return this.manageable && this.guild.members.me.permissions.has(Permissions2.FLAGS.KICK_MEMBERS);
      }
      /**
       * Whether this member is bannable by the client user
       * @type {boolean}
       * @readonly
       */
      get bannable() {
        return this.manageable && this.guild.members.me.permissions.has(Permissions2.FLAGS.BAN_MEMBERS);
      }
      /**
       * Whether this member is moderatable by the client user
       * @type {boolean}
       * @readonly
       */
      get moderatable() {
        var _a;
        return !this.permissions.has(Permissions2.FLAGS.ADMINISTRATOR) && this.manageable && (((_a = this.guild.members.me) == null ? void 0 : _a.permissions.has(Permissions2.FLAGS.MODERATE_MEMBERS)) ?? false);
      }
      /**
       * Whether this member is currently timed out
       * @returns {boolean}
       */
      isCommunicationDisabled() {
        return this.communicationDisabledUntilTimestamp > Date.now();
      }
      /**
       * Returns `channel.permissionsFor(guildMember)`. Returns permissions for a member in a guild channel,
       * taking into account roles and permission overwrites.
       * @param {GuildChannelResolvable} channel The guild channel to use as context
       * @returns {Readonly<Permissions>}
       */
      permissionsIn(channel) {
        channel = this.guild.channels.resolve(channel);
        if (!channel) throw new Error2("GUILD_CHANNEL_RESOLVE");
        return channel.permissionsFor(this);
      }
      /**
       * Edits this member.
       * @param {GuildMemberEditData} data The data to edit the member with
       * @param {string} [reason] Reason for editing this user
       * @returns {Promise<GuildMember>}
       */
      edit(data, reason) {
        return this.guild.members.edit(this, data, reason);
      }
      /**
       * Sets the nickname for this member.
       * @param {?string} nick The nickname for the guild member, or `null` if you want to reset their nickname
       * @param {string} [reason] Reason for setting the nickname
       * @returns {Promise<GuildMember>}
       * @example
       * // Set a nickname for a guild member
       * guildMember.setNickname('cool nickname', 'Needed a new nickname')
       *   .then(member => console.log(`Set nickname of ${member.user.username}`))
       *   .catch(console.error);
       * @example
       * // Remove a nickname for a guild member
       * guildMember.setNickname(null, 'No nicknames allowed!')
       *   .then(member => console.log(`Removed nickname for ${member.user.username}`))
       *   .catch(console.error);
       */
      setNickname(nick, reason) {
        return this.edit({ nick }, reason);
      }
      /**
       * Sets the flags for this member.
       * @param {GuildMemberFlagsResolvable} flags The flags to set
       * @param {string} [reason] Reason for setting the flags
       * @returns {Promise<GuildMember>}
       */
      setFlags(flags, reason) {
        return this.edit({ flags, reason });
      }
      /**
       * Creates a DM channel between the client and this member.
       * @param {boolean} [force=false] Whether to skip the cache check and request the API
       * @returns {Promise<DMChannel>}
       */
      createDM(force = false) {
        return this.user.createDM(force);
      }
      /**
       * Deletes any DMs with this member.
       * @returns {Promise<DMChannel>}
       */
      deleteDM() {
        return this.user.deleteDM();
      }
      /**
       * Kicks this member from the guild.
       * @param {string} [reason] Reason for kicking user
       * @returns {Promise<GuildMember>}
       */
      kick(reason) {
        return this.guild.members.kick(this, reason);
      }
      /**
       * Bans this guild member.
       * @param {BanOptions} [options] Options for the ban
       * @returns {Promise<GuildMember>}
       * @example
       * // Ban a guild member, deleting a week's worth of messages
       * guildMember.ban({ deleteMessageSeconds: 60 * 60 * 24 * 7, reason: 'They deserved it' })
       *   .then(console.log)
       *   .catch(console.error);
       */
      ban(options) {
        return this.guild.bans.create(this, options);
      }
      /**
       * Times this guild member out.
       * @param {DateResolvable|null} communicationDisabledUntil The date or timestamp
       * for the member's communication to be disabled until. Provide `null` to remove the timeout.
       * @param {string} [reason] The reason for this timeout.
       * @returns {Promise<GuildMember>}
       * @example
       * // Time a guild member out for 5 minutes
       * guildMember.disableCommunicationUntil(Date.now() + (5 * 60 * 1000), 'They deserved it')
       *   .then(console.log)
       *   .catch(console.error);
       * @example
       * // Remove the timeout of a guild member
       * guildMember.disableCommunicationUntil(null)
       *   .then(member => console.log(`Removed timeout for ${member.displayName}`))
       *   .catch(console.error);
       */
      disableCommunicationUntil(communicationDisabledUntil, reason) {
        return this.edit({ communicationDisabledUntil }, reason);
      }
      /**
       * Times this guild member out.
       * @param {number|null} timeout The time in milliseconds
       * for the member's communication to be disabled until. Provide `null` to remove the timeout.
       * @param {string} [reason] The reason for this timeout.
       * @returns {Promise<GuildMember>}
       * @example
       * // Time a guild member out for 5 minutes
       * guildMember.timeout(5 * 60 * 1000, 'They deserved it')
       *   .then(console.log)
       *   .catch(console.error);
       */
      timeout(timeout, reason) {
        return this.disableCommunicationUntil(timeout && Date.now() + timeout, reason);
      }
      /**
       * Fetches this GuildMember.
       * @param {boolean} [force=true] Whether to skip the cache check and request the API
       * @returns {Promise<GuildMember>}
       */
      fetch(force = true) {
        return this.guild.members.fetch({ user: this.id, cache: true, force });
      }
      /**
       * Whether this guild member equals another guild member. It compares all properties, so for most
       * comparison it is advisable to just compare `member.id === member2.id` as it is significantly faster
       * and is often what most users need.
       * @param {GuildMember} member The member to compare with
       * @returns {boolean}
       */
      equals(member) {
        return member instanceof this.constructor && this.id === member.id && this.partial === member.partial && this.guild.id === member.guild.id && this.joinedTimestamp === member.joinedTimestamp && this.nickname === member.nickname && this.avatar === member.avatar && this.pending === member.pending && this.communicationDisabledUntilTimestamp === member.communicationDisabledUntilTimestamp && this.flags.equals(member.flags) && (this._roles === member._roles || this._roles.length === member._roles.length && this._roles.every((role, i) => role === member._roles[i]));
      }
      /**
       * When concatenated with a string, this automatically returns the user's mention instead of the GuildMember object.
       * @returns {string}
       * @example
       * // Logs: Hello from <@123456789012345678>!
       * console.log(`Hello from ${member}!`);
       */
      toString() {
        return `<@${this.nickname ? "!" : ""}${this.user.id}>`;
      }
      toJSON() {
        const json = super.toJSON({
          guild: "guildId",
          user: "userId",
          displayName: true,
          roles: true
        });
        json.avatarURL = this.avatarURL();
        json.displayAvatarURL = this.displayAvatarURL();
        return json;
      }
      /**
       * Sets the guild avatar of the logged in client.
       * @param {?(BufferResolvable|Base64Resolvable)} avatar The new avatar
       * @returns {Promise<GuildMember>}
       */
      setAvatar(avatar) {
        return this.edit({ avatar });
      }
      /**
       * Sets the guild banner of the logged in client.
       * @param {?(BufferResolvable|Base64Resolvable)} banner The new banner
       * @returns {Promise<GuildMember>}
       */
      setBanner(banner) {
        return this.edit({ banner });
      }
      /**
       * Set Guild About me
       * @param {string | null} bio Bio to set
       * @returns {Promise<GuildMember>}
       */
      setAboutMe(bio = null) {
        return this.edit({ bio });
      }
    };
    TextBasedChannel.applyToClass(GuildMember);
    exports2.GuildMember = GuildMember;
    exports2.deletedGuildMembers = deletedGuildMembers;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/util/AttachmentFlags.js
var require_AttachmentFlags = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/util/AttachmentFlags.js"(exports2, module2) {
    "use strict";
    var BitField = require_BitField();
    var AttachmentFlags = class extends BitField {
    };
    AttachmentFlags.FLAGS = {
      IS_REMIX: 1 << 2
    };
    module2.exports = AttachmentFlags;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/MessageAttachment.js
var require_MessageAttachment = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/MessageAttachment.js"(exports2, module2) {
    "use strict";
    var AttachmentFlags = require_AttachmentFlags();
    var Util = require_Util();
    var MessageAttachment = class {
      /**
       * @param {BufferResolvable|Stream} attachment The file
       * @param {string} [name=null] The name of the file, if any
       * @param {APIAttachment} [data] Extra data
       */
      constructor(attachment, name = null, data) {
        this.attachment = attachment;
        this.name = name;
        if (data) this._patch(data);
      }
      /**
       * Sets the description of this attachment.
       * @param {string} description The description of the file
       * @returns {MessageAttachment} This attachment
       */
      setDescription(description) {
        this.description = description;
        return this;
      }
      /**
       * Sets the file of this attachment.
       * @param {BufferResolvable|Stream} attachment The file
       * @param {string} [name=null] The name of the file, if any
       * @returns {MessageAttachment} This attachment
       */
      setFile(attachment, name = null) {
        this.attachment = attachment;
        this.name = name;
        return this;
      }
      /**
       * Sets the name of this attachment.
       * @param {string} name The name of the file
       * @returns {MessageAttachment} This attachment
       */
      setName(name) {
        this.name = name;
        return this;
      }
      /**
       * Sets whether this attachment is a spoiler
       * @param {boolean} [spoiler=true] Whether the attachment should be marked as a spoiler
       * @returns {MessageAttachment} This attachment
       */
      setSpoiler(spoiler = true) {
        if (spoiler === this.spoiler) return this;
        if (!spoiler) {
          while (this.spoiler) {
            this.name = this.name.slice("SPOILER_".length);
          }
          return this;
        }
        this.name = `SPOILER_${this.name}`;
        return this;
      }
      _patch(data) {
        this.id = data.id;
        if ("size" in data) {
          this.size = data.size;
        }
        if ("url" in data) {
          this.url = data.url;
        }
        if ("proxy_url" in data) {
          this.proxyURL = data.proxy_url;
        }
        if ("height" in data) {
          this.height = data.height;
        } else {
          this.height ?? (this.height = null);
        }
        if ("width" in data) {
          this.width = data.width;
        } else {
          this.width ?? (this.width = null);
        }
        if ("content_type" in data) {
          this.contentType = data.content_type;
        } else {
          this.contentType ?? (this.contentType = null);
        }
        if ("description" in data) {
          this.description = data.description;
        } else {
          this.description ?? (this.description = null);
        }
        this.ephemeral = data.ephemeral ?? false;
        if ("duration_secs" in data) {
          this.duration = data.duration_secs;
        } else {
          this.duration ?? (this.duration = null);
        }
        if ("waveform" in data) {
          this.waveform = data.waveform;
        } else {
          this.waveform ?? (this.waveform = null);
        }
        if ("flags" in data) {
          this.flags = new AttachmentFlags(data.flags).freeze();
        } else {
          this.flags ?? (this.flags = new AttachmentFlags().freeze());
        }
        if ("title" in data) {
          this.title = data.title;
        } else {
          this.title ?? (this.title = null);
        }
      }
      /**
       * Whether or not this attachment has been marked as a spoiler
       * @type {boolean}
       * @readonly
       */
      get spoiler() {
        return Util.basename(this.url ?? this.name).startsWith("SPOILER_");
      }
      toJSON() {
        return Util.flatten(this);
      }
    };
    module2.exports = MessageAttachment;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/MessageMentions.js
var require_MessageMentions = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/MessageMentions.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var { ChannelTypes } = require_Constants();
    var Util = require_Util();
    var MessageMentions = class {
      constructor(message, users, roles, everyone, crosspostedChannels, repliedUser) {
        Object.defineProperty(this, "client", { value: message.client });
        Object.defineProperty(this, "guild", { value: message.guild });
        Object.defineProperty(this, "_content", { value: message.content });
        this.everyone = Boolean(everyone);
        if (users) {
          if (users instanceof Collection2) {
            this.users = new Collection2(users);
          } else {
            this.users = new Collection2();
            for (const mention of users) {
              if (mention.member && message.guild) {
                message.guild.members._add(Object.assign(mention.member, { user: mention }));
              }
              const user = message.client.users._add(mention);
              this.users.set(user.id, user);
            }
          }
        } else {
          this.users = new Collection2();
        }
        if (roles instanceof Collection2) {
          this.roles = new Collection2(roles);
        } else if (roles) {
          this.roles = new Collection2();
          const guild = message.guild;
          if (guild) {
            for (const mention of roles) {
              const role = guild.roles.cache.get(mention);
              if (role) this.roles.set(role.id, role);
            }
          }
        } else {
          this.roles = new Collection2();
        }
        this._members = null;
        this._channels = null;
        this._parsedUsers = null;
        if (crosspostedChannels) {
          if (crosspostedChannels instanceof Collection2) {
            this.crosspostedChannels = new Collection2(crosspostedChannels);
          } else {
            this.crosspostedChannels = new Collection2();
            const channelTypes = Object.keys(ChannelTypes);
            for (const d of crosspostedChannels) {
              const type = channelTypes[d.type];
              this.crosspostedChannels.set(d.id, {
                channelId: d.id,
                guildId: d.guild_id,
                type: type ?? "UNKNOWN",
                name: d.name
              });
            }
          }
        } else {
          this.crosspostedChannels = new Collection2();
        }
        this.repliedUser = repliedUser ? this.client.users._add(repliedUser) : null;
      }
      /**
       * Any members that were mentioned (only in {@link Guild}s)
       * <info>Order as received from the API, not as they appear in the message content</info>
       * @type {?Collection<Snowflake, GuildMember>}
       * @readonly
       */
      get members() {
        if (this._members) return this._members;
        if (!this.guild) return null;
        this._members = new Collection2();
        this.users.forEach((user) => {
          const member = this.guild.members.resolve(user);
          if (member) this._members.set(member.user.id, member);
        });
        return this._members;
      }
      /**
       * Any channels that were mentioned
       * <info>Order as they appear first in the message content</info>
       * @type {Collection<Snowflake, Channel>}
       * @readonly
       */
      get channels() {
        if (this._channels) return this._channels;
        this._channels = new Collection2();
        let matches;
        while ((matches = this.constructor.CHANNELS_PATTERN.exec(this._content)) !== null) {
          const chan = this.client.channels.cache.get(matches[1]);
          if (chan) this._channels.set(chan.id, chan);
        }
        return this._channels;
      }
      /**
       * Any user mentions that were included in the message content
       * <info>Order as they appear first in the message content</info>
       * @type {Collection<Snowflake, User>}
       * @readonly
       */
      get parsedUsers() {
        if (this._parsedUsers) return this._parsedUsers;
        this._parsedUsers = new Collection2();
        let matches;
        while ((matches = this.constructor.USERS_PATTERN.exec(this._content)) !== null) {
          const user = this.client.users.cache.get(matches[1]);
          if (user) this._parsedUsers.set(user.id, user);
        }
        return this._parsedUsers;
      }
      /**
       * Options used to check for a mention.
       * @typedef {Object} MessageMentionsHasOptions
       * @property {boolean} [ignoreDirect=false] Whether to ignore direct mentions to the item
       * @property {boolean} [ignoreRoles=false] Whether to ignore role mentions to a guild member
       * @property {boolean} [ignoreRepliedUser=false] Whether to ignore replied user mention to an user
       * @property {boolean} [ignoreEveryone=false] Whether to ignore `@everyone`/`@here` mentions
       */
      /**
       * Checks if a user, guild member, thread member, role, or channel is mentioned.
       * Takes into account user mentions, role mentions, channel mentions,
       * replied user mention, and `@everyone`/`@here` mentions.
       * @param {UserResolvable|RoleResolvable|ChannelResolvable} data The User/Role/Channel to check for
       * @param {MessageMentionsHasOptions} [options] The options for the check
       * @returns {boolean}
       */
      has(data, { ignoreDirect = false, ignoreRoles = false, ignoreRepliedUser = false, ignoreEveryone = false } = {}) {
        var _a, _b, _c;
        const user = this.client.users.resolve(data);
        if (!ignoreEveryone && user && this.everyone) return true;
        const userWasRepliedTo = user && ((_a = this.repliedUser) == null ? void 0 : _a.id) === user.id;
        if (!ignoreRepliedUser && userWasRepliedTo && this.users.has(user.id)) return true;
        if (!ignoreDirect) {
          if (user && (!ignoreRepliedUser || this.parsedUsers.has(user.id)) && this.users.has(user.id)) return true;
          const role = (_b = this.guild) == null ? void 0 : _b.roles.resolve(data);
          if (role && this.roles.has(role.id)) return true;
          const channel = this.client.channels.resolve(data);
          if (channel && this.channels.has(channel.id)) return true;
        }
        if (!ignoreRoles) {
          const member = (_c = this.guild) == null ? void 0 : _c.members.resolve(data);
          if (member) {
            for (const mentionedRole of this.roles.values()) if (member.roles.cache.has(mentionedRole.id)) return true;
          }
        }
        return false;
      }
      toJSON() {
        return Util.flatten(this, {
          members: true,
          channels: true
        });
      }
    };
    MessageMentions.EVERYONE_PATTERN = /@(everyone|here)/g;
    MessageMentions.USERS_PATTERN = /<@!?(\d{17,19})>/g;
    MessageMentions.ROLES_PATTERN = /<@&(\d{17,19})>/g;
    MessageMentions.CHANNELS_PATTERN = /<#(\d{17,19})>/g;
    module2.exports = MessageMentions;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/PollAnswer.js
var require_PollAnswer = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/PollAnswer.js"(exports2, module2) {
    "use strict";
    var Base = require_Base();
    var { Emoji } = require_Emoji();
    var PollAnswer = class extends Base {
      constructor(client, data, poll) {
        super(client);
        Object.defineProperty(this, "poll", { value: poll });
        this.id = data.answer_id;
        this.text = data.poll_media.text ?? null;
        Object.defineProperty(this, "_emoji", { value: data.poll_media.emoji ?? null });
        this._patch(data);
      }
      _patch(data) {
        if ("count" in data) {
          this.voteCount = data.count;
        } else {
          this.voteCount ?? (this.voteCount = 0);
        }
      }
      /**
       * The emoji of this answer
       * @type {?(GuildEmoji|Emoji)}
       */
      get emoji() {
        if (!this._emoji || !this._emoji.id && !this._emoji.name) return null;
        return this.client.emojis.resolve(this._emoji.id) ?? new Emoji(this.client, this._emoji);
      }
      /**
       * @typedef {Object} FetchPollVotersOptions
       * @property {number} [limit] The maximum number of voters to fetch
       * @property {Snowflake} [after] The user id to fetch voters after
       */
      /**
       * Fetches the users that voted for this answer
       * @param {FetchPollVotersOptions} [options={}] The options for fetching voters
       * @returns {Promise<Collection<Snowflake, User>>}
       */
      fetchVoters({ after, limit } = {}) {
        return this.poll.message.channel.messages.fetchPollAnswerVoters({
          messageId: this.poll.message.id,
          answerId: this.id,
          after,
          limit
        });
      }
    };
    module2.exports = { PollAnswer };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/Poll.js
var require_Poll = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/Poll.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var Base = require_Base();
    var { PollAnswer } = require_PollAnswer();
    var { Error: Error2 } = require_errors2();
    var { PollLayoutTypes } = require_Constants();
    var Poll = class extends Base {
      constructor(client, data, message) {
        super(client);
        Object.defineProperty(this, "message", { value: message });
        this.question = {
          text: data.question.text
        };
        this.answers = data.answers.reduce(
          (acc, answer) => acc.set(answer.answer_id, new PollAnswer(this.client, answer, this)),
          new Collection2()
        );
        this.expiresTimestamp = Date.parse(data.expiry);
        this.allowMultiselect = data.allow_multiselect;
        this.layoutType = PollLayoutTypes[data.layout_type];
        this._patch(data);
      }
      _patch(data) {
        if (data.results) {
          this.resultsFinalized = data.results.is_finalized;
          for (const answerResult of data.results.answer_counts) {
            const answer = this.answers.get(answerResult.id);
            answer == null ? void 0 : answer._patch(answerResult);
          }
        } else {
          this.resultsFinalized ?? (this.resultsFinalized = false);
        }
      }
      /**
       * The date when this poll expires
       * @type {Date}
       * @readonly
       */
      get expiresAt() {
        return new Date(this.expiresTimestamp);
      }
      /**
       * Ends this poll.
       * @returns {Promise<Message>}
       */
      end() {
        if (Date.now() > this.expiresTimestamp) {
          return Promise.reject(new Error2("POLL_ALREADY_EXPIRED"));
        }
        return this.message.channel.messages.endPoll(this.message.id);
      }
    };
    module2.exports = { Poll };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/ReactionCollector.js
var require_ReactionCollector = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/ReactionCollector.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var Collector = require_Collector();
    var { Events: Events2 } = require_Constants();
    var ReactionCollector = class _ReactionCollector extends Collector {
      /**
       * @param {Message} message The message upon which to collect reactions
       * @param {ReactionCollectorOptions} [options={}] The options to apply to this collector
       */
      constructor(message, options = {}) {
        super(message.client, options);
        this.message = message;
        this.users = new Collection2();
        this.total = 0;
        this.empty = this.empty.bind(this);
        this._handleChannelDeletion = this._handleChannelDeletion.bind(this);
        this._handleThreadDeletion = this._handleThreadDeletion.bind(this);
        this._handleGuildDeletion = this._handleGuildDeletion.bind(this);
        this._handleMessageDeletion = this._handleMessageDeletion.bind(this);
        const bulkDeleteListener = (messages) => {
          if (messages.has(this.message.id)) this.stop("messageDelete");
        };
        this.client.incrementMaxListeners();
        this.client.on(Events2.MESSAGE_REACTION_ADD, this.handleCollect);
        this.client.on(Events2.MESSAGE_REACTION_REMOVE, this.handleDispose);
        this.client.on(Events2.MESSAGE_REACTION_REMOVE_ALL, this.empty);
        this.client.on(Events2.MESSAGE_DELETE, this._handleMessageDeletion);
        this.client.on(Events2.MESSAGE_BULK_DELETE, bulkDeleteListener);
        this.client.on(Events2.CHANNEL_DELETE, this._handleChannelDeletion);
        this.client.on(Events2.THREAD_DELETE, this._handleThreadDeletion);
        this.client.on(Events2.GUILD_DELETE, this._handleGuildDeletion);
        this.once("end", () => {
          this.client.removeListener(Events2.MESSAGE_REACTION_ADD, this.handleCollect);
          this.client.removeListener(Events2.MESSAGE_REACTION_REMOVE, this.handleDispose);
          this.client.removeListener(Events2.MESSAGE_REACTION_REMOVE_ALL, this.empty);
          this.client.removeListener(Events2.MESSAGE_DELETE, this._handleMessageDeletion);
          this.client.removeListener(Events2.MESSAGE_BULK_DELETE, bulkDeleteListener);
          this.client.removeListener(Events2.CHANNEL_DELETE, this._handleChannelDeletion);
          this.client.removeListener(Events2.THREAD_DELETE, this._handleThreadDeletion);
          this.client.removeListener(Events2.GUILD_DELETE, this._handleGuildDeletion);
          this.client.decrementMaxListeners();
        });
        this.on("collect", (reaction, user) => {
          if (reaction.count === 1) {
            this.emit("create", reaction, user);
          }
          this.total++;
          this.users.set(user.id, user);
        });
        this.on("remove", (reaction, user) => {
          this.total--;
          if (!this.collected.some((r) => r.users.cache.has(user.id))) this.users.delete(user.id);
        });
      }
      /**
       * Handles an incoming reaction for possible collection.
       * @param {MessageReaction} reaction The reaction to possibly collect
       * @param {User} user The user that added the reaction
       * @returns {?(Snowflake|string)}
       * @private
       */
      collect(reaction) {
        if (reaction.message.id !== this.message.id) return null;
        return _ReactionCollector.key(reaction);
      }
      /**
       * Handles a reaction deletion for possible disposal.
       * @param {MessageReaction} reaction The reaction to possibly dispose of
       * @param {User} user The user that removed the reaction
       * @returns {?(Snowflake|string)}
       */
      dispose(reaction, user) {
        if (reaction.message.id !== this.message.id) return null;
        if (this.collected.has(_ReactionCollector.key(reaction)) && this.users.has(user.id)) {
          this.emit("remove", reaction, user);
        }
        return reaction.count ? null : _ReactionCollector.key(reaction);
      }
      /**
       * Empties this reaction collector.
       */
      empty() {
        this.total = 0;
        this.collected.clear();
        this.users.clear();
        this.checkEnd();
      }
      /**
       * The reason this collector has ended with, or null if it hasn't ended yet
       * @type {?string}
       * @readonly
       */
      get endReason() {
        if (this.options.max && this.total >= this.options.max) return "limit";
        if (this.options.maxEmojis && this.collected.size >= this.options.maxEmojis) return "emojiLimit";
        if (this.options.maxUsers && this.users.size >= this.options.maxUsers) return "userLimit";
        return null;
      }
      /**
       * Handles checking if the message has been deleted, and if so, stops the collector with the reason 'messageDelete'.
       * @private
       * @param {Message} message The message that was deleted
       * @returns {void}
       */
      _handleMessageDeletion(message) {
        if (message.id === this.message.id) {
          this.stop("messageDelete");
        }
      }
      /**
       * Handles checking if the channel has been deleted, and if so, stops the collector with the reason 'channelDelete'.
       * @private
       * @param {GuildChannel} channel The channel that was deleted
       * @returns {void}
       */
      _handleChannelDeletion(channel) {
        var _a;
        if (channel.id === this.message.channelId || ((_a = channel.threads) == null ? void 0 : _a.cache.has(this.message.channelId))) {
          this.stop("channelDelete");
        }
      }
      /**
       * Handles checking if the thread has been deleted, and if so, stops the collector with the reason 'threadDelete'.
       * @private
       * @param {ThreadChannel} thread The thread that was deleted
       * @returns {void}
       */
      _handleThreadDeletion(thread) {
        if (thread.id === this.message.channelId) {
          this.stop("threadDelete");
        }
      }
      /**
       * Handles checking if the guild has been deleted, and if so, stops the collector with the reason 'guildDelete'.
       * @private
       * @param {Guild} guild The guild that was deleted
       * @returns {void}
       */
      _handleGuildDeletion(guild) {
        var _a;
        if (guild.id === ((_a = this.message.guild) == null ? void 0 : _a.id)) {
          this.stop("guildDelete");
        }
      }
      /**
       * Gets the collector key for a reaction.
       * @param {MessageReaction} reaction The message reaction to get the key for
       * @returns {Snowflake|string}
       */
      static key(reaction) {
        return reaction.emoji.id ?? reaction.emoji.name;
      }
    };
    module2.exports = ReactionCollector;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/Sticker.js
var require_Sticker = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/Sticker.js"(exports2) {
    "use strict";
    var process2 = require_node_process();
    var Base = require_Base();
    var { Error: Error2 } = require_errors2();
    var { StickerFormatTypes, StickerTypes } = require_Constants();
    var SnowflakeUtil = require_SnowflakeUtil();
    var deletedStickers = /* @__PURE__ */ new WeakSet();
    var deprecationEmittedForDeleted = false;
    var Sticker2 = class _Sticker extends Base {
      constructor(client, sticker) {
        super(client);
        this._patch(sticker);
      }
      _patch(sticker) {
        this.id = sticker.id;
        if ("description" in sticker) {
          this.description = sticker.description;
        } else {
          this.description ?? (this.description = null);
        }
        if ("type" in sticker) {
          this.type = StickerTypes[sticker.type];
        } else {
          this.type ?? (this.type = null);
        }
        if ("format_type" in sticker) {
          this.format = StickerFormatTypes[sticker.format_type];
        }
        if ("name" in sticker) {
          this.name = sticker.name;
        }
        if ("pack_id" in sticker) {
          this.packId = sticker.pack_id;
        } else {
          this.packId ?? (this.packId = null);
        }
        if ("tags" in sticker) {
          this.tags = sticker.tags.split(", ");
        } else {
          this.tags ?? (this.tags = null);
        }
        if ("available" in sticker) {
          this.available = sticker.available;
        } else {
          this.available ?? (this.available = null);
        }
        if ("guild_id" in sticker) {
          this.guildId = sticker.guild_id;
        } else {
          this.guildId ?? (this.guildId = null);
        }
        if ("user" in sticker) {
          this.user = this.client.users._add(sticker.user);
        } else {
          this.user ?? (this.user = null);
        }
        if ("sort_value" in sticker) {
          this.sortValue = sticker.sort_value;
        } else {
          this.sortValue ?? (this.sortValue = null);
        }
      }
      /**
       * The timestamp the sticker was created at
       * @type {number}
       * @readonly
       */
      get createdTimestamp() {
        return SnowflakeUtil.timestampFrom(this.id);
      }
      /**
       * The time the sticker was created at
       * @type {Date}
       * @readonly
       */
      get createdAt() {
        return new Date(this.createdTimestamp);
      }
      /**
       * Whether or not the sticker has been deleted
       * @type {boolean}
       * @deprecated This will be removed in the next major version, see https://github.com/discordjs/discord.js/issues/7091
       */
      get deleted() {
        if (!deprecationEmittedForDeleted) {
          deprecationEmittedForDeleted = true;
          process2.emitWarning(
            "Sticker#deleted is deprecated, see https://github.com/discordjs/discord.js/issues/7091.",
            "DeprecationWarning"
          );
        }
        return deletedStickers.has(this);
      }
      set deleted(value) {
        if (!deprecationEmittedForDeleted) {
          deprecationEmittedForDeleted = true;
          process2.emitWarning(
            "Sticker#deleted is deprecated, see https://github.com/discordjs/discord.js/issues/7091.",
            "DeprecationWarning"
          );
        }
        if (value) deletedStickers.add(this);
        else deletedStickers.delete(this);
      }
      /**
       * Whether this sticker is partial
       * @type {boolean}
       * @readonly
       */
      get partial() {
        return !this.type;
      }
      /**
       * The guild that owns this sticker
       * @type {?Guild}
       * @readonly
       */
      get guild() {
        return this.client.guilds.resolve(this.guildId);
      }
      /**
       * A link to the sticker
       * <info>If the sticker's format is LOTTIE, it returns the URL of the Lottie JSON file.</info>
       * @type {string}
       */
      get url() {
        return this.client.rest.cdn.Sticker(this.id, this.format);
      }
      /**
       * Fetches this sticker.
       * @returns {Promise<Sticker>}
       */
      async fetch() {
        const data = await this.client.api.stickers(this.id).get();
        this._patch(data);
        return this;
      }
      /**
       * Fetches the pack this sticker is part of from Discord, if this is a Nitro sticker.
       * @returns {Promise<?StickerPack>}
       */
      async fetchPack() {
        return (this.packId && (await this.client.fetchPremiumStickerPacks()).get(this.packId)) ?? null;
      }
      /**
       * Fetches the user who uploaded this sticker, if this is a guild sticker.
       * @returns {Promise<?User>}
       */
      async fetchUser() {
        if (this.partial) await this.fetch();
        if (!this.guildId) throw new Error2("NOT_GUILD_STICKER");
        return this.guild.stickers.fetchUser(this);
      }
      /**
       * Data for editing a sticker.
       * @typedef {Object} GuildStickerEditData
       * @property {string} [name] The name of the sticker
       * @property {?string} [description] The description of the sticker
       * @property {string} [tags] The Discord name of a unicode emoji representing the sticker's expression
       */
      /**
       * Edits the sticker.
       * @param {GuildStickerEditData} [data] The new data for the sticker
       * @param {string} [reason] Reason for editing this sticker
       * @returns {Promise<Sticker>}
       * @example
       * // Update the name of a sticker
       * sticker.edit({ name: 'new name' })
       *   .then(s => console.log(`Updated the name of the sticker to ${s.name}`))
       *   .catch(console.error);
       */
      edit(data, reason) {
        return this.guild.stickers.edit(this, data, reason);
      }
      /**
       * Deletes the sticker.
       * @returns {Promise<Sticker>}
       * @param {string} [reason] Reason for deleting this sticker
       * @example
       * // Delete a message
       * sticker.delete()
       *   .then(s => console.log(`Deleted sticker ${s.name}`))
       *   .catch(console.error);
       */
      async delete(reason) {
        await this.guild.stickers.delete(this, reason);
        return this;
      }
      /**
       * Whether this sticker is the same as another one.
       * @param {Sticker|APISticker} other The sticker to compare it to
       * @returns {boolean}
       */
      equals(other) {
        if (other instanceof _Sticker) {
          return other.id === this.id && other.description === this.description && other.type === this.type && other.format === this.format && other.name === this.name && other.packId === this.packId && other.tags.length === this.tags.length && other.tags.every((tag) => this.tags.includes(tag)) && other.available === this.available && other.guildId === this.guildId && other.sortValue === this.sortValue;
        } else {
          return other.id === this.id && other.description === this.description && other.name === this.name && other.tags === this.tags.join(", ");
        }
      }
    };
    exports2.Sticker = Sticker2;
    exports2.deletedStickers = deletedStickers;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/managers/CachedManager.js
var require_CachedManager = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/managers/CachedManager.js"(exports2, module2) {
    "use strict";
    var DataManager = require_DataManager();
    var { _cleanupSymbol } = require_Constants();
    var CachedManager = class extends DataManager {
      constructor(client, holds, iterable) {
        var _a, _b;
        super(client, holds);
        Object.defineProperty(this, "_cache", { value: this.client.options.makeCache(this.constructor, this.holds) });
        let cleanup = (_b = (_a = this._cache)[_cleanupSymbol]) == null ? void 0 : _b.call(_a);
        if (cleanup) {
          cleanup = cleanup.bind(this._cache);
          client._cleanups.add(cleanup);
          client._finalizers.register(this, {
            cleanup,
            message: `Garbage collection completed on ${this.constructor.name}, which had a ${this._cache.constructor.name} of ${this.holds.name}.`,
            name: this.constructor.name
          });
        }
        if (iterable) {
          for (const item of iterable) {
            this._add(item);
          }
        }
      }
      /**
       * The cache of items for this manager.
       * @type {Collection}
       * @abstract
       */
      get cache() {
        return this._cache;
      }
      _add(data, cache = true, { id, extras = [] } = {}) {
        const existing = this.cache.get(id ?? data.id);
        if (existing) {
          if (cache) {
            existing._patch(data);
            return existing;
          }
          const clone = existing._clone();
          clone._patch(data);
          return clone;
        }
        const entry = this.holds ? new this.holds(this.client, data, ...extras) : data;
        if (cache) this.cache.set(id ?? entry.id, entry);
        return entry;
      }
    };
    module2.exports = CachedManager;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/BaseGuildEmoji.js
var require_BaseGuildEmoji = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/BaseGuildEmoji.js"(exports2, module2) {
    "use strict";
    var { Emoji } = require_Emoji();
    var BaseGuildEmoji = class extends Emoji {
      constructor(client, data, guild) {
        super(client, data);
        this.guild = guild;
        this.requiresColons = null;
        this.managed = null;
        this.available = null;
        this._patch(data);
      }
      _patch(data) {
        if ("name" in data) this.name = data.name;
        if ("require_colons" in data) {
          this.requiresColons = data.require_colons;
        }
        if ("managed" in data) {
          this.managed = data.managed;
        }
        if ("available" in data) {
          this.available = data.available;
        }
      }
    };
    module2.exports = BaseGuildEmoji;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/managers/GuildEmojiRoleManager.js
var require_GuildEmojiRoleManager = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/managers/GuildEmojiRoleManager.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var DataManager = require_DataManager();
    var { TypeError: TypeError2 } = require_errors2();
    var { Role } = require_Role();
    var GuildEmojiRoleManager = class extends DataManager {
      constructor(emoji) {
        super(emoji.client, Role);
        this.emoji = emoji;
        this.guild = emoji.guild;
      }
      /**
       * The cache of roles belonging to this emoji
       * @type {Collection<Snowflake, Role>}
       * @readonly
       */
      get cache() {
        return this.guild.roles.cache.filter((role) => this.emoji._roles.includes(role.id));
      }
      /**
       * Adds a role (or multiple roles) to the list of roles that can use this emoji.
       * @param {RoleResolvable|RoleResolvable[]|Collection<Snowflake, Role>} roleOrRoles The role or roles to add
       * @returns {Promise<GuildEmoji>}
       */
      add(roleOrRoles) {
        if (!Array.isArray(roleOrRoles) && !(roleOrRoles instanceof Collection2)) roleOrRoles = [roleOrRoles];
        const resolvedRoles = [];
        for (const role of roleOrRoles.values()) {
          const resolvedRole = this.guild.roles.resolveId(role);
          if (!resolvedRole) {
            return Promise.reject(new TypeError2("INVALID_ELEMENT", "Array or Collection", "roles", role));
          }
          resolvedRoles.push(resolvedRole);
        }
        const newRoles = [...new Set(resolvedRoles.concat(...this.cache.keys()))];
        return this.set(newRoles);
      }
      /**
       * Removes a role (or multiple roles) from the list of roles that can use this emoji.
       * @param {RoleResolvable|RoleResolvable[]|Collection<Snowflake, Role>} roleOrRoles The role or roles to remove
       * @returns {Promise<GuildEmoji>}
       */
      remove(roleOrRoles) {
        if (!Array.isArray(roleOrRoles) && !(roleOrRoles instanceof Collection2)) roleOrRoles = [roleOrRoles];
        const resolvedRoleIds = [];
        for (const role of roleOrRoles.values()) {
          const roleId = this.guild.roles.resolveId(role);
          if (!roleId) {
            return Promise.reject(new TypeError2("INVALID_ELEMENT", "Array or Collection", "roles", role));
          }
          resolvedRoleIds.push(roleId);
        }
        const newRoles = [...this.cache.keys()].filter((id) => !resolvedRoleIds.includes(id));
        return this.set(newRoles);
      }
      /**
       * Sets the role(s) that can use this emoji.
       * @param {Collection<Snowflake, Role>|RoleResolvable[]} roles The roles or role ids to apply
       * @returns {Promise<GuildEmoji>}
       * @example
       * // Set the emoji's roles to a single role
       * guildEmoji.roles.set(['391156570408615936'])
       *   .then(console.log)
       *   .catch(console.error);
       * @example
       * // Remove all roles from an emoji
       * guildEmoji.roles.set([])
       *    .then(console.log)
       *    .catch(console.error);
       */
      set(roles) {
        return this.emoji.edit({ roles });
      }
      clone() {
        const clone = new this.constructor(this.emoji);
        clone._patch([...this.cache.keys()]);
        return clone;
      }
      /**
       * Patches the roles for this manager's cache
       * @param {Snowflake[]} roles The new roles
       * @private
       */
      _patch(roles) {
        this.emoji._roles = roles;
      }
      valueOf() {
        return this.cache;
      }
    };
    module2.exports = GuildEmojiRoleManager;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/GuildEmoji.js
var require_GuildEmoji = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/GuildEmoji.js"(exports2, module2) {
    "use strict";
    var BaseGuildEmoji = require_BaseGuildEmoji();
    var { Error: Error2 } = require_errors2();
    var GuildEmojiRoleManager = require_GuildEmojiRoleManager();
    var Permissions2 = require_Permissions();
    var GuildEmoji = class _GuildEmoji extends BaseGuildEmoji {
      constructor(client, data, guild) {
        super(client, data, guild);
        this.author = null;
        Object.defineProperty(this, "_roles", { value: [], writable: true });
        this._patch(data);
      }
      /**
       * The guild this emoji is part of
       * @type {Guild}
       * @name GuildEmoji#guild
       */
      _clone() {
        const clone = super._clone();
        clone._roles = this._roles.slice();
        return clone;
      }
      _patch(data) {
        super._patch(data);
        if (data.user) this.author = this.client.users._add(data.user);
        if (data.roles) this._roles = data.roles;
      }
      /**
       * Whether the emoji is deletable by the client user
       * @type {boolean}
       * @readonly
       */
      get deletable() {
        if (!this.guild.members.me) throw new Error2("GUILD_UNCACHED_ME");
        return !this.managed && this.guild.members.me.permissions.has(Permissions2.FLAGS.MANAGE_EMOJIS_AND_STICKERS);
      }
      /**
       * A manager for roles this emoji is active for.
       * @type {GuildEmojiRoleManager}
       * @readonly
       */
      get roles() {
        return new GuildEmojiRoleManager(this);
      }
      /**
       * Fetches the author for this emoji
       * @returns {Promise<User>}
       */
      fetchAuthor() {
        return this.guild.emojis.fetchAuthor(this);
      }
      /**
       * Data for editing an emoji.
       * @typedef {Object} GuildEmojiEditData
       * @property {string} [name] The name of the emoji
       * @property {Collection<Snowflake, Role>|RoleResolvable[]} [roles] Roles to restrict emoji to
       */
      /**
       * Edits the emoji.
       * @param {GuildEmojiEditData} data The new data for the emoji
       * @param {string} [reason] Reason for editing this emoji
       * @returns {Promise<GuildEmoji>}
       * @example
       * // Edit an emoji
       * emoji.edit({ name: 'newemoji' })
       *   .then(e => console.log(`Edited emoji ${e}`))
       *   .catch(console.error);
       */
      async edit(data, reason) {
        var _a;
        const roles = (_a = data.roles) == null ? void 0 : _a.map((r) => r.id ?? r);
        const newData = await this.client.api.guilds(this.guild.id).emojis(this.id).patch({
          data: {
            name: data.name,
            roles
          },
          reason
        });
        const clone = this._clone();
        clone._patch(newData);
        return clone;
      }
      /**
       * Sets the name of the emoji.
       * @param {string} name The new name for the emoji
       * @param {string} [reason] Reason for changing the emoji's name
       * @returns {Promise<GuildEmoji>}
       */
      setName(name, reason) {
        return this.edit({ name }, reason);
      }
      /**
       * Deletes the emoji.
       * @param {string} [reason] Reason for deleting the emoji
       * @returns {Promise<GuildEmoji>}
       */
      async delete(reason) {
        await this.guild.emojis.delete(this, reason);
        return this;
      }
      /**
       * Whether this emoji is the same as another one.
       * @param {GuildEmoji|APIEmoji} other The emoji to compare it to
       * @returns {boolean}
       */
      equals(other) {
        if (other instanceof _GuildEmoji) {
          return other.id === this.id && other.name === this.name && other.managed === this.managed && other.available === this.available && other.requiresColons === this.requiresColons && other.roles.cache.size === this.roles.cache.size && other.roles.cache.every((role) => this.roles.cache.has(role.id));
        } else {
          return other.id === this.id && other.name === this.name && other.roles.length === this.roles.cache.size && other.roles.every((role) => this.roles.cache.has(role));
        }
      }
    };
    module2.exports = GuildEmoji;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/ReactionEmoji.js
var require_ReactionEmoji = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/ReactionEmoji.js"(exports2, module2) {
    "use strict";
    var { Emoji } = require_Emoji();
    var Util = require_Util();
    var ReactionEmoji = class extends Emoji {
      constructor(reaction, emoji) {
        super(reaction.message.client, emoji);
        this.reaction = reaction;
      }
      toJSON() {
        return Util.flatten(this, { identifier: true });
      }
      valueOf() {
        return this.id;
      }
    };
    module2.exports = ReactionEmoji;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/managers/ReactionUserManager.js
var require_ReactionUserManager = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/managers/ReactionUserManager.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var CachedManager = require_CachedManager();
    var { Error: Error2 } = require_errors2();
    var User = require_User();
    var { ReactionTypes } = require_Constants();
    var ReactionUserManager = class extends CachedManager {
      constructor(reaction, iterable) {
        super(reaction.client, User, iterable);
        this.reaction = reaction;
      }
      /**
       * The cache of this manager
       * @type {Collection<Snowflake, User>}
       * @name ReactionUserManager#cache
       */
      /**
       * Options used to fetch users who gave a reaction.
       * @typedef {Object} FetchReactionUsersOptions
       * @property {ReactionType} [type='NORMAL'] The reaction type to fetch
       * @property {number} [limit=100] The maximum amount of users to fetch, defaults to `100`
       * @property {Snowflake} [after] Limit fetching users to those with an id greater than the supplied id
       */
      /**
       * Fetches all the users that gave this reaction. Resolves with a collection of users, mapped by their ids.
       * @param {FetchReactionUsersOptions} [options] Options for fetching the users
       * @returns {Promise<Collection<Snowflake, User>>}
       */
      async fetch({ limit = 100, after, type = "NORMAL" } = {}) {
        const message = this.reaction.message;
        const data = await this.client.api.channels[message.channelId].messages[message.id].reactions[this.reaction.emoji.identifier].get({ query: { limit, after, type: typeof type == "number" ? type : ReactionTypes[type] } });
        const users = new Collection2();
        for (const rawUser of data) {
          const user = this.client.users._add(rawUser);
          this.cache.set(user.id, user);
          users.set(user.id, user);
        }
        return users;
      }
      /**
       * Removes a user from this reaction.
       * @param {UserResolvable} [user=this.client.user] The user to remove the reaction of
       * @returns {Promise<MessageReaction>}
       */
      async remove(user = this.client.user) {
        const userId = this.client.users.resolveId(user);
        if (!userId) throw new Error2("REACTION_RESOLVE_USER");
        const message = this.reaction.message;
        await this.client.api.channels[message.channelId].messages[message.id].reactions[this.reaction.emoji.identifier][userId === this.client.user.id ? "@me" : userId].delete();
        return this.reaction;
      }
    };
    module2.exports = ReactionUserManager;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/MessageReaction.js
var require_MessageReaction = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/MessageReaction.js"(exports2, module2) {
    "use strict";
    var GuildEmoji = require_GuildEmoji();
    var ReactionEmoji = require_ReactionEmoji();
    var ReactionUserManager = require_ReactionUserManager();
    var Util = require_Util();
    var MessageReaction = class {
      constructor(client, data, message) {
        Object.defineProperty(this, "client", { value: client });
        this.message = message;
        this.me = data.me;
        this.meBurst = data.me_burst;
        this.users = new ReactionUserManager(this, this.me ? [client.user] : []);
        this._emoji = new ReactionEmoji(this, data.emoji);
        this.burstColors = null;
        this._patch(data);
      }
      _patch(data) {
        if ("burst_colors" in data) {
          this.burstColors = data.burst_colors;
        }
        if ("count" in data) {
          this.count ?? (this.count = data.count);
        }
        if ("count_details" in data) {
          this.countDetails = {
            burst: data.count_details.burst,
            normal: data.count_details.normal
          };
        } else {
          this.countDetails ?? (this.countDetails = { burst: 0, normal: 0 });
        }
      }
      /**
       * Removes all users from this reaction.
       * @returns {Promise<MessageReaction>}
       */
      async remove() {
        await this.client.api.channels(this.message.channelId).messages(this.message.id).reactions(this._emoji.identifier).delete();
        return this;
      }
      /**
       * The emoji of this reaction. Either a {@link GuildEmoji} object for known custom emojis, or a {@link ReactionEmoji}
       * object which has fewer properties. Whatever the prototype of the emoji, it will still have
       * `name`, `id`, `identifier` and `toString()`
       * @type {GuildEmoji|ReactionEmoji}
       * @readonly
       */
      get emoji() {
        if (this._emoji instanceof GuildEmoji) return this._emoji;
        if (this._emoji.id) {
          const emojis = this.message.client.emojis.cache;
          if (emojis.has(this._emoji.id)) {
            const emoji = emojis.get(this._emoji.id);
            this._emoji = emoji;
            return emoji;
          }
        }
        return this._emoji;
      }
      /**
       * Whether or not this reaction is a partial
       * @type {boolean}
       * @readonly
       */
      get partial() {
        return this.count === null;
      }
      /**
       * Fetch this reaction.
       * @returns {Promise<MessageReaction>}
       */
      async fetch() {
        const message = await this.message.fetch();
        const existing = message.reactions.cache.get(this.emoji.id ?? this.emoji.name);
        this._patch(existing ?? { count: 0 });
        return this;
      }
      toJSON() {
        return Util.flatten(this, { emoji: "emojiId", message: "messageId" });
      }
      _add(user, burst) {
        if (this.partial) return;
        this.users.cache.set(user.id, user);
        if (!this.me || user.id !== this.message.client.user.id || this.count === 0) {
          this.count++;
          if (burst) this.countDetails.burst++;
          else this.countDetails.normal++;
        }
        if (user.id === this.message.client.user.id) {
          if (burst) this.meBurst = true;
          else this.me = true;
        }
      }
      _remove(user, burst) {
        if (this.partial) return;
        this.users.cache.delete(user.id);
        if (!this.me || user.id !== this.message.client.user.id) {
          this.count--;
          if (burst) this.countDetails.burst--;
          else this.countDetails.normal--;
        }
        if (user.id === this.message.client.user.id) {
          if (burst) this.meBurst = false;
          else this.me = false;
        }
        if (this.count <= 0 && this.users.cache.size === 0) {
          this.message.reactions.cache.delete(this.emoji.id ?? this.emoji.name);
        }
      }
    };
    module2.exports = MessageReaction;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/managers/ReactionManager.js
var require_ReactionManager = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/managers/ReactionManager.js"(exports2, module2) {
    "use strict";
    var CachedManager = require_CachedManager();
    var MessageReaction = require_MessageReaction();
    var ReactionManager = class extends CachedManager {
      constructor(message, iterable) {
        super(message.client, MessageReaction, iterable);
        this.message = message;
      }
      _add(data, cache) {
        return super._add(data, cache, { id: data.emoji.id ?? data.emoji.name, extras: [this.message] });
      }
      /**
       * The reaction cache of this manager
       * @type {Collection<string|Snowflake, MessageReaction>}
       * @name ReactionManager#cache
       */
      /**
       * Data that can be resolved to a MessageReaction object. This can be:
       * * A MessageReaction
       * * A Snowflake
       * * The Unicode representation of an emoji
       * @typedef {MessageReaction|Snowflake} MessageReactionResolvable
       */
      /**
       * Resolves a {@link MessageReactionResolvable} to a {@link MessageReaction} object.
       * @method resolve
       * @memberof ReactionManager
       * @instance
       * @param {MessageReactionResolvable} reaction The MessageReaction to resolve
       * @returns {?MessageReaction}
       */
      /**
       * Resolves a {@link MessageReactionResolvable} to a {@link MessageReaction} id.
       * @method resolveId
       * @memberof ReactionManager
       * @instance
       * @param {MessageReactionResolvable} reaction The MessageReaction to resolve
       * @returns {?Snowflake}
       */
      /**
       * Removes all reactions from a message.
       * @returns {Promise<Message>}
       */
      async removeAll() {
        await this.client.api.channels(this.message.channelId).messages(this.message.id).reactions.delete();
        return this.message;
      }
    };
    module2.exports = ReactionManager;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/Message.js
var require_Message = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/Message.js"(exports2) {
    "use strict";
    var process2 = require_node_process();
    var { Collection: Collection2 } = require_dist();
    var Base = require_Base();
    var BaseMessageComponent = require_BaseMessageComponent();
    var MessageAttachment = require_MessageAttachment();
    var Embed = require_MessageEmbed();
    var Mentions = require_MessageMentions();
    var MessagePayload = require_MessagePayload();
    var { Poll } = require_Poll();
    var ReactionCollector = require_ReactionCollector();
    var { Sticker: Sticker2 } = require_Sticker();
    var Application = require_Application();
    var { Error: Error2 } = require_errors2();
    var ReactionManager = require_ReactionManager();
    var {
      InteractionTypes,
      MessageTypes,
      SystemMessageTypes,
      MessageComponentTypes,
      MessageReferenceTypes
    } = require_Constants();
    var MessageFlags = require_MessageFlags();
    var Permissions2 = require_Permissions();
    var SnowflakeUtil = require_SnowflakeUtil();
    var Util = require_Util();
    var deletedMessages = /* @__PURE__ */ new WeakSet();
    var deprecationEmittedForDeleted = false;
    var Message = class _Message extends Base {
      constructor(client, data) {
        var _a, _b;
        super(client);
        this.channelId = data.channel_id;
        this.guildId = data.guild_id ?? ((_b = (_a = this.channel) == null ? void 0 : _a.guild) == null ? void 0 : _b.id) ?? null;
        this._patch(data);
      }
      _patch(data) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        this.id = data.id;
        if ("position" in data) {
          this.position = data.position;
        } else {
          this.position ?? (this.position = null);
        }
        this.createdTimestamp = this.id ? SnowflakeUtil.timestampFrom(this.id) : new Date(data.timestamp).getTime();
        if ("type" in data) {
          this.type = MessageTypes[data.type];
          this.system = SystemMessageTypes.includes(this.type);
        } else {
          this.system ?? (this.system = null);
          this.type ?? (this.type = null);
        }
        if ("content" in data) {
          this.content = data.content;
        } else {
          this.content ?? (this.content = null);
        }
        if ("author" in data) {
          this.author = this.client.users._add(data.author, !data.webhook_id);
        } else {
          this.author ?? (this.author = null);
        }
        if ("pinned" in data) {
          this.pinned = Boolean(data.pinned);
        } else {
          this.pinned ?? (this.pinned = null);
        }
        if ("tts" in data) {
          this.tts = data.tts;
        } else {
          this.tts ?? (this.tts = null);
        }
        if ("nonce" in data) {
          this.nonce = data.nonce;
        } else {
          this.nonce ?? (this.nonce = null);
        }
        if ("embeds" in data) {
          this.embeds = data.embeds.map((e) => new Embed(e, true));
        } else {
          this.embeds = ((_a = this.embeds) == null ? void 0 : _a.slice()) ?? [];
        }
        if ("components" in data) {
          this.components = data.components.map((c) => BaseMessageComponent.create(c, this.client));
        } else {
          this.components = ((_b = this.components) == null ? void 0 : _b.slice()) ?? [];
        }
        if ("attachments" in data) {
          this.attachments = new Collection2();
          if (data.attachments) {
            for (const attachment of data.attachments) {
              this.attachments.set(attachment.id, new MessageAttachment(attachment.url, attachment.filename, attachment));
            }
          }
        } else {
          this.attachments = new Collection2(this.attachments);
        }
        if ("sticker_items" in data || "stickers" in data) {
          this.stickers = new Collection2(
            (_c = data.sticker_items ?? data.stickers) == null ? void 0 : _c.map((s) => [s.id, new Sticker2(this.client, s)])
          );
        } else {
          this.stickers = new Collection2(this.stickers);
        }
        if (data.edited_timestamp) {
          this.editedTimestamp = new Date(data.edited_timestamp).getTime();
        } else {
          this.editedTimestamp ?? (this.editedTimestamp = null);
        }
        if ("reactions" in data) {
          this.reactions = new ReactionManager(this);
          if (((_d = data.reactions) == null ? void 0 : _d.length) > 0) {
            for (const reaction of data.reactions) {
              this.reactions._add(reaction);
            }
          }
        } else {
          this.reactions ?? (this.reactions = new ReactionManager(this));
        }
        if (!this.mentions) {
          this.mentions = new Mentions(
            this,
            data.mentions,
            data.mention_roles,
            data.mention_everyone,
            data.mention_channels,
            (_e = data.referenced_message) == null ? void 0 : _e.author
          );
        } else {
          this.mentions = new Mentions(
            this,
            data.mentions ?? this.mentions.users,
            data.mention_roles ?? this.mentions.roles,
            data.mention_everyone ?? this.mentions.everyone,
            data.mention_channels ?? this.mentions.crosspostedChannels,
            ((_f = data.referenced_message) == null ? void 0 : _f.author) ?? this.mentions.repliedUser
          );
        }
        if ("webhook_id" in data) {
          this.webhookId = data.webhook_id;
        } else {
          this.webhookId ?? (this.webhookId = null);
        }
        if (data.poll) {
          this.poll = new Poll(this.client, data.poll, this);
        } else {
          this.poll ?? (this.poll = null);
        }
        if ("application" in data) {
          this.groupActivityApplication = new Application(this.client, data.application);
        } else {
          this.groupActivityApplication ?? (this.groupActivityApplication = null);
        }
        if ("application_id" in data) {
          this.applicationId = data.application_id;
        } else {
          this.applicationId ?? (this.applicationId = null);
        }
        if ("activity" in data) {
          this.activity = {
            partyId: data.activity.party_id,
            type: data.activity.type
          };
        } else {
          this.activity ?? (this.activity = null);
        }
        if ("thread" in data) {
          this.client.channels._add(data.thread, this.guild);
        }
        if (this.member && data.member) {
          this.member._patch(data.member);
        } else if (data.member && this.guild && this.author) {
          this.guild.members._add(Object.assign(data.member, { user: this.author }));
        }
        if ("flags" in data) {
          this.flags = new MessageFlags(data.flags).freeze();
        } else {
          this.flags = new MessageFlags(this.flags).freeze();
        }
        if ("message_reference" in data) {
          this.reference = {
            channelId: data.message_reference.channel_id,
            guildId: data.message_reference.guild_id,
            messageId: data.message_reference.message_id,
            type: MessageReferenceTypes[data.message_reference.type ?? 0]
          };
        } else {
          this.reference ?? (this.reference = null);
        }
        if (data.referenced_message) {
          (_h = this.channel) == null ? void 0 : _h.messages._add({ guild_id: (_g = data.message_reference) == null ? void 0 : _g.guild_id, ...data.referenced_message });
        }
        if (data.interaction) {
          this.interaction = {
            id: data.interaction.id,
            type: InteractionTypes[data.interaction.type],
            commandName: data.interaction.name,
            user: this.client.users._add(data.interaction.user)
          };
        } else {
          this.interaction ?? (this.interaction = null);
        }
        if (data.call) {
          this.call = {
            endedTimestamp: data.call.ended_timestamp ? Date.parse(data.call.ended_timestamp) : null,
            participants: data.call.participants,
            get endedAt() {
              return this.endedTimestamp && new Date(this.endedTimestamp);
            }
          };
        } else {
          this.call ?? (this.call = null);
        }
        if ("message_snapshots" in data) {
          this.snapshots = [];
          for (const snapshot of data.message_snapshots) {
            this.snapshots.push(new _Message(this.client, snapshot.message));
          }
        } else {
          this.snapshots = null;
        }
      }
      /**
       * Whether or not the structure has been deleted
       * @type {boolean}
       * @deprecated This will be removed in the next major version, see https://github.com/discordjs/discord.js/issues/7091
       */
      get deleted() {
        if (!deprecationEmittedForDeleted) {
          deprecationEmittedForDeleted = true;
          process2.emitWarning(
            "Message#deleted is deprecated, see https://github.com/discordjs/discord.js/issues/7091.",
            "DeprecationWarning"
          );
        }
        return deletedMessages.has(this);
      }
      set deleted(value) {
        if (!deprecationEmittedForDeleted) {
          deprecationEmittedForDeleted = true;
          process2.emitWarning(
            "Message#deleted is deprecated, see https://github.com/discordjs/discord.js/issues/7091.",
            "DeprecationWarning"
          );
        }
        if (value) deletedMessages.add(this);
        else deletedMessages.delete(this);
      }
      /**
       * The channel that the message was sent in
       * @type {TextBasedChannels}
       * @readonly
       */
      get channel() {
        return this.client.channels.resolve(this.channelId);
      }
      /**
       * Whether or not this message is a partial
       * @type {boolean}
       * @readonly
       */
      get partial() {
        return typeof this.content !== "string" || !this.author;
      }
      /**
       * Represents the author of the message as a guild member.
       * Only available if the message comes from a guild where the author is still a member
       * @type {?GuildMember}
       * @readonly
       */
      get member() {
        var _a;
        return ((_a = this.guild) == null ? void 0 : _a.members.resolve(this.author)) ?? null;
      }
      /**
       * The time the message was sent at
       * @type {Date}
       * @readonly
       */
      get createdAt() {
        return new Date(this.createdTimestamp);
      }
      /**
       * The time the message was last edited at (if applicable)
       * @type {?Date}
       * @readonly
       */
      get editedAt() {
        return this.editedTimestamp ? new Date(this.editedTimestamp) : null;
      }
      /**
       * The guild the message was sent in (if in a guild channel)
       * @type {?Guild}
       * @readonly
       */
      get guild() {
        var _a;
        return this.client.guilds.resolve(this.guildId) ?? ((_a = this.channel) == null ? void 0 : _a.guild) ?? null;
      }
      /**
       * Whether this message has a thread associated with it
       * @type {boolean}
       * @readonly
       */
      get hasThread() {
        return this.flags.has(MessageFlags.FLAGS.HAS_THREAD);
      }
      /**
       * The thread started by this message
       * <info>This property is not suitable for checking whether a message has a thread,
       * use {@link Message#hasThread} instead.</info>
       * @type {?ThreadChannel}
       * @readonly
       */
      get thread() {
        var _a, _b;
        return ((_b = (_a = this.channel) == null ? void 0 : _a.threads) == null ? void 0 : _b.resolve(this.id)) ?? null;
      }
      /**
       * The URL to jump to this message
       * @type {string}
       * @readonly
       */
      get url() {
        return `https://discord.com/channels/${this.guildId ?? "@me"}/${this.channelId}/${this.id}`;
      }
      /**
       * The message contents with all mentions replaced by the equivalent text.
       * If mentions cannot be resolved to a name, the relevant mention in the message content will not be converted.
       * @type {?string}
       * @readonly
       */
      get cleanContent() {
        return this.content != null ? Util.cleanContent(this.content, this.channel) : null;
      }
      /**
       * Creates a reaction collector.
       * @param {ReactionCollectorOptions} [options={}] Options to send to the collector
       * @returns {ReactionCollector}
       * @example
       * // Create a reaction collector
       * const filter = (reaction, user) => reaction.emoji.name === '👌' && user.id === 'someId';
       * const collector = message.createReactionCollector({ filter, time: 15_000 });
       * collector.on('collect', r => console.log(`Collected ${r.emoji.name}`));
       * collector.on('end', collected => console.log(`Collected ${collected.size} items`));
       */
      createReactionCollector(options = {}) {
        return new ReactionCollector(this, options);
      }
      /**
       * An object containing the same properties as CollectorOptions, but a few more:
       * @typedef {ReactionCollectorOptions} AwaitReactionsOptions
       * @property {string[]} [errors] Stop/end reasons that cause the promise to reject
       */
      /**
       * Similar to createReactionCollector but in promise form.
       * Resolves with a collection of reactions that pass the specified filter.
       * @param {AwaitReactionsOptions} [options={}] Optional options to pass to the internal collector
       * @returns {Promise<Collection<string | Snowflake, MessageReaction>>}
       * @example
       * // Create a reaction collector
       * const filter = (reaction, user) => reaction.emoji.name === '👌' && user.id === 'someId'
       * message.awaitReactions({ filter, time: 15_000 })
       *   .then(collected => console.log(`Collected ${collected.size} reactions`))
       *   .catch(console.error);
       */
      awaitReactions(options = {}) {
        return new Promise((resolve, reject) => {
          const collector = this.createReactionCollector(options);
          collector.once("end", (reactions, reason) => {
            var _a;
            if ((_a = options.errors) == null ? void 0 : _a.includes(reason)) reject(reactions);
            else resolve(reactions);
          });
        });
      }
      /**
       * Whether the message is editable by the client user
       * @type {boolean}
       * @readonly
       */
      get editable() {
        var _a, _b;
        const precheck = Boolean(
          this.author.id === this.client.user.id && !deletedMessages.has(this) && (!this.guild || ((_a = this.channel) == null ? void 0 : _a.viewable))
        );
        if ((_b = this.channel) == null ? void 0 : _b.isThread()) {
          if (this.channel.archived) return false;
          if (this.channel.locked) {
            const permissions = this.channel.permissionsFor(this.client.user);
            if (!(permissions == null ? void 0 : permissions.has(Permissions2.FLAGS.MANAGE_THREADS, true))) return false;
          }
        }
        return precheck;
      }
      /**
       * Whether the message is deletable by the client user
       * @type {boolean}
       * @readonly
       */
      get deletable() {
        var _a, _b;
        if (deletedMessages.has(this)) {
          return false;
        }
        if (!this.guild) {
          return this.author.id === this.client.user.id;
        }
        if (!((_a = this.channel) == null ? void 0 : _a.viewable)) {
          return false;
        }
        const permissions = (_b = this.channel) == null ? void 0 : _b.permissionsFor(this.client.user);
        if (!permissions) return false;
        if (permissions.has(Permissions2.FLAGS.ADMINISTRATOR, false)) return true;
        return Boolean(
          this.author.id === this.client.user.id || permissions.has(Permissions2.FLAGS.MANAGE_MESSAGES, false) && this.guild.members.me.communicationDisabledUntilTimestamp < Date.now()
        );
      }
      /**
       * Whether the message is bulk deletable by the client user
       * @type {boolean}
       * @readonly
       * @example
       * // Filter for bulk deletable messages
       * channel.bulkDelete(messages.filter(message => message.bulkDeletable));
       */
      get bulkDeletable() {
        return false;
      }
      /**
       * Whether the message is pinnable by the client user
       * @type {boolean}
       * @readonly
       */
      get pinnable() {
        var _a;
        const { channel } = this;
        return Boolean(
          !this.system && !deletedMessages.has(this) && (!this.guild || (channel == null ? void 0 : channel.viewable) && ((_a = channel == null ? void 0 : channel.permissionsFor(this.client.user)) == null ? void 0 : _a.has(Permissions2.FLAGS.MANAGE_MESSAGES, false)))
        );
      }
      /**
       * Fetches the Message this crosspost/reply/pin-add references, if available to the client
       * @returns {Promise<Message>}
       */
      async fetchReference() {
        if (!this.reference) throw new Error2("MESSAGE_REFERENCE_MISSING");
        const { channelId, messageId } = this.reference;
        if (!messageId) throw new Error2("MESSAGE_REFERENCE_MISSING");
        const channel = this.client.channels.resolve(channelId);
        if (!channel) throw new Error2("GUILD_CHANNEL_RESOLVE");
        const message = await channel.messages.fetch(messageId);
        return message;
      }
      /**
       * Whether the message is crosspostable by the client user
       * @type {boolean}
       * @readonly
       */
      get crosspostable() {
        var _a;
        const bitfield = Permissions2.FLAGS.SEND_MESSAGES | (this.author.id === this.client.user.id ? Permissions2.defaultBit : Permissions2.FLAGS.MANAGE_MESSAGES);
        const { channel } = this;
        return Boolean(
          (channel == null ? void 0 : channel.type) === "GUILD_NEWS" && !this.flags.has(MessageFlags.FLAGS.CROSSPOSTED) && this.type === "DEFAULT" && !this.poll && channel.viewable && ((_a = channel.permissionsFor(this.client.user)) == null ? void 0 : _a.has(bitfield, false)) && !deletedMessages.has(this)
        );
      }
      /**
       * Options that can be passed into {@link Message#edit}.
       * @typedef {Object} MessageEditOptions
       * @property {?string} [content] Content to be edited
       * @property {MessageEmbed[]|APIEmbed[]} [embeds] Embeds to be added/edited
       * @property {MessageMentionOptions} [allowedMentions] Which mentions should be parsed from the message content
       * @property {MessageFlags} [flags] Which flags to set for the message. Only `SUPPRESS_EMBEDS` can be edited.
       * @property {MessageAttachment[]} [attachments] An array of attachments to keep,
       * all attachments will be kept if omitted
       * @property {FileOptions[]|BufferResolvable[]|MessageAttachment[]} [files] Files to add to the message
       * @property {MessageActionRow[]|MessageActionRowOptions[]} [components]
       * Action rows containing interactive components for the message (buttons, select menus)
       */
      /**
       * Edits the content of the message.
       * @param {string|MessagePayload|MessageEditOptions} options The options to provide
       * @returns {Promise<Message>}
       * @example
       * // Update the content of a message
       * message.edit('This is my new content!')
       *   .then(msg => console.log(`Updated the content of a message to ${msg.content}`))
       *   .catch(console.error);
       */
      edit(options) {
        if (!this.channel) return Promise.reject(new Error2("CHANNEL_NOT_CACHED"));
        return this.channel.messages.edit(this, options);
      }
      /**
       * Publishes a message in an announcement channel to all channels following it.
       * @returns {Promise<Message>}
       * @example
       * // Crosspost a message
       * if (message.channel.type === 'GUILD_NEWS') {
       *   message.crosspost()
       *     .then(() => console.log('Crossposted message'))
       *     .catch(console.error);
       * }
       */
      crosspost() {
        if (!this.channel) return Promise.reject(new Error2("CHANNEL_NOT_CACHED"));
        return this.channel.messages.crosspost(this.id);
      }
      /**
       * Pins this message to the channel's pinned messages.
       * @param {string} [reason] Reason for pinning
       * @returns {Promise<Message>}
       * @example
       * // Pin a message
       * message.pin()
       *   .then(console.log)
       *   .catch(console.error)
       */
      async pin(reason) {
        if (!this.channel) throw new Error2("CHANNEL_NOT_CACHED");
        await this.channel.messages.pin(this.id, reason);
        return this;
      }
      /**
       * Unpins this message from the channel's pinned messages.
       * @param {string} [reason] Reason for unpinning
       * @returns {Promise<Message>}
       * @example
       * // Unpin a message
       * message.unpin()
       *   .then(console.log)
       *   .catch(console.error)
       */
      async unpin(reason) {
        if (!this.channel) throw new Error2("CHANNEL_NOT_CACHED");
        await this.channel.messages.unpin(this.id, reason);
        return this;
      }
      /**
       * Adds a reaction to the message.
       * @param {EmojiIdentifierResolvable} emoji The emoji to react with
       * @param {boolean} [burst=false] Super Reactions
       * @returns {Promise<MessageReaction>}
       * @example
       * // React to a message with a unicode emoji
       * message.react('🤔')
       *   .then(console.log)
       *   .catch(console.error);
       * @example
       * // React to a message with a custom emoji
       * message.react(message.guild.emojis.cache.get('123456789012345678'))
       *   .then(console.log)
       *   .catch(console.error);
       */
      async react(emoji, burst = false) {
        if (!this.channel) throw new Error2("CHANNEL_NOT_CACHED");
        await this.channel.messages.react(this.id, emoji, burst);
        return this.client.actions.MessageReactionAdd.handle(
          {
            [this.client.actions.injectedUser]: this.client.user,
            [this.client.actions.injectedChannel]: this.channel,
            [this.client.actions.injectedMessage]: this,
            emoji: Util.resolvePartialEmoji(emoji),
            me_burst: burst
          },
          true
        ).reaction;
      }
      /**
       * Deletes the message.
       * @returns {Promise<Message>}
       * @example
       * // Delete a message
       * message.delete()
       *   .then(msg => console.log(`Deleted message from ${msg.author.username}`))
       *   .catch(console.error);
       */
      async delete() {
        if (!this.channel) throw new Error2("CHANNEL_NOT_CACHED");
        await this.channel.messages.delete(this.id);
        return this;
      }
      /**
       * Options provided when sending a message as an inline reply.
       * @typedef {BaseMessageOptions} ReplyMessageOptions
       * @property {boolean} [failIfNotExists=true] Whether to error if the referenced message
       * does not exist (creates a standard message in this case when false)
       * @property {StickerResolvable[]} [stickers=[]] Stickers to send in the message
       */
      /**
       * Send an inline reply to this message.
       * @param {string|MessagePayload|ReplyMessageOptions} options The options to provide
       * @returns {Promise<Message>}
       * @example
       * // Reply to a message
       * message.reply('This is a reply!')
       *   .then(() => console.log(`Replied to message "${message.content}"`))
       *   .catch(console.error);
       */
      reply(options) {
        if (!this.channel) return Promise.reject(new Error2("CHANNEL_NOT_CACHED"));
        let data;
        if (options instanceof MessagePayload) {
          data = options;
        } else {
          data = MessagePayload.create(this, options, {
            reply: {
              messageReference: this,
              failIfNotExists: (options == null ? void 0 : options.failIfNotExists) ?? this.client.options.failIfNotExists
            }
          });
        }
        return this.channel.send(data);
      }
      /**
       * Forwards this message to a channel.
       * @param {TextBasedChannelResolvable} channel The channel to forward the message to
       * @returns {Promise<Message>}
       */
      forward(channel) {
        channel = this.client.channels.resolve(channel);
        if (!channel || !this.channelId) return Promise.reject(new Error2("CHANNEL_NOT_CACHED"));
        const data = MessagePayload.create(
          this,
          {},
          {
            forward: {
              channel_id: this.channelId,
              guild_id: this.guildId,
              message_id: this.id,
              type: 1
            }
          }
        );
        return channel.send(data);
      }
      /**
       * A number that is allowed to be the duration (in minutes) of inactivity after which a thread is automatically
       * archived. This can be:
       * * `60` (1 hour)
       * * `1440` (1 day)
       * * `4320` (3 days)
       * * `10080` (7 days)
       * * `'MAX'` (7 days)
       * <warn>This option is deprecated and will be removed in the next major version.</warn>
       * @typedef {number|string} ThreadAutoArchiveDuration
       */
      /**
       * Options for starting a thread on a message.
       * @typedef {Object} StartThreadOptions
       * @property {string} name The name of the new thread
       * @property {ThreadAutoArchiveDuration} [autoArchiveDuration=this.channel.defaultAutoArchiveDuration] The amount of
       * time (in minutes) after which the thread should automatically archive in case of no recent activity
       * @property {string} [reason] Reason for creating the thread
       * @property {number} [rateLimitPerUser] The rate limit per user (slowmode) for the thread in seconds
       */
      /**
       * Create a new public thread from this message
       * @see GuildTextThreadManager#create
       * @param {StartThreadOptions} [options] Options for starting a thread on this message
       * @returns {Promise<ThreadChannel>}
       */
      startThread(options = {}) {
        if (!this.channel) return Promise.reject(new Error2("CHANNEL_NOT_CACHED"));
        if (!["GUILD_TEXT", "GUILD_NEWS"].includes(this.channel.type)) {
          return Promise.reject(new Error2("MESSAGE_THREAD_PARENT"));
        }
        if (this.hasThread) return Promise.reject(new Error2("MESSAGE_EXISTING_THREAD"));
        return this.channel.threads.create({ ...options, startMessage: this });
      }
      /**
       * Submits a poll vote for the current user. Returns a 204 empty response on success.
       * @param  {...number[]} ids ID of the answer
       * @returns {Promise<void>}
       * @example
       * // Vote multi choices
       * message.vote(1,2);
       * // Remove vote
       * message.vote();
       */
      vote(...ids) {
        return this.client.api.channels(this.channel.id).polls(this.id).answers["@me"].put({
          data: {
            answer_ids: ids.flat(1).map((value) => value.toString())
          }
        });
      }
      /**
       * Fetch this message.
       * @param {boolean} [force=true] Whether to skip the cache check and request the API
       * @returns {Promise<Message>}
       */
      fetch(force = true) {
        if (!this.channel) return Promise.reject(new Error2("CHANNEL_NOT_CACHED"));
        return this.channel.messages.fetch(this.id, { force });
      }
      /**
       * Fetches the webhook used to create this message.
       * @returns {Promise<?Webhook>}
       */
      fetchWebhook() {
        if (!this.webhookId) return Promise.reject(new Error2("WEBHOOK_MESSAGE"));
        if (this.webhookId === this.applicationId) return Promise.reject(new Error2("WEBHOOK_APPLICATION"));
        return this.client.fetchWebhook(this.webhookId);
      }
      /**
       * Suppresses or unsuppresses embeds on a message.
       * @param {boolean} [suppress=true] If the embeds should be suppressed or not
       * @returns {Promise<Message>}
       */
      suppressEmbeds(suppress = true) {
        const flags = new MessageFlags(this.flags.bitfield);
        if (suppress) {
          flags.add(MessageFlags.FLAGS.SUPPRESS_EMBEDS);
        } else {
          flags.remove(MessageFlags.FLAGS.SUPPRESS_EMBEDS);
        }
        return this.edit({ flags });
      }
      /**
       * Removes the attachments from this message.
       * @returns {Promise<Message>}
       */
      removeAttachments() {
        return this.edit({ attachments: [] });
      }
      /**
       * Resolves a component by a custom id.
       * @param {string} customId The custom id to resolve against
       * @returns {?MessageActionRowComponent}
       */
      resolveComponent(customId) {
        return this.components.flatMap((row) => row.components).find((component) => component.customId === customId) ?? null;
      }
      /**
       * Used mainly internally. Whether two messages are identical in properties. If you want to compare messages
       * without checking all the properties, use `message.id === message2.id`, which is much more efficient. This
       * method allows you to see if there are differences in content, embeds, attachments, nonce and tts properties.
       * @param {Message} message The message to compare it to
       * @param {APIMessage} rawData Raw data passed through the WebSocket about this message
       * @returns {boolean}
       */
      equals(message, rawData) {
        if (!message) return false;
        const embedUpdate = !message.author && !message.attachments;
        if (embedUpdate) return this.id === message.id && this.embeds.length === message.embeds.length;
        let equal = this.id === message.id && this.author.id === message.author.id && this.content === message.content && this.tts === message.tts && this.nonce === message.nonce && this.embeds.length === message.embeds.length && this.attachments.size === message.attachments.size && this.attachments.every((attachment) => message.attachments.has(attachment.id)) && this.embeds.every((embed, index) => embed.equals(message.embeds[index]));
        if (equal && rawData) {
          equal = this.mentions.everyone === message.mentions.everyone && this.createdTimestamp === new Date(rawData.timestamp).getTime() && this.editedTimestamp === new Date(rawData.edited_timestamp).getTime();
        }
        return equal;
      }
      /**
       * Whether this message is from a guild.
       * @returns {boolean}
       */
      inGuild() {
        return Boolean(this.guildId);
      }
      /**
       * When concatenated with a string, this automatically concatenates the message's content instead of the object.
       * @returns {string}
       * @example
       * // Logs: Message: This is a message!
       * console.log(`Message: ${message}`);
       */
      toString() {
        return this.content;
      }
      toJSON() {
        return super.toJSON({
          channel: "channelId",
          author: "authorId",
          groupActivityApplication: "groupActivityApplicationId",
          guild: "guildId",
          cleanContent: true,
          member: false,
          reactions: false
        });
      }
      // TypeScript
      /**
       * Check data
       * @type {boolean}
       * @readonly
       */
      get isMessage() {
        return true;
      }
      /**
       * Click specific button with X and Y
       * @typedef {Object} MessageButtonLocation
       * @property {number} X Index of the row
       * @property {number} Y Index of the column
       */
      /**
       * Click specific button or automatically click first button if no button is specified.
       * @param {MessageButtonLocation|string|undefined} button button
       * @returns {Promise<Message|Modal>}
       * @example
       * // Demo msg
       * Some content
       *  ――――――――――――――――――――――――――――――――> X from 0
       *  │ [button1] [button2] [button3]
       *  │ [button4] [button5] [button6]
       *  ↓
       *  Y from 0
       * // Click button6 with X and Y
       * [0,0] [1,0] [2,0]
       * [0,1] [1,1] [2,1]
       * // Code
       * message.clickButton({
       *  X: 2, Y: 1,
       * });
       * // Click button with customId (Ex button 5)
       * message.clickButton('button5');
       * // Click button 1
       * message.clickButton();
       */
      clickButton(button) {
        var _a;
        if (typeof button == "undefined") {
          button = this.components.flatMap((row) => row.components).find((b) => b.type === "BUTTON" && b.customId && !b.disabled);
        } else if (typeof button == "string") {
          button = this.components.flatMap((row) => row.components).find((b) => b.type === "BUTTON" && b.customId == button);
        } else {
          button = (_a = this.components[button.Y]) == null ? void 0 : _a.components[button.X];
        }
        if (!button) throw new TypeError("BUTTON_NOT_FOUND");
        button = button.toJSON();
        if (!button.custom_id || button.disabled) throw new TypeError("BUTTON_CANNOT_CLICK");
        const nonce = SnowflakeUtil.generate();
        const data = {
          type: InteractionTypes.MESSAGE_COMPONENT,
          nonce,
          guild_id: this.guildId,
          channel_id: this.channelId,
          message_id: this.id,
          application_id: this.applicationId ?? this.author.id,
          session_id: this.client.sessionId,
          message_flags: this.flags.bitfield,
          data: {
            component_type: MessageComponentTypes.BUTTON,
            custom_id: button.custom_id
          }
        };
        this.client.api.interactions.post({
          data
        });
        return Util.createPromiseInteraction(this.client, nonce, 5e3, true, this);
      }
      /**
       * Select specific menu
       * @param {number|string} menu Target
       * @param {Array<UserResolvable | RoleResolvable | ChannelResolvable | string>} values Any value
       * @returns {Promise<Message|Modal>}
       */
      selectMenu(menu, values = []) {
        var _a;
        let selectMenu = menu;
        if (/[0-4]/.test(menu)) {
          selectMenu = (_a = this.components[menu]) == null ? void 0 : _a.components[0];
        } else if (typeof menu == "string") {
          selectMenu = this.components.flatMap((row) => row.components).find(
            (b) => ["STRING_SELECT", "USER_SELECT", "ROLE_SELECT", "MENTIONABLE_SELECT", "CHANNEL_SELECT"].includes(b.type) && b.customId == menu && !b.disabled
          );
        }
        if (values.length < selectMenu.minValues) {
          throw new RangeError(`[SELECT_MENU_MIN_VALUES] The minimum number of values is ${selectMenu.minValues}`);
        }
        if (values.length > (selectMenu == null ? void 0 : selectMenu.maxValues)) {
          throw new RangeError(`[SELECT_MENU_MAX_VALUES] The maximum number of values is ${selectMenu.maxValues}`);
        }
        values = values.map((value) => {
          switch (selectMenu.type) {
            case "STRING_SELECT": {
              return selectMenu.options.find((obj) => obj.value === value || obj.label === value).value;
            }
            case "USER_SELECT": {
              return this.client.users.resolveId(value);
            }
            case "ROLE_SELECT": {
              return this.guild.roles.resolveId(value);
            }
            case "MENTIONABLE_SELECT": {
              return this.client.users.resolveId(value) || this.guild.roles.resolveId(value);
            }
            case "CHANNEL_SELECT": {
              return this.client.channels.resolveId(value);
            }
            default: {
              return value;
            }
          }
        });
        const nonce = SnowflakeUtil.generate();
        const data = {
          type: InteractionTypes.MESSAGE_COMPONENT,
          guild_id: this.guildId,
          channel_id: this.channelId,
          message_id: this.id,
          application_id: this.applicationId ?? this.author.id,
          session_id: this.client.sessionId,
          message_flags: this.flags.bitfield,
          data: {
            component_type: MessageComponentTypes[selectMenu.type],
            custom_id: selectMenu.customId,
            type: MessageComponentTypes[selectMenu.type],
            values
          },
          nonce
        };
        this.client.api.interactions.post({
          data
        });
        return Util.createPromiseInteraction(this.client, nonce, 5e3, true, this);
      }
      /**
       * Marks the message as unread.
       * @returns {Promise<void>}
       */
      markUnread() {
        return this.client.api.channels[this.channelId].messages[this.id].ack.post({
          data: {
            manual: true,
            mention_count: 1
          }
        });
      }
      /**
       * Marks the message as read.
       * @returns {Promise<void>}
       */
      markRead() {
        return this.client.api.channels[this.channelId].messages[this.id].ack.post({
          data: {
            token: null
          }
        });
      }
      /**
       * Report Message
       * @param {Arrray<number>} breadcrumbs Options for reporting
       * @param {Object} [elements={}] Metadata
       * @returns {Promise<{ report_id: Snowflake }>}
       * @example
       * // GET https://discord.com/api/v9/reporting/menu/message?variant=4
       * // Report Category
       * // - <hidden>MESSAGE_WELCOME (3)</hidden>
       * // - Something else (28)
       * // - Hacks, cheats, phishing or malicious links (72)
       * message.report([3, 28, 72]).then(console.log);
       * // { "report_id": "1199663489988440124" }
       */
      report(breadcrumbs, elements = {}) {
        return this.client.api.reporting.message.post({
          data: {
            version: "1.0",
            variant: "4",
            language: "en",
            breadcrumbs,
            elements,
            channel_id: this.channelId,
            message_id: this.id,
            name: "message"
          }
        });
      }
    };
    exports2.Message = Message;
    exports2.deletedMessages = deletedMessages;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/managers/MessageManager.js
var require_MessageManager = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/managers/MessageManager.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var CachedManager = require_CachedManager();
    var { TypeError: TypeError2 } = require_errors2();
    var { Message } = require_Message();
    var MessagePayload = require_MessagePayload();
    var Util = require_Util();
    var MessageManager = class extends CachedManager {
      constructor(channel, iterable) {
        super(channel.client, Message, iterable);
        this.channel = channel;
      }
      /**
       * The cache of Messages
       * @type {Collection<Snowflake, Message>}
       * @name MessageManager#cache
       */
      _add(data, cache) {
        return super._add(data, cache);
      }
      /**
       * The parameters to pass in when requesting previous messages from a channel. `around`, `before` and
       * `after` are mutually exclusive. All the parameters are optional.
       * @typedef {Object} ChannelLogsQueryOptions
       * @property {number} [limit=50] Number of messages to acquire
       * @property {Snowflake} [before] The message's id to get the messages that were posted before it
       * @property {Snowflake} [after] The message's id to get the messages that were posted after it
       * @property {Snowflake} [around] The message's id to get the messages that were posted around it
       */
      /**
       * Gets a message, or messages, from this channel.
       * <info>The returned Collection does not contain reaction users of the messages if they were not cached.
       * Those need to be fetched separately in such a case.</info>
       * @param {Snowflake|ChannelLogsQueryOptions} [message] The id of the message to fetch, or query parameters.
       * @param {BaseFetchOptions} [options] Additional options for this fetch
       * @returns {Promise<Message|Collection<Snowflake, Message>>}
       * @example
       * // Get message
       * channel.messages.fetch('99539446449315840')
       *   .then(message => console.log(message.content))
       *   .catch(console.error);
       * @example
       * // Get messages
       * channel.messages.fetch({ limit: 10 })
       *   .then(messages => console.log(`Received ${messages.size} messages`))
       *   .catch(console.error);
       * @example
       * // Get messages and filter by user id
       * channel.messages.fetch()
       *   .then(messages => console.log(`${messages.filter(m => m.author.id === '84484653687267328').size} messages`))
       *   .catch(console.error);
       */
      fetch(message, { cache = true, force = false } = {}) {
        return typeof message === "string" ? this._fetchId(message, cache, force) : this._fetchMany(message, cache);
      }
      /**
       * Fetches the pinned messages of this channel and returns a collection of them.
       * <info>The returned Collection does not contain any reaction data of the messages.
       * Those need to be fetched separately.</info>
       * @param {boolean} [cache=true] Whether to cache the message(s)
       * @returns {Promise<Collection<Snowflake, Message>>}
       * @example
       * // Get pinned messages
       * channel.messages.fetchPinned()
       *   .then(messages => console.log(`Received ${messages.size} messages`))
       *   .catch(console.error);
       */
      async fetchPinned(cache = true) {
        const data = await this.client.api.channels[this.channel.id].pins.get();
        const messages = new Collection2();
        for (const message of data) messages.set(message.id, this._add(message, cache));
        return messages;
      }
      /**
       * Data that can be resolved to a Message object. This can be:
       * * A Message
       * * A Snowflake
       * @typedef {Message|Snowflake} MessageResolvable
       */
      /**
       * Resolves a {@link MessageResolvable} to a {@link Message} object.
       * @method resolve
       * @memberof MessageManager
       * @instance
       * @param {MessageResolvable} message The message resolvable to resolve
       * @returns {?Message}
       */
      /**
       * Resolves a {@link MessageResolvable} to a {@link Message} id.
       * @method resolveId
       * @memberof MessageManager
       * @instance
       * @param {MessageResolvable} message The message resolvable to resolve
       * @returns {?Snowflake}
       */
      /**
       * Edits a message, even if it's not cached.
       * @param {MessageResolvable} message The message to edit
       * @param {string|MessageEditOptions|MessagePayload} options The options to edit the message
       * @returns {Promise<Message>}
       */
      async edit(message, options) {
        const messageId = this.resolveId(message);
        if (!messageId) throw new TypeError2("INVALID_TYPE", "message", "MessageResolvable");
        const { data, files } = await (options instanceof MessagePayload ? options : MessagePayload.create(message instanceof Message ? message : this, options)).resolveData().resolveFiles();
        const attachments = await Util.getUploadURL(this.client, this.channel.id, files);
        const requestPromises = attachments.map(async (attachment) => {
          await Util.uploadFile(files[attachment.id].file, attachment.upload_url);
          return {
            id: attachment.id,
            filename: files[attachment.id].name,
            uploaded_filename: attachment.upload_filename,
            description: files[attachment.id].description,
            duration_secs: files[attachment.id].duration_secs,
            waveform: files[attachment.id].waveform
          };
        });
        const attachmentsData = await Promise.all(requestPromises);
        attachmentsData.sort((a, b) => parseInt(a.id) - parseInt(b.id));
        data.attachments = attachmentsData;
        const d = await this.client.api.channels[this.channel.id].messages[messageId].patch({ data });
        const existing = this.cache.get(messageId);
        if (existing) {
          const clone = existing._clone();
          clone._patch(d);
          return clone;
        }
        return this._add(d);
      }
      /**
       * Publishes a message in an announcement channel to all channels following it, even if it's not cached.
       * @param {MessageResolvable} message The message to publish
       * @returns {Promise<Message>}
       */
      async crosspost(message) {
        message = this.resolveId(message);
        if (!message) throw new TypeError2("INVALID_TYPE", "message", "MessageResolvable");
        const data = await this.client.api.channels(this.channel.id).messages(message).crosspost.post();
        return this.cache.get(data.id) ?? this._add(data);
      }
      /**
       * Pins a message to the channel's pinned messages, even if it's not cached.
       * @param {MessageResolvable} message The message to pin
       * @param {string} [reason] Reason for pinning
       * @returns {Promise<void>}
       */
      async pin(message, reason) {
        message = this.resolveId(message);
        if (!message) throw new TypeError2("INVALID_TYPE", "message", "MessageResolvable");
        await this.client.api.channels(this.channel.id).pins(message).put({ reason });
      }
      /**
       * Unpins a message from the channel's pinned messages, even if it's not cached.
       * @param {MessageResolvable} message The message to unpin
       * @param {string} [reason] Reason for unpinning
       * @returns {Promise<void>}
       */
      async unpin(message, reason) {
        message = this.resolveId(message);
        if (!message) throw new TypeError2("INVALID_TYPE", "message", "MessageResolvable");
        await this.client.api.channels(this.channel.id).pins(message).delete({ reason });
      }
      /**
       * Adds a reaction to a message, even if it's not cached.
       * @param {MessageResolvable} message The message to react to
       * @param {EmojiIdentifierResolvable} emoji The emoji to react with
       * @param {boolean} [burst=false] Super Reactions (Discord Nitro only)
       * @returns {Promise<void>}
       */
      async react(message, emoji, burst = false) {
        message = this.resolveId(message);
        if (!message) throw new TypeError2("INVALID_TYPE", "message", "MessageResolvable");
        emoji = Util.resolvePartialEmoji(emoji);
        if (!emoji) throw new TypeError2("EMOJI_TYPE", "emoji", "EmojiIdentifierResolvable");
        const emojiId = emoji.id ? `${emoji.animated ? "a:" : ""}${emoji.name}:${emoji.id}` : encodeURIComponent(emoji.name);
        await this.client.api.channels(this.channel.id).messages(message).reactions(emojiId, "@me").put({
          query: {
            type: burst ? 1 : 0
          }
        });
      }
      /**
       * Deletes a message, even if it's not cached.
       * @param {MessageResolvable} message The message to delete
       * @returns {Promise<void>}
       */
      async delete(message) {
        message = this.resolveId(message);
        if (!message) throw new TypeError2("INVALID_TYPE", "message", "MessageResolvable");
        await this.client.api.channels(this.channel.id).messages(message).delete();
      }
      _fetchId(messageId, cache, force) {
        if (!force) {
          const existing = this.cache.get(messageId);
          if (existing && !existing.partial) return existing;
        }
        return new Promise((resolve, reject) => {
          this._fetchMany(
            {
              around: messageId,
              limit: 50
            },
            cache
          ).then(
            (data_) => data_.has(messageId) ? resolve(data_.get(messageId)) : reject(new Error("MESSAGE_ID_NOT_FOUND"))
          ).catch(reject);
        });
      }
      /**
       * @typedef {object} MessageSearchOptions
       * @property {Array<UserResolvable>} [authors] An array of author to filter by
       * @property {Array<UserResolvable>} [mentions] An array of user (mentioned) to filter by
       * @property {string} [content] A messageContent to filter by
       * @property {Snowflake} [maxId] The maximum Message ID to filter by
       * @property {Snowflake} [minId] The minimum Message ID to filter by
       * @property {Array<TextChannelResolvable>} [channels] An array of channel to filter by
       * @property {boolean} [pinned] Whether to filter by pinned messages
       * @property {Array<string>} [has] Message has: `link`, `embed`, `file`, `video`, `image`, or `sound`
       * @property {boolean} [nsfw=false] Whether to filter by NSFW channels
       * @property {number} [offset=0] The number of messages to skip (for pagination, 25 results per page)
       * @property {number} [limit=25] The number of messages to fetch
       * <info>The maximum limit allowed is 25.</info>
       * @property {string} [sortBy] The order to sort by (`timestamp` or `relevance`)
       * @property {string} [sortOrder] The order to return results in (`asc` or `desc`)
       * <info>The default sort is <code>timestamp</code> in descending order <code>desc</code> (newest first).</info>
       */
      /**
       * @typedef {object} MessageSearchResult
       * @property {Collection<Snowflake, Message>} messages A collection of found messages
       * @property {number} total The total number of messages that match the search criteria
       */
      /**
       * Search Messages in the channel.
       * @param {MessageSearchOptions} options Performs a search within the channel.
       * @returns {MessageSearchResult}
       */
      async search(options = {}) {
        let { authors, content, mentions, has, maxId, minId, channels, pinned, nsfw, offset, limit, sortBy, sortOrder } = Object.assign(
          {
            authors: [],
            content: "",
            mentions: [],
            has: [],
            maxId: null,
            minId: null,
            channels: [],
            pinned: false,
            nsfw: false,
            offset: 0,
            limit: 25,
            sortBy: "timestamp",
            sortOrder: "desc"
          },
          options
        );
        if (authors.length > 0) authors = authors.map((u) => this.client.users.resolveId(u));
        if (mentions.length > 0) mentions = mentions.map((u) => this.client.users.resolveId(u));
        if (channels.length > 0) {
          channels = channels.map((c) => this.client.channels.resolveId(c)).filter((id) => {
            if (this.channel.guildId) {
              const c = this.channel.guild.channels.cache.get(id);
              if (!c || !c.messages) return false;
              const perm = c.permissionsFor(this.client.user);
              if (!perm.has("READ_MESSAGE_HISTORY") || !perm.has("VIEW_CHANNEL")) return false;
              return true;
            } else {
              return true;
            }
          });
        }
        if (limit && limit > 25) throw new RangeError("MESSAGE_SEARCH_LIMIT");
        let stringQuery = [];
        const result = new Collection2();
        let data;
        if (authors.length > 0) stringQuery.push(authors.map((id) => `author_id=${id}`).join("&"));
        if (content && content.length) stringQuery.push(`content=${encodeURIComponent(content)}`);
        if (mentions.length > 0) stringQuery.push(mentions.map((id) => `mentions=${id}`).join("&"));
        has = has.filter((v) => ["link", "embed", "file", "video", "image", "sound", "sticker"].includes(v));
        if (has.length > 0) stringQuery.push(has.map((v) => `has=${v}`).join("&"));
        if (maxId) stringQuery.push(`max_id=${maxId}`);
        if (minId) stringQuery.push(`min_id=${minId}`);
        if (nsfw) stringQuery.push("include_nsfw=true");
        if (offset !== 0) stringQuery.push(`offset=${offset}`);
        if (limit !== 25) stringQuery.push(`limit=${limit}`);
        if (["timestamp", "relevance"].includes(options.sortBy)) {
          stringQuery.push(`sort_by=${options.sortBy}`);
        } else {
          stringQuery.push("sort_by=timestamp");
        }
        if (["asc", "desc"].includes(options.sortOrder)) {
          stringQuery.push(`sort_order=${options.sortOrder}`);
        } else {
          stringQuery.push("sort_order=desc");
        }
        if (this.channel.guildId && channels.length > 0) {
          stringQuery.push(channels.map((id) => `channel_id=${id}`).join("&"));
        }
        if (typeof pinned == "boolean") stringQuery.push(`pinned=${pinned}`);
        if (!stringQuery.length) {
          return {
            messages: result,
            total: 0
          };
        }
        if (this.channel.guildId) {
          data = await this.client.api.guilds[this.channel.guildId].messages[`search?${stringQuery.join("&")}`].get();
        } else {
          stringQuery = stringQuery.filter((v) => !v.startsWith("channel_id") && !v.startsWith("include_nsfw"));
          data = await this.client.api.channels[this.channel.id].messages[`search?${stringQuery.join("&")}`].get();
        }
        for await (const message of data.messages) result.set(message[0].id, new Message(this.client, message[0]));
        return {
          messages: result,
          total: data.total_results
        };
      }
      async _fetchMany(options = {}, cache) {
        const data = await this.client.api.channels[this.channel.id].messages.get({ query: options });
        const messages = new Collection2();
        for (const message of data) messages.set(message.id, this._add(message, cache));
        return messages;
      }
      /**
       * Ends a poll.
       * @param {Snowflake} messageId The id of the message
       * @returns {Promise<Message>}
       */
      async endPoll(messageId) {
        const message = await this.client.api.channels(this.channel.id).polls(messageId).expire.post();
        return this._add(message, false);
      }
      /**
       * Options used for fetching voters of an answer in a poll.
       * @typedef {BaseFetchPollAnswerVotersOptions} FetchPollAnswerVotersOptions
       * @param {Snowflake} messageId The id of the message
       * @param {number} answerId The id of the answer
       */
      /**
       * Fetches the users that voted for a poll answer.
       * @param {FetchPollAnswerVotersOptions} options The options for fetching the poll answer voters
       * @returns {Promise<Collection<Snowflake, User>>}
       */
      async fetchPollAnswerVoters({ messageId, answerId, after, limit }) {
        const voters = await this.client.channels(this.channel.id).polls(messageId).answers(answerId).get({
          query: { limit, after }
        });
        return voters.users.reduce((acc, user) => acc.set(user.id, this.client.users._add(user, false)), new Collection2());
      }
    };
    module2.exports = MessageManager;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/Interaction.js
var require_Interaction = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/Interaction.js"(exports2, module2) {
    "use strict";
    var Base = require_Base();
    var { InteractionTypes, MessageComponentTypes, ApplicationCommandTypes } = require_Constants();
    var Permissions2 = require_Permissions();
    var SnowflakeUtil = require_SnowflakeUtil();
    var Interaction = class extends Base {
      constructor(client, data) {
        var _a, _b;
        super(client);
        this.type = InteractionTypes[data.type];
        this.id = data.id;
        Object.defineProperty(this, "token", { value: data.token });
        this.applicationId = data.application_id;
        this.channelId = data.channel_id ?? null;
        this.guildId = data.guild_id ?? null;
        this.user = this.client.users._add(data.user ?? data.member.user);
        this.member = data.member ? ((_a = this.guild) == null ? void 0 : _a.members._add(data.member)) ?? data.member : null;
        this.version = data.version;
        this.appPermissions = data.app_permissions ? new Permissions2(data.app_permissions).freeze() : null;
        this.memberPermissions = ((_b = data.member) == null ? void 0 : _b.permissions) ? new Permissions2(data.member.permissions).freeze() : null;
        this.locale = data.locale;
        this.guildLocale = data.guild_locale ?? null;
      }
      /**
       * The timestamp the interaction was created at
       * @type {number}
       * @readonly
       */
      get createdTimestamp() {
        return SnowflakeUtil.timestampFrom(this.id);
      }
      /**
       * The time the interaction was created at
       * @type {Date}
       * @readonly
       */
      get createdAt() {
        return new Date(this.createdTimestamp);
      }
      /**
       * The channel this interaction was sent in
       * @type {?TextBasedChannels}
       * @readonly
       */
      get channel() {
        return this.client.channels.cache.get(this.channelId) ?? null;
      }
      /**
       * The guild this interaction was sent in
       * @type {?Guild}
       * @readonly
       */
      get guild() {
        return this.client.guilds.cache.get(this.guildId) ?? null;
      }
      /**
       * Indicates whether this interaction is received from a guild.
       * @returns {boolean}
       */
      inGuild() {
        return Boolean(this.guildId && this.member);
      }
      /**
       * Indicates whether or not this interaction is both cached and received from a guild.
       * @returns {boolean}
       */
      inCachedGuild() {
        return Boolean(this.guild && this.member);
      }
      /**
       * Indicates whether or not this interaction is received from an uncached guild.
       * @returns {boolean}
       */
      inRawGuild() {
        return Boolean(this.guildId && !this.guild && this.member);
      }
      /**
       * Indicates whether this interaction is a {@link BaseCommandInteraction}.
       * @returns {boolean}
       */
      isApplicationCommand() {
        return InteractionTypes[this.type] === InteractionTypes.APPLICATION_COMMAND;
      }
      /**
       * Indicates whether this interaction is a {@link CommandInteraction}.
       * @returns {boolean}
       */
      isCommand() {
        return InteractionTypes[this.type] === InteractionTypes.APPLICATION_COMMAND && typeof this.targetId === "undefined";
      }
      /**
       * Indicates whether this interaction is a {@link ContextMenuInteraction}
       * @returns {boolean}
       */
      isContextMenu() {
        return InteractionTypes[this.type] === InteractionTypes.APPLICATION_COMMAND && typeof this.targetId !== "undefined";
      }
      /**
       * Indicates whether this interaction is a {@link ModalSubmitInteraction}
       * @returns {boolean}
       */
      isModalSubmit() {
        return InteractionTypes[this.type] === InteractionTypes.MODAL_SUBMIT;
      }
      /**
       * Indicates whether this interaction is a {@link UserContextMenuInteraction}
       * @returns {boolean}
       */
      isUserContextMenu() {
        return this.isContextMenu() && ApplicationCommandTypes[this.targetType] === ApplicationCommandTypes.USER;
      }
      /**
       * Indicates whether this interaction is a {@link MessageContextMenuInteraction}
       * @returns {boolean}
       */
      isMessageContextMenu() {
        return this.isContextMenu() && ApplicationCommandTypes[this.targetType] === ApplicationCommandTypes.MESSAGE;
      }
      /**
       * Indicates whether this interaction is an {@link AutocompleteInteraction}
       * @returns {boolean}
       */
      isAutocomplete() {
        return InteractionTypes[this.type] === InteractionTypes.APPLICATION_COMMAND_AUTOCOMPLETE;
      }
      /**
       * Indicates whether this interaction is a {@link MessageComponentInteraction}.
       * @returns {boolean}
       */
      isMessageComponent() {
        return InteractionTypes[this.type] === InteractionTypes.MESSAGE_COMPONENT;
      }
      /**
       * Indicates whether this interaction is a {@link ButtonInteraction}.
       * @returns {boolean}
       */
      isButton() {
        return InteractionTypes[this.type] === InteractionTypes.MESSAGE_COMPONENT && MessageComponentTypes[this.componentType] === MessageComponentTypes.BUTTON;
      }
      /**
       * Indicates whether this interaction is a {@link SelectMenuInteraction}.
       * @returns {boolean}
       */
      isSelectMenu() {
        return InteractionTypes[this.type] === InteractionTypes.MESSAGE_COMPONENT && MessageComponentTypes[this.componentType] === MessageComponentTypes.SELECT_MENU;
      }
      /**
       * Indicates whether this interaction can be replied to.
       * @returns {boolean}
       */
      isRepliable() {
        return ![InteractionTypes.PING, InteractionTypes.APPLICATION_COMMAND_AUTOCOMPLETE].includes(
          InteractionTypes[this.type]
        );
      }
    };
    module2.exports = Interaction;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/InteractionWebhook.js
var require_InteractionWebhook = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/InteractionWebhook.js"(exports2, module2) {
    "use strict";
    var Webhook2 = require_Webhook();
    var InteractionWebhook = class {
      /**
       * @param {Client} client The instantiating client
       * @param {Snowflake} id The application's id
       * @param {string} token The interaction's token
       */
      constructor(client, id, token) {
        Object.defineProperty(this, "client", { value: client });
        this.id = id;
        Object.defineProperty(this, "token", { value: token, writable: true, configurable: true });
      }
      // These are here only for documentation purposes - they are implemented by Webhook
      /* eslint-disable no-empty-function, valid-jsdoc */
      /**
       * Sends a message with this webhook.
       * @param {string|MessagePayload|InteractionReplyOptions} options The content for the reply
       * @returns {Promise<Message|APIMessage>}
       */
      send() {
      }
      fetchMessage() {
      }
      editMessage() {
      }
      deleteMessage() {
      }
      get url() {
      }
    };
    Webhook2.applyToClass(InteractionWebhook, ["sendSlackMessage", "edit", "delete", "createdTimestamp", "createdAt"]);
    module2.exports = InteractionWebhook;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/MessagePayload.js
var require_MessagePayload = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/MessagePayload.js"(exports2, module2) {
    "use strict";
    var { Buffer: Buffer2 } = require_node_buffer();
    var BaseMessageComponent = require_BaseMessageComponent();
    var MessageEmbed = require_MessageEmbed();
    var { RangeError: RangeError2 } = require_errors2();
    var ActivityFlags = require_ActivityFlags();
    var { PollLayoutTypes, MessageReferenceTypes } = require_Constants();
    var DataResolver2 = require_DataResolver();
    var MessageFlags = require_MessageFlags();
    var Util = require_Util();
    var MessagePayload = class {
      /**
       * @param {MessageTarget} target The target for this message to be sent to
       * @param {MessageOptions|WebhookMessageOptions} options Options passed in from send
       */
      constructor(target, options) {
        this.target = target;
        this.options = options;
        this.data = null;
        this.files = null;
      }
      /**
       * Whether or not the target is a {@link Webhook} or a {@link WebhookClient}
       * @type {boolean}
       * @readonly
       */
      get isWebhook() {
        const Webhook2 = require_Webhook();
        const WebhookClient = require_WebhookClient();
        return this.target instanceof Webhook2 || this.target instanceof WebhookClient;
      }
      /**
       * Whether or not the target is a {@link User}
       * @type {boolean}
       * @readonly
       */
      get isUser() {
        const User = require_User();
        const { GuildMember } = require_GuildMember();
        return this.target instanceof User || this.target instanceof GuildMember;
      }
      /**
       * Whether or not the target is a {@link Message}
       * @type {boolean}
       * @readonly
       */
      get isMessage() {
        const { Message } = require_Message();
        return this.target instanceof Message;
      }
      /**
       * Whether or not the target is a {@link MessageManager}
       * @type {boolean}
       * @readonly
       */
      get isMessageManager() {
        const MessageManager = require_MessageManager();
        return this.target instanceof MessageManager;
      }
      /**
       * Whether or not the target is an {@link Interaction} or an {@link InteractionWebhook}
       * @type {boolean}
       * @readonly
       */
      get isInteraction() {
        const Interaction = require_Interaction();
        const InteractionWebhook = require_InteractionWebhook();
        return this.target instanceof Interaction || this.target instanceof InteractionWebhook;
      }
      /**
       * Makes the content of this message.
       * @returns {?string}
       */
      makeContent() {
        let content;
        if (this.options.content === null) {
          content = "";
        } else if (typeof this.options.content !== "undefined") {
          content = Util.verifyString(this.options.content, RangeError2, "MESSAGE_CONTENT_TYPE", false);
        }
        return content;
      }
      /**
       * Resolves data.
       * @returns {MessagePayload}
       */
      resolveData() {
        var _a, _b, _c, _d, _e;
        if (this.data) return this;
        const isInteraction = this.isInteraction;
        const isWebhook = this.isWebhook;
        const content = this.makeContent();
        const tts = Boolean(this.options.tts);
        let nonce;
        if (typeof this.options.nonce !== "undefined") {
          nonce = this.options.nonce;
          if (typeof nonce === "number" ? !Number.isInteger(nonce) : typeof nonce !== "string") {
            throw new RangeError2("MESSAGE_NONCE_TYPE");
          }
        }
        const components = (_a = this.options.components) == null ? void 0 : _a.map((c) => BaseMessageComponent.create(c).toJSON());
        let username;
        let avatarURL;
        let threadName;
        let appliedTags;
        if (isWebhook) {
          username = this.options.username ?? this.target.name;
          if (this.options.avatarURL) avatarURL = this.options.avatarURL;
          if (this.options.threadName) threadName = this.options.threadName;
          if (this.options.appliedTags) appliedTags = this.options.appliedTags;
        }
        let flags;
        if (typeof this.options.flags !== "undefined" || this.isMessage && typeof this.options.reply === "undefined" || this.isMessageManager) {
          flags = this.options.flags != null ? new MessageFlags(this.options.flags).bitfield : (_b = this.target.flags) == null ? void 0 : _b.bitfield;
        }
        if (isInteraction && this.options.ephemeral) {
          flags |= MessageFlags.FLAGS.EPHEMERAL;
        }
        let allowedMentions = typeof this.options.allowedMentions === "undefined" ? this.target.client.options.allowedMentions : this.options.allowedMentions;
        if (allowedMentions) {
          allowedMentions = Util.cloneObject(allowedMentions);
          allowedMentions.replied_user = allowedMentions.repliedUser;
          delete allowedMentions.repliedUser;
        }
        let message_reference;
        if (typeof this.options.reply === "object") {
          const reference = this.options.reply.messageReference;
          const message_id = this.isMessage ? reference.id ?? reference : this.target.messages.resolveId(reference);
          if (message_id) {
            message_reference = {
              message_id,
              type: MessageReferenceTypes.DEFAULT,
              fail_if_not_exists: this.options.reply.failIfNotExists ?? this.target.client.options.failIfNotExists
            };
          }
        }
        if (typeof this.options.forward === "object") {
          message_reference = this.options.forward;
          message_reference.type = MessageReferenceTypes.FORWARD;
        }
        const attachments = (_c = this.options.files) == null ? void 0 : _c.map((file, index) => ({
          id: index.toString(),
          description: file.description
        }));
        if (Array.isArray(this.options.attachments)) {
          this.options.attachments.push(...attachments ?? []);
        } else {
          this.options.attachments = attachments;
        }
        let activity;
        if (this.options.activity instanceof Object && typeof this.options.activity.partyId == "string" && this.options.activity.type) {
          const type = ActivityFlags.resolve(this.options.activity.type);
          const sessionId = this.target.client.sessionId;
          const partyId = this.options.activity.partyId;
          activity = {
            type,
            party_id: partyId,
            session_id: sessionId
          };
        }
        let poll;
        if (this.options.poll) {
          poll = {
            question: {
              text: this.options.poll.question.text
            },
            answers: this.options.poll.answers.map((answer) => ({
              poll_media: { text: answer.text, emoji: Util.resolvePartialEmoji(answer.emoji) }
            })),
            duration: this.options.poll.duration,
            allow_multiselect: this.options.poll.allowMultiselect,
            layout_type: typeof this.options.poll.layoutType == "number" ? this.options.poll.layoutType : PollLayoutTypes[this.options.poll.layoutType]
          };
        }
        this.data = {
          activity,
          content,
          tts,
          nonce,
          embeds: (_d = this.options.embeds) == null ? void 0 : _d.map((embed) => new MessageEmbed(embed).toJSON()),
          components,
          username,
          avatar_url: avatarURL,
          allowed_mentions: typeof content === "undefined" && typeof message_reference === "undefined" ? void 0 : allowedMentions,
          flags,
          message_reference,
          attachments: this.options.attachments,
          sticker_ids: (_e = this.options.stickers) == null ? void 0 : _e.map((sticker) => sticker.id ?? sticker),
          thread_name: threadName,
          applied_tags: appliedTags,
          poll
        };
        return this;
      }
      /**
       * Resolves files.
       * @returns {Promise<MessagePayload>}
       */
      async resolveFiles() {
        var _a;
        if (this.files) return this;
        this.files = await Promise.all(((_a = this.options.files) == null ? void 0 : _a.map((file) => this.constructor.resolveFile(file))) ?? []);
        return this;
      }
      /**
       * Resolves a single file into an object sendable to the API.
       * @param {BufferResolvable|Stream|FileOptions|MessageAttachment} fileLike Something that could be resolved to a file
       * @returns {Promise<MessageFile>}
       */
      static async resolveFile(fileLike) {
        let attachment;
        let name;
        const findName = (thing) => {
          if (typeof thing === "string") {
            return Util.basename(thing);
          }
          if (thing.path) {
            return Util.basename(thing.path);
          }
          return "file.jpg";
        };
        const ownAttachment = typeof fileLike === "string" || fileLike instanceof Buffer2 || typeof fileLike.pipe === "function";
        if (ownAttachment) {
          attachment = fileLike;
          name = findName(attachment);
        } else {
          attachment = fileLike.attachment;
          name = fileLike.name ?? findName(attachment);
        }
        const resource = await DataResolver2.resolveFile(attachment);
        return {
          attachment,
          name,
          file: resource,
          description: fileLike.description,
          duration_secs: fileLike.duration,
          waveform: fileLike.waveform
        };
      }
      /**
       * Creates a {@link MessagePayload} from user-level arguments.
       * @param {MessageTarget} target Target to send to
       * @param {string|MessageOptions|WebhookMessageOptions} options Options or content to use
       * @param {MessageOptions|WebhookMessageOptions} [extra={}] Extra options to add onto specified options
       * @returns {MessagePayload}
       */
      static create(target, options, extra = {}) {
        return new this(
          target,
          typeof options !== "object" || options === null ? { content: options, ...extra } : { ...options, ...extra }
        );
      }
    };
    module2.exports = MessagePayload;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/@sapphire/shapeshift/dist/cjs/index.cjs
var require_cjs3 = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/@sapphire/shapeshift/dist/cjs/index.cjs"(exports2) {
    "use strict";
    var get = require_get();
    var fastDeepEqual = require_es6();
    var uniqWith = require_uniqWith();
    function _interopDefault(e3) {
      return e3 && e3.__esModule ? e3 : { default: e3 };
    }
    var get__default = _interopDefault(get);
    var fastDeepEqual__default = _interopDefault(fastDeepEqual);
    var uniqWith__default = _interopDefault(uniqWith);
    var __defProp = Object.defineProperty;
    var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
    var validationEnabled = true;
    function setGlobalValidationEnabled(enabled) {
      validationEnabled = enabled;
    }
    __name(setGlobalValidationEnabled, "setGlobalValidationEnabled");
    function getGlobalValidationEnabled() {
      return validationEnabled;
    }
    __name(getGlobalValidationEnabled, "getGlobalValidationEnabled");
    var _Result = class _Result2 {
      constructor(success, value, error2) {
        this.success = success;
        if (success) {
          this.value = value;
        } else {
          this.error = error2;
        }
      }
      isOk() {
        return this.success;
      }
      isErr() {
        return !this.success;
      }
      unwrap() {
        if (this.isOk())
          return this.value;
        throw this.error;
      }
      static ok(value) {
        return new _Result2(true, value);
      }
      static err(error2) {
        return new _Result2(false, void 0, error2);
      }
    };
    __name(_Result, "Result");
    var Result = _Result;
    function getValue(valueOrFn) {
      return typeof valueOrFn === "function" ? valueOrFn() : valueOrFn;
    }
    __name(getValue, "getValue");
    var e;
    var t;
    var n;
    var r = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : globalThis;
    var o = e = {};
    function i() {
      throw new Error("setTimeout has not been defined");
    }
    __name(i, "i");
    function u() {
      throw new Error("clearTimeout has not been defined");
    }
    __name(u, "u");
    function c(e3) {
      if (t === setTimeout)
        return setTimeout(e3, 0);
      if ((t === i || !t) && setTimeout)
        return t = setTimeout, setTimeout(e3, 0);
      try {
        return t(e3, 0);
      } catch (n3) {
        try {
          return t.call(null, e3, 0);
        } catch (n4) {
          return t.call(this || r, e3, 0);
        }
      }
    }
    __name(c, "c");
    !function() {
      try {
        t = "function" == typeof setTimeout ? setTimeout : i;
      } catch (e3) {
        t = i;
      }
      try {
        n = "function" == typeof clearTimeout ? clearTimeout : u;
      } catch (e3) {
        n = u;
      }
    }();
    var l;
    var s = [];
    var f = false;
    var a = -1;
    function h() {
      f && l && (f = false, l.length ? s = l.concat(s) : a = -1, s.length && d());
    }
    __name(h, "h");
    function d() {
      if (!f) {
        var e3 = c(h);
        f = true;
        for (var t3 = s.length; t3; ) {
          for (l = s, s = []; ++a < t3; )
            l && l[a].run();
          a = -1, t3 = s.length;
        }
        l = null, f = false, function(e4) {
          if (n === clearTimeout)
            return clearTimeout(e4);
          if ((n === u || !n) && clearTimeout)
            return n = clearTimeout, clearTimeout(e4);
          try {
            n(e4);
          } catch (t4) {
            try {
              return n.call(null, e4);
            } catch (t5) {
              return n.call(this || r, e4);
            }
          }
        }(e3);
      }
    }
    __name(d, "d");
    function m(e3, t3) {
      (this || r).fun = e3, (this || r).array = t3;
    }
    __name(m, "m");
    function p() {
    }
    __name(p, "p");
    o.nextTick = function(e3) {
      var t3 = new Array(arguments.length - 1);
      if (arguments.length > 1)
        for (var n3 = 1; n3 < arguments.length; n3++)
          t3[n3 - 1] = arguments[n3];
      s.push(new m(e3, t3)), 1 !== s.length || f || c(d);
    }, m.prototype.run = function() {
      (this || r).fun.apply(null, (this || r).array);
    }, o.title = "browser", o.browser = true, o.env = {}, o.argv = [], o.version = "", o.versions = {}, o.on = p, o.addListener = p, o.once = p, o.off = p, o.removeListener = p, o.removeAllListeners = p, o.emit = p, o.prependListener = p, o.prependOnceListener = p, o.listeners = function(e3) {
      return [];
    }, o.binding = function(e3) {
      throw new Error("process.binding is not supported");
    }, o.cwd = function() {
      return "/";
    }, o.chdir = function(e3) {
      throw new Error("process.chdir is not supported");
    }, o.umask = function() {
      return 0;
    };
    var T = e;
    T.addListener;
    T.argv;
    T.binding;
    T.browser;
    T.chdir;
    T.cwd;
    T.emit;
    T.env;
    T.listeners;
    T.nextTick;
    T.off;
    T.on;
    T.once;
    T.prependListener;
    T.prependOnceListener;
    T.removeAllListeners;
    T.removeListener;
    T.title;
    T.umask;
    T.version;
    T.versions;
    var t2 = "function" == typeof Symbol && "symbol" == typeof Symbol.toStringTag;
    var e2 = Object.prototype.toString;
    var o2 = __name(function(o3) {
      return !(t2 && o3 && "object" == typeof o3 && Symbol.toStringTag in o3) && "[object Arguments]" === e2.call(o3);
    }, "o");
    var n2 = __name(function(t3) {
      return !!o2(t3) || null !== t3 && "object" == typeof t3 && "number" == typeof t3.length && t3.length >= 0 && "[object Array]" !== e2.call(t3) && "[object Function]" === e2.call(t3.callee);
    }, "n");
    var r2 = function() {
      return o2(arguments);
    }();
    o2.isLegacyArguments = n2;
    var l2 = r2 ? o2 : n2;
    var t$1 = Object.prototype.toString;
    var o$1 = Function.prototype.toString;
    var n$1 = /^\s*(?:function)?\*/;
    var e$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.toStringTag;
    var r$1 = Object.getPrototypeOf;
    var c2 = function() {
      if (!e$1)
        return false;
      try {
        return Function("return function*() {}")();
      } catch (t3) {
      }
    }();
    var u2 = c2 ? r$1(c2) : {};
    var i2 = __name(function(c3) {
      return "function" == typeof c3 && (!!n$1.test(o$1.call(c3)) || (e$1 ? r$1(c3) === u2 : "[object GeneratorFunction]" === t$1.call(c3)));
    }, "i");
    var t$2 = "function" == typeof Object.create ? function(t3, e3) {
      e3 && (t3.super_ = e3, t3.prototype = Object.create(e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }));
    } : function(t3, e3) {
      if (e3) {
        t3.super_ = e3;
        var o3 = __name(function() {
        }, "o");
        o3.prototype = e3.prototype, t3.prototype = new o3(), t3.prototype.constructor = t3;
      }
    };
    var i$1 = __name(function(e3) {
      return e3 && "object" == typeof e3 && "function" == typeof e3.copy && "function" == typeof e3.fill && "function" == typeof e3.readUInt8;
    }, "i$1");
    var o$2 = {};
    var u$1 = i$1;
    var f2 = l2;
    var a2 = i2;
    function c$1(e3) {
      return e3.call.bind(e3);
    }
    __name(c$1, "c$1");
    var s2 = "undefined" != typeof BigInt;
    var p2 = "undefined" != typeof Symbol;
    var y = p2 && void 0 !== Symbol.toStringTag;
    var l$1 = "undefined" != typeof Uint8Array;
    var d2 = "undefined" != typeof ArrayBuffer;
    if (l$1 && y)
      var g = Object.getPrototypeOf(Uint8Array.prototype), b = c$1(Object.getOwnPropertyDescriptor(g, Symbol.toStringTag).get);
    var m2 = c$1(Object.prototype.toString);
    var h2 = c$1(Number.prototype.valueOf);
    var j = c$1(String.prototype.valueOf);
    var A = c$1(Boolean.prototype.valueOf);
    if (s2)
      var w = c$1(BigInt.prototype.valueOf);
    if (p2)
      var v = c$1(Symbol.prototype.valueOf);
    function O(e3, t3) {
      if ("object" != typeof e3)
        return false;
      try {
        return t3(e3), true;
      } catch (e4) {
        return false;
      }
    }
    __name(O, "O");
    function S(e3) {
      return l$1 && y ? void 0 !== b(e3) : B(e3) || k(e3) || E(e3) || D(e3) || U(e3) || P(e3) || x(e3) || I(e3) || M(e3) || z(e3) || F(e3);
    }
    __name(S, "S");
    function B(e3) {
      return l$1 && y ? "Uint8Array" === b(e3) : "[object Uint8Array]" === m2(e3) || u$1(e3) && void 0 !== e3.buffer;
    }
    __name(B, "B");
    function k(e3) {
      return l$1 && y ? "Uint8ClampedArray" === b(e3) : "[object Uint8ClampedArray]" === m2(e3);
    }
    __name(k, "k");
    function E(e3) {
      return l$1 && y ? "Uint16Array" === b(e3) : "[object Uint16Array]" === m2(e3);
    }
    __name(E, "E");
    function D(e3) {
      return l$1 && y ? "Uint32Array" === b(e3) : "[object Uint32Array]" === m2(e3);
    }
    __name(D, "D");
    function U(e3) {
      return l$1 && y ? "Int8Array" === b(e3) : "[object Int8Array]" === m2(e3);
    }
    __name(U, "U");
    function P(e3) {
      return l$1 && y ? "Int16Array" === b(e3) : "[object Int16Array]" === m2(e3);
    }
    __name(P, "P");
    function x(e3) {
      return l$1 && y ? "Int32Array" === b(e3) : "[object Int32Array]" === m2(e3);
    }
    __name(x, "x");
    function I(e3) {
      return l$1 && y ? "Float32Array" === b(e3) : "[object Float32Array]" === m2(e3);
    }
    __name(I, "I");
    function M(e3) {
      return l$1 && y ? "Float64Array" === b(e3) : "[object Float64Array]" === m2(e3);
    }
    __name(M, "M");
    function z(e3) {
      return l$1 && y ? "BigInt64Array" === b(e3) : "[object BigInt64Array]" === m2(e3);
    }
    __name(z, "z");
    function F(e3) {
      return l$1 && y ? "BigUint64Array" === b(e3) : "[object BigUint64Array]" === m2(e3);
    }
    __name(F, "F");
    function T2(e3) {
      return "[object Map]" === m2(e3);
    }
    __name(T2, "T");
    function N(e3) {
      return "[object Set]" === m2(e3);
    }
    __name(N, "N");
    function W(e3) {
      return "[object WeakMap]" === m2(e3);
    }
    __name(W, "W");
    function $(e3) {
      return "[object WeakSet]" === m2(e3);
    }
    __name($, "$");
    function C(e3) {
      return "[object ArrayBuffer]" === m2(e3);
    }
    __name(C, "C");
    function V(e3) {
      return "undefined" != typeof ArrayBuffer && (C.working ? C(e3) : e3 instanceof ArrayBuffer);
    }
    __name(V, "V");
    function G(e3) {
      return "[object DataView]" === m2(e3);
    }
    __name(G, "G");
    function R(e3) {
      return "undefined" != typeof DataView && (G.working ? G(e3) : e3 instanceof DataView);
    }
    __name(R, "R");
    function J(e3) {
      return "[object SharedArrayBuffer]" === m2(e3);
    }
    __name(J, "J");
    function _(e3) {
      return "undefined" != typeof SharedArrayBuffer && (J.working ? J(e3) : e3 instanceof SharedArrayBuffer);
    }
    __name(_, "_");
    function H(e3) {
      return O(e3, h2);
    }
    __name(H, "H");
    function Z(e3) {
      return O(e3, j);
    }
    __name(Z, "Z");
    function q(e3) {
      return O(e3, A);
    }
    __name(q, "q");
    function K(e3) {
      return s2 && O(e3, w);
    }
    __name(K, "K");
    function L(e3) {
      return p2 && O(e3, v);
    }
    __name(L, "L");
    o$2.isArgumentsObject = f2, o$2.isGeneratorFunction = a2, o$2.isPromise = function(e3) {
      return "undefined" != typeof Promise && e3 instanceof Promise || null !== e3 && "object" == typeof e3 && "function" == typeof e3.then && "function" == typeof e3.catch;
    }, o$2.isArrayBufferView = function(e3) {
      return d2 && ArrayBuffer.isView ? ArrayBuffer.isView(e3) : S(e3) || R(e3);
    }, o$2.isTypedArray = S, o$2.isUint8Array = B, o$2.isUint8ClampedArray = k, o$2.isUint16Array = E, o$2.isUint32Array = D, o$2.isInt8Array = U, o$2.isInt16Array = P, o$2.isInt32Array = x, o$2.isFloat32Array = I, o$2.isFloat64Array = M, o$2.isBigInt64Array = z, o$2.isBigUint64Array = F, T2.working = "undefined" != typeof Map && T2(/* @__PURE__ */ new Map()), o$2.isMap = function(e3) {
      return "undefined" != typeof Map && (T2.working ? T2(e3) : e3 instanceof Map);
    }, N.working = "undefined" != typeof Set && N(/* @__PURE__ */ new Set()), o$2.isSet = function(e3) {
      return "undefined" != typeof Set && (N.working ? N(e3) : e3 instanceof Set);
    }, W.working = "undefined" != typeof WeakMap && W(/* @__PURE__ */ new WeakMap()), o$2.isWeakMap = function(e3) {
      return "undefined" != typeof WeakMap && (W.working ? W(e3) : e3 instanceof WeakMap);
    }, $.working = "undefined" != typeof WeakSet && $(/* @__PURE__ */ new WeakSet()), o$2.isWeakSet = function(e3) {
      return $(e3);
    }, C.working = "undefined" != typeof ArrayBuffer && C(new ArrayBuffer()), o$2.isArrayBuffer = V, G.working = "undefined" != typeof ArrayBuffer && "undefined" != typeof DataView && G(new DataView(new ArrayBuffer(1), 0, 1)), o$2.isDataView = R, J.working = "undefined" != typeof SharedArrayBuffer && J(new SharedArrayBuffer()), o$2.isSharedArrayBuffer = _, o$2.isAsyncFunction = function(e3) {
      return "[object AsyncFunction]" === m2(e3);
    }, o$2.isMapIterator = function(e3) {
      return "[object Map Iterator]" === m2(e3);
    }, o$2.isSetIterator = function(e3) {
      return "[object Set Iterator]" === m2(e3);
    }, o$2.isGeneratorObject = function(e3) {
      return "[object Generator]" === m2(e3);
    }, o$2.isWebAssemblyCompiledModule = function(e3) {
      return "[object WebAssembly.Module]" === m2(e3);
    }, o$2.isNumberObject = H, o$2.isStringObject = Z, o$2.isBooleanObject = q, o$2.isBigIntObject = K, o$2.isSymbolObject = L, o$2.isBoxedPrimitive = function(e3) {
      return H(e3) || Z(e3) || q(e3) || K(e3) || L(e3);
    }, o$2.isAnyArrayBuffer = function(e3) {
      return l$1 && (V(e3) || _(e3));
    }, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(e3) {
      Object.defineProperty(o$2, e3, { enumerable: false, value: function() {
        throw new Error(e3 + " is not supported in userland");
      } });
    });
    var Q = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : globalThis;
    var X = {};
    var Y = T;
    var ee = Object.getOwnPropertyDescriptors || function(e3) {
      for (var t3 = Object.keys(e3), r3 = {}, n3 = 0; n3 < t3.length; n3++)
        r3[t3[n3]] = Object.getOwnPropertyDescriptor(e3, t3[n3]);
      return r3;
    };
    var te = /%[sdj%]/g;
    X.format = function(e3) {
      if (!ge(e3)) {
        for (var t3 = [], r3 = 0; r3 < arguments.length; r3++)
          t3.push(oe(arguments[r3]));
        return t3.join(" ");
      }
      r3 = 1;
      for (var n3 = arguments, i3 = n3.length, o3 = String(e3).replace(te, function(e4) {
        if ("%%" === e4)
          return "%";
        if (r3 >= i3)
          return e4;
        switch (e4) {
          case "%s":
            return String(n3[r3++]);
          case "%d":
            return Number(n3[r3++]);
          case "%j":
            try {
              return JSON.stringify(n3[r3++]);
            } catch (e5) {
              return "[Circular]";
            }
          default:
            return e4;
        }
      }), u3 = n3[r3]; r3 < i3; u3 = n3[++r3])
        le(u3) || !he(u3) ? o3 += " " + u3 : o3 += " " + oe(u3);
      return o3;
    }, X.deprecate = function(e3, t3) {
      if (void 0 !== Y && true === Y.noDeprecation)
        return e3;
      if (void 0 === Y)
        return function() {
          return X.deprecate(e3, t3).apply(this || Q, arguments);
        };
      var r3 = false;
      return function() {
        if (!r3) {
          if (Y.throwDeprecation)
            throw new Error(t3);
          Y.traceDeprecation ? console.trace(t3) : console.error(t3), r3 = true;
        }
        return e3.apply(this || Q, arguments);
      };
    };
    var re = {};
    var ne = /^$/;
    if (Y.env.NODE_DEBUG) {
      ie = Y.env.NODE_DEBUG;
      ie = ie.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), ne = new RegExp("^" + ie + "$", "i");
    }
    var ie;
    function oe(e3, t3) {
      var r3 = { seen: [], stylize: fe };
      return arguments.length >= 3 && (r3.depth = arguments[2]), arguments.length >= 4 && (r3.colors = arguments[3]), ye(t3) ? r3.showHidden = t3 : t3 && X._extend(r3, t3), be(r3.showHidden) && (r3.showHidden = false), be(r3.depth) && (r3.depth = 2), be(r3.colors) && (r3.colors = false), be(r3.customInspect) && (r3.customInspect = true), r3.colors && (r3.stylize = ue), ae(r3, e3, r3.depth);
    }
    __name(oe, "oe");
    function ue(e3, t3) {
      var r3 = oe.styles[t3];
      return r3 ? "\x1B[" + oe.colors[r3][0] + "m" + e3 + "\x1B[" + oe.colors[r3][1] + "m" : e3;
    }
    __name(ue, "ue");
    function fe(e3, t3) {
      return e3;
    }
    __name(fe, "fe");
    function ae(e3, t3, r3) {
      if (e3.customInspect && t3 && we(t3.inspect) && t3.inspect !== X.inspect && (!t3.constructor || t3.constructor.prototype !== t3)) {
        var n3 = t3.inspect(r3, e3);
        return ge(n3) || (n3 = ae(e3, n3, r3)), n3;
      }
      var i3 = function(e4, t4) {
        if (be(t4))
          return e4.stylize("undefined", "undefined");
        if (ge(t4)) {
          var r4 = "'" + JSON.stringify(t4).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
          return e4.stylize(r4, "string");
        }
        if (de(t4))
          return e4.stylize("" + t4, "number");
        if (ye(t4))
          return e4.stylize("" + t4, "boolean");
        if (le(t4))
          return e4.stylize("null", "null");
      }(e3, t3);
      if (i3)
        return i3;
      var o3 = Object.keys(t3), u3 = function(e4) {
        var t4 = {};
        return e4.forEach(function(e5, r4) {
          t4[e5] = true;
        }), t4;
      }(o3);
      if (e3.showHidden && (o3 = Object.getOwnPropertyNames(t3)), Ae(t3) && (o3.indexOf("message") >= 0 || o3.indexOf("description") >= 0))
        return ce(t3);
      if (0 === o3.length) {
        if (we(t3)) {
          var f3 = t3.name ? ": " + t3.name : "";
          return e3.stylize("[Function" + f3 + "]", "special");
        }
        if (me(t3))
          return e3.stylize(RegExp.prototype.toString.call(t3), "regexp");
        if (je(t3))
          return e3.stylize(Date.prototype.toString.call(t3), "date");
        if (Ae(t3))
          return ce(t3);
      }
      var a3, c3 = "", s4 = false, p3 = ["{", "}"];
      (pe(t3) && (s4 = true, p3 = ["[", "]"]), we(t3)) && (c3 = " [Function" + (t3.name ? ": " + t3.name : "") + "]");
      return me(t3) && (c3 = " " + RegExp.prototype.toString.call(t3)), je(t3) && (c3 = " " + Date.prototype.toUTCString.call(t3)), Ae(t3) && (c3 = " " + ce(t3)), 0 !== o3.length || s4 && 0 != t3.length ? r3 < 0 ? me(t3) ? e3.stylize(RegExp.prototype.toString.call(t3), "regexp") : e3.stylize("[Object]", "special") : (e3.seen.push(t3), a3 = s4 ? function(e4, t4, r4, n4, i4) {
        for (var o4 = [], u4 = 0, f4 = t4.length; u4 < f4; ++u4)
          ke(t4, String(u4)) ? o4.push(se(e4, t4, r4, n4, String(u4), true)) : o4.push("");
        return i4.forEach(function(i5) {
          i5.match(/^\d+$/) || o4.push(se(e4, t4, r4, n4, i5, true));
        }), o4;
      }(e3, t3, r3, u3, o3) : o3.map(function(n4) {
        return se(e3, t3, r3, u3, n4, s4);
      }), e3.seen.pop(), function(e4, t4, r4) {
        var n4 = 0;
        if (e4.reduce(function(e5, t5) {
          return n4++, t5.indexOf("\n") >= 0 && n4++, e5 + t5.replace(/\u001b\[\d\d?m/g, "").length + 1;
        }, 0) > 60)
          return r4[0] + ("" === t4 ? "" : t4 + "\n ") + " " + e4.join(",\n  ") + " " + r4[1];
        return r4[0] + t4 + " " + e4.join(", ") + " " + r4[1];
      }(a3, c3, p3)) : p3[0] + c3 + p3[1];
    }
    __name(ae, "ae");
    function ce(e3) {
      return "[" + Error.prototype.toString.call(e3) + "]";
    }
    __name(ce, "ce");
    function se(e3, t3, r3, n3, i3, o3) {
      var u3, f3, a3;
      if ((a3 = Object.getOwnPropertyDescriptor(t3, i3) || { value: t3[i3] }).get ? f3 = a3.set ? e3.stylize("[Getter/Setter]", "special") : e3.stylize("[Getter]", "special") : a3.set && (f3 = e3.stylize("[Setter]", "special")), ke(n3, i3) || (u3 = "[" + i3 + "]"), f3 || (e3.seen.indexOf(a3.value) < 0 ? (f3 = le(r3) ? ae(e3, a3.value, null) : ae(e3, a3.value, r3 - 1)).indexOf("\n") > -1 && (f3 = o3 ? f3.split("\n").map(function(e4) {
        return "  " + e4;
      }).join("\n").substr(2) : "\n" + f3.split("\n").map(function(e4) {
        return "   " + e4;
      }).join("\n")) : f3 = e3.stylize("[Circular]", "special")), be(u3)) {
        if (o3 && i3.match(/^\d+$/))
          return f3;
        (u3 = JSON.stringify("" + i3)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (u3 = u3.substr(1, u3.length - 2), u3 = e3.stylize(u3, "name")) : (u3 = u3.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), u3 = e3.stylize(u3, "string"));
      }
      return u3 + ": " + f3;
    }
    __name(se, "se");
    function pe(e3) {
      return Array.isArray(e3);
    }
    __name(pe, "pe");
    function ye(e3) {
      return "boolean" == typeof e3;
    }
    __name(ye, "ye");
    function le(e3) {
      return null === e3;
    }
    __name(le, "le");
    function de(e3) {
      return "number" == typeof e3;
    }
    __name(de, "de");
    function ge(e3) {
      return "string" == typeof e3;
    }
    __name(ge, "ge");
    function be(e3) {
      return void 0 === e3;
    }
    __name(be, "be");
    function me(e3) {
      return he(e3) && "[object RegExp]" === ve(e3);
    }
    __name(me, "me");
    function he(e3) {
      return "object" == typeof e3 && null !== e3;
    }
    __name(he, "he");
    function je(e3) {
      return he(e3) && "[object Date]" === ve(e3);
    }
    __name(je, "je");
    function Ae(e3) {
      return he(e3) && ("[object Error]" === ve(e3) || e3 instanceof Error);
    }
    __name(Ae, "Ae");
    function we(e3) {
      return "function" == typeof e3;
    }
    __name(we, "we");
    function ve(e3) {
      return Object.prototype.toString.call(e3);
    }
    __name(ve, "ve");
    function Oe(e3) {
      return e3 < 10 ? "0" + e3.toString(10) : e3.toString(10);
    }
    __name(Oe, "Oe");
    X.debuglog = function(e3) {
      if (e3 = e3.toUpperCase(), !re[e3])
        if (ne.test(e3)) {
          var t3 = Y.pid;
          re[e3] = function() {
            var r3 = X.format.apply(X, arguments);
            console.error("%s %d: %s", e3, t3, r3);
          };
        } else
          re[e3] = function() {
          };
      return re[e3];
    }, X.inspect = oe, oe.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, oe.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" }, X.types = o$2, X.isArray = pe, X.isBoolean = ye, X.isNull = le, X.isNullOrUndefined = function(e3) {
      return null == e3;
    }, X.isNumber = de, X.isString = ge, X.isSymbol = function(e3) {
      return "symbol" == typeof e3;
    }, X.isUndefined = be, X.isRegExp = me, X.types.isRegExp = me, X.isObject = he, X.isDate = je, X.types.isDate = je, X.isError = Ae, X.types.isNativeError = Ae, X.isFunction = we, X.isPrimitive = function(e3) {
      return null === e3 || "boolean" == typeof e3 || "number" == typeof e3 || "string" == typeof e3 || "symbol" == typeof e3 || void 0 === e3;
    }, X.isBuffer = i$1;
    var Se = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    function Be() {
      var e3 = /* @__PURE__ */ new Date(), t3 = [Oe(e3.getHours()), Oe(e3.getMinutes()), Oe(e3.getSeconds())].join(":");
      return [e3.getDate(), Se[e3.getMonth()], t3].join(" ");
    }
    __name(Be, "Be");
    function ke(e3, t3) {
      return Object.prototype.hasOwnProperty.call(e3, t3);
    }
    __name(ke, "ke");
    X.log = function() {
      console.log("%s - %s", Be(), X.format.apply(X, arguments));
    }, X.inherits = t$2, X._extend = function(e3, t3) {
      if (!t3 || !he(t3))
        return e3;
      for (var r3 = Object.keys(t3), n3 = r3.length; n3--; )
        e3[r3[n3]] = t3[r3[n3]];
      return e3;
    };
    var Ee = "undefined" != typeof Symbol ? Symbol("util.promisify.custom") : void 0;
    function De(e3, t3) {
      if (!e3) {
        var r3 = new Error("Promise was rejected with a falsy value");
        r3.reason = e3, e3 = r3;
      }
      return t3(e3);
    }
    __name(De, "De");
    X.promisify = function(e3) {
      if ("function" != typeof e3)
        throw new TypeError('The "original" argument must be of type Function');
      if (Ee && e3[Ee]) {
        var t3;
        if ("function" != typeof (t3 = e3[Ee]))
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        return Object.defineProperty(t3, Ee, { value: t3, enumerable: false, writable: false, configurable: true }), t3;
      }
      function t3() {
        for (var t4, r3, n3 = new Promise(function(e4, n4) {
          t4 = e4, r3 = n4;
        }), i3 = [], o3 = 0; o3 < arguments.length; o3++)
          i3.push(arguments[o3]);
        i3.push(function(e4, n4) {
          e4 ? r3(e4) : t4(n4);
        });
        try {
          e3.apply(this || Q, i3);
        } catch (e4) {
          r3(e4);
        }
        return n3;
      }
      __name(t3, "t");
      return Object.setPrototypeOf(t3, Object.getPrototypeOf(e3)), Ee && Object.defineProperty(t3, Ee, { value: t3, enumerable: false, writable: false, configurable: true }), Object.defineProperties(t3, ee(e3));
    }, X.promisify.custom = Ee, X.callbackify = function(e3) {
      if ("function" != typeof e3)
        throw new TypeError('The "original" argument must be of type Function');
      function t3() {
        for (var t4 = [], r3 = 0; r3 < arguments.length; r3++)
          t4.push(arguments[r3]);
        var n3 = t4.pop();
        if ("function" != typeof n3)
          throw new TypeError("The last argument must be of type Function");
        var i3 = this || Q, o3 = __name(function() {
          return n3.apply(i3, arguments);
        }, "o");
        e3.apply(this || Q, t4).then(function(e4) {
          Y.nextTick(o3.bind(null, null, e4));
        }, function(e4) {
          Y.nextTick(De.bind(null, e4, o3));
        });
      }
      __name(t3, "t");
      return Object.setPrototypeOf(t3, Object.getPrototypeOf(e3)), Object.defineProperties(t3, ee(e3)), t3;
    };
    X._extend;
    X.callbackify;
    X.debuglog;
    X.deprecate;
    X.format;
    X.inherits;
    X.inspect;
    X.isArray;
    X.isBoolean;
    X.isBuffer;
    X.isDate;
    X.isError;
    X.isFunction;
    X.isNull;
    X.isNullOrUndefined;
    X.isNumber;
    X.isObject;
    X.isPrimitive;
    X.isRegExp;
    X.isString;
    X.isSymbol;
    X.isUndefined;
    X.log;
    X.promisify;
    X._extend;
    X.callbackify;
    X.debuglog;
    X.deprecate;
    X.format;
    X.inherits;
    X.inspect;
    X.isArray;
    X.isBoolean;
    X.isBuffer;
    X.isDate;
    X.isError;
    X.isFunction;
    X.isNull;
    X.isNullOrUndefined;
    X.isNumber;
    X.isObject;
    X.isPrimitive;
    X.isRegExp;
    X.isString;
    X.isSymbol;
    X.isUndefined;
    X.log;
    X.promisify;
    X.types;
    X._extend;
    X.callbackify;
    X.debuglog;
    X.deprecate;
    X.format;
    X.inherits;
    var inspect2 = X.inspect;
    X.isArray;
    X.isBoolean;
    X.isBuffer;
    X.isDate;
    X.isError;
    X.isFunction;
    X.isNull;
    X.isNullOrUndefined;
    X.isNumber;
    X.isObject;
    X.isPrimitive;
    X.isRegExp;
    X.isString;
    X.isSymbol;
    X.isUndefined;
    X.log;
    X.promisify;
    X.types;
    X.TextEncoder = globalThis.TextEncoder;
    X.TextDecoder = globalThis.TextDecoder;
    var customInspectSymbol = Symbol.for("nodejs.util.inspect.custom");
    var customInspectSymbolStackLess = Symbol.for("nodejs.util.inspect.custom.stack-less");
    var _BaseError = class _BaseError extends Error {
      [customInspectSymbol](depth, options) {
        return `${this[customInspectSymbolStackLess](depth, options)}
${this.stack.slice(this.stack.indexOf("\n"))}`;
      }
    };
    __name(_BaseError, "BaseError");
    var BaseError = _BaseError;
    var _BaseConstraintError = class _BaseConstraintError extends BaseError {
      constructor(constraint, message, given) {
        super(message);
        this.constraint = constraint;
        this.given = given;
      }
    };
    __name(_BaseConstraintError, "BaseConstraintError");
    var BaseConstraintError = _BaseConstraintError;
    var _ExpectedConstraintError = class _ExpectedConstraintError extends BaseConstraintError {
      constructor(constraint, message, given, expected) {
        super(constraint, message, given);
        this.expected = expected;
      }
      toJSON() {
        return {
          name: this.name,
          constraint: this.constraint,
          given: this.given,
          expected: this.expected
        };
      }
      [customInspectSymbolStackLess](depth, options) {
        const constraint = options.stylize(this.constraint, "string");
        if (depth < 0) {
          return options.stylize(`[ExpectedConstraintError: ${constraint}]`, "special");
        }
        const newOptions = { ...options, depth: options.depth === null ? null : options.depth - 1 };
        const padding = `
  ${options.stylize("|", "undefined")} `;
        const given = inspect2(this.given, newOptions).replace(/\n/g, padding);
        const header = `${options.stylize("ExpectedConstraintError", "special")} > ${constraint}`;
        const message = options.stylize(this.message, "regexp");
        const expectedBlock = `
  ${options.stylize("Expected: ", "string")}${options.stylize(this.expected, "boolean")}`;
        const givenBlock = `
  ${options.stylize("Received:", "regexp")}${padding}${given}`;
        return `${header}
  ${message}
${expectedBlock}
${givenBlock}`;
      }
    };
    __name(_ExpectedConstraintError, "ExpectedConstraintError");
    var ExpectedConstraintError = _ExpectedConstraintError;
    function whenConstraint(key, options, validator) {
      return {
        run(input, parent) {
          if (!parent) {
            return Result.err(new ExpectedConstraintError("s.object(T.when)", "Validator has no parent", parent, "Validator to have a parent"));
          }
          const isKeyArray = Array.isArray(key);
          const value = isKeyArray ? key.map((k2) => get__default.default(parent, k2)) : get__default.default(parent, key);
          const predicate = resolveBooleanIs(options, value, isKeyArray) ? options.then : options.otherwise;
          if (predicate) {
            return predicate(validator).run(input);
          }
          return Result.ok(input);
        }
      };
    }
    __name(whenConstraint, "whenConstraint");
    function resolveBooleanIs(options, value, isKeyArray) {
      if (options.is === void 0) {
        return isKeyArray ? !value.some((val) => !val) : Boolean(value);
      }
      if (typeof options.is === "function") {
        return options.is(value);
      }
      return value === options.is;
    }
    __name(resolveBooleanIs, "resolveBooleanIs");
    var _BaseValidator = class _BaseValidator {
      constructor(constraints = []) {
        this.constraints = [];
        this.isValidationEnabled = null;
        this.constraints = constraints;
      }
      setParent(parent) {
        this.parent = parent;
        return this;
      }
      get optional() {
        return new UnionValidator([new LiteralValidator(void 0), this.clone()]);
      }
      get nullable() {
        return new UnionValidator([new LiteralValidator(null), this.clone()]);
      }
      get nullish() {
        return new UnionValidator([new NullishValidator(), this.clone()]);
      }
      get array() {
        return new ArrayValidator(this.clone());
      }
      get set() {
        return new SetValidator(this.clone());
      }
      or(...predicates) {
        return new UnionValidator([this.clone(), ...predicates]);
      }
      transform(cb) {
        return this.addConstraint({ run: (input) => Result.ok(cb(input)) });
      }
      reshape(cb) {
        return this.addConstraint({ run: cb });
      }
      default(value) {
        return new DefaultValidator(this.clone(), value);
      }
      when(key, options) {
        return this.addConstraint(whenConstraint(key, options, this));
      }
      describe(description) {
        const clone = this.clone();
        clone.description = description;
        return clone;
      }
      run(value) {
        let result = this.handle(value);
        if (result.isErr())
          return result;
        for (const constraint of this.constraints) {
          result = constraint.run(result.value, this.parent);
          if (result.isErr())
            break;
        }
        return result;
      }
      parse(value) {
        if (!this.shouldRunConstraints) {
          return this.handle(value).unwrap();
        }
        return this.constraints.reduce((v2, constraint) => constraint.run(v2).unwrap(), this.handle(value).unwrap());
      }
      is(value) {
        return this.run(value).isOk();
      }
      /**
       * Sets if the validator should also run constraints or just do basic checks.
       * @param isValidationEnabled Whether this validator should be enabled or disabled. You can pass boolean or a function returning boolean which will be called just before parsing.
       * Set to `null` to go off of the global configuration.
       */
      setValidationEnabled(isValidationEnabled) {
        const clone = this.clone();
        clone.isValidationEnabled = isValidationEnabled;
        return clone;
      }
      getValidationEnabled() {
        return getValue(this.isValidationEnabled);
      }
      get shouldRunConstraints() {
        return getValue(this.isValidationEnabled) ?? getGlobalValidationEnabled();
      }
      clone() {
        const clone = Reflect.construct(this.constructor, [this.constraints]);
        clone.isValidationEnabled = this.isValidationEnabled;
        return clone;
      }
      addConstraint(constraint) {
        const clone = this.clone();
        clone.constraints = clone.constraints.concat(constraint);
        return clone;
      }
    };
    __name(_BaseValidator, "BaseValidator");
    var BaseValidator = _BaseValidator;
    function isUnique(input) {
      if (input.length < 2)
        return true;
      const uniqueArray2 = uniqWith__default.default(input, fastDeepEqual__default.default);
      return uniqueArray2.length === input.length;
    }
    __name(isUnique, "isUnique");
    function lessThan(a3, b2) {
      return a3 < b2;
    }
    __name(lessThan, "lessThan");
    function lessThanOrEqual(a3, b2) {
      return a3 <= b2;
    }
    __name(lessThanOrEqual, "lessThanOrEqual");
    function greaterThan(a3, b2) {
      return a3 > b2;
    }
    __name(greaterThan, "greaterThan");
    function greaterThanOrEqual(a3, b2) {
      return a3 >= b2;
    }
    __name(greaterThanOrEqual, "greaterThanOrEqual");
    function equal(a3, b2) {
      return a3 === b2;
    }
    __name(equal, "equal");
    function notEqual(a3, b2) {
      return a3 !== b2;
    }
    __name(notEqual, "notEqual");
    function arrayLengthComparator(comparator, name, expected, length) {
      return {
        run(input) {
          return comparator(input.length, length) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, "Invalid Array length", input, expected));
        }
      };
    }
    __name(arrayLengthComparator, "arrayLengthComparator");
    function arrayLengthLessThan(value) {
      const expected = `expected.length < ${value}`;
      return arrayLengthComparator(lessThan, "s.array(T).lengthLessThan", expected, value);
    }
    __name(arrayLengthLessThan, "arrayLengthLessThan");
    function arrayLengthLessThanOrEqual(value) {
      const expected = `expected.length <= ${value}`;
      return arrayLengthComparator(lessThanOrEqual, "s.array(T).lengthLessThanOrEqual", expected, value);
    }
    __name(arrayLengthLessThanOrEqual, "arrayLengthLessThanOrEqual");
    function arrayLengthGreaterThan(value) {
      const expected = `expected.length > ${value}`;
      return arrayLengthComparator(greaterThan, "s.array(T).lengthGreaterThan", expected, value);
    }
    __name(arrayLengthGreaterThan, "arrayLengthGreaterThan");
    function arrayLengthGreaterThanOrEqual(value) {
      const expected = `expected.length >= ${value}`;
      return arrayLengthComparator(greaterThanOrEqual, "s.array(T).lengthGreaterThanOrEqual", expected, value);
    }
    __name(arrayLengthGreaterThanOrEqual, "arrayLengthGreaterThanOrEqual");
    function arrayLengthEqual(value) {
      const expected = `expected.length === ${value}`;
      return arrayLengthComparator(equal, "s.array(T).lengthEqual", expected, value);
    }
    __name(arrayLengthEqual, "arrayLengthEqual");
    function arrayLengthNotEqual(value) {
      const expected = `expected.length !== ${value}`;
      return arrayLengthComparator(notEqual, "s.array(T).lengthNotEqual", expected, value);
    }
    __name(arrayLengthNotEqual, "arrayLengthNotEqual");
    function arrayLengthRange(start, endBefore) {
      const expected = `expected.length >= ${start} && expected.length < ${endBefore}`;
      return {
        run(input) {
          return input.length >= start && input.length < endBefore ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.array(T).lengthRange", "Invalid Array length", input, expected));
        }
      };
    }
    __name(arrayLengthRange, "arrayLengthRange");
    function arrayLengthRangeInclusive(start, end) {
      const expected = `expected.length >= ${start} && expected.length <= ${end}`;
      return {
        run(input) {
          return input.length >= start && input.length <= end ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.array(T).lengthRangeInclusive", "Invalid Array length", input, expected));
        }
      };
    }
    __name(arrayLengthRangeInclusive, "arrayLengthRangeInclusive");
    function arrayLengthRangeExclusive(startAfter, endBefore) {
      const expected = `expected.length > ${startAfter} && expected.length < ${endBefore}`;
      return {
        run(input) {
          return input.length > startAfter && input.length < endBefore ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.array(T).lengthRangeExclusive", "Invalid Array length", input, expected));
        }
      };
    }
    __name(arrayLengthRangeExclusive, "arrayLengthRangeExclusive");
    var uniqueArray = {
      run(input) {
        return isUnique(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.array(T).unique", "Array values are not unique", input, "Expected all values to be unique"));
      }
    };
    var _CombinedPropertyError = class _CombinedPropertyError2 extends BaseError {
      constructor(errors2) {
        super("Received one or more errors");
        this.errors = errors2;
      }
      [customInspectSymbolStackLess](depth, options) {
        if (depth < 0) {
          return options.stylize("[CombinedPropertyError]", "special");
        }
        const newOptions = { ...options, depth: options.depth === null ? null : options.depth - 1, compact: true };
        const padding = `
  ${options.stylize("|", "undefined")} `;
        const header = `${options.stylize("CombinedPropertyError", "special")} (${options.stylize(this.errors.length.toString(), "number")})`;
        const message = options.stylize(this.message, "regexp");
        const errors2 = this.errors.map(([key, error2]) => {
          const property = _CombinedPropertyError2.formatProperty(key, options);
          const body = error2[customInspectSymbolStackLess](depth - 1, newOptions).replace(/\n/g, padding);
          return `  input${property}${padding}${body}`;
        }).join("\n\n");
        return `${header}
  ${message}

${errors2}`;
      }
      static formatProperty(key, options) {
        if (typeof key === "string")
          return options.stylize(`.${key}`, "symbol");
        if (typeof key === "number")
          return `[${options.stylize(key.toString(), "number")}]`;
        return `[${options.stylize("Symbol", "symbol")}(${key.description})]`;
      }
    };
    __name(_CombinedPropertyError, "CombinedPropertyError");
    var CombinedPropertyError = _CombinedPropertyError;
    var _ValidationError = class _ValidationError extends BaseError {
      constructor(validator, message, given) {
        super(message);
        this.validator = validator;
        this.given = given;
      }
      toJSON() {
        return {
          name: this.name,
          validator: this.validator,
          given: this.given
        };
      }
      [customInspectSymbolStackLess](depth, options) {
        const validator = options.stylize(this.validator, "string");
        if (depth < 0) {
          return options.stylize(`[ValidationError: ${validator}]`, "special");
        }
        const newOptions = { ...options, depth: options.depth === null ? null : options.depth - 1, compact: true };
        const padding = `
  ${options.stylize("|", "undefined")} `;
        const given = inspect2(this.given, newOptions).replace(/\n/g, padding);
        const header = `${options.stylize("ValidationError", "special")} > ${validator}`;
        const message = options.stylize(this.message, "regexp");
        const givenBlock = `
  ${options.stylize("Received:", "regexp")}${padding}${given}`;
        return `${header}
  ${message}
${givenBlock}`;
      }
    };
    __name(_ValidationError, "ValidationError");
    var ValidationError = _ValidationError;
    var _ArrayValidator = class _ArrayValidator extends BaseValidator {
      constructor(validator, constraints = []) {
        super(constraints);
        this.validator = validator;
      }
      lengthLessThan(length) {
        return this.addConstraint(arrayLengthLessThan(length));
      }
      lengthLessThanOrEqual(length) {
        return this.addConstraint(arrayLengthLessThanOrEqual(length));
      }
      lengthGreaterThan(length) {
        return this.addConstraint(arrayLengthGreaterThan(length));
      }
      lengthGreaterThanOrEqual(length) {
        return this.addConstraint(arrayLengthGreaterThanOrEqual(length));
      }
      lengthEqual(length) {
        return this.addConstraint(arrayLengthEqual(length));
      }
      lengthNotEqual(length) {
        return this.addConstraint(arrayLengthNotEqual(length));
      }
      lengthRange(start, endBefore) {
        return this.addConstraint(arrayLengthRange(start, endBefore));
      }
      lengthRangeInclusive(startAt, endAt) {
        return this.addConstraint(arrayLengthRangeInclusive(startAt, endAt));
      }
      lengthRangeExclusive(startAfter, endBefore) {
        return this.addConstraint(arrayLengthRangeExclusive(startAfter, endBefore));
      }
      get unique() {
        return this.addConstraint(uniqueArray);
      }
      clone() {
        return Reflect.construct(this.constructor, [this.validator, this.constraints]);
      }
      handle(values) {
        if (!Array.isArray(values)) {
          return Result.err(new ValidationError("s.array(T)", "Expected an array", values));
        }
        if (!this.shouldRunConstraints) {
          return Result.ok(values);
        }
        const errors2 = [];
        const transformed = [];
        for (let i3 = 0; i3 < values.length; i3++) {
          const result = this.validator.run(values[i3]);
          if (result.isOk())
            transformed.push(result.value);
          else
            errors2.push([i3, result.error]);
        }
        return errors2.length === 0 ? Result.ok(transformed) : Result.err(new CombinedPropertyError(errors2));
      }
    };
    __name(_ArrayValidator, "ArrayValidator");
    var ArrayValidator = _ArrayValidator;
    function bigintComparator(comparator, name, expected, number) {
      return {
        run(input) {
          return comparator(input, number) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, "Invalid bigint value", input, expected));
        }
      };
    }
    __name(bigintComparator, "bigintComparator");
    function bigintLessThan(value) {
      const expected = `expected < ${value}n`;
      return bigintComparator(lessThan, "s.bigint.lessThan", expected, value);
    }
    __name(bigintLessThan, "bigintLessThan");
    function bigintLessThanOrEqual(value) {
      const expected = `expected <= ${value}n`;
      return bigintComparator(lessThanOrEqual, "s.bigint.lessThanOrEqual", expected, value);
    }
    __name(bigintLessThanOrEqual, "bigintLessThanOrEqual");
    function bigintGreaterThan(value) {
      const expected = `expected > ${value}n`;
      return bigintComparator(greaterThan, "s.bigint.greaterThan", expected, value);
    }
    __name(bigintGreaterThan, "bigintGreaterThan");
    function bigintGreaterThanOrEqual(value) {
      const expected = `expected >= ${value}n`;
      return bigintComparator(greaterThanOrEqual, "s.bigint.greaterThanOrEqual", expected, value);
    }
    __name(bigintGreaterThanOrEqual, "bigintGreaterThanOrEqual");
    function bigintEqual(value) {
      const expected = `expected === ${value}n`;
      return bigintComparator(equal, "s.bigint.equal", expected, value);
    }
    __name(bigintEqual, "bigintEqual");
    function bigintNotEqual(value) {
      const expected = `expected !== ${value}n`;
      return bigintComparator(notEqual, "s.bigint.notEqual", expected, value);
    }
    __name(bigintNotEqual, "bigintNotEqual");
    function bigintDivisibleBy(divider) {
      const expected = `expected % ${divider}n === 0n`;
      return {
        run(input) {
          return input % divider === 0n ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.bigint.divisibleBy", "BigInt is not divisible", input, expected));
        }
      };
    }
    __name(bigintDivisibleBy, "bigintDivisibleBy");
    var _BigIntValidator = class _BigIntValidator extends BaseValidator {
      lessThan(number) {
        return this.addConstraint(bigintLessThan(number));
      }
      lessThanOrEqual(number) {
        return this.addConstraint(bigintLessThanOrEqual(number));
      }
      greaterThan(number) {
        return this.addConstraint(bigintGreaterThan(number));
      }
      greaterThanOrEqual(number) {
        return this.addConstraint(bigintGreaterThanOrEqual(number));
      }
      equal(number) {
        return this.addConstraint(bigintEqual(number));
      }
      notEqual(number) {
        return this.addConstraint(bigintNotEqual(number));
      }
      get positive() {
        return this.greaterThanOrEqual(0n);
      }
      get negative() {
        return this.lessThan(0n);
      }
      divisibleBy(number) {
        return this.addConstraint(bigintDivisibleBy(number));
      }
      get abs() {
        return this.transform((value) => value < 0 ? -value : value);
      }
      intN(bits) {
        return this.transform((value) => BigInt.asIntN(bits, value));
      }
      uintN(bits) {
        return this.transform((value) => BigInt.asUintN(bits, value));
      }
      handle(value) {
        return typeof value === "bigint" ? Result.ok(value) : Result.err(new ValidationError("s.bigint", "Expected a bigint primitive", value));
      }
    };
    __name(_BigIntValidator, "BigIntValidator");
    var BigIntValidator = _BigIntValidator;
    var booleanTrue = {
      run(input) {
        return input ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.boolean.true", "Invalid boolean value", input, "true"));
      }
    };
    var booleanFalse = {
      run(input) {
        return input ? Result.err(new ExpectedConstraintError("s.boolean.false", "Invalid boolean value", input, "false")) : Result.ok(input);
      }
    };
    var _BooleanValidator = class _BooleanValidator extends BaseValidator {
      get true() {
        return this.addConstraint(booleanTrue);
      }
      get false() {
        return this.addConstraint(booleanFalse);
      }
      equal(value) {
        return value ? this.true : this.false;
      }
      notEqual(value) {
        return value ? this.false : this.true;
      }
      handle(value) {
        return typeof value === "boolean" ? Result.ok(value) : Result.err(new ValidationError("s.boolean", "Expected a boolean primitive", value));
      }
    };
    __name(_BooleanValidator, "BooleanValidator");
    var BooleanValidator = _BooleanValidator;
    function dateComparator(comparator, name, expected, number) {
      return {
        run(input) {
          return comparator(input.getTime(), number) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, "Invalid Date value", input, expected));
        }
      };
    }
    __name(dateComparator, "dateComparator");
    function dateLessThan(value) {
      const expected = `expected < ${value.toISOString()}`;
      return dateComparator(lessThan, "s.date.lessThan", expected, value.getTime());
    }
    __name(dateLessThan, "dateLessThan");
    function dateLessThanOrEqual(value) {
      const expected = `expected <= ${value.toISOString()}`;
      return dateComparator(lessThanOrEqual, "s.date.lessThanOrEqual", expected, value.getTime());
    }
    __name(dateLessThanOrEqual, "dateLessThanOrEqual");
    function dateGreaterThan(value) {
      const expected = `expected > ${value.toISOString()}`;
      return dateComparator(greaterThan, "s.date.greaterThan", expected, value.getTime());
    }
    __name(dateGreaterThan, "dateGreaterThan");
    function dateGreaterThanOrEqual(value) {
      const expected = `expected >= ${value.toISOString()}`;
      return dateComparator(greaterThanOrEqual, "s.date.greaterThanOrEqual", expected, value.getTime());
    }
    __name(dateGreaterThanOrEqual, "dateGreaterThanOrEqual");
    function dateEqual(value) {
      const expected = `expected === ${value.toISOString()}`;
      return dateComparator(equal, "s.date.equal", expected, value.getTime());
    }
    __name(dateEqual, "dateEqual");
    function dateNotEqual(value) {
      const expected = `expected !== ${value.toISOString()}`;
      return dateComparator(notEqual, "s.date.notEqual", expected, value.getTime());
    }
    __name(dateNotEqual, "dateNotEqual");
    var dateInvalid = {
      run(input) {
        return Number.isNaN(input.getTime()) ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.date.invalid", "Invalid Date value", input, "expected === NaN"));
      }
    };
    var dateValid = {
      run(input) {
        return Number.isNaN(input.getTime()) ? Result.err(new ExpectedConstraintError("s.date.valid", "Invalid Date value", input, "expected !== NaN")) : Result.ok(input);
      }
    };
    var _DateValidator = class _DateValidator extends BaseValidator {
      lessThan(date) {
        return this.addConstraint(dateLessThan(new Date(date)));
      }
      lessThanOrEqual(date) {
        return this.addConstraint(dateLessThanOrEqual(new Date(date)));
      }
      greaterThan(date) {
        return this.addConstraint(dateGreaterThan(new Date(date)));
      }
      greaterThanOrEqual(date) {
        return this.addConstraint(dateGreaterThanOrEqual(new Date(date)));
      }
      equal(date) {
        const resolved = new Date(date);
        return Number.isNaN(resolved.getTime()) ? this.invalid : this.addConstraint(dateEqual(resolved));
      }
      notEqual(date) {
        const resolved = new Date(date);
        return Number.isNaN(resolved.getTime()) ? this.valid : this.addConstraint(dateNotEqual(resolved));
      }
      get valid() {
        return this.addConstraint(dateValid);
      }
      get invalid() {
        return this.addConstraint(dateInvalid);
      }
      handle(value) {
        return value instanceof Date ? Result.ok(value) : Result.err(new ValidationError("s.date", "Expected a Date", value));
      }
    };
    __name(_DateValidator, "DateValidator");
    var DateValidator = _DateValidator;
    var _ExpectedValidationError = class _ExpectedValidationError extends ValidationError {
      constructor(validator, message, given, expected) {
        super(validator, message, given);
        this.expected = expected;
      }
      toJSON() {
        return {
          name: this.name,
          validator: this.validator,
          given: this.given,
          expected: this.expected
        };
      }
      [customInspectSymbolStackLess](depth, options) {
        const validator = options.stylize(this.validator, "string");
        if (depth < 0) {
          return options.stylize(`[ExpectedValidationError: ${validator}]`, "special");
        }
        const newOptions = { ...options, depth: options.depth === null ? null : options.depth - 1 };
        const padding = `
  ${options.stylize("|", "undefined")} `;
        const expected = inspect2(this.expected, newOptions).replace(/\n/g, padding);
        const given = inspect2(this.given, newOptions).replace(/\n/g, padding);
        const header = `${options.stylize("ExpectedValidationError", "special")} > ${validator}`;
        const message = options.stylize(this.message, "regexp");
        const expectedBlock = `
  ${options.stylize("Expected:", "string")}${padding}${expected}`;
        const givenBlock = `
  ${options.stylize("Received:", "regexp")}${padding}${given}`;
        return `${header}
  ${message}
${expectedBlock}
${givenBlock}`;
      }
    };
    __name(_ExpectedValidationError, "ExpectedValidationError");
    var ExpectedValidationError = _ExpectedValidationError;
    var _InstanceValidator = class _InstanceValidator extends BaseValidator {
      constructor(expected, constraints = []) {
        super(constraints);
        this.expected = expected;
      }
      handle(value) {
        return value instanceof this.expected ? Result.ok(value) : Result.err(new ExpectedValidationError("s.instance(V)", "Expected", value, this.expected));
      }
      clone() {
        return Reflect.construct(this.constructor, [this.expected, this.constraints]);
      }
    };
    __name(_InstanceValidator, "InstanceValidator");
    var InstanceValidator = _InstanceValidator;
    var _LiteralValidator = class _LiteralValidator extends BaseValidator {
      constructor(literal, constraints = []) {
        super(constraints);
        this.expected = literal;
      }
      handle(value) {
        return Object.is(value, this.expected) ? Result.ok(value) : Result.err(new ExpectedValidationError("s.literal(V)", "Expected values to be equals", value, this.expected));
      }
      clone() {
        return Reflect.construct(this.constructor, [this.expected, this.constraints]);
      }
    };
    __name(_LiteralValidator, "LiteralValidator");
    var LiteralValidator = _LiteralValidator;
    var _NeverValidator = class _NeverValidator extends BaseValidator {
      handle(value) {
        return Result.err(new ValidationError("s.never", "Expected a value to not be passed", value));
      }
    };
    __name(_NeverValidator, "NeverValidator");
    var NeverValidator = _NeverValidator;
    var _NullishValidator = class _NullishValidator extends BaseValidator {
      handle(value) {
        return value === void 0 || value === null ? Result.ok(value) : Result.err(new ValidationError("s.nullish", "Expected undefined or null", value));
      }
    };
    __name(_NullishValidator, "NullishValidator");
    var NullishValidator = _NullishValidator;
    function numberComparator(comparator, name, expected, number) {
      return {
        run(input) {
          return comparator(input, number) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, "Invalid number value", input, expected));
        }
      };
    }
    __name(numberComparator, "numberComparator");
    function numberLessThan(value) {
      const expected = `expected < ${value}`;
      return numberComparator(lessThan, "s.number.lessThan", expected, value);
    }
    __name(numberLessThan, "numberLessThan");
    function numberLessThanOrEqual(value) {
      const expected = `expected <= ${value}`;
      return numberComparator(lessThanOrEqual, "s.number.lessThanOrEqual", expected, value);
    }
    __name(numberLessThanOrEqual, "numberLessThanOrEqual");
    function numberGreaterThan(value) {
      const expected = `expected > ${value}`;
      return numberComparator(greaterThan, "s.number.greaterThan", expected, value);
    }
    __name(numberGreaterThan, "numberGreaterThan");
    function numberGreaterThanOrEqual(value) {
      const expected = `expected >= ${value}`;
      return numberComparator(greaterThanOrEqual, "s.number.greaterThanOrEqual", expected, value);
    }
    __name(numberGreaterThanOrEqual, "numberGreaterThanOrEqual");
    function numberEqual(value) {
      const expected = `expected === ${value}`;
      return numberComparator(equal, "s.number.equal", expected, value);
    }
    __name(numberEqual, "numberEqual");
    function numberNotEqual(value) {
      const expected = `expected !== ${value}`;
      return numberComparator(notEqual, "s.number.notEqual", expected, value);
    }
    __name(numberNotEqual, "numberNotEqual");
    var numberInt = {
      run(input) {
        return Number.isInteger(input) ? Result.ok(input) : Result.err(
          new ExpectedConstraintError("s.number.int", "Given value is not an integer", input, "Number.isInteger(expected) to be true")
        );
      }
    };
    var numberSafeInt = {
      run(input) {
        return Number.isSafeInteger(input) ? Result.ok(input) : Result.err(
          new ExpectedConstraintError(
            "s.number.safeInt",
            "Given value is not a safe integer",
            input,
            "Number.isSafeInteger(expected) to be true"
          )
        );
      }
    };
    var numberFinite = {
      run(input) {
        return Number.isFinite(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.number.finite", "Given value is not finite", input, "Number.isFinite(expected) to be true"));
      }
    };
    var numberNaN = {
      run(input) {
        return Number.isNaN(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.number.equal(NaN)", "Invalid number value", input, "expected === NaN"));
      }
    };
    var numberNotNaN = {
      run(input) {
        return Number.isNaN(input) ? Result.err(new ExpectedConstraintError("s.number.notEqual(NaN)", "Invalid number value", input, "expected !== NaN")) : Result.ok(input);
      }
    };
    function numberDivisibleBy(divider) {
      const expected = `expected % ${divider} === 0`;
      return {
        run(input) {
          return input % divider === 0 ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.number.divisibleBy", "Number is not divisible", input, expected));
        }
      };
    }
    __name(numberDivisibleBy, "numberDivisibleBy");
    var _NumberValidator = class _NumberValidator extends BaseValidator {
      lessThan(number) {
        return this.addConstraint(numberLessThan(number));
      }
      lessThanOrEqual(number) {
        return this.addConstraint(numberLessThanOrEqual(number));
      }
      greaterThan(number) {
        return this.addConstraint(numberGreaterThan(number));
      }
      greaterThanOrEqual(number) {
        return this.addConstraint(numberGreaterThanOrEqual(number));
      }
      equal(number) {
        return Number.isNaN(number) ? this.addConstraint(numberNaN) : this.addConstraint(numberEqual(number));
      }
      notEqual(number) {
        return Number.isNaN(number) ? this.addConstraint(numberNotNaN) : this.addConstraint(numberNotEqual(number));
      }
      get int() {
        return this.addConstraint(numberInt);
      }
      get safeInt() {
        return this.addConstraint(numberSafeInt);
      }
      get finite() {
        return this.addConstraint(numberFinite);
      }
      get positive() {
        return this.greaterThanOrEqual(0);
      }
      get negative() {
        return this.lessThan(0);
      }
      divisibleBy(divider) {
        return this.addConstraint(numberDivisibleBy(divider));
      }
      get abs() {
        return this.transform(Math.abs);
      }
      get sign() {
        return this.transform(Math.sign);
      }
      get trunc() {
        return this.transform(Math.trunc);
      }
      get floor() {
        return this.transform(Math.floor);
      }
      get fround() {
        return this.transform(Math.fround);
      }
      get round() {
        return this.transform(Math.round);
      }
      get ceil() {
        return this.transform(Math.ceil);
      }
      handle(value) {
        return typeof value === "number" ? Result.ok(value) : Result.err(new ValidationError("s.number", "Expected a number primitive", value));
      }
    };
    __name(_NumberValidator, "NumberValidator");
    var NumberValidator = _NumberValidator;
    var _MissingPropertyError = class _MissingPropertyError extends BaseError {
      constructor(property) {
        super("A required property is missing");
        this.property = property;
      }
      toJSON() {
        return {
          name: this.name,
          property: this.property
        };
      }
      [customInspectSymbolStackLess](depth, options) {
        const property = options.stylize(this.property.toString(), "string");
        if (depth < 0) {
          return options.stylize(`[MissingPropertyError: ${property}]`, "special");
        }
        const header = `${options.stylize("MissingPropertyError", "special")} > ${property}`;
        const message = options.stylize(this.message, "regexp");
        return `${header}
  ${message}`;
      }
    };
    __name(_MissingPropertyError, "MissingPropertyError");
    var MissingPropertyError = _MissingPropertyError;
    var _UnknownPropertyError = class _UnknownPropertyError extends BaseError {
      constructor(property, value) {
        super("Received unexpected property");
        this.property = property;
        this.value = value;
      }
      toJSON() {
        return {
          name: this.name,
          property: this.property,
          value: this.value
        };
      }
      [customInspectSymbolStackLess](depth, options) {
        const property = options.stylize(this.property.toString(), "string");
        if (depth < 0) {
          return options.stylize(`[UnknownPropertyError: ${property}]`, "special");
        }
        const newOptions = { ...options, depth: options.depth === null ? null : options.depth - 1, compact: true };
        const padding = `
  ${options.stylize("|", "undefined")} `;
        const given = inspect2(this.value, newOptions).replace(/\n/g, padding);
        const header = `${options.stylize("UnknownPropertyError", "special")} > ${property}`;
        const message = options.stylize(this.message, "regexp");
        const givenBlock = `
  ${options.stylize("Received:", "regexp")}${padding}${given}`;
        return `${header}
  ${message}
${givenBlock}`;
      }
    };
    __name(_UnknownPropertyError, "UnknownPropertyError");
    var UnknownPropertyError = _UnknownPropertyError;
    var _DefaultValidator = class _DefaultValidator extends BaseValidator {
      constructor(validator, value, constraints = []) {
        super(constraints);
        this.validator = validator;
        this.defaultValue = value;
      }
      default(value) {
        const clone = this.clone();
        clone.defaultValue = value;
        return clone;
      }
      handle(value) {
        return typeof value === "undefined" ? Result.ok(getValue(this.defaultValue)) : this.validator["handle"](value);
      }
      clone() {
        return Reflect.construct(this.constructor, [this.validator, this.defaultValue, this.constraints]);
      }
    };
    __name(_DefaultValidator, "DefaultValidator");
    var DefaultValidator = _DefaultValidator;
    var _CombinedError = class _CombinedError extends BaseError {
      constructor(errors2) {
        super("Received one or more errors");
        this.errors = errors2;
      }
      [customInspectSymbolStackLess](depth, options) {
        if (depth < 0) {
          return options.stylize("[CombinedError]", "special");
        }
        const newOptions = { ...options, depth: options.depth === null ? null : options.depth - 1, compact: true };
        const padding = `
  ${options.stylize("|", "undefined")} `;
        const header = `${options.stylize("CombinedError", "special")} (${options.stylize(this.errors.length.toString(), "number")})`;
        const message = options.stylize(this.message, "regexp");
        const errors2 = this.errors.map((error2, i3) => {
          const index = options.stylize((i3 + 1).toString(), "number");
          const body = error2[customInspectSymbolStackLess](depth - 1, newOptions).replace(/\n/g, padding);
          return `  ${index} ${body}`;
        }).join("\n\n");
        return `${header}
  ${message}

${errors2}`;
      }
    };
    __name(_CombinedError, "CombinedError");
    var CombinedError = _CombinedError;
    var _UnionValidator = class _UnionValidator2 extends BaseValidator {
      constructor(validators, constraints = []) {
        super(constraints);
        this.validators = validators;
      }
      get optional() {
        if (this.validators.length === 0)
          return new _UnionValidator2([new LiteralValidator(void 0)], this.constraints);
        const [validator] = this.validators;
        if (validator instanceof LiteralValidator) {
          if (validator.expected === void 0)
            return this.clone();
          if (validator.expected === null) {
            return new _UnionValidator2(
              [new NullishValidator(), ...this.validators.slice(1)],
              this.constraints
            );
          }
        } else if (validator instanceof NullishValidator) {
          return this.clone();
        }
        return new _UnionValidator2([new LiteralValidator(void 0), ...this.validators]);
      }
      get required() {
        if (this.validators.length === 0)
          return this.clone();
        const [validator] = this.validators;
        if (validator instanceof LiteralValidator) {
          if (validator.expected === void 0)
            return new _UnionValidator2(this.validators.slice(1), this.constraints);
        } else if (validator instanceof NullishValidator) {
          return new _UnionValidator2([new LiteralValidator(null), ...this.validators.slice(1)], this.constraints);
        }
        return this.clone();
      }
      get nullable() {
        if (this.validators.length === 0)
          return new _UnionValidator2([new LiteralValidator(null)], this.constraints);
        const [validator] = this.validators;
        if (validator instanceof LiteralValidator) {
          if (validator.expected === null)
            return this.clone();
          if (validator.expected === void 0) {
            return new _UnionValidator2(
              [new NullishValidator(), ...this.validators.slice(1)],
              this.constraints
            );
          }
        } else if (validator instanceof NullishValidator) {
          return this.clone();
        }
        return new _UnionValidator2([new LiteralValidator(null), ...this.validators]);
      }
      get nullish() {
        if (this.validators.length === 0)
          return new _UnionValidator2([new NullishValidator()], this.constraints);
        const [validator] = this.validators;
        if (validator instanceof LiteralValidator) {
          if (validator.expected === null || validator.expected === void 0) {
            return new _UnionValidator2([new NullishValidator(), ...this.validators.slice(1)], this.constraints);
          }
        } else if (validator instanceof NullishValidator) {
          return this.clone();
        }
        return new _UnionValidator2([new NullishValidator(), ...this.validators]);
      }
      or(...predicates) {
        return new _UnionValidator2([...this.validators, ...predicates]);
      }
      clone() {
        return Reflect.construct(this.constructor, [this.validators, this.constraints]);
      }
      handle(value) {
        const errors2 = [];
        for (const validator of this.validators) {
          const result = validator.run(value);
          if (result.isOk())
            return result;
          errors2.push(result.error);
        }
        return Result.err(new CombinedError(errors2));
      }
    };
    __name(_UnionValidator, "UnionValidator");
    var UnionValidator = _UnionValidator;
    var _ObjectValidator = class _ObjectValidator2 extends BaseValidator {
      constructor(shape, strategy = 0, constraints = []) {
        super(constraints);
        this.keys = [];
        this.requiredKeys = /* @__PURE__ */ new Map();
        this.possiblyUndefinedKeys = /* @__PURE__ */ new Map();
        this.possiblyUndefinedKeysWithDefaults = /* @__PURE__ */ new Map();
        this.shape = shape;
        this.strategy = strategy;
        switch (this.strategy) {
          case 0:
            this.handleStrategy = (value) => this.handleIgnoreStrategy(value);
            break;
          case 1: {
            this.handleStrategy = (value) => this.handleStrictStrategy(value);
            break;
          }
          case 2:
            this.handleStrategy = (value) => this.handlePassthroughStrategy(value);
            break;
        }
        const shapeEntries = Object.entries(shape);
        this.keys = shapeEntries.map(([key]) => key);
        for (const [key, validator] of shapeEntries) {
          if (validator instanceof UnionValidator) {
            const [possiblyLiteralOrNullishPredicate] = validator["validators"];
            if (possiblyLiteralOrNullishPredicate instanceof NullishValidator) {
              this.possiblyUndefinedKeys.set(key, validator);
            } else if (possiblyLiteralOrNullishPredicate instanceof LiteralValidator) {
              if (possiblyLiteralOrNullishPredicate.expected === void 0) {
                this.possiblyUndefinedKeys.set(key, validator);
              } else {
                this.requiredKeys.set(key, validator);
              }
            } else if (validator instanceof DefaultValidator) {
              this.possiblyUndefinedKeysWithDefaults.set(key, validator);
            } else {
              this.requiredKeys.set(key, validator);
            }
          } else if (validator instanceof NullishValidator) {
            this.possiblyUndefinedKeys.set(key, validator);
          } else if (validator instanceof LiteralValidator) {
            if (validator.expected === void 0) {
              this.possiblyUndefinedKeys.set(key, validator);
            } else {
              this.requiredKeys.set(key, validator);
            }
          } else if (validator instanceof DefaultValidator) {
            this.possiblyUndefinedKeysWithDefaults.set(key, validator);
          } else {
            this.requiredKeys.set(key, validator);
          }
        }
      }
      get strict() {
        return Reflect.construct(this.constructor, [this.shape, 1, this.constraints]);
      }
      get ignore() {
        return Reflect.construct(this.constructor, [this.shape, 0, this.constraints]);
      }
      get passthrough() {
        return Reflect.construct(this.constructor, [this.shape, 2, this.constraints]);
      }
      get partial() {
        const shape = Object.fromEntries(this.keys.map((key) => [key, this.shape[key].optional]));
        return Reflect.construct(this.constructor, [shape, this.strategy, this.constraints]);
      }
      get required() {
        const shape = Object.fromEntries(
          this.keys.map((key) => {
            let validator = this.shape[key];
            if (validator instanceof UnionValidator)
              validator = validator.required;
            return [key, validator];
          })
        );
        return Reflect.construct(this.constructor, [shape, this.strategy, this.constraints]);
      }
      extend(schema) {
        const shape = { ...this.shape, ...schema instanceof _ObjectValidator2 ? schema.shape : schema };
        return Reflect.construct(this.constructor, [shape, this.strategy, this.constraints]);
      }
      pick(keys) {
        const shape = Object.fromEntries(
          keys.filter((key) => this.keys.includes(key)).map((key) => [key, this.shape[key]])
        );
        return Reflect.construct(this.constructor, [shape, this.strategy, this.constraints]);
      }
      omit(keys) {
        const shape = Object.fromEntries(
          this.keys.filter((key) => !keys.includes(key)).map((key) => [key, this.shape[key]])
        );
        return Reflect.construct(this.constructor, [shape, this.strategy, this.constraints]);
      }
      handle(value) {
        const typeOfValue = typeof value;
        if (typeOfValue !== "object") {
          return Result.err(new ValidationError("s.object(T)", `Expected the value to be an object, but received ${typeOfValue} instead`, value));
        }
        if (value === null) {
          return Result.err(new ValidationError("s.object(T)", "Expected the value to not be null", value));
        }
        if (Array.isArray(value)) {
          return Result.err(new ValidationError("s.object(T)", "Expected the value to not be an array", value));
        }
        if (!this.shouldRunConstraints) {
          return Result.ok(value);
        }
        for (const predicate of Object.values(this.shape)) {
          predicate.setParent(this.parent ?? value);
        }
        return this.handleStrategy(value);
      }
      clone() {
        return Reflect.construct(this.constructor, [this.shape, this.strategy, this.constraints]);
      }
      handleIgnoreStrategy(value) {
        const errors2 = [];
        const finalObject = {};
        const inputEntries = new Map(Object.entries(value));
        const runPredicate = __name((key, predicate) => {
          const result = predicate.run(value[key]);
          if (result.isOk()) {
            finalObject[key] = result.value;
          } else {
            const error2 = result.error;
            errors2.push([key, error2]);
          }
        }, "runPredicate");
        for (const [key, predicate] of this.requiredKeys) {
          if (inputEntries.delete(key)) {
            runPredicate(key, predicate);
          } else {
            errors2.push([key, new MissingPropertyError(key)]);
          }
        }
        for (const [key, validator] of this.possiblyUndefinedKeysWithDefaults) {
          inputEntries.delete(key);
          runPredicate(key, validator);
        }
        if (inputEntries.size === 0) {
          return errors2.length === 0 ? Result.ok(finalObject) : Result.err(new CombinedPropertyError(errors2));
        }
        const checkInputEntriesInsteadOfSchemaKeys = this.possiblyUndefinedKeys.size > inputEntries.size;
        if (checkInputEntriesInsteadOfSchemaKeys) {
          for (const [key] of inputEntries) {
            const predicate = this.possiblyUndefinedKeys.get(key);
            if (predicate) {
              runPredicate(key, predicate);
            }
          }
        } else {
          for (const [key, predicate] of this.possiblyUndefinedKeys) {
            if (inputEntries.delete(key)) {
              runPredicate(key, predicate);
            }
          }
        }
        return errors2.length === 0 ? Result.ok(finalObject) : Result.err(new CombinedPropertyError(errors2));
      }
      handleStrictStrategy(value) {
        const errors2 = [];
        const finalResult = {};
        const inputEntries = new Map(Object.entries(value));
        const runPredicate = __name((key, predicate) => {
          const result = predicate.run(value[key]);
          if (result.isOk()) {
            finalResult[key] = result.value;
          } else {
            const error2 = result.error;
            errors2.push([key, error2]);
          }
        }, "runPredicate");
        for (const [key, predicate] of this.requiredKeys) {
          if (inputEntries.delete(key)) {
            runPredicate(key, predicate);
          } else {
            errors2.push([key, new MissingPropertyError(key)]);
          }
        }
        for (const [key, validator] of this.possiblyUndefinedKeysWithDefaults) {
          inputEntries.delete(key);
          runPredicate(key, validator);
        }
        for (const [key, predicate] of this.possiblyUndefinedKeys) {
          if (inputEntries.size === 0) {
            break;
          }
          if (inputEntries.delete(key)) {
            runPredicate(key, predicate);
          }
        }
        if (inputEntries.size !== 0) {
          for (const [key, value2] of inputEntries.entries()) {
            errors2.push([key, new UnknownPropertyError(key, value2)]);
          }
        }
        return errors2.length === 0 ? Result.ok(finalResult) : Result.err(new CombinedPropertyError(errors2));
      }
      handlePassthroughStrategy(value) {
        const result = this.handleIgnoreStrategy(value);
        return result.isErr() ? result : Result.ok({ ...value, ...result.value });
      }
    };
    __name(_ObjectValidator, "ObjectValidator");
    var ObjectValidator = _ObjectValidator;
    var _PassthroughValidator = class _PassthroughValidator extends BaseValidator {
      handle(value) {
        return Result.ok(value);
      }
    };
    __name(_PassthroughValidator, "PassthroughValidator");
    var PassthroughValidator = _PassthroughValidator;
    var _RecordValidator = class _RecordValidator extends BaseValidator {
      constructor(validator, constraints = []) {
        super(constraints);
        this.validator = validator;
      }
      clone() {
        return Reflect.construct(this.constructor, [this.validator, this.constraints]);
      }
      handle(value) {
        if (typeof value !== "object") {
          return Result.err(new ValidationError("s.record(T)", "Expected an object", value));
        }
        if (value === null) {
          return Result.err(new ValidationError("s.record(T)", "Expected the value to not be null", value));
        }
        if (Array.isArray(value)) {
          return Result.err(new ValidationError("s.record(T)", "Expected the value to not be an array", value));
        }
        if (!this.shouldRunConstraints) {
          return Result.ok(value);
        }
        const errors2 = [];
        const transformed = {};
        for (const [key, val] of Object.entries(value)) {
          const result = this.validator.run(val);
          if (result.isOk())
            transformed[key] = result.value;
          else
            errors2.push([key, result.error]);
        }
        return errors2.length === 0 ? Result.ok(transformed) : Result.err(new CombinedPropertyError(errors2));
      }
    };
    __name(_RecordValidator, "RecordValidator");
    var RecordValidator = _RecordValidator;
    var _SetValidator = class _SetValidator extends BaseValidator {
      constructor(validator, constraints = []) {
        super(constraints);
        this.validator = validator;
      }
      clone() {
        return Reflect.construct(this.constructor, [this.validator, this.constraints]);
      }
      handle(values) {
        if (!(values instanceof Set)) {
          return Result.err(new ValidationError("s.set(T)", "Expected a set", values));
        }
        if (!this.shouldRunConstraints) {
          return Result.ok(values);
        }
        const errors2 = [];
        const transformed = /* @__PURE__ */ new Set();
        for (const value of values) {
          const result = this.validator.run(value);
          if (result.isOk())
            transformed.add(result.value);
          else
            errors2.push(result.error);
        }
        return errors2.length === 0 ? Result.ok(transformed) : Result.err(new CombinedError(errors2));
      }
    };
    __name(_SetValidator, "SetValidator");
    var SetValidator = _SetValidator;
    var accountRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]$/i;
    function validateEmail(email) {
      if (!email)
        return false;
      const atIndex = email.indexOf("@");
      if (atIndex === -1)
        return false;
      if (atIndex > 64)
        return false;
      const domainIndex = atIndex + 1;
      if (email.includes("@", domainIndex))
        return false;
      if (email.length - domainIndex > 255)
        return false;
      let dotIndex = email.indexOf(".", domainIndex);
      if (dotIndex === -1)
        return false;
      let lastDotIndex = domainIndex;
      do {
        if (dotIndex - lastDotIndex > 63)
          return false;
        lastDotIndex = dotIndex + 1;
      } while ((dotIndex = email.indexOf(".", lastDotIndex)) !== -1);
      if (email.length - lastDotIndex > 63)
        return false;
      return accountRegex.test(email.slice(0, atIndex)) && validateEmailDomain(email.slice(domainIndex));
    }
    __name(validateEmail, "validateEmail");
    function validateEmailDomain(domain) {
      try {
        return new URL(`http://${domain}`).hostname === domain;
      } catch {
        return false;
      }
    }
    __name(validateEmailDomain, "validateEmailDomain");
    var v4Seg = "(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])";
    var v4Str = `(${v4Seg}[.]){3}${v4Seg}`;
    var IPv4Reg = new RegExp(`^${v4Str}$`);
    var v6Seg = "(?:[0-9a-fA-F]{1,4})";
    var IPv6Reg = new RegExp(
      `^((?:${v6Seg}:){7}(?:${v6Seg}|:)|(?:${v6Seg}:){6}(?:${v4Str}|:${v6Seg}|:)|(?:${v6Seg}:){5}(?::${v4Str}|(:${v6Seg}){1,2}|:)|(?:${v6Seg}:){4}(?:(:${v6Seg}){0,1}:${v4Str}|(:${v6Seg}){1,3}|:)|(?:${v6Seg}:){3}(?:(:${v6Seg}){0,2}:${v4Str}|(:${v6Seg}){1,4}|:)|(?:${v6Seg}:){2}(?:(:${v6Seg}){0,3}:${v4Str}|(:${v6Seg}){1,5}|:)|(?:${v6Seg}:){1}(?:(:${v6Seg}){0,4}:${v4Str}|(:${v6Seg}){1,6}|:)|(?::((?::${v6Seg}){0,5}:${v4Str}|(?::${v6Seg}){1,7}|:)))(%[0-9a-zA-Z-.:]{1,})?$`
    );
    function isIPv4(s4) {
      return IPv4Reg.test(s4);
    }
    __name(isIPv4, "isIPv4");
    function isIPv6(s4) {
      return IPv6Reg.test(s4);
    }
    __name(isIPv6, "isIPv6");
    function isIP(s4) {
      if (isIPv4(s4))
        return 4;
      if (isIPv6(s4))
        return 6;
      return 0;
    }
    __name(isIP, "isIP");
    var phoneNumberRegex = /^((?:\+|0{0,2})\d{1,2}\s?)?\(?\d{3}\)?[\s.-]?\d{3}[\s.-]?\d{4}$/;
    function validatePhoneNumber(input) {
      return phoneNumberRegex.test(input);
    }
    __name(validatePhoneNumber, "validatePhoneNumber");
    var _MultiplePossibilitiesConstraintError = class _MultiplePossibilitiesConstraintError extends BaseConstraintError {
      constructor(constraint, message, given, expected) {
        super(constraint, message, given);
        this.expected = expected;
      }
      toJSON() {
        return {
          name: this.name,
          constraint: this.constraint,
          given: this.given,
          expected: this.expected
        };
      }
      [customInspectSymbolStackLess](depth, options) {
        const constraint = options.stylize(this.constraint, "string");
        if (depth < 0) {
          return options.stylize(`[MultiplePossibilitiesConstraintError: ${constraint}]`, "special");
        }
        const newOptions = { ...options, depth: options.depth === null ? null : options.depth - 1 };
        const verticalLine = options.stylize("|", "undefined");
        const padding = `
  ${verticalLine} `;
        const given = inspect2(this.given, newOptions).replace(/\n/g, padding);
        const header = `${options.stylize("MultiplePossibilitiesConstraintError", "special")} > ${constraint}`;
        const message = options.stylize(this.message, "regexp");
        const expectedPadding = `
  ${verticalLine} - `;
        const expectedBlock = `
  ${options.stylize("Expected any of the following:", "string")}${expectedPadding}${this.expected.map((possible) => options.stylize(possible, "boolean")).join(expectedPadding)}`;
        const givenBlock = `
  ${options.stylize("Received:", "regexp")}${padding}${given}`;
        return `${header}
  ${message}
${expectedBlock}
${givenBlock}`;
      }
    };
    __name(_MultiplePossibilitiesConstraintError, "MultiplePossibilitiesConstraintError");
    var MultiplePossibilitiesConstraintError = _MultiplePossibilitiesConstraintError;
    function combinedErrorFn(...fns) {
      switch (fns.length) {
        case 0:
          return () => null;
        case 1:
          return fns[0];
        case 2: {
          const [fn0, fn1] = fns;
          return (...params) => fn0(...params) || fn1(...params);
        }
        default: {
          return (...params) => {
            for (const fn of fns) {
              const result = fn(...params);
              if (result)
                return result;
            }
            return null;
          };
        }
      }
    }
    __name(combinedErrorFn, "combinedErrorFn");
    function createUrlValidators(options) {
      var _a, _b;
      const fns = [];
      if ((_a = options == null ? void 0 : options.allowedProtocols) == null ? void 0 : _a.length)
        fns.push(allowedProtocolsFn(options.allowedProtocols));
      if ((_b = options == null ? void 0 : options.allowedDomains) == null ? void 0 : _b.length)
        fns.push(allowedDomainsFn(options.allowedDomains));
      return combinedErrorFn(...fns);
    }
    __name(createUrlValidators, "createUrlValidators");
    function allowedProtocolsFn(allowedProtocols) {
      return (input, url) => allowedProtocols.includes(url.protocol) ? null : new MultiplePossibilitiesConstraintError("s.string.url", "Invalid URL protocol", input, allowedProtocols);
    }
    __name(allowedProtocolsFn, "allowedProtocolsFn");
    function allowedDomainsFn(allowedDomains) {
      return (input, url) => allowedDomains.includes(url.hostname) ? null : new MultiplePossibilitiesConstraintError("s.string.url", "Invalid URL domain", input, allowedDomains);
    }
    __name(allowedDomainsFn, "allowedDomainsFn");
    function stringLengthComparator(comparator, name, expected, length) {
      return {
        run(input) {
          return comparator(input.length, length) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, "Invalid string length", input, expected));
        }
      };
    }
    __name(stringLengthComparator, "stringLengthComparator");
    function stringLengthLessThan(length) {
      const expected = `expected.length < ${length}`;
      return stringLengthComparator(lessThan, "s.string.lengthLessThan", expected, length);
    }
    __name(stringLengthLessThan, "stringLengthLessThan");
    function stringLengthLessThanOrEqual(length) {
      const expected = `expected.length <= ${length}`;
      return stringLengthComparator(lessThanOrEqual, "s.string.lengthLessThanOrEqual", expected, length);
    }
    __name(stringLengthLessThanOrEqual, "stringLengthLessThanOrEqual");
    function stringLengthGreaterThan(length) {
      const expected = `expected.length > ${length}`;
      return stringLengthComparator(greaterThan, "s.string.lengthGreaterThan", expected, length);
    }
    __name(stringLengthGreaterThan, "stringLengthGreaterThan");
    function stringLengthGreaterThanOrEqual(length) {
      const expected = `expected.length >= ${length}`;
      return stringLengthComparator(greaterThanOrEqual, "s.string.lengthGreaterThanOrEqual", expected, length);
    }
    __name(stringLengthGreaterThanOrEqual, "stringLengthGreaterThanOrEqual");
    function stringLengthEqual(length) {
      const expected = `expected.length === ${length}`;
      return stringLengthComparator(equal, "s.string.lengthEqual", expected, length);
    }
    __name(stringLengthEqual, "stringLengthEqual");
    function stringLengthNotEqual(length) {
      const expected = `expected.length !== ${length}`;
      return stringLengthComparator(notEqual, "s.string.lengthNotEqual", expected, length);
    }
    __name(stringLengthNotEqual, "stringLengthNotEqual");
    function stringEmail() {
      return {
        run(input) {
          return validateEmail(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.string.email", "Invalid email address", input, "expected to be an email address"));
        }
      };
    }
    __name(stringEmail, "stringEmail");
    function stringRegexValidator(type, expected, regex) {
      return {
        run(input) {
          return regex.test(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError(type, "Invalid string format", input, expected));
        }
      };
    }
    __name(stringRegexValidator, "stringRegexValidator");
    function stringUrl(options) {
      const validatorFn = createUrlValidators(options);
      return {
        run(input) {
          let url;
          try {
            url = new URL(input);
          } catch {
            return Result.err(new ExpectedConstraintError("s.string.url", "Invalid URL", input, "expected to match a URL"));
          }
          const validatorFnResult = validatorFn(input, url);
          if (validatorFnResult === null)
            return Result.ok(input);
          return Result.err(validatorFnResult);
        }
      };
    }
    __name(stringUrl, "stringUrl");
    function stringIp(version) {
      const ipVersion = version ? `v${version}` : "";
      const validatorFn = version === 4 ? isIPv4 : version === 6 ? isIPv6 : isIP;
      const name = `s.string.ip${ipVersion}`;
      const message = `Invalid IP${ipVersion} address`;
      const expected = `expected to be an IP${ipVersion} address`;
      return {
        run(input) {
          return validatorFn(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, message, input, expected));
        }
      };
    }
    __name(stringIp, "stringIp");
    function stringRegex(regex) {
      return stringRegexValidator("s.string.regex", `expected ${regex}.test(expected) to be true`, regex);
    }
    __name(stringRegex, "stringRegex");
    function stringUuid({ version = 4, nullable = false } = {}) {
      version ?? (version = "1-5");
      const regex = new RegExp(
        `^(?:[0-9A-F]{8}-[0-9A-F]{4}-[${version}][0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}${nullable ? "|00000000-0000-0000-0000-000000000000" : ""})$`,
        "i"
      );
      const expected = `expected to match UUID${typeof version === "number" ? `v${version}` : ` in range of ${version}`}`;
      return stringRegexValidator("s.string.uuid", expected, regex);
    }
    __name(stringUuid, "stringUuid");
    function stringDate() {
      return {
        run(input) {
          const time = Date.parse(input);
          return Number.isNaN(time) ? Result.err(
            new ExpectedConstraintError(
              "s.string.date",
              "Invalid date string",
              input,
              "expected to be a valid date string (in the ISO 8601 or ECMA-262 format)"
            )
          ) : Result.ok(input);
        }
      };
    }
    __name(stringDate, "stringDate");
    function stringPhone() {
      return {
        run(input) {
          return validatePhoneNumber(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.string.phone", "Invalid phone number", input, "expected to be a phone number"));
        }
      };
    }
    __name(stringPhone, "stringPhone");
    var _StringValidator = class _StringValidator extends BaseValidator {
      lengthLessThan(length) {
        return this.addConstraint(stringLengthLessThan(length));
      }
      lengthLessThanOrEqual(length) {
        return this.addConstraint(stringLengthLessThanOrEqual(length));
      }
      lengthGreaterThan(length) {
        return this.addConstraint(stringLengthGreaterThan(length));
      }
      lengthGreaterThanOrEqual(length) {
        return this.addConstraint(stringLengthGreaterThanOrEqual(length));
      }
      lengthEqual(length) {
        return this.addConstraint(stringLengthEqual(length));
      }
      lengthNotEqual(length) {
        return this.addConstraint(stringLengthNotEqual(length));
      }
      get email() {
        return this.addConstraint(stringEmail());
      }
      url(options) {
        return this.addConstraint(stringUrl(options));
      }
      uuid(options) {
        return this.addConstraint(stringUuid(options));
      }
      regex(regex) {
        return this.addConstraint(stringRegex(regex));
      }
      get date() {
        return this.addConstraint(stringDate());
      }
      get ipv4() {
        return this.ip(4);
      }
      get ipv6() {
        return this.ip(6);
      }
      ip(version) {
        return this.addConstraint(stringIp(version));
      }
      phone() {
        return this.addConstraint(stringPhone());
      }
      handle(value) {
        return typeof value === "string" ? Result.ok(value) : Result.err(new ValidationError("s.string", "Expected a string primitive", value));
      }
    };
    __name(_StringValidator, "StringValidator");
    var StringValidator = _StringValidator;
    var _TupleValidator = class _TupleValidator extends BaseValidator {
      constructor(validators, constraints = []) {
        super(constraints);
        this.validators = [];
        this.validators = validators;
      }
      clone() {
        return Reflect.construct(this.constructor, [this.validators, this.constraints]);
      }
      handle(values) {
        if (!Array.isArray(values)) {
          return Result.err(new ValidationError("s.tuple(T)", "Expected an array", values));
        }
        if (values.length !== this.validators.length) {
          return Result.err(new ValidationError("s.tuple(T)", `Expected an array of length ${this.validators.length}`, values));
        }
        if (!this.shouldRunConstraints) {
          return Result.ok(values);
        }
        const errors2 = [];
        const transformed = [];
        for (let i3 = 0; i3 < values.length; i3++) {
          const result = this.validators[i3].run(values[i3]);
          if (result.isOk())
            transformed.push(result.value);
          else
            errors2.push([i3, result.error]);
        }
        return errors2.length === 0 ? Result.ok(transformed) : Result.err(new CombinedPropertyError(errors2));
      }
    };
    __name(_TupleValidator, "TupleValidator");
    var TupleValidator = _TupleValidator;
    var _MapValidator = class _MapValidator extends BaseValidator {
      constructor(keyValidator, valueValidator, constraints = []) {
        super(constraints);
        this.keyValidator = keyValidator;
        this.valueValidator = valueValidator;
      }
      clone() {
        return Reflect.construct(this.constructor, [this.keyValidator, this.valueValidator, this.constraints]);
      }
      handle(value) {
        if (!(value instanceof Map)) {
          return Result.err(new ValidationError("s.map(K, V)", "Expected a map", value));
        }
        if (!this.shouldRunConstraints) {
          return Result.ok(value);
        }
        const errors2 = [];
        const transformed = /* @__PURE__ */ new Map();
        for (const [key, val] of value.entries()) {
          const keyResult = this.keyValidator.run(key);
          const valueResult = this.valueValidator.run(val);
          const { length } = errors2;
          if (keyResult.isErr())
            errors2.push([key, keyResult.error]);
          if (valueResult.isErr())
            errors2.push([key, valueResult.error]);
          if (errors2.length === length)
            transformed.set(keyResult.value, valueResult.value);
        }
        return errors2.length === 0 ? Result.ok(transformed) : Result.err(new CombinedPropertyError(errors2));
      }
    };
    __name(_MapValidator, "MapValidator");
    var MapValidator = _MapValidator;
    var _LazyValidator = class _LazyValidator extends BaseValidator {
      constructor(validator, constraints = []) {
        super(constraints);
        this.validator = validator;
      }
      clone() {
        return Reflect.construct(this.constructor, [this.validator, this.constraints]);
      }
      handle(values) {
        return this.validator(values).run(values);
      }
    };
    __name(_LazyValidator, "LazyValidator");
    var LazyValidator = _LazyValidator;
    var _UnknownEnumValueError = class _UnknownEnumValueError extends BaseError {
      constructor(value, keys, enumMappings) {
        super("Expected the value to be one of the following enum values:");
        this.value = value;
        this.enumKeys = keys;
        this.enumMappings = enumMappings;
      }
      toJSON() {
        return {
          name: this.name,
          value: this.value,
          enumKeys: this.enumKeys,
          enumMappings: [...this.enumMappings.entries()]
        };
      }
      [customInspectSymbolStackLess](depth, options) {
        const value = options.stylize(this.value.toString(), "string");
        if (depth < 0) {
          return options.stylize(`[UnknownEnumValueError: ${value}]`, "special");
        }
        const padding = `
  ${options.stylize("|", "undefined")} `;
        const pairs = this.enumKeys.map((key) => {
          const enumValue = this.enumMappings.get(key);
          return `${options.stylize(key, "string")} or ${options.stylize(
            enumValue.toString(),
            typeof enumValue === "number" ? "number" : "string"
          )}`;
        }).join(padding);
        const header = `${options.stylize("UnknownEnumValueError", "special")} > ${value}`;
        const message = options.stylize(this.message, "regexp");
        const pairsBlock = `${padding}${pairs}`;
        return `${header}
  ${message}
${pairsBlock}`;
      }
    };
    __name(_UnknownEnumValueError, "UnknownEnumValueError");
    var UnknownEnumValueError = _UnknownEnumValueError;
    var _NativeEnumValidator = class _NativeEnumValidator extends BaseValidator {
      constructor(enumShape) {
        super();
        this.hasNumericElements = false;
        this.enumMapping = /* @__PURE__ */ new Map();
        this.enumShape = enumShape;
        this.enumKeys = Object.keys(enumShape).filter((key) => {
          return typeof enumShape[enumShape[key]] !== "number";
        });
        for (const key of this.enumKeys) {
          const enumValue = enumShape[key];
          this.enumMapping.set(key, enumValue);
          this.enumMapping.set(enumValue, enumValue);
          if (typeof enumValue === "number") {
            this.hasNumericElements = true;
            this.enumMapping.set(`${enumValue}`, enumValue);
          }
        }
      }
      handle(value) {
        const typeOfValue = typeof value;
        if (typeOfValue === "number") {
          if (!this.hasNumericElements) {
            return Result.err(new ValidationError("s.nativeEnum(T)", "Expected the value to be a string", value));
          }
        } else if (typeOfValue !== "string") {
          return Result.err(new ValidationError("s.nativeEnum(T)", "Expected the value to be a string or number", value));
        }
        const casted = value;
        const possibleEnumValue = this.enumMapping.get(casted);
        return typeof possibleEnumValue === "undefined" ? Result.err(new UnknownEnumValueError(casted, this.enumKeys, this.enumMapping)) : Result.ok(possibleEnumValue);
      }
      clone() {
        return Reflect.construct(this.constructor, [this.enumShape]);
      }
    };
    __name(_NativeEnumValidator, "NativeEnumValidator");
    var NativeEnumValidator = _NativeEnumValidator;
    function typedArrayByteLengthComparator(comparator, name, expected, length) {
      return {
        run(input) {
          return comparator(input.byteLength, length) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, "Invalid Typed Array byte length", input, expected));
        }
      };
    }
    __name(typedArrayByteLengthComparator, "typedArrayByteLengthComparator");
    function typedArrayByteLengthLessThan(value) {
      const expected = `expected.byteLength < ${value}`;
      return typedArrayByteLengthComparator(lessThan, "s.typedArray(T).byteLengthLessThan", expected, value);
    }
    __name(typedArrayByteLengthLessThan, "typedArrayByteLengthLessThan");
    function typedArrayByteLengthLessThanOrEqual(value) {
      const expected = `expected.byteLength <= ${value}`;
      return typedArrayByteLengthComparator(lessThanOrEqual, "s.typedArray(T).byteLengthLessThanOrEqual", expected, value);
    }
    __name(typedArrayByteLengthLessThanOrEqual, "typedArrayByteLengthLessThanOrEqual");
    function typedArrayByteLengthGreaterThan(value) {
      const expected = `expected.byteLength > ${value}`;
      return typedArrayByteLengthComparator(greaterThan, "s.typedArray(T).byteLengthGreaterThan", expected, value);
    }
    __name(typedArrayByteLengthGreaterThan, "typedArrayByteLengthGreaterThan");
    function typedArrayByteLengthGreaterThanOrEqual(value) {
      const expected = `expected.byteLength >= ${value}`;
      return typedArrayByteLengthComparator(greaterThanOrEqual, "s.typedArray(T).byteLengthGreaterThanOrEqual", expected, value);
    }
    __name(typedArrayByteLengthGreaterThanOrEqual, "typedArrayByteLengthGreaterThanOrEqual");
    function typedArrayByteLengthEqual(value) {
      const expected = `expected.byteLength === ${value}`;
      return typedArrayByteLengthComparator(equal, "s.typedArray(T).byteLengthEqual", expected, value);
    }
    __name(typedArrayByteLengthEqual, "typedArrayByteLengthEqual");
    function typedArrayByteLengthNotEqual(value) {
      const expected = `expected.byteLength !== ${value}`;
      return typedArrayByteLengthComparator(notEqual, "s.typedArray(T).byteLengthNotEqual", expected, value);
    }
    __name(typedArrayByteLengthNotEqual, "typedArrayByteLengthNotEqual");
    function typedArrayByteLengthRange(start, endBefore) {
      const expected = `expected.byteLength >= ${start} && expected.byteLength < ${endBefore}`;
      return {
        run(input) {
          return input.byteLength >= start && input.byteLength < endBefore ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.typedArray(T).byteLengthRange", "Invalid Typed Array byte length", input, expected));
        }
      };
    }
    __name(typedArrayByteLengthRange, "typedArrayByteLengthRange");
    function typedArrayByteLengthRangeInclusive(start, end) {
      const expected = `expected.byteLength >= ${start} && expected.byteLength <= ${end}`;
      return {
        run(input) {
          return input.byteLength >= start && input.byteLength <= end ? Result.ok(input) : Result.err(
            new ExpectedConstraintError("s.typedArray(T).byteLengthRangeInclusive", "Invalid Typed Array byte length", input, expected)
          );
        }
      };
    }
    __name(typedArrayByteLengthRangeInclusive, "typedArrayByteLengthRangeInclusive");
    function typedArrayByteLengthRangeExclusive(startAfter, endBefore) {
      const expected = `expected.byteLength > ${startAfter} && expected.byteLength < ${endBefore}`;
      return {
        run(input) {
          return input.byteLength > startAfter && input.byteLength < endBefore ? Result.ok(input) : Result.err(
            new ExpectedConstraintError("s.typedArray(T).byteLengthRangeExclusive", "Invalid Typed Array byte length", input, expected)
          );
        }
      };
    }
    __name(typedArrayByteLengthRangeExclusive, "typedArrayByteLengthRangeExclusive");
    function typedArrayLengthComparator(comparator, name, expected, length) {
      return {
        run(input) {
          return comparator(input.length, length) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, "Invalid Typed Array length", input, expected));
        }
      };
    }
    __name(typedArrayLengthComparator, "typedArrayLengthComparator");
    function typedArrayLengthLessThan(value) {
      const expected = `expected.length < ${value}`;
      return typedArrayLengthComparator(lessThan, "s.typedArray(T).lengthLessThan", expected, value);
    }
    __name(typedArrayLengthLessThan, "typedArrayLengthLessThan");
    function typedArrayLengthLessThanOrEqual(value) {
      const expected = `expected.length <= ${value}`;
      return typedArrayLengthComparator(lessThanOrEqual, "s.typedArray(T).lengthLessThanOrEqual", expected, value);
    }
    __name(typedArrayLengthLessThanOrEqual, "typedArrayLengthLessThanOrEqual");
    function typedArrayLengthGreaterThan(value) {
      const expected = `expected.length > ${value}`;
      return typedArrayLengthComparator(greaterThan, "s.typedArray(T).lengthGreaterThan", expected, value);
    }
    __name(typedArrayLengthGreaterThan, "typedArrayLengthGreaterThan");
    function typedArrayLengthGreaterThanOrEqual(value) {
      const expected = `expected.length >= ${value}`;
      return typedArrayLengthComparator(greaterThanOrEqual, "s.typedArray(T).lengthGreaterThanOrEqual", expected, value);
    }
    __name(typedArrayLengthGreaterThanOrEqual, "typedArrayLengthGreaterThanOrEqual");
    function typedArrayLengthEqual(value) {
      const expected = `expected.length === ${value}`;
      return typedArrayLengthComparator(equal, "s.typedArray(T).lengthEqual", expected, value);
    }
    __name(typedArrayLengthEqual, "typedArrayLengthEqual");
    function typedArrayLengthNotEqual(value) {
      const expected = `expected.length !== ${value}`;
      return typedArrayLengthComparator(notEqual, "s.typedArray(T).lengthNotEqual", expected, value);
    }
    __name(typedArrayLengthNotEqual, "typedArrayLengthNotEqual");
    function typedArrayLengthRange(start, endBefore) {
      const expected = `expected.length >= ${start} && expected.length < ${endBefore}`;
      return {
        run(input) {
          return input.length >= start && input.length < endBefore ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.typedArray(T).lengthRange", "Invalid Typed Array length", input, expected));
        }
      };
    }
    __name(typedArrayLengthRange, "typedArrayLengthRange");
    function typedArrayLengthRangeInclusive(start, end) {
      const expected = `expected.length >= ${start} && expected.length <= ${end}`;
      return {
        run(input) {
          return input.length >= start && input.length <= end ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.typedArray(T).lengthRangeInclusive", "Invalid Typed Array length", input, expected));
        }
      };
    }
    __name(typedArrayLengthRangeInclusive, "typedArrayLengthRangeInclusive");
    function typedArrayLengthRangeExclusive(startAfter, endBefore) {
      const expected = `expected.length > ${startAfter} && expected.length < ${endBefore}`;
      return {
        run(input) {
          return input.length > startAfter && input.length < endBefore ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.typedArray(T).lengthRangeExclusive", "Invalid Typed Array length", input, expected));
        }
      };
    }
    __name(typedArrayLengthRangeExclusive, "typedArrayLengthRangeExclusive");
    var vowels = ["a", "e", "i", "o", "u"];
    var aOrAn = __name((word) => {
      return `${vowels.includes(word[0].toLowerCase()) ? "an" : "a"} ${word}`;
    }, "aOrAn");
    var TypedArrays = {
      Int8Array: (x2) => x2 instanceof Int8Array,
      Uint8Array: (x2) => x2 instanceof Uint8Array,
      Uint8ClampedArray: (x2) => x2 instanceof Uint8ClampedArray,
      Int16Array: (x2) => x2 instanceof Int16Array,
      Uint16Array: (x2) => x2 instanceof Uint16Array,
      Int32Array: (x2) => x2 instanceof Int32Array,
      Uint32Array: (x2) => x2 instanceof Uint32Array,
      Float32Array: (x2) => x2 instanceof Float32Array,
      Float64Array: (x2) => x2 instanceof Float64Array,
      BigInt64Array: (x2) => x2 instanceof BigInt64Array,
      BigUint64Array: (x2) => x2 instanceof BigUint64Array,
      TypedArray: (x2) => ArrayBuffer.isView(x2) && !(x2 instanceof DataView)
    };
    var _TypedArrayValidator = class _TypedArrayValidator extends BaseValidator {
      constructor(type, constraints = []) {
        super(constraints);
        this.type = type;
      }
      byteLengthLessThan(length) {
        return this.addConstraint(typedArrayByteLengthLessThan(length));
      }
      byteLengthLessThanOrEqual(length) {
        return this.addConstraint(typedArrayByteLengthLessThanOrEqual(length));
      }
      byteLengthGreaterThan(length) {
        return this.addConstraint(typedArrayByteLengthGreaterThan(length));
      }
      byteLengthGreaterThanOrEqual(length) {
        return this.addConstraint(typedArrayByteLengthGreaterThanOrEqual(length));
      }
      byteLengthEqual(length) {
        return this.addConstraint(typedArrayByteLengthEqual(length));
      }
      byteLengthNotEqual(length) {
        return this.addConstraint(typedArrayByteLengthNotEqual(length));
      }
      byteLengthRange(start, endBefore) {
        return this.addConstraint(typedArrayByteLengthRange(start, endBefore));
      }
      byteLengthRangeInclusive(startAt, endAt) {
        return this.addConstraint(typedArrayByteLengthRangeInclusive(startAt, endAt));
      }
      byteLengthRangeExclusive(startAfter, endBefore) {
        return this.addConstraint(typedArrayByteLengthRangeExclusive(startAfter, endBefore));
      }
      lengthLessThan(length) {
        return this.addConstraint(typedArrayLengthLessThan(length));
      }
      lengthLessThanOrEqual(length) {
        return this.addConstraint(typedArrayLengthLessThanOrEqual(length));
      }
      lengthGreaterThan(length) {
        return this.addConstraint(typedArrayLengthGreaterThan(length));
      }
      lengthGreaterThanOrEqual(length) {
        return this.addConstraint(typedArrayLengthGreaterThanOrEqual(length));
      }
      lengthEqual(length) {
        return this.addConstraint(typedArrayLengthEqual(length));
      }
      lengthNotEqual(length) {
        return this.addConstraint(typedArrayLengthNotEqual(length));
      }
      lengthRange(start, endBefore) {
        return this.addConstraint(typedArrayLengthRange(start, endBefore));
      }
      lengthRangeInclusive(startAt, endAt) {
        return this.addConstraint(typedArrayLengthRangeInclusive(startAt, endAt));
      }
      lengthRangeExclusive(startAfter, endBefore) {
        return this.addConstraint(typedArrayLengthRangeExclusive(startAfter, endBefore));
      }
      clone() {
        return Reflect.construct(this.constructor, [this.type, this.constraints]);
      }
      handle(value) {
        return TypedArrays[this.type](value) ? Result.ok(value) : Result.err(new ValidationError("s.typedArray", `Expected ${aOrAn(this.type)}`, value));
      }
    };
    __name(_TypedArrayValidator, "TypedArrayValidator");
    var TypedArrayValidator = _TypedArrayValidator;
    var _Shapes = class _Shapes {
      get string() {
        return new StringValidator();
      }
      get number() {
        return new NumberValidator();
      }
      get bigint() {
        return new BigIntValidator();
      }
      get boolean() {
        return new BooleanValidator();
      }
      get date() {
        return new DateValidator();
      }
      object(shape) {
        return new ObjectValidator(shape);
      }
      get undefined() {
        return this.literal(void 0);
      }
      get null() {
        return this.literal(null);
      }
      get nullish() {
        return new NullishValidator();
      }
      get any() {
        return new PassthroughValidator();
      }
      get unknown() {
        return new PassthroughValidator();
      }
      get never() {
        return new NeverValidator();
      }
      enum(...values) {
        return this.union(...values.map((value) => this.literal(value)));
      }
      nativeEnum(enumShape) {
        return new NativeEnumValidator(enumShape);
      }
      literal(value) {
        if (value instanceof Date)
          return this.date.equal(value);
        return new LiteralValidator(value);
      }
      instance(expected) {
        return new InstanceValidator(expected);
      }
      union(...validators) {
        return new UnionValidator(validators);
      }
      array(validator) {
        return new ArrayValidator(validator);
      }
      typedArray(type = "TypedArray") {
        return new TypedArrayValidator(type);
      }
      get int8Array() {
        return this.typedArray("Int8Array");
      }
      get uint8Array() {
        return this.typedArray("Uint8Array");
      }
      get uint8ClampedArray() {
        return this.typedArray("Uint8ClampedArray");
      }
      get int16Array() {
        return this.typedArray("Int16Array");
      }
      get uint16Array() {
        return this.typedArray("Uint16Array");
      }
      get int32Array() {
        return this.typedArray("Int32Array");
      }
      get uint32Array() {
        return this.typedArray("Uint32Array");
      }
      get float32Array() {
        return this.typedArray("Float32Array");
      }
      get float64Array() {
        return this.typedArray("Float64Array");
      }
      get bigInt64Array() {
        return this.typedArray("BigInt64Array");
      }
      get bigUint64Array() {
        return this.typedArray("BigUint64Array");
      }
      tuple(validators) {
        return new TupleValidator(validators);
      }
      set(validator) {
        return new SetValidator(validator);
      }
      record(validator) {
        return new RecordValidator(validator);
      }
      map(keyValidator, valueValidator) {
        return new MapValidator(keyValidator, valueValidator);
      }
      lazy(validator) {
        return new LazyValidator(validator);
      }
    };
    __name(_Shapes, "Shapes");
    var Shapes = _Shapes;
    var s3 = new Shapes();
    exports2.BaseError = BaseError;
    exports2.CombinedError = CombinedError;
    exports2.CombinedPropertyError = CombinedPropertyError;
    exports2.ExpectedConstraintError = ExpectedConstraintError;
    exports2.ExpectedValidationError = ExpectedValidationError;
    exports2.MissingPropertyError = MissingPropertyError;
    exports2.MultiplePossibilitiesConstraintError = MultiplePossibilitiesConstraintError;
    exports2.Result = Result;
    exports2.UnknownEnumValueError = UnknownEnumValueError;
    exports2.UnknownPropertyError = UnknownPropertyError;
    exports2.ValidationError = ValidationError;
    exports2.customInspectSymbol = customInspectSymbol;
    exports2.customInspectSymbolStackLess = customInspectSymbolStackLess;
    exports2.getGlobalValidationEnabled = getGlobalValidationEnabled;
    exports2.s = s3;
    exports2.setGlobalValidationEnabled = setGlobalValidationEnabled;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/interfaces/TextBasedChannel.js
var require_TextBasedChannel = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/interfaces/TextBasedChannel.js"(exports2, module2) {
    "use strict";
    var MessageCollector = require_MessageCollector();
    var MessagePayload = require_MessagePayload();
    var { InteractionTypes, ApplicationCommandOptionTypes, Events: Events2 } = require_Constants();
    var { Error: Error2 } = require_errors2();
    var SnowflakeUtil = require_SnowflakeUtil();
    var { setTimeout: setTimeout2 } = require_node_timers();
    var { s } = require_cjs3();
    var Util = require_Util();
    var validateName = (stringName) => s.string.lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(32).regex(/^[\p{Ll}\p{Lm}\p{Lo}\p{N}\p{sc=Devanagari}\p{sc=Thai}_-]+$/u).setValidationEnabled(true).parse(stringName);
    var TextBasedChannel = class _TextBasedChannel {
      constructor() {
        this.messages = new MessageManager(this);
        this.lastMessageId = null;
        this.lastPinTimestamp = null;
      }
      /**
       * The Message object of the last message in the channel, if one was sent
       * @type {?Message}
       * @readonly
       */
      get lastMessage() {
        return this.messages.resolve(this.lastMessageId);
      }
      /**
       * The date when the last pinned message was pinned, if there was one
       * @type {?Date}
       * @readonly
       */
      get lastPinAt() {
        return this.lastPinTimestamp ? new Date(this.lastPinTimestamp) : null;
      }
      /**
       * Represents the data for a poll answer.
       * @typedef {Object} PollAnswerData
       * @property {string} text The text for the poll answer
       * @property {EmojiIdentifierResolvable} [emoji] The emoji for the poll answer
       */
      /**
       * Represents the data for a poll.
       * @typedef {Object} PollData
       * @property {PollQuestionMedia} question The question for the poll
       * @property {PollAnswerData[]} answers The answers for the poll
       * @property {number} duration The duration in hours for the poll
       * @property {boolean} allowMultiselect Whether the poll allows multiple answers
       * @property {PollLayoutType} [layoutType] The layout type for the poll
       */
      /**
       * @external PollLayoutType
       * @see {@link https://discord-api-types.dev/api/discord-api-types-v10/enum/PollLayoutType}
       */
      /**
       * Base options provided when sending.
       * @typedef {Object} BaseMessageOptions
       * @property {MessageActivity} [activity] Group activity
       * @property {boolean} [tts=false] Whether or not the message should be spoken aloud
       * @property {string} [nonce=''] The nonce for the message
       * @property {string} [content=''] The content for the message
       * @property {Array<(MessageEmbed|APIEmbed)>} [embeds] The embeds for the message
       * (see [here](https://discord.com/developers/docs/resources/channel#embed-object) for more details)
       * @property {MessageMentionOptions} [allowedMentions] Which mentions should be parsed from the message content
       * (see [here](https://discord.com/developers/docs/resources/channel#allowed-mentions-object) for more details)
       * @property {Array<(FileOptions|BufferResolvable|MessageAttachment[])>} [files] Files to send with the message
       * @property {Array<(MessageActionRow|MessageActionRowOptions)>} [components]
       * Action rows containing interactive components for the message (buttons, select menus)
       * @property {MessageAttachment[]} [attachments] Attachments to send in the message
       */
      /**
       * The base message options for messages including a poll.
       * @typedef {BaseMessageOptions} BaseMessageOptionsWithPoll
       * @property {PollData} [poll] The poll to send with the message
       */
      /**
       * Options provided when sending or editing a message.
       * @typedef {BaseMessageOptions} MessageOptions
       * @property {ReplyOptions} [reply] The options for replying to a message
       * @property {StickerResolvable[]} [stickers=[]] Stickers to send in the message
       * @property {MessageFlags} [flags] Which flags to set for the message.
       * Only `SUPPRESS_EMBEDS`, `SUPPRESS_NOTIFICATIONS` and `IS_VOICE_MESSAGE` can be set.
       */
      /**
       * Options provided to control parsing of mentions by Discord
       * @typedef {Object} MessageMentionOptions
       * @property {MessageMentionTypes[]} [parse] Types of mentions to be parsed
       * @property {Snowflake[]} [users] Snowflakes of Users to be parsed as mentions
       * @property {Snowflake[]} [roles] Snowflakes of Roles to be parsed as mentions
       * @property {boolean} [repliedUser=true] Whether the author of the Message being replied to should be pinged
       */
      /**
       * Types of mentions to enable in MessageMentionOptions.
       * - `roles`
       * - `users`
       * - `everyone`
       * @typedef {string} MessageMentionTypes
       */
      /**
       * @typedef {Object} FileOptions
       * @property {BufferResolvable} attachment File to attach
       * @property {string} [name='file.jpg'] Filename of the attachment
       * @property {string} description The description of the file
       */
      /**
       * Options for sending a message with a reply.
       * @typedef {Object} ReplyOptions
       * @property {MessageResolvable} messageReference The message to reply to (must be in the same channel and not system)
       * @property {boolean} [failIfNotExists=true] Whether to error if the referenced message
       * does not exist (creates a standard message in this case when false)
       */
      /**
       * Sends a message to this channel.
       * @param {string|MessagePayload|MessageOptions} options The options to provide
       * @returns {Promise<Message>}
       * @example
       * // Send a basic message
       * channel.send('hello!')
       *   .then(message => console.log(`Sent message: ${message.content}`))
       *   .catch(console.error);
       * @example
       * // Send a remote file
       * channel.send({
       *   files: ['https://cdn.discordapp.com/icons/222078108977594368/6e1019b3179d71046e463a75915e7244.png?size=2048']
       * })
       *   .then(console.log)
       *   .catch(console.error);
       * @example
       * // Send a local file
       * channel.send({
       *   files: [{
       *     attachment: 'entire/path/to/file.jpg',
       *     name: 'file.jpg',
       *     description: 'A description of the file'
       *   }]
       * })
       *   .then(console.log)
       *   .catch(console.error);
       */
      async send(options) {
        const User = require_User();
        const { GuildMember } = require_GuildMember();
        if (this instanceof User || this instanceof GuildMember) {
          const dm = await this.createDM();
          return dm.send(options);
        }
        let messagePayload;
        if (options instanceof MessagePayload) {
          messagePayload = options.resolveData();
        } else {
          messagePayload = MessagePayload.create(this, options).resolveData();
        }
        const { data, files } = await messagePayload.resolveFiles();
        const attachments = await Util.getUploadURL(this.client, this.id, files);
        const requestPromises = attachments.map(async (attachment) => {
          await Util.uploadFile(files[attachment.id].file, attachment.upload_url);
          return {
            id: attachment.id,
            filename: files[attachment.id].name,
            uploaded_filename: attachment.upload_filename,
            description: files[attachment.id].description,
            duration_secs: files[attachment.id].duration_secs,
            waveform: files[attachment.id].waveform
          };
        });
        const attachmentsData = await Promise.all(requestPromises);
        attachmentsData.sort((a, b) => parseInt(a.id) - parseInt(b.id));
        data.attachments = attachmentsData;
        const d = await this.client.api.channels[this.id].messages.post({ data });
        return this.messages.cache.get(d.id) ?? this.messages._add(d);
      }
      searchInteractionFromGuildAndPrivateChannel() {
        var _a;
        return this.client.api[this.guild ? "guilds" : "channels"][((_a = this.guild) == null ? void 0 : _a.id) || this.id]["application-command-index"].get().catch(() => ({
          application_commands: [],
          applications: [],
          version: ""
        }));
      }
      searchInteractionUserApps() {
        return this.client.api.users["@me"]["application-command-index"].get().catch(() => ({
          application_commands: [],
          applications: [],
          version: ""
        }));
      }
      searchInteraction() {
        return Promise.all([this.searchInteractionFromGuildAndPrivateChannel(), this.searchInteractionUserApps()]).then(
          ([dataA, dataB]) => ({
            applications: [...dataA.applications, ...dataB.applications],
            application_commands: [...dataA.application_commands, ...dataB.application_commands]
          })
        );
      }
      async sendSlash(botOrApplicationId, commandNameString, ...args) {
        var _a, _b;
        const cmd = commandNameString.trim().split(" ");
        const commandName = validateName(cmd[0]);
        const sub = cmd.slice(1);
        for (let i = 0; i < sub.length; i++) {
          if (sub.length > 2) {
            throw new Error2("INVALID_COMMAND_NAME", cmd);
          }
          validateName(sub[i]);
        }
        const data = await this.searchInteraction();
        const filterCommand = data.application_commands.filter(
          (obj) => (
            // Filter: name | name_default
            [obj.name, obj.name_default].includes(commandName)
          )
        );
        botOrApplicationId = this.client.users.resolveId(botOrApplicationId);
        const application = data.applications.find(
          (obj) => {
            var _a2;
            return obj.id == botOrApplicationId || ((_a2 = obj.bot) == null ? void 0 : _a2.id) == botOrApplicationId;
          }
        );
        const command = filterCommand.find((command2) => command2.application_id == application.id);
        if (!command) {
          throw new Error2("INVALID_APPLICATION_COMMAND", application.id);
        }
        args = args.flat(2);
        let optionFormat = [];
        let attachments = [];
        let optionsMaxdepth, subGroup, subCommand;
        if (sub.length == 2) {
          subGroup = command.options.find(
            (obj) => obj.type == ApplicationCommandOptionTypes.SUB_COMMAND_GROUP && [obj.name, obj.name_default].includes(sub[0])
          );
          if (!subGroup) throw new Error2("SLASH_COMMAND_SUB_COMMAND_GROUP_INVALID", sub[0]);
          subCommand = subGroup.options.find(
            (obj) => obj.type == ApplicationCommandOptionTypes.SUB_COMMAND && [obj.name, obj.name_default].includes(sub[1])
          );
          if (!subCommand) throw new Error2("SLASH_COMMAND_SUB_COMMAND_INVALID", sub[1]);
          optionsMaxdepth = subCommand.options;
        } else if (sub.length == 1) {
          subCommand = command.options.find(
            (obj) => obj.type == ApplicationCommandOptionTypes.SUB_COMMAND && [obj.name, obj.name_default].includes(sub[0])
          );
          if (!subCommand) throw new Error2("SLASH_COMMAND_SUB_COMMAND_INVALID", sub[0]);
          optionsMaxdepth = subCommand.options;
        } else {
          optionsMaxdepth = command.options;
        }
        const valueRequired = (optionsMaxdepth == null ? void 0 : optionsMaxdepth.filter((o) => o.required).length) || 0;
        for (let i = 0; i < Math.min(args.length, (optionsMaxdepth == null ? void 0 : optionsMaxdepth.length) || 0); i++) {
          const optionInput = optionsMaxdepth[i];
          const value = args[i];
          const parseData = await parseOption(
            this.client,
            optionInput,
            value,
            optionFormat,
            attachments,
            command,
            application.id,
            (_a = this.guild) == null ? void 0 : _a.id,
            this.id,
            subGroup,
            subCommand
          );
          optionFormat = parseData.optionFormat;
          attachments = parseData.attachments;
        }
        if (valueRequired > args.length) {
          throw new Error2("SLASH_COMMAND_REQUIRED_OPTIONS_MISSING", valueRequired, optionFormat.length);
        }
        let postData;
        if (subGroup) {
          postData = [
            {
              type: ApplicationCommandOptionTypes.SUB_COMMAND_GROUP,
              name: subGroup.name,
              options: [
                {
                  type: ApplicationCommandOptionTypes.SUB_COMMAND,
                  name: subCommand.name,
                  options: optionFormat
                }
              ]
            }
          ];
        } else if (subCommand) {
          postData = [
            {
              type: ApplicationCommandOptionTypes.SUB_COMMAND,
              name: subCommand.name,
              options: optionFormat
            }
          ];
        } else {
          postData = optionFormat;
        }
        const nonce = SnowflakeUtil.generate();
        const body = createPostData(
          this.client,
          false,
          application.id,
          nonce,
          (_b = this.guild) == null ? void 0 : _b.id,
          Boolean(command.guild_id),
          this.id,
          command.version,
          command.id,
          command.name_default || command.name,
          command.type,
          postData,
          attachments
        );
        this.client.api.interactions.post({
          data: body,
          usePayloadJSON: true
        });
        return Util.createPromiseInteraction(this.client, nonce, 5e3);
      }
      /**
       * Sends a typing indicator in the channel.
       * @returns {Promise<void>} Resolves upon the typing status being sent
       * @example
       * // Start typing in a channel
       * channel.sendTyping();
       */
      async sendTyping() {
        await this.client.api.channels(this.id).typing.post();
      }
      /**
       * Creates a Message Collector.
       * @param {MessageCollectorOptions} [options={}] The options to pass to the collector
       * @returns {MessageCollector}
       * @example
       * // Create a message collector
       * const filter = m => m.content.includes('discord');
       * const collector = channel.createMessageCollector({ filter, time: 15_000 });
       * collector.on('collect', m => console.log(`Collected ${m.content}`));
       * collector.on('end', collected => console.log(`Collected ${collected.size} items`));
       */
      createMessageCollector(options = {}) {
        return new MessageCollector(this, options);
      }
      /**
       * An object containing the same properties as CollectorOptions, but a few more:
       * @typedef {MessageCollectorOptions} AwaitMessagesOptions
       * @property {string[]} [errors] Stop/end reasons that cause the promise to reject
       */
      /**
       * Similar to createMessageCollector but in promise form.
       * Resolves with a collection of messages that pass the specified filter.
       * @param {AwaitMessagesOptions} [options={}] Optional options to pass to the internal collector
       * @returns {Promise<Collection<Snowflake, Message>>}
       * @example
       * // Await !vote messages
       * const filter = m => m.content.startsWith('!vote');
       * // Errors: ['time'] treats ending because of the time limit as an error
       * channel.awaitMessages({ filter, max: 4, time: 60_000, errors: ['time'] })
       *   .then(collected => console.log(collected.size))
       *   .catch(collected => console.log(`After a minute, only ${collected.size} out of 4 voted.`));
       */
      awaitMessages(options = {}) {
        return new Promise((resolve, reject) => {
          const collector = this.createMessageCollector(options);
          collector.once("end", (collection, reason) => {
            var _a;
            if ((_a = options.errors) == null ? void 0 : _a.includes(reason)) {
              reject(collection);
            } else {
              resolve(collection);
            }
          });
        });
      }
      /**
       * Fetches all webhooks for the channel.
       * @returns {Promise<Collection<Snowflake, Webhook>>}
       * @example
       * // Fetch webhooks
       * channel.fetchWebhooks()
       *   .then(hooks => console.log(`This channel has ${hooks.size} hooks`))
       *   .catch(console.error);
       */
      fetchWebhooks() {
        return this.guild.channels.fetchWebhooks(this.id);
      }
      /**
       * Options used to create a {@link Webhook} in a guild text-based channel.
       * @typedef {Object} ChannelWebhookCreateOptions
       * @property {?(BufferResolvable|Base64Resolvable)} [avatar] Avatar for the webhook
       * @property {string} [reason] Reason for creating the webhook
       */
      /**
       * Creates a webhook for the channel.
       * @param {string} name The name of the webhook
       * @param {ChannelWebhookCreateOptions} [options] Options for creating the webhook
       * @returns {Promise<Webhook>} Returns the created Webhook
       * @example
       * // Create a webhook for the current channel
       * channel.createWebhook('Snek', {
       *   avatar: 'https://i.imgur.com/mI8XcpG.jpg',
       *   reason: 'Needed a cool new Webhook'
       * })
       *   .then(console.log)
       *   .catch(console.error)
       */
      createWebhook(name, options = {}) {
        return this.guild.channels.createWebhook(this.id, name, options);
      }
      /**
       * Sets the rate limit per user (slowmode) for this channel.
       * @param {number} rateLimitPerUser The new rate limit in seconds
       * @param {string} [reason] Reason for changing the channel's rate limit
       * @returns {Promise<this>}
       */
      setRateLimitPerUser(rateLimitPerUser, reason) {
        return this.edit({ rateLimitPerUser }, reason);
      }
      /**
       * Sets whether this channel is flagged as NSFW.
       * @param {boolean} [nsfw=true] Whether the channel should be considered NSFW
       * @param {string} [reason] Reason for changing the channel's NSFW flag
       * @returns {Promise<this>}
       */
      setNSFW(nsfw = true, reason) {
        return this.edit({ nsfw }, reason);
      }
      static applyToClass(structure, full = false, ignore = []) {
        const props = ["send"];
        if (full) {
          props.push(
            "sendSlash",
            "searchInteraction",
            "searchInteractionFromGuildAndPrivateChannel",
            "searchInteractionUserApps",
            "lastMessage",
            "lastPinAt",
            "sendTyping",
            "createMessageCollector",
            "awaitMessages",
            "fetchWebhooks",
            "createWebhook",
            "setRateLimitPerUser",
            "setNSFW"
          );
        }
        for (const prop of props) {
          if (ignore.includes(prop)) continue;
          Object.defineProperty(
            structure.prototype,
            prop,
            Object.getOwnPropertyDescriptor(_TextBasedChannel.prototype, prop)
          );
        }
      }
    };
    module2.exports = TextBasedChannel;
    var MessageManager = require_MessageManager();
    function parseChoices(parent, list_choices, value) {
      if (value !== void 0) {
        if (Array.isArray(list_choices) && list_choices.length) {
          const choice = list_choices.find((c) => [c.name, c.value].includes(value));
          if (choice) {
            return choice.value;
          } else {
            throw new Error2("INVALID_SLASH_COMMAND_CHOICES", parent, value);
          }
        } else {
          return value;
        }
      } else {
        return void 0;
      }
    }
    async function addDataFromAttachment(value, client, channelId, attachments) {
      value = await MessagePayload.resolveFile(value);
      if (!(value == null ? void 0 : value.file)) {
        throw new TypeError("The attachment data must be a BufferResolvable or Stream or FileOptions of MessageAttachment");
      }
      const data = await Util.getUploadURL(client, channelId, [value]);
      await Util.uploadFile(value.file, data[0].upload_url);
      const id = attachments.length;
      attachments.push({
        id,
        filename: value.name,
        uploaded_filename: data[0].upload_filename
      });
      return {
        id,
        attachments
      };
    }
    async function parseOption(client, optionCommand, value, optionFormat, attachments, command, applicationId, guildId, channelId, subGroup, subCommand) {
      const data = {
        type: optionCommand.type,
        name: optionCommand.name
      };
      if (value !== void 0) {
        switch (optionCommand.type) {
          case ApplicationCommandOptionTypes.BOOLEAN:
          case "BOOLEAN": {
            data.value = Boolean(value);
            break;
          }
          case ApplicationCommandOptionTypes.INTEGER:
          case "INTEGER": {
            data.value = Number(value);
            break;
          }
          case ApplicationCommandOptionTypes.ATTACHMENT:
          case "ATTACHMENT": {
            const parseData = await addDataFromAttachment(value, client, channelId, attachments);
            data.value = parseData.id;
            attachments = parseData.attachments;
            break;
          }
          case ApplicationCommandOptionTypes.SUB_COMMAND_GROUP:
          case "SUB_COMMAND_GROUP": {
            break;
          }
          default: {
            value = parseChoices(optionCommand.name, optionCommand.choices, value);
            if (optionCommand.autocomplete) {
              const nonce = SnowflakeUtil.generate();
              let postData;
              if (subGroup) {
                postData = [
                  {
                    type: ApplicationCommandOptionTypes.SUB_COMMAND_GROUP,
                    name: subGroup.name,
                    options: [
                      {
                        type: ApplicationCommandOptionTypes.SUB_COMMAND,
                        name: subCommand.name,
                        options: [
                          {
                            type: optionCommand.type,
                            name: optionCommand.name,
                            value,
                            focused: true
                          }
                        ]
                      }
                    ]
                  }
                ];
              } else if (subCommand) {
                postData = [
                  {
                    type: ApplicationCommandOptionTypes.SUB_COMMAND,
                    name: subCommand.name,
                    options: [
                      {
                        type: optionCommand.type,
                        name: optionCommand.name,
                        value,
                        focused: true
                      }
                    ]
                  }
                ];
              } else {
                postData = [
                  {
                    type: optionCommand.type,
                    name: optionCommand.name,
                    value,
                    focused: true
                  }
                ];
              }
              const body = createPostData(
                client,
                true,
                applicationId,
                nonce,
                guildId,
                Boolean(command.guild_id),
                channelId,
                command.version,
                command.id,
                command.name_default || command.name,
                command.type,
                postData,
                []
              );
              await client.api.interactions.post({
                data: body
              });
              data.value = await awaitAutocomplete(client, nonce, value);
            } else {
              data.value = value;
            }
          }
        }
        optionFormat.push(data);
      }
      return {
        optionFormat,
        attachments
      };
    }
    function awaitAutocomplete(client, nonce, defaultValue) {
      return new Promise((resolve) => {
        const handler = (data) => {
          var _a;
          if (data.t !== "APPLICATION_COMMAND_AUTOCOMPLETE_RESPONSE") return;
          if (((_a = data.d) == null ? void 0 : _a.nonce) !== nonce) return;
          clearTimeout(timeout);
          client.removeListener(Events2.UNHANDLED_PACKET, handler);
          client.decrementMaxListeners();
          if (data.d.choices.length >= 1) {
            resolve(data.d.choices[0].value);
          } else {
            resolve(defaultValue);
          }
        };
        const timeout = setTimeout2(() => {
          client.removeListener(Events2.UNHANDLED_PACKET, handler);
          client.decrementMaxListeners();
          resolve(defaultValue);
        }, 5e3).unref();
        client.incrementMaxListeners();
        client.on(Events2.UNHANDLED_PACKET, handler);
      });
    }
    function createPostData(client, isAutocomplete = false, applicationId, nonce, guildId, isGuildCommand, channelId, commandVersion, commandId, commandName, commandType, postData, attachments = []) {
      const data = {
        type: isAutocomplete ? InteractionTypes.APPLICATION_COMMAND_AUTOCOMPLETE : InteractionTypes.APPLICATION_COMMAND,
        application_id: applicationId,
        guild_id: guildId,
        channel_id: channelId,
        session_id: client.sessionId,
        data: {
          version: commandVersion,
          id: commandId,
          name: commandName,
          type: commandType,
          options: postData,
          attachments
        },
        nonce
      };
      if (isGuildCommand) {
        data.data.guild_id = guildId;
      }
      return data;
    }
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/DMChannel.js
var require_DMChannel = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/DMChannel.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var { Channel } = require_Channel();
    var TextBasedChannel = require_TextBasedChannel();
    var MessageManager = require_MessageManager();
    var { Opcodes, Status: Status2 } = require_Constants();
    var DMChannel = class extends Channel {
      constructor(client, data) {
        super(client, data);
        this.type = "DM";
        this.messages = new MessageManager(this);
      }
      _patch(data) {
        super._patch(data);
        if (data.recipients) {
          this.recipient = this.client.users._add(data.recipients[0]);
        }
        if ("last_message_id" in data) {
          this.lastMessageId = data.last_message_id;
        }
        if ("last_pin_timestamp" in data) {
          this.lastPinTimestamp = new Date(data.last_pin_timestamp).getTime();
        } else {
          this.lastPinTimestamp ?? (this.lastPinTimestamp = null);
        }
        if ("is_message_request" in data) {
          this.messageRequest = data.is_message_request;
        }
        if ("is_message_request_timestamp" in data) {
          this.messageRequestTimestamp = new Date(data.is_message_request_timestamp).getTime();
        }
      }
      /**
       * Accept this DMChannel.
       * @returns {Promise<DMChannel>}
       */
      async acceptMessageRequest() {
        if (!this.messageRequest) {
          throw new Error("NOT_MESSAGE_REQUEST", "This channel is not a message request");
        }
        const c = await this.client.api.channels[this.id].recipients["@me"].put({
          data: {
            consent_status: 2
          }
        });
        this.messageRequest = false;
        return this.client.channels._add(c);
      }
      /**
       * Cancel this DMChannel.
       * @returns {Promise<DMChannel>}
       */
      async cancelMessageRequest() {
        if (!this.messageRequest) {
          throw new Error("NOT_MESSAGE_REQUEST", "This channel is not a message request");
        }
        await this.client.api.channels[this.id].recipients["@me"].delete();
        return this;
      }
      /**
       * Whether this DMChannel is a partial
       * @type {boolean}
       * @readonly
       */
      get partial() {
        return typeof this.lastMessageId === "undefined";
      }
      /**
       * Fetch this DMChannel.
       * @param {boolean} [force=true] Whether to skip the cache check and request the API
       * @returns {Promise<DMChannel>}
       */
      fetch(force = true) {
        return this.recipient.createDM(force);
      }
      /**
       * When concatenated with a string, this automatically returns the recipient's mention instead of the
       * DMChannel object.
       * @returns {string}
       * @example
       * // Logs: Hello from <@123456789012345678>!
       * console.log(`Hello from ${channel}!`);
       */
      toString() {
        return this.recipient.toString();
      }
      /**
       * Sync VoiceState of this DMChannel.
       * @returns {undefined}
       */
      sync() {
        this.client.ws.broadcast({
          op: Opcodes.DM_UPDATE,
          d: {
            channel_id: this.id
          }
        });
      }
      /**
       * Ring the user's phone / PC (call)
       * @returns {Promise<void>}
       */
      ring() {
        return this.client.api.channels(this.id).call.ring.post({
          data: {
            recipients: null
          }
        });
      }
      /**
       * The user in this voice-based channel
       * @type {Collection<Snowflake, User>}
       * @readonly
       */
      get voiceUsers() {
        const coll = new Collection2();
        for (const state of this.client.voiceStates.cache.values()) {
          if (state.channelId === this.id && state.user) {
            coll.set(state.id, state.user);
          }
        }
        return coll;
      }
      /**
       * Get current shard
       * @type {WebSocketShard}
       * @readonly
       */
      get shard() {
        return this.client.ws.shards.first();
      }
      /**
       * The voice state adapter for this client that can be used with @discordjs/voice to play audio in DM / Group DM channels.
       * @type {?Function}
       * @readonly
       */
      get voiceAdapterCreator() {
        return (methods) => {
          this.client.voice.adapters.set(this.id, methods);
          return {
            sendPayload: (data) => {
              if (this.shard.status !== Status2.READY) return false;
              this.shard.send(data);
              return true;
            },
            destroy: () => {
              this.client.voice.adapters.delete(this.id);
            }
          };
        };
      }
      // These are here only for documentation purposes - they are implemented by TextBasedChannel
      /* eslint-disable no-empty-function */
      get lastMessage() {
      }
      get lastPinAt() {
      }
      send() {
      }
      sendTyping() {
      }
      createMessageCollector() {
      }
      awaitMessages() {
      }
      // Doesn't work on DM channels; setRateLimitPerUser() {}
      // Doesn't work on DM channels; setNSFW() {}
    };
    TextBasedChannel.applyToClass(DMChannel, true, ["fetchWebhooks", "createWebhook", "setRateLimitPerUser", "setNSFW"]);
    module2.exports = DMChannel;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/util/ThreadMemberFlags.js
var require_ThreadMemberFlags = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/util/ThreadMemberFlags.js"(exports2, module2) {
    "use strict";
    var BitField = require_BitField();
    var ThreadMemberFlags = class extends BitField {
    };
    ThreadMemberFlags.FLAGS = {};
    module2.exports = ThreadMemberFlags;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/ThreadMember.js
var require_ThreadMember = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/ThreadMember.js"(exports2, module2) {
    "use strict";
    var Base = require_Base();
    var ThreadMemberFlags = require_ThreadMemberFlags();
    var ThreadMember = class extends Base {
      constructor(thread, data, extra = {}) {
        super(thread.client);
        this.thread = thread;
        this.joinedTimestamp = null;
        this.id = data.user_id;
        this._patch(data, extra);
      }
      _patch(data, extra = {}) {
        if ("join_timestamp" in data) this.joinedTimestamp = new Date(data.join_timestamp).getTime();
        if ("flags" in data) {
          this.flags = new ThreadMemberFlags(data.flags).freeze();
        }
        if ("member" in data) {
          this.member = this.thread.guild.members._add(data.member, extra.cache);
        } else {
          this.member ?? (this.member = null);
        }
      }
      /**
       * The guild member associated with this thread member
       * @type {?GuildMember}
       * @readonly
       */
      get guildMember() {
        return this.member ?? this.thread.guild.members.resolve(this.id);
      }
      /**
       * The last time this member joined the thread
       * @type {?Date}
       * @readonly
       */
      get joinedAt() {
        return this.joinedTimestamp ? new Date(this.joinedTimestamp) : null;
      }
      /**
       * The user associated with this thread member
       * @type {?User}
       * @readonly
       */
      get user() {
        return this.client.users.resolve(this.id);
      }
      /**
       * Whether the client user can manage this thread member
       * @type {boolean}
       * @readonly
       */
      get manageable() {
        return !this.thread.archived && this.thread.editable;
      }
      /**
       * Removes this member from the thread.
       * @param {string} [reason] Reason for removing the member
       * @returns {ThreadMember}
       */
      async remove(reason) {
        await this.thread.members.remove(this.id, reason);
        return this;
      }
    };
    module2.exports = ThreadMember;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/managers/ThreadMemberManager.js
var require_ThreadMemberManager = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/managers/ThreadMemberManager.js"(exports2, module2) {
    "use strict";
    var process2 = require_node_process();
    var { Collection: Collection2 } = require_dist();
    var CachedManager = require_CachedManager();
    var { TypeError: TypeError2 } = require_errors2();
    var ThreadMember = require_ThreadMember();
    var deprecationEmittedForPassingBoolean = false;
    var ThreadMemberManager = class extends CachedManager {
      constructor(thread, iterable) {
        super(thread.client, ThreadMember, iterable);
        this.thread = thread;
      }
      /**
       * The cache of this Manager
       * @type {Collection<Snowflake, ThreadMember>}
       * @name ThreadMemberManager#cache
       */
      _add(data, cache = true) {
        const existing = this.cache.get(data.user_id);
        if (cache) existing == null ? void 0 : existing._patch(data, { cache });
        if (existing) return existing;
        const member = new ThreadMember(this.thread, data, { cache });
        if (cache) this.cache.set(data.user_id, member);
        return member;
      }
      /**
       * Fetches the client user as a ThreadMember of the thread.
       * @param {BaseFetchOptions} [options] The options for fetching the member
       * @returns {Promise<ThreadMember>}
       */
      fetchMe(options) {
        return this.fetch(this.client.user.id, options);
      }
      /**
       * The client user as a ThreadMember of this ThreadChannel
       * @type {?ThreadMember}
       * @readonly
       */
      get me() {
        return this.resolve(this.client.user.id);
      }
      /**
       * Data that resolves to give a ThreadMember object. This can be:
       * * A ThreadMember object
       * * A User resolvable
       * @typedef {ThreadMember|UserResolvable} ThreadMemberResolvable
       */
      /**
       * Resolves a {@link ThreadMemberResolvable} to a {@link ThreadMember} object.
       * @param {ThreadMemberResolvable} member The user that is part of the thread
       * @returns {?GuildMember}
       */
      resolve(member) {
        const memberResolvable = super.resolve(member);
        if (memberResolvable) return memberResolvable;
        const userResolvable = this.client.users.resolveId(member);
        if (userResolvable) return super.resolve(userResolvable);
        return null;
      }
      /**
       * Resolves a {@link ThreadMemberResolvable} to a {@link ThreadMember} id string.
       * @param {ThreadMemberResolvable} member The user that is part of the guild
       * @returns {?Snowflake}
       */
      resolveId(member) {
        const memberResolvable = super.resolveId(member);
        if (memberResolvable) return memberResolvable;
        const userResolvable = this.client.users.resolveId(member);
        return this.cache.has(userResolvable) ? userResolvable : null;
      }
      /**
       * Adds a member to the thread.
       * @param {UserResolvable|'@me'} member The member to add
       * @param {string} [reason] The reason for adding this member
       * @returns {Promise<Snowflake>}
       */
      async add(member, reason) {
        const id = member === "@me" ? member : this.client.users.resolveId(member);
        if (!id) throw new TypeError2("INVALID_TYPE", "member", "UserResolvable");
        await this.client.api.channels(this.thread.id, "thread-members", id).put({ reason });
        return id;
      }
      /**
       * Remove a user from the thread.
       * @param {Snowflake|'@me'} id The id of the member to remove
       * @param {string} [reason] The reason for removing this member from the thread
       * @returns {Promise<Snowflake>}
       */
      async remove(id, reason) {
        await this.client.api.channels(this.thread.id, "thread-members", id).delete({ reason });
        return id;
      }
      async _fetchOne(memberId, { cache, force = false, withMember }) {
        if (!force) {
          const existing = this.cache.get(memberId);
          if (existing) return existing;
        }
        const data = await this.client.api.channels(this.thread.id, "thread-members", memberId).get({
          query: { with_member: withMember }
        });
        return this._add(data, cache);
      }
      async _fetchMany({ cache, limit, after, withMember } = {}) {
        const raw = await this.client.api.channels(this.thread.id, "thread-members").get({
          query: { with_member: withMember, limit, after }
        });
        return raw.reduce((col, member) => col.set(member.user_id, this._add(member, cache)), new Collection2());
      }
      /**
       * Options used to fetch a thread member.
       * @typedef {BaseFetchOptions} FetchThreadMemberOptions
       * @property {boolean} [withMember] Whether to also return the guild member associated with this thread member
       */
      /**
       * Options used to fetch multiple thread members with guild member data.
       * <info>With `withMember` set to `true`, pagination is enabled.</info>
       * @typedef {Object} FetchThreadMembersWithGuildMemberDataOptions
       * @property {true} withMember Whether to also return the guild member data
       * @property {Snowflake} [after] Consider only thread members after this id
       * @property {number} [limit] The maximum number of thread members to return
       * @property {boolean} [cache] Whether to cache the fetched thread members and guild members
       */
      /**
       * Options used to fetch multiple thread members without guild member data.
       * @typedef {Object} FetchThreadMembersWithoutGuildMemberDataOptions
       * @property {false} [withMember] Whether to also return the guild member data
       * @property {boolean} [cache] Whether to cache the fetched thread members
       */
      /**
       * Options used to fetch multiple thread members.
       * @typedef {FetchThreadMembersWithGuildMemberDataOptions|
       * FetchThreadMembersWithoutGuildMemberDataOptions} FetchThreadMembersOptions
       */
      /**
       * Fetches member(s) for the thread from Discord.
       * @param {UserResolvable|FetchThreadMembersOptions|boolean} [member] The member to fetch. If `undefined`, all members
       * in the thread are fetched, and will be cached based on `options.cache`.
       * @param {FetchThreadMemberOptions|FetchThreadMembersOptions} [options] Additional options for this fetch
       * @returns {Promise<ThreadMember|Collection<Snowflake, ThreadMember>>}
       */
      fetch(member, options = { cache: true, force: false }) {
        if (typeof member === "boolean" && !deprecationEmittedForPassingBoolean) {
          process2.emitWarning(
            "Passing boolean to member option is deprecated, use cache property instead.",
            "DeprecationWarning"
          );
          deprecationEmittedForPassingBoolean = true;
        }
        const id = this.resolveId(member);
        return id ? this._fetchOne(id, options) : this._fetchMany(typeof member === "boolean" ? { ...options, cache: member } : options);
      }
    };
    module2.exports = ThreadMemberManager;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/ThreadChannel.js
var require_ThreadChannel = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/ThreadChannel.js"(exports2, module2) {
    "use strict";
    var { Channel } = require_Channel();
    var TextBasedChannel = require_TextBasedChannel();
    var { RangeError: RangeError2 } = require_errors2();
    var MessageManager = require_MessageManager();
    var ThreadMemberManager = require_ThreadMemberManager();
    var ChannelFlags = require_ChannelFlags();
    var Permissions2 = require_Permissions();
    var { resolveAutoArchiveMaxLimit } = require_Util();
    var ThreadChannel = class extends Channel {
      constructor(guild, data, client) {
        super((guild == null ? void 0 : guild.client) ?? client, data, false);
        this.guild = guild;
        this.guildId = (guild == null ? void 0 : guild.id) ?? data.guild_id;
        this.messages = new MessageManager(this);
        this.members = new ThreadMemberManager(this);
        if (data) this._patch(data);
      }
      _patch(data, partial = false) {
        super._patch(data);
        if ("name" in data) {
          this.name = data.name;
        }
        if ("guild_id" in data) {
          this.guildId = data.guild_id;
        }
        if ("parent_id" in data) {
          this.parentId = data.parent_id;
        } else {
          this.parentId ?? (this.parentId = null);
        }
        if ("thread_metadata" in data) {
          this.locked = data.thread_metadata.locked ?? false;
          this.invitable = this.type === "GUILD_PRIVATE_THREAD" ? data.thread_metadata.invitable ?? false : null;
          this.archived = data.thread_metadata.archived;
          this.autoArchiveDuration = data.thread_metadata.auto_archive_duration;
          this.archiveTimestamp = new Date(data.thread_metadata.archive_timestamp).getTime();
          if ("create_timestamp" in data.thread_metadata) {
            this._createdTimestamp = Date.parse(data.thread_metadata.create_timestamp);
          }
        } else {
          this.locked ?? (this.locked = null);
          this.archived ?? (this.archived = null);
          this.autoArchiveDuration ?? (this.autoArchiveDuration = null);
          this.archiveTimestamp ?? (this.archiveTimestamp = null);
          this.invitable ?? (this.invitable = null);
        }
        this._createdTimestamp ?? (this._createdTimestamp = this.type === "GUILD_PRIVATE_THREAD" ? super.createdTimestamp : null);
        if ("owner_id" in data) {
          this.ownerId = data.owner_id;
        } else {
          this.ownerId ?? (this.ownerId = null);
        }
        if ("last_message_id" in data) {
          this.lastMessageId = data.last_message_id;
        } else {
          this.lastMessageId ?? (this.lastMessageId = null);
        }
        if ("last_pin_timestamp" in data) {
          this.lastPinTimestamp = data.last_pin_timestamp ? new Date(data.last_pin_timestamp).getTime() : null;
        } else {
          this.lastPinTimestamp ?? (this.lastPinTimestamp = null);
        }
        if ("rate_limit_per_user" in data || !partial) {
          this.rateLimitPerUser = data.rate_limit_per_user ?? 0;
        } else {
          this.rateLimitPerUser ?? (this.rateLimitPerUser = null);
        }
        if ("message_count" in data) {
          this.messageCount = data.message_count;
        } else {
          this.messageCount ?? (this.messageCount = null);
        }
        if ("member_count" in data) {
          this.memberCount = data.member_count;
        } else {
          this.memberCount ?? (this.memberCount = null);
        }
        if ("total_message_sent" in data) {
          this.totalMessageSent = data.total_message_sent;
        } else {
          this.totalMessageSent ?? (this.totalMessageSent = null);
        }
        if ("applied_tags" in data) {
          this.appliedTags = data.applied_tags;
        } else {
          this.appliedTags ?? (this.appliedTags = []);
        }
        if (data.member && this.client.user) this.members._add({ user_id: this.client.user.id, ...data.member });
        if (data.messages) for (const message of data.messages) this.messages._add(message);
      }
      /**
       * The timestamp when this thread was created. This isn't available for threads
       * created before 2022-01-09
       * @type {?number}
       * @readonly
       */
      get createdTimestamp() {
        return this._createdTimestamp;
      }
      /**
       * A collection of associated guild member objects of this thread's members
       * @type {Collection<Snowflake, GuildMember>}
       * @readonly
       */
      get guildMembers() {
        return this.members.cache.mapValues((member) => member.guildMember);
      }
      /**
       * The time at which this thread's archive status was last changed
       * <info>If the thread was never archived or unarchived, this is the time at which the thread was created</info>
       * @type {?Date}
       * @readonly
       */
      get archivedAt() {
        if (!this.archiveTimestamp) return null;
        return new Date(this.archiveTimestamp);
      }
      /**
       * The time the thread was created at
       * @type {?Date}
       * @readonly
       */
      get createdAt() {
        return this.createdTimestamp && new Date(this.createdTimestamp);
      }
      /**
       * The parent channel of this thread
       * @type {?(NewsChannel|TextChannel|ForumChannel|MediaChannel)}
       * @readonly
       */
      get parent() {
        return this.guild.channels.resolve(this.parentId);
      }
      /**
       * Makes the client user join the thread.
       * @returns {Promise<ThreadChannel>}
       */
      async join() {
        await this.members.add("@me");
        return this;
      }
      /**
       * Makes the client user leave the thread.
       * @returns {Promise<ThreadChannel>}
       */
      async leave() {
        await this.members.remove("@me");
        return this;
      }
      /**
       * Gets the overall set of permissions for a member or role in this thread's parent channel, taking overwrites into
       * account.
       * @param {GuildMemberResolvable|RoleResolvable} memberOrRole The member or role to obtain the overall permissions for
       * @param {boolean} [checkAdmin=true] Whether having `ADMINISTRATOR` will return all permissions
       * @returns {?Readonly<Permissions>}
       */
      permissionsFor(memberOrRole, checkAdmin) {
        var _a;
        return ((_a = this.parent) == null ? void 0 : _a.permissionsFor(memberOrRole, checkAdmin)) ?? null;
      }
      /**
       * Fetches the owner of this thread. If the thread member object isn't needed,
       * use {@link ThreadChannel#ownerId} instead.
       * @param {BaseFetchOptions} [options] The options for fetching the member
       * @returns {Promise<?ThreadMember>}
       */
      async fetchOwner({ cache = true, force = false } = {}) {
        if (!force) {
          const existing = this.members.cache.get(this.ownerId);
          if (existing) return existing;
        }
        const members = await this.members.fetch(cache);
        return members.get(this.ownerId) ?? null;
      }
      /**
       * Fetches the message that started this thread, if any.
       * <info>The `Promise` will reject if the original message in a forum post is deleted
       * or when the original message in the parent channel is deleted.
       * If you just need the id of that message, use {@link ThreadChannel#id} instead.</info>
       * @param {BaseFetchOptions} [options] Additional options for this fetch
       * @returns {Promise<Message|null>}
       */
      // eslint-disable-next-line require-await
      async fetchStarterMessage(options) {
        var _a;
        const channel = ((_a = this.parent) == null ? void 0 : _a.type) === "GUILD_FORUM" ? this : this.parent;
        return (channel == null ? void 0 : channel.messages.fetch(this.id, options)) ?? null;
      }
      /**
       * The options used to edit a thread channel
       * @typedef {Object} ThreadEditData
       * @property {string} [name] The new name for the thread
       * @property {boolean} [archived] Whether the thread is archived
       * @property {ThreadAutoArchiveDuration} [autoArchiveDuration] The amount of time (in minutes) after which the thread
       * should automatically archive in case of no recent activity
       * @property {number} [rateLimitPerUser] The rate limit per user (slowmode) for the thread in seconds
       * @property {boolean} [locked] Whether the thread is locked
       * @property {boolean} [invitable] Whether non-moderators can add other non-moderators to a thread
       * <info>Can only be edited on `GUILD_PRIVATE_THREAD`</info>
       * @property {Snowflake[]} [appliedTags] The tags to apply to the thread
       * @property {ChannelFlagsResolvable} [flags] The flags to set on the channel
       */
      /**
       * Edits this thread.
       * @param {ThreadEditData} data The new data for this thread
       * @param {string} [reason] Reason for editing this thread
       * @returns {Promise<ThreadChannel>}
       * @example
       * // Edit a thread
       * thread.edit({ name: 'new-thread' })
       *   .then(editedThread => console.log(editedThread))
       *   .catch(console.error);
       */
      async edit(data, reason) {
        let autoArchiveDuration = data.autoArchiveDuration;
        if (autoArchiveDuration === "MAX") autoArchiveDuration = resolveAutoArchiveMaxLimit(this.guild);
        const newData = await this.client.api.channels(this.id).patch({
          data: {
            name: (data.name ?? this.name).trim(),
            archived: data.archived,
            auto_archive_duration: autoArchiveDuration,
            rate_limit_per_user: data.rateLimitPerUser,
            locked: data.locked,
            invitable: this.type === "GUILD_PRIVATE_THREAD" ? data.invitable : void 0,
            applied_tags: data.appliedTags,
            flags: "flags" in data ? ChannelFlags.resolve(data.flags) : void 0
          },
          reason
        });
        return this.client.actions.ChannelUpdate.handle(newData).updated;
      }
      /**
       * Sets whether the thread is archived.
       * @param {boolean} [archived=true] Whether the thread is archived
       * @param {string} [reason] Reason for archiving or unarchiving
       * @returns {Promise<ThreadChannel>}
       * @example
       * // Archive the thread
       * thread.setArchived(true)
       *   .then(newThread => console.log(`Thread is now ${newThread.archived ? 'archived' : 'active'}`))
       *   .catch(console.error);
       */
      setArchived(archived = true, reason) {
        return this.edit({ archived }, reason);
      }
      /**
       * Sets the duration after which the thread will automatically archive in case of no recent activity.
       * @param {ThreadAutoArchiveDuration} autoArchiveDuration The amount of time (in minutes) after which the thread
       * should automatically archive in case of no recent activity
       * @param {string} [reason] Reason for changing the auto archive duration
       * @returns {Promise<ThreadChannel>}
       * @example
       * // Set the thread's auto archive time to 1 hour
       * thread.setAutoArchiveDuration(60)
       *   .then(newThread => {
       *     console.log(`Thread will now archive after ${newThread.autoArchiveDuration} minutes of inactivity`);
       *    });
       *   .catch(console.error);
       */
      setAutoArchiveDuration(autoArchiveDuration, reason) {
        return this.edit({ autoArchiveDuration }, reason);
      }
      /**
       * Sets whether members without the `MANAGE_THREADS` permission can invite other members without the
       * `MANAGE_THREADS` permission to this thread.
       * @param {boolean} [invitable=true] Whether non-moderators can invite non-moderators to this thread
       * @param {string} [reason] Reason for changing invite
       * @returns {Promise<ThreadChannel>}
       */
      setInvitable(invitable = true, reason) {
        if (this.type !== "GUILD_PRIVATE_THREAD") return Promise.reject(new RangeError2("THREAD_INVITABLE_TYPE", this.type));
        return this.edit({ invitable }, reason);
      }
      /**
       * Sets whether the thread can be **unarchived** by anyone with `SEND_MESSAGES` permission.
       * When a thread is locked only members with `MANAGE_THREADS` can unarchive it.
       * @param {boolean} [locked=true] Whether the thread is locked
       * @param {string} [reason] Reason for locking or unlocking the thread
       * @returns {Promise<ThreadChannel>}
       * @example
       * // Set the thread to locked
       * thread.setLocked(true)
       *   .then(newThread => console.log(`Thread is now ${newThread.locked ? 'locked' : 'unlocked'}`))
       *   .catch(console.error);
       */
      setLocked(locked = true, reason) {
        return this.edit({ locked }, reason);
      }
      /**
       * Sets a new name for this thread.
       * @param {string} name The new name for the thread
       * @param {string} [reason] Reason for changing the thread's name
       * @returns {Promise<ThreadChannel>}
       * @example
       * // Change the thread's name
       * thread.setName('not_general')
       *   .then(newThread => console.log(`Thread's new name is ${newThread.name}`))
       *   .catch(console.error);
       */
      setName(name, reason) {
        return this.edit({ name }, reason);
      }
      /**
       * Sets the rate limit per user (slowmode) for this thread.
       * @param {number} rateLimitPerUser The new rate limit in seconds
       * @param {string} [reason] Reason for changing the thread's rate limit
       * @returns {Promise<ThreadChannel>}
       */
      setRateLimitPerUser(rateLimitPerUser, reason) {
        return this.edit({ rateLimitPerUser }, reason);
      }
      /**
       * Pins this thread from the forum channel.
       * @param {string} [reason] Reason for pinning
       * @returns {Promise<ThreadChannel>}
       */
      pin(reason) {
        return this.edit({ flags: this.flags.add(ChannelFlags.FLAGS.PINNED) }, reason);
      }
      /**
       * Unpins this thread from the forum channel.
       * @param {string} [reason] Reason for unpinning
       * @returns {Promise<ThreadChannel>}
       */
      unpin(reason) {
        return this.edit({ flags: this.flags.remove(ChannelFlags.FLAGS.PINNED) }, reason);
      }
      /**
       * Set the applied tags for this channel (only applicable to forum threads)
       * @param {Snowflake[]} appliedTags The tags to set for this channel
       * @param {string} [reason] Reason for changing the thread's applied tags
       * @returns {Promise<ThreadChannel>}
       */
      setAppliedTags(appliedTags, reason) {
        return this.edit({ appliedTags }, reason);
      }
      /**
       * Whether the client user is a member of the thread.
       * @type {boolean}
       * @readonly
       */
      get joined() {
        var _a;
        return this.members.cache.has((_a = this.client.user) == null ? void 0 : _a.id);
      }
      /**
       * Whether the thread is editable by the client user (name, archived, autoArchiveDuration)
       * @type {boolean}
       * @readonly
       */
      get editable() {
        return this.ownerId === this.client.user.id && (this.type !== "GUILD_PRIVATE_THREAD" || this.joined) || this.manageable;
      }
      /**
       * Whether the thread is joinable by the client user
       * @type {boolean}
       * @readonly
       */
      get joinable() {
        var _a;
        return !this.archived && !this.joined && ((_a = this.permissionsFor(this.client.user)) == null ? void 0 : _a.has(
          this.type === "GUILD_PRIVATE_THREAD" ? Permissions2.FLAGS.MANAGE_THREADS : Permissions2.FLAGS.VIEW_CHANNEL,
          false
        ));
      }
      /**
       * Whether the thread is manageable by the client user, for deleting or editing rateLimitPerUser or locked.
       * @type {boolean}
       * @readonly
       */
      get manageable() {
        const permissions = this.permissionsFor(this.client.user);
        if (!permissions) return false;
        if (permissions.has(Permissions2.FLAGS.ADMINISTRATOR, false)) return true;
        return this.guild.members.me.communicationDisabledUntilTimestamp < Date.now() && permissions.has(Permissions2.FLAGS.MANAGE_THREADS, false);
      }
      /**
       * Whether the thread is viewable by the client user
       * @type {boolean}
       * @readonly
       */
      get viewable() {
        if (this.client.user.id === this.guild.ownerId) return true;
        const permissions = this.permissionsFor(this.client.user);
        if (!permissions) return false;
        return permissions.has(Permissions2.FLAGS.VIEW_CHANNEL, false);
      }
      /**
       * Whether the client user can send messages in this thread
       * @type {boolean}
       * @readonly
       */
      get sendable() {
        const permissions = this.permissionsFor(this.client.user);
        if (!permissions) return false;
        if (permissions.has(Permissions2.FLAGS.ADMINISTRATOR, false)) return true;
        return !(this.archived && this.locked && !this.manageable) && (this.type !== "GUILD_PRIVATE_THREAD" || this.joined || this.manageable) && permissions.has(Permissions2.FLAGS.SEND_MESSAGES_IN_THREADS, false) && this.guild.members.me.communicationDisabledUntilTimestamp < Date.now();
      }
      /**
       * Whether the thread is unarchivable by the client user
       * @type {boolean}
       * @readonly
       */
      get unarchivable() {
        return this.archived && this.sendable && (!this.locked || this.manageable);
      }
      /**
       * Whether this thread is a private thread
       * @returns {boolean}
       */
      isPrivate() {
        return this.type === "GUILD_PRIVATE_THREAD";
      }
      /**
       * Deletes this thread.
       * @param {string} [reason] Reason for deleting this thread
       * @returns {Promise<ThreadChannel>}
       * @example
       * // Delete the thread
       * thread.delete('cleaning out old threads')
       *   .then(deletedThread => console.log(deletedThread))
       *   .catch(console.error);
       */
      async delete(reason) {
        await this.guild.channels.delete(this.id, reason);
        return this;
      }
      // These are here only for documentation purposes - they are implemented by TextBasedChannel
      /* eslint-disable no-empty-function */
      get lastMessage() {
      }
      get lastPinAt() {
      }
      send() {
      }
      sendTyping() {
      }
      createMessageCollector() {
      }
      awaitMessages() {
      }
      // Doesn't work on Thread channels; setRateLimitPerUser() {}
      // Doesn't work on Thread channels; setNSFW() {}
    };
    TextBasedChannel.applyToClass(ThreadChannel, true, ["fetchWebhooks", "setRateLimitPerUser", "setNSFW"]);
    module2.exports = ThreadChannel;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/managers/ThreadManager.js
var require_ThreadManager = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/managers/ThreadManager.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var CachedManager = require_CachedManager();
    var ThreadChannel = require_ThreadChannel();
    var ThreadManager = class extends CachedManager {
      constructor(channel, iterable) {
        super(channel.client, ThreadChannel, iterable);
        this.channel = channel;
      }
      /**
       * The cache of this Manager
       * @type {Collection<Snowflake, ThreadChannel>}
       * @name ThreadManager#cache
       */
      _add(thread) {
        const existing = this.cache.get(thread.id);
        if (existing) return existing;
        this.cache.set(thread.id, thread);
        return thread;
      }
      /**
       * Data that can be resolved to a Thread Channel object. This can be:
       * * A ThreadChannel object
       * * A Snowflake
       * @typedef {ThreadChannel|Snowflake} ThreadChannelResolvable
       */
      /**
       * Resolves a {@link ThreadChannelResolvable} to a {@link ThreadChannel} object.
       * @method resolve
       * @memberof ThreadManager
       * @instance
       * @param {ThreadChannelResolvable} thread The ThreadChannel resolvable to resolve
       * @returns {?ThreadChannel}
       */
      /**
       * Resolves a {@link ThreadChannelResolvable} to a {@link ThreadChannel} id.
       * @method resolveId
       * @memberof ThreadManager
       * @instance
       * @param {ThreadChannelResolvable} thread The ThreadChannel resolvable to resolve
       * @returns {?Snowflake}
       */
      /**
       * Options for fetching multiple threads.
       * @typedef {Object} FetchThreadsOptions
       * @property {FetchArchivedThreadOptions} [archived] The options used to fetch archived threads
       */
      /**
       * Obtains a thread from Discord, or the channel cache if it's already available.
       * @param {ThreadChannelResolvable|FetchChannelThreadsOptions|FetchThreadsOptions} [options] The options to fetch threads. If it is a
       * ThreadChannelResolvable then the specified thread will be fetched. Fetches all active threads if `undefined`
       * @param {BaseFetchOptions} [cacheOptions] Additional options for this fetch. <warn>The `force` field gets ignored
       * if `options` is not a {@link ThreadChannelResolvable}</warn>
       * @returns {Promise<?(ThreadChannel|FetchedThreads)>}
       * @example
       * // Fetch a thread by its id
       * channel.threads.fetch('831955138126104859')
       *   .then(channel => console.log(channel.name))
       *   .catch(console.error);
       */
      fetch(options, { cache, force } = {}) {
        if (!options) return this.fetchActive(cache);
        const channel = this.client.channels.resolveId(options);
        if (channel) return this.client.channels.fetch(channel, { cache, force });
        if (options.archived) {
          return this.fetchArchived(options.archived, cache);
        }
        return this.fetchActive(cache);
      }
      /**
       * Data that can be resolved to a Date object. This can be:
       * * A Date object
       * * A number representing a timestamp
       * * An [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) string
       * @typedef {Date|number|string} DateResolvable
       */
      /**
       * The options used to fetch archived threads.
       * @typedef {Object} FetchArchivedThreadOptions
       * @property {string} [type='public'] The type of threads to fetch, either `public` or `private`
       * @property {boolean} [fetchAll=false] Whether to fetch **all** archived threads when type is `private`.
       * Requires `MANAGE_THREADS` if true
       * @property {DateResolvable|ThreadChannelResolvable} [before] Only return threads that were archived before this Date
       * or Snowflake. <warn>Must be a {@link ThreadChannelResolvable} when type is `private` and fetchAll is `false`</warn>
       * @property {number} [limit] Maximum number of threads to return
       */
      /**
       * The data returned from a thread fetch that returns multiple threads.
       * @typedef {Object} FetchedThreads
       * @property {Collection<Snowflake, ThreadChannel>} threads The threads that were fetched, with any members returned
       * @property {?boolean} hasMore Whether there are potentially additional threads that require a subsequent call
       */
      /**
       * Obtains a set of archived threads from Discord, requires `READ_MESSAGE_HISTORY` in the parent channel.
       * @param {FetchChannelThreadsOptions} [options] The options to fetch archived threads
       * @param {boolean} [cache=true] Whether to cache the new thread objects if they aren't already
       * @returns {Promise<FetchedThreads>}
       */
      fetchArchived(options = {}, cache = true) {
        return this.fetchActive(cache, { archived: true, ...options });
      }
      /**
       * Discord.js self-bot specific options field for fetching active threads.
       * @typedef {Object} FetchChannelThreadsOptions
       * @property {boolean} [archived] Whether to fetch archived threads (default is false)
       * @property {string} [sortBy] The order in which the threads should be fetched in (default is last_message_time)
       * @property {string} [sortOrder] How the threads should be ordered (default is desc)
       * @property {number} [limit] The maximum number of threads to return (default is 25)
       * @property {number} [offset] The number of threads to offset fetching (useful when making multiple fetches) (default is 0)
       */
      /**
       * Obtains the accessible active threads from Discord, requires `READ_MESSAGE_HISTORY` in the parent channel.
       * @param {boolean} [cache=true] Whether to cache the new thread objects if they aren't already
       * @param {FetchChannelThreadsOptions} [options] Options for self-bots where advanced users can specify further options
       * @returns {Promise<FetchedThreads>}
       */
      async fetchActive(cache = true, options = {}) {
        const raw = await this.client.api.channels(this.channel.id).threads.search.get({
          query: {
            archived: (options == null ? void 0 : options.archived) ?? false,
            limit: (options == null ? void 0 : options.limit) ?? 25,
            offset: (options == null ? void 0 : options.offset) ?? 0,
            sort_by: (options == null ? void 0 : options.sortBy) ?? "last_message_time",
            sort_order: (options == null ? void 0 : options.sortOrder) ?? "desc"
          }
        });
        return this.constructor._mapThreads(raw, this.client, { parent: this.channel, cache });
      }
      static _mapThreads(rawThreads, client, { parent, guild, cache }) {
        var _a, _b;
        const threads = rawThreads.threads.reduce((coll, raw) => {
          const thread = client.channels._add(raw, guild ?? (parent == null ? void 0 : parent.guild), { cache });
          if (parent && thread.parentId !== parent.id) return coll;
          return coll.set(thread.id, thread);
        }, new Collection2());
        for (const rawMember of rawThreads.members) (_a = client.channels.cache.get(rawMember.id)) == null ? void 0 : _a.members._add(rawMember);
        for (const rawMessage of rawThreads.first_messages) {
          (_b = client.channels.cache.get(rawMessage.id)) == null ? void 0 : _b.messages._add(rawMessage);
        }
        return {
          threads,
          hasMore: rawThreads.has_more ?? false
        };
      }
    };
    module2.exports = ThreadManager;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/managers/GuildTextThreadManager.js
var require_GuildTextThreadManager = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/managers/GuildTextThreadManager.js"(exports2, module2) {
    "use strict";
    var ThreadManager = require_ThreadManager();
    var { TypeError: TypeError2 } = require_errors2();
    var { ChannelTypes } = require_Constants();
    var { resolveAutoArchiveMaxLimit } = require_Util();
    var GuildTextThreadManager = class extends ThreadManager {
      /**
       * The channel this Manager belongs to
       * @name GuildTextThreadManager#channel
       * @type {TextChannel|NewsChannel}
       */
      /**
       * Options for creating a thread. <warn>Only one of `startMessage` or `type` can be defined.</warn>
       * @typedef {StartThreadOptions} GuildTextThreadCreateOptions
       * @property {MessageResolvable} [startMessage] The message to start a thread from. <warn>If this is defined then type
       * of thread gets automatically defined and cannot be changed. The provided `type` field will be ignored</warn>
       * @property {ThreadChannelTypes|number} [type] The type of thread to create. Defaults to `GUILD_PUBLIC_THREAD` if
       * created in a {@link TextChannel} <warn>When creating threads in a {@link NewsChannel} this is ignored and is always
       * `GUILD_NEWS_THREAD`</warn>
       * @property {boolean} [invitable] Whether non-moderators can add other non-moderators to the thread
       * <info>Can only be set when type will be `GUILD_PRIVATE_THREAD`</info>
       * @property {number} [rateLimitPerUser] The rate limit per user (slowmode) for the new channel in seconds
       */
      /**
       * Creates a new thread in the channel.
       * @param {GuildTextThreadCreateOptions} [options] Options to create a new thread
       * @returns {Promise<ThreadChannel>}
       * @example
       * // Create a new public thread
       * channel.threads
       *   .create({
       *     name: 'food-talk',
       *     autoArchiveDuration: 60,
       *     reason: 'Needed a separate thread for food',
       *   })
       *   .then(threadChannel => console.log(threadChannel))
       *   .catch(console.error);
       * @example
       * // Create a new private thread
       * channel.threads
       *   .create({
       *      name: 'mod-talk',
       *      autoArchiveDuration: 60,
       *      type: 'GUILD_PRIVATE_THREAD',
       *      reason: 'Needed a separate thread for moderation',
       *    })
       *   .then(threadChannel => console.log(threadChannel))
       *   .catch(console.error);
       */
      async create({
        name,
        autoArchiveDuration = this.channel.defaultAutoArchiveDuration,
        startMessage,
        type,
        invitable,
        reason,
        rateLimitPerUser
      } = {}) {
        let path = this.client.api.channels(this.channel.id);
        if (type && typeof type !== "string" && typeof type !== "number") {
          throw new TypeError2("INVALID_TYPE", "type", "ThreadChannelType or Number");
        }
        let resolvedType = this.channel.type === "GUILD_NEWS" ? ChannelTypes.GUILD_NEWS_THREAD : ChannelTypes.GUILD_PUBLIC_THREAD;
        if (startMessage) {
          const startMessageId = this.channel.messages.resolveId(startMessage);
          if (!startMessageId) throw new TypeError2("INVALID_TYPE", "startMessage", "MessageResolvable");
          path = path.messages(startMessageId);
        } else if (this.channel.type !== "GUILD_NEWS") {
          resolvedType = typeof type === "string" ? ChannelTypes[type] : type ?? resolvedType;
        }
        if (autoArchiveDuration === "MAX") autoArchiveDuration = resolveAutoArchiveMaxLimit(this.channel.guild);
        const data = await path.threads.post({
          data: {
            name,
            auto_archive_duration: autoArchiveDuration,
            type: resolvedType,
            invitable: resolvedType === ChannelTypes.GUILD_PRIVATE_THREAD ? invitable : void 0,
            rate_limit_per_user: rateLimitPerUser
          },
          reason
        });
        return this.client.actions.ThreadCreate.handle(data).thread;
      }
    };
    module2.exports = GuildTextThreadManager;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/BaseGuildTextChannel.js
var require_BaseGuildTextChannel = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/BaseGuildTextChannel.js"(exports2, module2) {
    "use strict";
    var GuildChannel = require_GuildChannel();
    var TextBasedChannel = require_TextBasedChannel();
    var GuildTextThreadManager = require_GuildTextThreadManager();
    var MessageManager = require_MessageManager();
    var BaseGuildTextChannel = class extends GuildChannel {
      constructor(guild, data, client) {
        super(guild, data, client, false);
        this.messages = new MessageManager(this);
        this.threads = new GuildTextThreadManager(this);
        this.nsfw = Boolean(data.nsfw);
        this._patch(data);
      }
      _patch(data) {
        super._patch(data);
        if ("topic" in data) {
          this.topic = data.topic;
        }
        if ("nsfw" in data) {
          this.nsfw = Boolean(data.nsfw);
        }
        if ("last_message_id" in data) {
          this.lastMessageId = data.last_message_id;
        }
        if ("last_pin_timestamp" in data) {
          this.lastPinTimestamp = data.last_pin_timestamp ? new Date(data.last_pin_timestamp).getTime() : null;
        }
        if ("default_auto_archive_duration" in data) {
          this.defaultAutoArchiveDuration = data.default_auto_archive_duration;
        }
        if ("default_thread_rate_limit_per_user" in data) {
          this.defaultThreadRateLimitPerUser = data.default_thread_rate_limit_per_user;
        } else {
          this.defaultThreadRateLimitPerUser ?? (this.defaultThreadRateLimitPerUser = null);
        }
        if ("messages" in data) {
          for (const message of data.messages) this.messages._add(message);
        }
      }
      /**
       * Sets the default auto archive duration for all newly created threads in this channel.
       * @param {ThreadAutoArchiveDuration} defaultAutoArchiveDuration The new default auto archive duration
       * @param {string} [reason] Reason for changing the channel's default auto archive duration
       * @returns {Promise<TextChannel>}
       */
      setDefaultAutoArchiveDuration(defaultAutoArchiveDuration, reason) {
        return this.edit({ defaultAutoArchiveDuration }, reason);
      }
      /**
       * Sets the type of this channel (only conversion between text and news is supported)
       * @param {string} type The new channel type
       * @param {string} [reason] Reason for changing the channel's type
       * @returns {Promise<GuildChannel>}
       */
      setType(type, reason) {
        return this.edit({ type }, reason);
      }
      /**
       * Sets a new topic for the guild channel.
       * @param {?string} topic The new topic for the guild channel
       * @param {string} [reason] Reason for changing the guild channel's topic
       * @returns {Promise<GuildChannel>}
       * @example
       * // Set a new channel topic
       * channel.setTopic('needs more rate limiting')
       *   .then(newChannel => console.log(`Channel's new topic is ${newChannel.topic}`))
       *   .catch(console.error);
       */
      setTopic(topic, reason) {
        return this.edit({ topic }, reason);
      }
      /**
       * Data that can be resolved to an Application. This can be:
       * * An Application
       * * An Activity with associated Application
       * * A Snowflake
       * @typedef {Application|Snowflake} ApplicationResolvable
       */
      /**
       * Options used to create an invite to a guild channel.
       * @typedef {Object} CreateInviteOptions
       * @property {boolean} [temporary=false] Whether members that joined via the invite should be automatically
       * kicked after 24 hours if they have not yet received a role
       * @property {number} [maxAge=86400] How long the invite should last (in seconds, 0 for forever)
       * @property {number} [maxUses=0] Maximum number of uses
       * @property {boolean} [unique=false] Create a unique invite, or use an existing one with similar settings
       * @property {UserResolvable} [targetUser] The user whose stream to display for this invite,
       * required if `targetType` is 1, the user must be streaming in the channel
       * @property {ApplicationResolvable} [targetApplication] The embedded application to open for this invite,
       * required if `targetType` is 2, the application must have the `EMBEDDED` flag
       * @property {TargetType} [targetType] The type of the target for this voice channel invite
       * @property {string} [reason] The reason for creating the invite
       */
      /**
       * Creates an invite to this guild channel.
       * @param {CreateInviteOptions} [options={}] The options for creating the invite
       * @returns {Promise<Invite>}
       * @example
       * // Create an invite to a channel
       * channel.createInvite()
       *   .then(invite => console.log(`Created an invite with a code of ${invite.code}`))
       *   .catch(console.error);
       */
      createInvite(options) {
        return this.guild.invites.create(this.id, options);
      }
      /**
       * Fetches a collection of invites to this guild channel.
       * Resolves with a collection mapping invites by their codes.
       * @param {boolean} [cache=true] Whether or not to cache the fetched invites
       * @returns {Promise<Collection<string, Invite>>}
       */
      fetchInvites(cache = true) {
        return this.guild.invites.fetch({ channelId: this.id, cache });
      }
      // These are here only for documentation purposes - they are implemented by TextBasedChannel
      /* eslint-disable no-empty-function */
      get lastMessage() {
      }
      get lastPinAt() {
      }
      send() {
      }
      sendTyping() {
      }
      createMessageCollector() {
      }
      awaitMessages() {
      }
      fetchWebhooks() {
      }
      createWebhook() {
      }
      setRateLimitPerUser() {
      }
      setNSFW() {
      }
    };
    TextBasedChannel.applyToClass(BaseGuildTextChannel, true);
    module2.exports = BaseGuildTextChannel;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/NewsChannel.js
var require_NewsChannel = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/NewsChannel.js"(exports2, module2) {
    "use strict";
    var BaseGuildTextChannel = require_BaseGuildTextChannel();
    var { Error: Error2 } = require_errors2();
    var NewsChannel = class extends BaseGuildTextChannel {
      /**
       * Adds the target to this channel's followers.
       * <info>If you need the created webhook id, use {@link GuildChannelManager#addFollower}.</info>
       * @param {TextChannelResolvable} channel The channel where the webhook should be created
       * @param {string} [reason] Reason for creating the webhook
       * @returns {Promise<NewsChannel>}
       * @example
       * if (channel.type === 'GUILD_NEWS') {
       *   channel.addFollower('222197033908436994', 'Important announcements')
       *     .then(() => console.log('Added follower'))
       *     .catch(console.error);
       * }
       */
      async addFollower(channel, reason) {
        const channelId = this.guild.channels.resolveId(channel);
        if (!channelId) throw new Error2("GUILD_CHANNEL_RESOLVE");
        await this.client.api.channels(this.id).followers.post({ data: { webhook_channel_id: channelId }, reason });
        return this;
      }
    };
    module2.exports = NewsChannel;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/BaseGuildVoiceChannel.js
var require_BaseGuildVoiceChannel = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/BaseGuildVoiceChannel.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var GuildChannel = require_GuildChannel();
    var TextBasedChannel = require_TextBasedChannel();
    var MessageManager = require_MessageManager();
    var { VideoQualityModes } = require_Constants();
    var Permissions2 = require_Permissions();
    var BaseGuildVoiceChannel = class extends GuildChannel {
      constructor(guild, data, client) {
        super(guild, data, client, false);
        this.messages = new MessageManager(this);
        this.nsfw = Boolean(data.nsfw);
        this._patch(data);
      }
      _patch(data) {
        super._patch(data);
        if ("bitrate" in data) {
          this.bitrate = data.bitrate;
        }
        if ("rtc_region" in data) {
          this.rtcRegion = data.rtc_region;
        }
        if ("user_limit" in data) {
          this.userLimit = data.user_limit;
        }
        if ("video_quality_mode" in data) {
          this.videoQualityMode = VideoQualityModes[data.video_quality_mode];
        } else {
          this.videoQualityMode ?? (this.videoQualityMode = null);
        }
        if ("last_message_id" in data) {
          this.lastMessageId = data.last_message_id;
        }
        if ("messages" in data) {
          for (const message of data.messages) this.messages._add(message);
        }
        if ("rate_limit_per_user" in data) {
          this.rateLimitPerUser = data.rate_limit_per_user;
        }
        if ("nsfw" in data) {
          this.nsfw = data.nsfw;
        }
        if ("status" in data) {
          this.status = data.status;
        }
      }
      /**
       * The members in this voice-based channel
       * @type {Collection<Snowflake, GuildMember>}
       * @readonly
       */
      get members() {
        const coll = new Collection2();
        for (const state of this.guild.voiceStates.cache.values()) {
          if (state.channelId === this.id && state.member) {
            coll.set(state.id, state.member);
          }
        }
        return coll;
      }
      /**
       * Checks if the voice-based channel is full
       * @type {boolean}
       * @readonly
       */
      get full() {
        return this.userLimit > 0 && this.members.size >= this.userLimit;
      }
      /**
       * Whether the channel is joinable by the client user
       * @type {boolean}
       * @readonly
       */
      get joinable() {
        if (!this.viewable) return false;
        const permissions = this.permissionsFor(this.client.user);
        if (!permissions) return false;
        if (permissions.has(Permissions2.FLAGS.ADMINISTRATOR, false)) return true;
        return this.guild.members.me.communicationDisabledUntilTimestamp < Date.now() && permissions.has(Permissions2.FLAGS.CONNECT, false);
      }
      /**
       * Creates an invite to this guild channel.
       * @param {CreateInviteOptions} [options={}] The options for creating the invite
       * @returns {Promise<Invite>}
       * @example
       * // Create an invite to a channel
       * channel.createInvite()
       *   .then(invite => console.log(`Created an invite with a code of ${invite.code}`))
       *   .catch(console.error);
       */
      createInvite(options) {
        return this.guild.invites.create(this.id, options);
      }
      /**
       * Fetches a collection of invites to this guild channel.
       * Resolves with a collection mapping invites by their codes.
       * @param {boolean} [cache=true] Whether or not to cache the fetched invites
       * @returns {Promise<Collection<string, Invite>>}
       */
      fetchInvites(cache = true) {
        return this.guild.invites.fetch({ channelId: this.id, cache });
      }
      /**
       * Sets the bitrate of the channel.
       * @param {number} bitrate The new bitrate
       * @param {string} [reason] Reason for changing the channel's bitrate
       * @returns {Promise<BaseGuildVoiceChannel>}
       * @example
       * // Set the bitrate of a voice channel
       * channel.setBitrate(48_000)
       *   .then(channel => console.log(`Set bitrate to ${channel.bitrate}bps for ${channel.name}`))
       *   .catch(console.error);
       */
      setBitrate(bitrate, reason) {
        return this.edit({ bitrate }, reason);
      }
      /**
       * Sets the RTC region of the channel.
       * @param {?string} rtcRegion The new region of the channel. Set to `null` to remove a specific region for the channel
       * @param {string} [reason] The reason for modifying this region.
       * @returns {Promise<BaseGuildVoiceChannel>}
       * @example
       * // Set the RTC region to sydney
       * channel.setRTCRegion('sydney');
       * @example
       * // Remove a fixed region for this channel - let Discord decide automatically
       * channel.setRTCRegion(null, 'We want to let Discord decide.');
       */
      setRTCRegion(rtcRegion, reason) {
        return this.edit({ rtcRegion }, reason);
      }
      /**
       * Sets the user limit of the channel.
       * @param {number} userLimit The new user limit
       * @param {string} [reason] Reason for changing the user limit
       * @returns {Promise<BaseGuildVoiceChannel>}
       * @example
       * // Set the user limit of a voice channel
       * channel.setUserLimit(42)
       *   .then(channel => console.log(`Set user limit to ${channel.userLimit} for ${channel.name}`))
       *   .catch(console.error);
       */
      setUserLimit(userLimit, reason) {
        return this.edit({ userLimit }, reason);
      }
      /**
       * Sets the camera video quality mode of the channel.
       * @param {VideoQualityMode|number} videoQualityMode The new camera video quality mode.
       * @param {string} [reason] Reason for changing the camera video quality mode.
       * @returns {Promise<BaseGuildVoiceChannel>}
       */
      setVideoQualityMode(videoQualityMode, reason) {
        return this.edit({ videoQualityMode }, reason);
      }
      // These are here only for documentation purposes - they are implemented by TextBasedChannel
      /* eslint-disable no-empty-function */
      get lastMessage() {
      }
      send() {
      }
      sendTyping() {
      }
      createMessageCollector() {
      }
      awaitMessages() {
      }
      fetchWebhooks() {
      }
      createWebhook() {
      }
      setRateLimitPerUser() {
      }
      setNSFW() {
      }
    };
    TextBasedChannel.applyToClass(BaseGuildVoiceChannel, true, ["lastPinAt"]);
    module2.exports = BaseGuildVoiceChannel;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/StageChannel.js
var require_StageChannel = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/StageChannel.js"(exports2, module2) {
    "use strict";
    var BaseGuildVoiceChannel = require_BaseGuildVoiceChannel();
    var StageChannel = class extends BaseGuildVoiceChannel {
      _patch(data) {
        super._patch(data);
        if ("topic" in data) {
          this.topic = data.topic;
        }
      }
      /**
       * The stage instance of this stage channel, if it exists
       * @type {?StageInstance}
       * @readonly
       */
      get stageInstance() {
        return this.guild.stageInstances.cache.find((stageInstance) => stageInstance.channelId === this.id) ?? null;
      }
      /**
       * Creates a stage instance associated with this stage channel.
       * @param {StageInstanceCreateOptions} options The options to create the stage instance
       * @returns {Promise<StageInstance>}
       */
      createStageInstance(options) {
        return this.guild.stageInstances.create(this.id, options);
      }
      /**
       * Sets a new topic for the guild channel.
       * @param {?string} topic The new topic for the guild channel
       * @param {string} [reason] Reason for changing the guild channel's topic
       * @returns {Promise<GuildChannel>}
       * @example
       * // Set a new channel topic
       * channel.setTopic('needs more rate limiting')
       *   .then(newChannel => console.log(`Channel's new topic is ${newChannel.topic}`))
       *   .catch(console.error);
       */
      setTopic(topic, reason) {
        return this.edit({ topic }, reason);
      }
      /**
       * Sets the bitrate of the channel.
       * @name StageChannel#setBitrate
       * @param {number} bitrate The new bitrate
       * @param {string} [reason] Reason for changing the channel's bitrate
       * @returns {Promise<StageChannel>}
       * @example
       * // Set the bitrate of a voice channel
       * stageChannel.setBitrate(48_000)
       *   .then(channel => console.log(`Set bitrate to ${channel.bitrate}bps for ${channel.name}`))
       *   .catch(console.error);
       */
      /**
       * Sets the RTC region of the channel.
       * @name StageChannel#setRTCRegion
       * @param {?string} rtcRegion The new region of the channel. Set to `null` to remove a specific region for the channel
       * @param {string} [reason] The reason for modifying this region.
       * @returns {Promise<StageChannel>}
       * @example
       * // Set the RTC region to sydney
       * stageChannel.setRTCRegion('sydney');
       * @example
       * // Remove a fixed region for this channel - let Discord decide automatically
       * stageChannel.setRTCRegion(null, 'We want to let Discord decide.');
       */
      /**
       * Sets the user limit of the channel.
       * @name StageChannel#setUserLimit
       * @param {number} userLimit The new user limit
       * @param {string} [reason] Reason for changing the user limit
       * @returns {Promise<StageChannel>}
       * @example
       * // Set the user limit of a voice channel
       * stageChannel.setUserLimit(42)
       *   .then(channel => console.log(`Set user limit to ${channel.userLimit} for ${channel.name}`))
       *   .catch(console.error);
       */
      /**
       * Sets the camera video quality mode of the channel.
       * @name StageChannel#setVideoQualityMode
       * @param {VideoQualityMode|number} videoQualityMode The new camera video quality mode.
       * @param {string} [reason] Reason for changing the camera video quality mode.
       * @returns {Promise<StageChannel>}
       */
    };
    module2.exports = StageChannel;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/StoreChannel.js
var require_StoreChannel = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/StoreChannel.js"(exports2, module2) {
    "use strict";
    var GuildChannel = require_GuildChannel();
    var StoreChannel = class extends GuildChannel {
      constructor(guild, data, client) {
        super(guild, data, client);
        this.nsfw = Boolean(data.nsfw);
      }
      _patch(data) {
        super._patch(data);
        if ("nsfw" in data) {
          this.nsfw = Boolean(data.nsfw);
        }
      }
      /**
       * Creates an invite to this guild channel.
       * @param {CreateInviteOptions} [options={}] The options for creating the invite
       * @returns {Promise<Invite>}
       * @example
       * // Create an invite to a channel
       * channel.createInvite()
       *   .then(invite => console.log(`Created an invite with a code of ${invite.code}`))
       *   .catch(console.error);
       */
      createInvite(options) {
        return this.guild.invites.create(this.id, options);
      }
      /**
       * Fetches a collection of invites to this guild channel.
       * Resolves with a collection mapping invites by their codes.
       * @param {boolean} [cache=true] Whether or not to cache the fetched invites
       * @returns {Promise<Collection<string, Invite>>}
       */
      fetchInvites(cache = true) {
        return this.guild.invites.fetch({ channelId: this.id, cache });
      }
    };
    module2.exports = StoreChannel;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/TextChannel.js
var require_TextChannel = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/TextChannel.js"(exports2, module2) {
    "use strict";
    var BaseGuildTextChannel = require_BaseGuildTextChannel();
    var TextChannel = class extends BaseGuildTextChannel {
      _patch(data) {
        super._patch(data);
        if ("rate_limit_per_user" in data) {
          this.rateLimitPerUser = data.rate_limit_per_user;
        }
      }
      /**
       * Sets the rate limit per user (slowmode) for this channel.
       * @param {number} rateLimitPerUser The new rate limit in seconds
       * @param {string} [reason] Reason for changing the channel's rate limit
       * @returns {Promise<TextChannel>}
       */
      setRateLimitPerUser(rateLimitPerUser, reason) {
        return this.edit({ rateLimitPerUser }, reason);
      }
    };
    module2.exports = TextChannel;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/VoiceChannel.js
var require_VoiceChannel = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/VoiceChannel.js"(exports2, module2) {
    "use strict";
    var process2 = require_node_process();
    var BaseGuildVoiceChannel = require_BaseGuildVoiceChannel();
    var Permissions2 = require_Permissions();
    var deprecationEmittedForEditable = false;
    var VoiceChannel = class extends BaseGuildVoiceChannel {
      /**
       * Whether the channel is editable by the client user
       * @type {boolean}
       * @readonly
       * @deprecated Use {@link VoiceChannel#manageable} instead
       */
      get editable() {
        if (!deprecationEmittedForEditable) {
          process2.emitWarning(
            "The VoiceChannel#editable getter is deprecated. Use VoiceChannel#manageable instead.",
            "DeprecationWarning"
          );
          deprecationEmittedForEditable = true;
        }
        return this.manageable;
      }
      /**
       * Whether the channel is joinable by the client user
       * @type {boolean}
       * @readonly
       */
      get joinable() {
        if (!super.joinable) return false;
        if (this.full && !this.permissionsFor(this.client.user).has(Permissions2.FLAGS.MOVE_MEMBERS, false)) return false;
        return true;
      }
      /**
       * Checks if the client has permission to send audio to the voice channel
       * @type {boolean}
       * @readonly
       */
      get speakable() {
        const permissions = this.permissionsFor(this.client.user);
        if (!permissions) return false;
        if (permissions.has(Permissions2.FLAGS.ADMINISTRATOR, false)) return true;
        return this.guild.members.me.communicationDisabledUntilTimestamp < Date.now() && permissions.has(Permissions2.FLAGS.SPEAK, false);
      }
      /**
       * Sets the bitrate of the channel.
       * @name VoiceChannel#setBitrate
       * @param {number} bitrate The new bitrate
       * @param {string} [reason] Reason for changing the channel's bitrate
       * @returns {Promise<VoiceChannel>}
       * @example
       * // Set the bitrate of a voice channel
       * voiceChannel.setBitrate(48_000)
       *   .then(channel => console.log(`Set bitrate to ${channel.bitrate}bps for ${channel.name}`))
       *   .catch(console.error);
       */
      /**
       * Sets the RTC region of the channel.
       * @name VoiceChannel#setRTCRegion
       * @param {?string} rtcRegion The new region of the channel. Set to `null` to remove a specific region for the channel
       * @param {string} [reason] The reason for modifying this region.
       * @returns {Promise<VoiceChannel>}
       * @example
       * // Set the RTC region to sydney
       * voiceChannel.setRTCRegion('sydney');
       * @example
       * // Remove a fixed region for this channel - let Discord decide automatically
       * voiceChannel.setRTCRegion(null, 'We want to let Discord decide.');
       */
      /**
       * Sets the user limit of the channel.
       * @name VoiceChannel#setUserLimit
       * @param {number} userLimit The new user limit
       * @param {string} [reason] Reason for changing the user limit
       * @returns {Promise<VoiceChannel>}
       * @example
       * // Set the user limit of a voice channel
       * voiceChannel.setUserLimit(42)
       *   .then(channel => console.log(`Set user limit to ${channel.userLimit} for ${channel.name}`))
       *   .catch(console.error);
       */
      /**
       * Sets the camera video quality mode of the channel.
       * @name VoiceChannel#setVideoQualityMode
       * @param {VideoQualityMode|number} videoQualityMode The new camera video quality mode.
       * @param {string} [reason] Reason for changing the camera video quality mode.
       * @returns {Promise<VoiceChannel>}
       */
    };
    module2.exports = VoiceChannel;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/DirectoryChannel.js
var require_DirectoryChannel = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/DirectoryChannel.js"(exports2, module2) {
    "use strict";
    var { Channel } = require_Channel();
    var DirectoryChannel = class extends Channel {
      _patch(data) {
        super._patch(data);
        this.name = data.name;
      }
    };
    module2.exports = DirectoryChannel;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/managers/GuildForumThreadManager.js
var require_GuildForumThreadManager = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/managers/GuildForumThreadManager.js"(exports2, module2) {
    "use strict";
    var ThreadManager = require_ThreadManager();
    var { TypeError: TypeError2 } = require_errors2();
    var MessagePayload = require_MessagePayload();
    var { resolveAutoArchiveMaxLimit, getUploadURL, uploadFile } = require_Util();
    var GuildForumThreadManager = class extends ThreadManager {
      /**
       * The channel this Manager belongs to
       * @name GuildForumThreadManager#channel
       * @type {ForumChannel|MediaChannel}
       */
      /**
       * @typedef {BaseMessageOptions} GuildForumThreadMessageCreateOptions
       * @property {StickerResolvable} [stickers] The stickers to send with the message
       * @property {BitFieldResolvable} [flags] The flags to send with the message.
       * Only `SUPPRESS_EMBEDS` and `SUPPRESS_NOTIFICATIONS` can be set.
       */
      /**
       * Options for creating a thread.
       * @typedef {StartThreadOptions} GuildForumThreadCreateOptions
       * @property {GuildForumThreadMessageCreateOptions|MessagePayload} message The message associated with the thread post
       * @property {Snowflake[]} [appliedTags] The tags to apply to the thread
       */
      /**
       * Creates a new thread in the channel.
       * @param {GuildForumThreadCreateOptions} [options] Options to create a new thread
       * @returns {Promise<ThreadChannel>}
       * @example
       * // Create a new forum post
       * forum.threads
       *   .create({
       *     name: 'Food Talk',
       *     autoArchiveDuration: 60,
       *     message: {
       *      content: 'Discuss your favorite food!',
       *     },
       *     reason: 'Needed a separate thread for food',
       *   })
       *   .then(threadChannel => console.log(threadChannel))
       *   .catch(console.error);
       */
      async create({
        name,
        autoArchiveDuration = this.channel.defaultAutoArchiveDuration,
        message,
        reason,
        rateLimitPerUser,
        appliedTags
      } = {}) {
        if (!message) {
          throw new TypeError2("GUILD_FORUM_MESSAGE_REQUIRED");
        }
        let messagePayload;
        if (message instanceof MessagePayload) {
          messagePayload = message.resolveData();
        } else {
          messagePayload = MessagePayload.create(this, message).resolveData();
        }
        const { data: body, files } = await messagePayload.resolveFiles();
        const attachments = await getUploadURL(this.client, this.channel.id, files);
        const requestPromises = attachments.map(async (attachment) => {
          await uploadFile(files[attachment.id].file, attachment.upload_url);
          return {
            id: attachment.id,
            filename: files[attachment.id].name,
            uploaded_filename: attachment.upload_filename,
            description: files[attachment.id].description,
            duration_secs: files[attachment.id].duration_secs,
            waveform: files[attachment.id].waveform
          };
        });
        const attachmentsData = await Promise.all(requestPromises);
        attachmentsData.sort((a, b) => parseInt(a.id) - parseInt(b.id));
        if (autoArchiveDuration === "MAX") autoArchiveDuration = resolveAutoArchiveMaxLimit(this.channel.guild);
        const post_data = await this.client.api.channels(this.channel.id).threads.post({
          data: {
            name,
            auto_archive_duration: autoArchiveDuration,
            rate_limit_per_user: rateLimitPerUser,
            applied_tags: appliedTags,
            message: body,
            attachments: attachmentsData
          },
          files: [],
          reason
        });
        return this.client.actions.ThreadCreate.handle(post_data).thread;
      }
    };
    module2.exports = GuildForumThreadManager;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/ThreadOnlyChannel.js
var require_ThreadOnlyChannel = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/ThreadOnlyChannel.js"(exports2, module2) {
    "use strict";
    var GuildChannel = require_GuildChannel();
    var TextBasedChannel = require_TextBasedChannel();
    var GuildForumThreadManager = require_GuildForumThreadManager();
    var { SortOrderTypes } = require_Constants();
    var { transformAPIGuildForumTag, transformAPIGuildDefaultReaction } = require_Util();
    var ThreadOnlyChannel = class extends GuildChannel {
      constructor(guild, data, client) {
        super(guild, data, client, false);
        this.threads = new GuildForumThreadManager(this);
        this._patch(data);
      }
      _patch(data) {
        super._patch(data);
        if ("available_tags" in data) {
          this.availableTags = data.available_tags.map((tag) => transformAPIGuildForumTag(tag));
        } else {
          this.availableTags ?? (this.availableTags = []);
        }
        if ("default_reaction_emoji" in data) {
          this.defaultReactionEmoji = data.default_reaction_emoji && transformAPIGuildDefaultReaction(data.default_reaction_emoji);
        } else {
          this.defaultReactionEmoji ?? (this.defaultReactionEmoji = null);
        }
        if ("default_thread_rate_limit_per_user" in data) {
          this.defaultThreadRateLimitPerUser = data.default_thread_rate_limit_per_user;
        } else {
          this.defaultThreadRateLimitPerUser ?? (this.defaultThreadRateLimitPerUser = null);
        }
        if ("rate_limit_per_user" in data) {
          this.rateLimitPerUser = data.rate_limit_per_user;
        } else {
          this.rateLimitPerUser ?? (this.rateLimitPerUser = null);
        }
        if ("default_auto_archive_duration" in data) {
          this.defaultAutoArchiveDuration = data.default_auto_archive_duration;
        } else {
          this.defaultAutoArchiveDuration ?? (this.defaultAutoArchiveDuration = null);
        }
        if ("nsfw" in data) {
          this.nsfw = data.nsfw;
        } else {
          this.nsfw ?? (this.nsfw = false);
        }
        if ("topic" in data) {
          this.topic = data.topic;
        }
        if ("default_sort_order" in data) {
          this.defaultSortOrder = SortOrderTypes[data.default_sort_order];
        } else {
          this.defaultSortOrder ?? (this.defaultSortOrder = null);
        }
      }
      /**
       * Sets the available tags for this forum channel
       * @param {GuildForumTagData[]} availableTags The tags to set as available in this channel
       * @param {string} [reason] Reason for changing the available tags
       * @returns {Promise<this>}
       */
      setAvailableTags(availableTags, reason) {
        return this.edit({ availableTags }, reason);
      }
      /**
       * Sets the default reaction emoji for this channel
       * @param {?DefaultReactionEmoji} defaultReactionEmoji The emoji to set as the default reaction emoji
       * @param {string} [reason] Reason for changing the default reaction emoji
       * @returns {Promise<this>}
       */
      setDefaultReactionEmoji(defaultReactionEmoji, reason) {
        return this.edit({ defaultReactionEmoji }, reason);
      }
      /**
       * Sets the default rate limit per user (slowmode) for new threads in this channel
       * @param {number} defaultThreadRateLimitPerUser The rate limit to set on newly created threads in this channel
       * @param {string} [reason] Reason for changing the default rate limit
       * @returns {Promise<this>}
       */
      setDefaultThreadRateLimitPerUser(defaultThreadRateLimitPerUser, reason) {
        return this.edit({ defaultThreadRateLimitPerUser }, reason);
      }
      /**
       * Sets the default sort order mode used to order posts
       * @param {?SortOrderType} defaultSortOrder The default sort order mode to set on this channel
       * @param {string} [reason] Reason for changing the default sort order
       * @returns {Promise<this>}
       */
      setDefaultSortOrder(defaultSortOrder, reason) {
        return this.edit({ defaultSortOrder }, reason);
      }
      /**
       * Creates an invite to this guild channel.
       * @param {CreateInviteOptions} [options={}] The options for creating the invite
       * @returns {Promise<Invite>}
       * @example
       * // Create an invite to a channel
       * channel.createInvite()
       *   .then(invite => console.log(`Created an invite with a code of ${invite.code}`))
       *   .catch(console.error);
       */
      createInvite(options) {
        return this.guild.invites.create(this.id, options);
      }
      /**
       * Fetches a collection of invites to this guild channel.
       * Resolves with a collection mapping invites by their codes.
       * @param {boolean} [cache=true] Whether or not to cache the fetched invites
       * @returns {Promise<Collection<string, Invite>>}
       */
      fetchInvites(cache = true) {
        return this.guild.invites.fetch({ channelId: this.id, cache });
      }
      /**
       * Sets the default auto archive duration for all newly created threads in this channel.
       * @param {ThreadAutoArchiveDuration} defaultAutoArchiveDuration The new default auto archive duration
       * @param {string} [reason] Reason for changing the channel's default auto archive duration
       * @returns {Promise<this>}
       */
      setDefaultAutoArchiveDuration(defaultAutoArchiveDuration, reason) {
        return this.edit({ defaultAutoArchiveDuration }, reason);
      }
      /**
       * Sets a new topic for the guild channel.
       * @param {?string} topic The new topic for the guild channel
       * @param {string} [reason] Reason for changing the guild channel's topic
       * @returns {Promise<this>}
       * @example
       * // Set a new channel topic
       * channel.setTopic('needs more rate limiting')
       *   .then(newChannel => console.log(`Channel's new topic is ${newChannel.topic}`))
       *   .catch(console.error);
       */
      setTopic(topic, reason) {
        return this.edit({ topic }, reason);
      }
      // These are here only for documentation purposes - they are implemented by TextBasedChannel
      /* eslint-disable no-empty-function */
      createWebhook() {
      }
      fetchWebhooks() {
      }
      setNSFW() {
      }
      setRateLimitPerUser() {
      }
    };
    TextBasedChannel.applyToClass(ThreadOnlyChannel, true, [
      "send",
      "lastMessage",
      "lastPinAt",
      "bulkDelete",
      "sendTyping",
      "createMessageCollector",
      "awaitMessages",
      "createMessageComponentCollector",
      "awaitMessageComponent"
    ]);
    module2.exports = ThreadOnlyChannel;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/ForumChannel.js
var require_ForumChannel = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/ForumChannel.js"(exports2, module2) {
    "use strict";
    var ThreadOnlyChannel = require_ThreadOnlyChannel();
    var { ForumLayoutTypes } = require_Constants();
    var ForumChannel = class extends ThreadOnlyChannel {
      _patch(data) {
        super._patch(data);
        this.defaultForumLayout = ForumLayoutTypes[data.default_forum_layout];
      }
      /**
       * Sets the default forum layout type used to display posts
       * @param {ForumLayoutType} defaultForumLayout The default forum layout type to set on this channel
       * @param {string} [reason] Reason for changing the default forum layout
       * @returns {Promise<ForumChannel>}
       */
      setDefaultForumLayout(defaultForumLayout, reason) {
        return this.edit({ defaultForumLayout }, reason);
      }
    };
    module2.exports = ForumChannel;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/MediaChannel.js
var require_MediaChannel = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/MediaChannel.js"(exports2, module2) {
    "use strict";
    var ThreadOnlyChannel = require_ThreadOnlyChannel();
    var MediaChannel = class extends ThreadOnlyChannel {
    };
    module2.exports = MediaChannel;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/GroupDMChannel.js
var require_GroupDMChannel = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/GroupDMChannel.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var { Channel } = require_Channel();
    var Invite2 = require_Invite();
    var TextBasedChannel = require_TextBasedChannel();
    var MessageManager = require_MessageManager();
    var { Status: Status2, Opcodes } = require_Constants();
    var DataResolver2 = require_DataResolver();
    var GroupDMChannel = class extends Channel {
      constructor(client, data) {
        super(client, data);
        this.type = "GROUP_DM";
        this.messages = new MessageManager(this);
      }
      _patch(data) {
        super._patch(data);
        if ("recipients" in data && Array.isArray(data.recipients)) {
          this._recipients = data.recipients;
          data.recipients.forEach((u) => this.client.users._add(u));
        } else {
          this._recipients = [];
        }
        if ("last_message_id" in data) {
          this.lastMessageId = data.last_message_id;
        }
        if ("last_pin_timestamp" in data) {
          this.lastPinTimestamp = new Date(data.last_pin_timestamp).getTime();
        } else {
          this.lastPinTimestamp ?? (this.lastPinTimestamp = null);
        }
        if ("owner_id" in data) {
          this.ownerId = data.owner_id;
        }
        if ("name" in data) {
          this.name = data.name;
        }
        if ("icon" in data) {
          this.icon = data.icon;
        }
      }
      /**
       * The URL to this channel's icon.
       * @param {StaticImageURLOptions} [options={}] Options for the Image URL
       * @returns {?string}
       */
      iconURL({ format, size } = {}) {
        return this.icon && this.client.rest.cdn.GDMIcon(this.id, this.icon, format, size);
      }
      /**
       * The recipients of this Group DM Channel.
       * @type {Collection<Snowflake, User>}
       * @readonly
       */
      get recipients() {
        const collect = new Collection2();
        this._recipients.map((recipient) => collect.set(recipient.id, this.client.users.cache.get(recipient.id)));
        collect.set(this.client.user.id, this.client.user);
        return collect;
      }
      /**
       * The owner of this Group DM Channel
       * @type {?User}
       * @readonly
       */
      get owner() {
        return this.client.users.cache.get(this.ownerId);
      }
      /**
       * Whether this DMChannel is a partial
       * @type {boolean}
       * @readonly
       */
      get partial() {
        return typeof this.lastMessageId === "undefined";
      }
      /**
       * Leave this Group DM Channel.
       * @param {?boolean} slient Leave without notifying other members
       * @returns {Promise<GroupDMChannel>}
       * @example
       * // Delete the channel
       * channel.delete()
       *   .then(console.log)
       *   .catch(console.error);
       */
      async delete(slient = false) {
        if (typeof slient === "boolean" && slient) {
          await this.client.api.channels[this.id].delete({
            query: {
              silent: true
            }
          });
        } else {
          await this.client.api.channels[this.id].delete();
        }
        return this;
      }
      /**
       * When concatenated with a string, this automatically returns the recipient's mention instead of the
       * GroupDMChannel object.
       * @returns {string}
       * @example
       * // Logs: Hello from Group Test!
       * console.log(`Hello from ${channel}!`);
       */
      toString() {
        return this.name ?? this._recipients.filter((user) => user.id !== this.client.user.id).map((user) => user.username).join(", ");
      }
      toJSON() {
        const json = super.toJSON({
          createdTimestamp: true
        });
        json.iconURL = this.iconURL();
        return json;
      }
      /**
       * The data for editing a channe;.
       * @typedef {Object} GroupDMChannelEditData
       * @property {string} [name] The name of the channel
       * @property {?(BufferResolvable|Base64Resolvable)} [icon] The icon of the channel
       * @property {GuildMemberResolvable} [owner] The owner of the channel
       */
      /**
       * Edit channel data
       * @param {GroupDMChannelEditData} data Data
       * @returns {Promise<GroupDMChannel>}
       * @example
       * // Set the channel name
       * channel.edit({
       *   name: 'Group Test',
       * })
       *   .then(updated => console.log(`New channel name ${updated}`))
       *   .catch(console.error);
       */
      async edit(data) {
        var _a;
        const _data = {};
        if ("name" in data) _data.name = ((_a = data.name) == null ? void 0 : _a.trim()) ?? null;
        if (typeof data.icon !== "undefined") {
          _data.icon = await DataResolver2.resolveImage(data.icon);
        }
        if ("owner" in data) {
          _data.owner = data.owner;
        }
        const newData = await this.client.api.channels[this.id].patch({
          data: _data
        });
        return this.client.actions.ChannelUpdate.handle(newData).updated;
      }
      /**
       * Renames this Group DM Channel.
       * @param {?string} name Name of the channel
       * @returns {Promise<GroupDMChannel>}
       */
      setName(name) {
        return this.edit({ name });
      }
      /**
       * Sets the icon of this Group DM Channel.
       * @param {?(Base64Resolvable|BufferResolvable)} icon Icon of the channel
       * @returns {Promise<GroupDMChannel>}
       */
      setIcon(icon) {
        return this.edit({ icon });
      }
      /**
       * Changes the owner of this Group DM Channel.
       * @param {UserResolvable} user User to transfer ownership to
       * @returns {Promise<GroupDMChannel>}
       */
      setOwner(user) {
        const id = this.client.users.resolveId(user);
        if (this.ownerId === id) {
          return Promise.resolve(this);
        }
        return this.edit({ owner: id });
      }
      /**
       * Adds a user to this Group DM Channel.
       * @param {UserResolvable} user User to add to the group
       * @returns {Promise<GroupDMChannel>}
       */
      async addUser(user) {
        user = this.client.users.resolveId(user);
        await this.client.api.channels[this.id].recipients[user].put();
        return this;
      }
      /**
       * Removes a user from this Group DM Channel.
       * @param {UserResolvable} user User to remove from the group
       * @returns {Promise<GroupDMChannel>}
       */
      async removeUser(user) {
        user = this.client.users.resolveId(user);
        await this.client.api.channels[this.id].recipients[user].delete();
        return this;
      }
      /**
       * Gets the invite for this Group DM Channel.
       * @returns {Promise<Invite>}
       */
      async getInvite() {
        const inviteCode = await this.client.api.channels(this.id).invites.post({
          data: {
            max_age: 86400
          }
        });
        return new Invite2(this.client, inviteCode);
      }
      /**
       * Get all the invites for this Group DM Channel.
       * @returns {Promise<Collection<string, Invite>>}
       */
      async fetchAllInvite() {
        const invites = await this.client.api.channels(this.id).invites.get();
        return new Collection2(invites.map((invite) => [invite.code, new Invite2(this.client, invite)]));
      }
      /**
       * Delete invites from this Group DM Channel.
       * @param {InviteResolvable} invite Invite to add to the channel
       * @returns {Promise<GroupDMChannel>}
       */
      async removeInvite(invite) {
        let code = invite == null ? void 0 : invite.code;
        if (!code && URL.canParse(invite)) code = new URL(invite).pathname.slice(1);
        else code = invite;
        await this.client.api.channels(this.id).invites[invite].delete();
        return this;
      }
      /**
       * Ring the user's phone / PC (call)
       * @param {UserResolvable[]} [recipients] Array of recipients
       * @returns {Promise<void>}
       */
      ring(recipients) {
        if (!recipients || !Array.isArray(recipients) || recipients.length == 0) {
          recipients = null;
        } else {
          recipients = recipients.map((r) => this.client.users.resolveId(r)).filter((r) => r && this.recipients.get(r));
        }
        return this.client.api.channels(this.id).call.ring.post({
          data: {
            recipients
          }
        });
      }
      /**
       * Sync VoiceState of this Group DMChannel.
       * @returns {undefined}
       */
      sync() {
        this.client.ws.broadcast({
          op: Opcodes.DM_UPDATE,
          d: {
            channel_id: this.id
          }
        });
      }
      /**
       * The user in this voice-based channel
       * @type {Collection<Snowflake, User>}
       * @readonly
       */
      get voiceUsers() {
        const coll = new Collection2();
        for (const state of this.client.voiceStates.cache.values()) {
          if (state.channelId === this.id && state.user) {
            coll.set(state.id, state.user);
          }
        }
        return coll;
      }
      /**
       * Get current shard
       * @type {WebSocketShard}
       * @readonly
       */
      get shard() {
        return this.client.ws.shards.first();
      }
      /**
       * The voice state adapter for this client that can be used with @discordjs/voice to play audio in DM / Group DM channels.
       * @type {?Function}
       * @readonly
       */
      get voiceAdapterCreator() {
        return (methods) => {
          this.client.voice.adapters.set(this.id, methods);
          return {
            sendPayload: (data) => {
              if (this.shard.status !== Status2.READY) return false;
              this.shard.send(data);
              return true;
            },
            destroy: () => {
              this.client.voice.adapters.delete(this.id);
            }
          };
        };
      }
      // These are here only for documentation purposes - they are implemented by TextBasedChannel
      /* eslint-disable no-empty-function */
      get lastMessage() {
      }
      get lastPinAt() {
      }
      send() {
      }
      sendTyping() {
      }
      createMessageCollector() {
      }
      awaitMessages() {
      }
      // Doesn't work on DM channels; setRateLimitPerUser() {}
      // Doesn't work on DM channels; setNSFW() {}
    };
    TextBasedChannel.applyToClass(GroupDMChannel, true, [
      "fetchWebhooks",
      "createWebhook",
      "setRateLimitPerUser",
      "setNSFW"
    ]);
    module2.exports = GroupDMChannel;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/Channel.js
var require_Channel = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/Channel.js"(exports2) {
    "use strict";
    var process2 = require_node_process();
    var Base = require_Base();
    var CategoryChannel;
    var DMChannel;
    var NewsChannel;
    var StageChannel;
    var StoreChannel;
    var TextChannel;
    var ThreadChannel;
    var VoiceChannel;
    var DirectoryChannel;
    var ForumChannel;
    var MediaChannel;
    var ChannelFlags = require_ChannelFlags();
    var { ChannelTypes, ThreadChannelTypes, VoiceBasedChannelTypes } = require_Constants();
    var SnowflakeUtil = require_SnowflakeUtil();
    var deletedChannels = /* @__PURE__ */ new WeakSet();
    var deprecationEmittedForDeleted = false;
    var Channel = class extends Base {
      constructor(client, data, immediatePatch = true) {
        super(client);
        const type = ChannelTypes[data == null ? void 0 : data.type];
        this.type = type ?? "UNKNOWN";
        if (data && immediatePatch) this._patch(data);
      }
      _patch(data) {
        this.id = data.id;
        if ("flags" in data) {
          this.flags = new ChannelFlags(data.flags).freeze();
        } else {
          this.flags ?? (this.flags = new ChannelFlags().freeze());
        }
      }
      /**
       * The timestamp the channel was created at
       * @type {number}
       * @readonly
       */
      get createdTimestamp() {
        return SnowflakeUtil.timestampFrom(this.id);
      }
      /**
       * The time the channel was created at
       * @type {Date}
       * @readonly
       */
      get createdAt() {
        return new Date(this.createdTimestamp);
      }
      /**
       * Whether or not the structure has been deleted
       * @type {boolean}
       * @deprecated This will be removed in the next major version, see https://github.com/discordjs/discord.js/issues/7091
       */
      get deleted() {
        if (!deprecationEmittedForDeleted) {
          deprecationEmittedForDeleted = true;
          process2.emitWarning(
            "Channel#deleted is deprecated, see https://github.com/discordjs/discord.js/issues/7091.",
            "DeprecationWarning"
          );
        }
        return deletedChannels.has(this);
      }
      set deleted(value) {
        if (!deprecationEmittedForDeleted) {
          deprecationEmittedForDeleted = true;
          process2.emitWarning(
            "Channel#deleted is deprecated, see https://github.com/discordjs/discord.js/issues/7091.",
            "DeprecationWarning"
          );
        }
        if (value) deletedChannels.add(this);
        else deletedChannels.delete(this);
      }
      /**
       * Whether this Channel is a partial
       * <info>This is always false outside of DM channels.</info>
       * @type {boolean}
       * @readonly
       */
      get partial() {
        return false;
      }
      /**
       * When concatenated with a string, this automatically returns the channel's mention instead of the Channel object.
       * @returns {string}
       * @example
       * // Logs: Hello from <#123456789012345678>!
       * console.log(`Hello from ${channel}!`);
       */
      toString() {
        return `<#${this.id}>`;
      }
      /**
       * Deletes this channel.
       * @returns {Promise<Channel>}
       * @example
       * // Delete the channel
       * channel.delete()
       *   .then(console.log)
       *   .catch(console.error);
       */
      async delete() {
        await this.client.api.channels(this.id).delete();
        return this;
      }
      /**
       * Fetches this channel.
       * @param {boolean} [force=true] Whether to skip the cache check and request the API
       * @returns {Promise<Channel>}
       */
      fetch(force = true) {
        return this.client.channels.fetch(this.id, { force });
      }
      /**
       * Indicates whether this channel is {@link TextBasedChannels text-based}.
       * @returns {boolean}
       */
      isText() {
        return "messages" in this;
      }
      /**
       * Indicates whether this channel is {@link BaseGuildVoiceChannel voice-based}.
       * @returns {boolean}
       */
      isVoice() {
        return VoiceBasedChannelTypes.includes(this.type);
      }
      /**
       * Indicates whether this channel is a {@link ThreadChannel}.
       * @returns {boolean}
       */
      isThread() {
        return ThreadChannelTypes.includes(this.type);
      }
      /**
       * Indicates whether this channel is {@link ThreadOnlyChannel}.
       * @returns {boolean}
       */
      isThreadOnly() {
        return "availableTags" in this;
      }
      /**
       * Indicates whether this channel is a {@link DirectoryChannel}
       * @returns {boolean}
       */
      isDirectory() {
        return this.type === "GUILD_DIRECTORY";
      }
      static create(client, data, guild, { allowUnknownGuild } = {}) {
        var _a, _b;
        CategoryChannel ?? (CategoryChannel = require_CategoryChannel());
        DMChannel ?? (DMChannel = require_DMChannel());
        NewsChannel ?? (NewsChannel = require_NewsChannel());
        StageChannel ?? (StageChannel = require_StageChannel());
        StoreChannel ?? (StoreChannel = require_StoreChannel());
        TextChannel ?? (TextChannel = require_TextChannel());
        ThreadChannel ?? (ThreadChannel = require_ThreadChannel());
        VoiceChannel ?? (VoiceChannel = require_VoiceChannel());
        DirectoryChannel ?? (DirectoryChannel = require_DirectoryChannel());
        ForumChannel ?? (ForumChannel = require_ForumChannel());
        MediaChannel ?? (MediaChannel = require_MediaChannel());
        let channel;
        if (!data.guild_id && !guild) {
          if (data.recipients && data.type !== ChannelTypes.GROUP_DM || data.type === ChannelTypes.DM) {
            channel = new DMChannel(client, data);
          } else if (data.type === ChannelTypes.GROUP_DM) {
            const GroupDMChannel = require_GroupDMChannel();
            channel = new GroupDMChannel(client, data);
          }
        } else {
          guild ?? (guild = client.guilds.cache.get(data.guild_id));
          if (guild || allowUnknownGuild) {
            switch (data.type) {
              case ChannelTypes.GUILD_TEXT: {
                channel = new TextChannel(guild, data, client);
                break;
              }
              case ChannelTypes.GUILD_VOICE: {
                channel = new VoiceChannel(guild, data, client);
                break;
              }
              case ChannelTypes.GUILD_CATEGORY: {
                channel = new CategoryChannel(guild, data, client);
                break;
              }
              case ChannelTypes.GUILD_NEWS: {
                channel = new NewsChannel(guild, data, client);
                break;
              }
              case ChannelTypes.GUILD_STORE: {
                channel = new StoreChannel(guild, data, client);
                break;
              }
              case ChannelTypes.GUILD_STAGE_VOICE: {
                channel = new StageChannel(guild, data, client);
                break;
              }
              case ChannelTypes.GUILD_NEWS_THREAD:
              case ChannelTypes.GUILD_PUBLIC_THREAD:
              case ChannelTypes.GUILD_PRIVATE_THREAD: {
                channel = new ThreadChannel(guild, data, client);
                if (!allowUnknownGuild) (_a = channel.parent) == null ? void 0 : _a.threads.cache.set(channel.id, channel);
                break;
              }
              case ChannelTypes.GUILD_DIRECTORY:
                channel = new DirectoryChannel(client, data);
                break;
              case ChannelTypes.GUILD_FORUM:
                channel = new ForumChannel(guild, data, client);
                break;
              case ChannelTypes.GUILD_MEDIA:
                channel = new MediaChannel(guild, data, client);
                break;
            }
            if (channel && !allowUnknownGuild) (_b = guild.channels) == null ? void 0 : _b.cache.set(channel.id, channel);
          }
        }
        return channel;
      }
      toJSON(...props) {
        return super.toJSON({ createdTimestamp: true }, ...props);
      }
    };
    exports2.Channel = Channel;
    exports2.deletedChannels = deletedChannels;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/PermissionOverwrites.js
var require_PermissionOverwrites = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/PermissionOverwrites.js"(exports2, module2) {
    "use strict";
    var Base = require_Base();
    var { Role } = require_Role();
    var { TypeError: TypeError2 } = require_errors2();
    var { OverwriteTypes } = require_Constants();
    var Permissions2 = require_Permissions();
    var PermissionOverwrites = class extends Base {
      constructor(client, data, channel) {
        super(client);
        Object.defineProperty(this, "channel", { value: channel });
        if (data) this._patch(data);
      }
      _patch(data) {
        this.id = data.id;
        if ("type" in data) {
          this.type = typeof data.type === "number" ? OverwriteTypes[data.type] : data.type;
        }
        if ("deny" in data) {
          this.deny = new Permissions2(BigInt(data.deny)).freeze();
        }
        if ("allow" in data) {
          this.allow = new Permissions2(BigInt(data.allow)).freeze();
        }
      }
      /**
       * Edits this Permission Overwrite.
       * @param {PermissionOverwriteOptions} options The options for the update
       * @param {string} [reason] Reason for creating/editing this overwrite
       * @returns {Promise<PermissionOverwrites>}
       * @example
       * // Update permission overwrites
       * permissionOverwrites.edit({
       *   SEND_MESSAGES: false
       * })
       *   .then(channel => console.log(channel.permissionOverwrites.get(message.author.id)))
       *   .catch(console.error);
       */
      async edit(options, reason) {
        await this.channel.permissionOverwrites.upsert(this.id, options, { type: OverwriteTypes[this.type], reason }, this);
        return this;
      }
      /**
       * Deletes this Permission Overwrite.
       * @param {string} [reason] Reason for deleting this overwrite
       * @returns {Promise<PermissionOverwrites>}
       */
      async delete(reason) {
        await this.channel.permissionOverwrites.delete(this.id, reason);
        return this;
      }
      toJSON() {
        return {
          id: this.id,
          type: OverwriteTypes[this.type],
          allow: this.allow,
          deny: this.deny
        };
      }
      /**
       * An object mapping permission flags to `true` (enabled), `null` (unset) or `false` (disabled).
       * ```js
       * {
       *  'SEND_MESSAGES': true,
       *  'EMBED_LINKS': null,
       *  'ATTACH_FILES': false,
       * }
       * ```
       * @typedef {Object} PermissionOverwriteOptions
       */
      /**
       * @typedef {Object} ResolvedOverwriteOptions
       * @property {Permissions} allow The allowed permissions
       * @property {Permissions} deny The denied permissions
       */
      /**
       * Resolves bitfield permissions overwrites from an object.
       * @param {PermissionOverwriteOptions} options The options for the update
       * @param {ResolvedOverwriteOptions} initialPermissions The initial permissions
       * @returns {ResolvedOverwriteOptions}
       */
      static resolveOverwriteOptions(options, { allow, deny } = {}) {
        allow = new Permissions2(allow);
        deny = new Permissions2(deny);
        for (const [perm, value] of Object.entries(options)) {
          if (value === true) {
            allow.add(perm);
            deny.remove(perm);
          } else if (value === false) {
            allow.remove(perm);
            deny.add(perm);
          } else if (value === null) {
            allow.remove(perm);
            deny.remove(perm);
          }
        }
        return { allow, deny };
      }
      /**
       * The raw data for a permission overwrite
       * @typedef {Object} RawOverwriteData
       * @property {Snowflake} id The id of the {@link Role} or {@link User} this overwrite belongs to
       * @property {string} allow The permissions to allow
       * @property {string} deny The permissions to deny
       * @property {number} type The type of this OverwriteData
       */
      /**
       * Data that can be resolved into {@link RawOverwriteData}. This can be:
       * * PermissionOverwrites
       * * OverwriteData
       * @typedef {PermissionOverwrites|OverwriteData} OverwriteResolvable
       */
      /**
       * Data that can be used for a permission overwrite
       * @typedef {Object} OverwriteData
       * @property {GuildMemberResolvable|RoleResolvable} id Member or role this overwrite is for
       * @property {PermissionResolvable} [allow] The permissions to allow
       * @property {PermissionResolvable} [deny] The permissions to deny
       * @property {OverwriteType} [type] The type of this OverwriteData
       */
      /**
       * Resolves an overwrite into {@link RawOverwriteData}.
       * @param {OverwriteResolvable} overwrite The overwrite-like data to resolve
       * @param {Guild} [guild] The guild to resolve from
       * @returns {RawOverwriteData}
       */
      static resolve(overwrite, guild) {
        if (overwrite instanceof this) return overwrite.toJSON();
        if (typeof overwrite.id === "string" && overwrite.type in OverwriteTypes) {
          return {
            id: overwrite.id,
            type: OverwriteTypes[overwrite.type],
            allow: Permissions2.resolve(overwrite.allow ?? Permissions2.defaultBit).toString(),
            deny: Permissions2.resolve(overwrite.deny ?? Permissions2.defaultBit).toString()
          };
        }
        const userOrRole = guild.roles.resolve(overwrite.id) ?? guild.client.users.resolve(overwrite.id);
        if (!userOrRole) throw new TypeError2("INVALID_TYPE", "parameter", "User nor a Role");
        const type = userOrRole instanceof Role ? OverwriteTypes.role : OverwriteTypes.member;
        return {
          id: userOrRole.id,
          type,
          allow: Permissions2.resolve(overwrite.allow ?? Permissions2.defaultBit).toString(),
          deny: Permissions2.resolve(overwrite.deny ?? Permissions2.defaultBit).toString()
        };
      }
    };
    module2.exports = PermissionOverwrites;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/managers/PermissionOverwriteManager.js
var require_PermissionOverwriteManager = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/managers/PermissionOverwriteManager.js"(exports2, module2) {
    "use strict";
    var process2 = require_node_process();
    var { Collection: Collection2 } = require_dist();
    var CachedManager = require_CachedManager();
    var { TypeError: TypeError2 } = require_errors2();
    var PermissionOverwrites = require_PermissionOverwrites();
    var { Role } = require_Role();
    var { OverwriteTypes } = require_Constants();
    var cacheWarningEmitted = false;
    var PermissionOverwriteManager = class extends CachedManager {
      constructor(channel, iterable) {
        super(channel.client, PermissionOverwrites);
        if (!cacheWarningEmitted && this._cache.constructor.name !== "Collection") {
          cacheWarningEmitted = true;
          process2.emitWarning(
            `Overriding the cache handling for ${this.constructor.name} is unsupported and breaks functionality.`,
            "UnsupportedCacheOverwriteWarning"
          );
        }
        this.channel = channel;
        if (iterable) {
          for (const item of iterable) {
            this._add(item);
          }
        }
      }
      /**
       * The cache of this Manager
       * @type {Collection<Snowflake, PermissionOverwrites>}
       * @name PermissionOverwriteManager#cache
       */
      _add(data, cache) {
        return super._add(data, cache, { extras: [this.channel] });
      }
      /**
       * Replaces the permission overwrites in this channel.
       * @param {OverwriteResolvable[]|Collection<Snowflake, OverwriteResolvable>} overwrites
       * Permission overwrites the channel gets updated with
       * @param {string} [reason] Reason for updating the channel overwrites
       * @returns {Promise<GuildChannel>}
       * @example
       * message.channel.permissionOverwrites.set([
       *   {
       *      id: message.author.id,
       *      deny: [Permissions.FLAGS.VIEW_CHANNEL],
       *   },
       * ], 'Needed to change permissions');
       */
      set(overwrites, reason) {
        if (!Array.isArray(overwrites) && !(overwrites instanceof Collection2)) {
          return Promise.reject(
            new TypeError2("INVALID_TYPE", "overwrites", "Array or Collection of Permission Overwrites", true)
          );
        }
        return this.channel.edit({ permissionOverwrites: overwrites, reason });
      }
      /**
       * Extra information about the overwrite
       * @typedef {Object} GuildChannelOverwriteOptions
       * @property {string} [reason] Reason for creating/editing this overwrite
       * @property {number} [type] The type of overwrite, either `0` for a role or `1` for a member. Use this to bypass
       * automatic resolution of type that results in an error for uncached structure
       */
      /**
       * Creates or edits permission overwrites for a user or role in this channel.
       * @param {RoleResolvable|UserResolvable} userOrRole The user or role to update
       * @param {PermissionOverwriteOptions} options The options for the update
       * @param {GuildChannelOverwriteOptions} [overwriteOptions] The extra information for the update
       * @param {PermissionOverwrites} [existing] The existing overwrites to merge with this update
       * @returns {Promise<GuildChannel>}
       * @private
       */
      async upsert(userOrRole, options, overwriteOptions = {}, existing) {
        let userOrRoleId = this.channel.guild.roles.resolveId(userOrRole) ?? this.client.users.resolveId(userOrRole);
        let { type, reason } = overwriteOptions;
        if (typeof type !== "number") {
          userOrRole = this.channel.guild.roles.resolve(userOrRole) ?? this.client.users.resolve(userOrRole);
          if (!userOrRole) throw new TypeError2("INVALID_TYPE", "parameter", "User nor a Role");
          type = userOrRole instanceof Role ? OverwriteTypes.role : OverwriteTypes.member;
        }
        const { allow, deny } = PermissionOverwrites.resolveOverwriteOptions(options, existing);
        await this.client.api.channels(this.channel.id).permissions(userOrRoleId).put({
          data: { id: userOrRoleId, type, allow, deny },
          reason
        });
        return this.channel;
      }
      /**
       * Creates permission overwrites for a user or role in this channel, or replaces them if already present.
       * @param {RoleResolvable|UserResolvable} userOrRole The user or role to update
       * @param {PermissionOverwriteOptions} options The options for the update
       * @param {GuildChannelOverwriteOptions} [overwriteOptions] The extra information for the update
       * @returns {Promise<GuildChannel>}
       * @example
       * // Create or Replace permission overwrites for a message author
       * message.channel.permissionOverwrites.create(message.author, {
       *   SEND_MESSAGES: false
       * })
       *   .then(channel => console.log(channel.permissionOverwrites.cache.get(message.author.id)))
       *   .catch(console.error);
       */
      create(userOrRole, options, overwriteOptions) {
        return this.upsert(userOrRole, options, overwriteOptions);
      }
      /**
       * Edits permission overwrites for a user or role in this channel, or creates an entry if not already present.
       * @param {RoleResolvable|UserResolvable} userOrRole The user or role to update
       * @param {PermissionOverwriteOptions} options The options for the update
       * @param {GuildChannelOverwriteOptions} [overwriteOptions] The extra information for the update
       * @returns {Promise<GuildChannel>}
       * @example
       * // Edit or Create permission overwrites for a message author
       * message.channel.permissionOverwrites.edit(message.author, {
       *   SEND_MESSAGES: false
       * })
       *   .then(channel => console.log(channel.permissionOverwrites.cache.get(message.author.id)))
       *   .catch(console.error);
       */
      edit(userOrRole, options, overwriteOptions) {
        const existing = this.cache.get(
          this.channel.guild.roles.resolveId(userOrRole) ?? this.client.users.resolveId(userOrRole)
        );
        return this.upsert(userOrRole, options, overwriteOptions, existing);
      }
      /**
       * Deletes permission overwrites for a user or role in this channel.
       * @param {UserResolvable|RoleResolvable} userOrRole The user or role to delete
       * @param {string} [reason] The reason for deleting the overwrite
       * @returns {Promise<GuildChannel>}
       */
      async delete(userOrRole, reason) {
        const userOrRoleId = this.channel.guild.roles.resolveId(userOrRole) ?? this.client.users.resolveId(userOrRole);
        if (!userOrRoleId) throw new TypeError2("INVALID_TYPE", "parameter", "User nor a Role");
        await this.client.api.channels(this.channel.id).permissions(userOrRoleId).delete({ reason });
        return this.channel;
      }
    };
    module2.exports = PermissionOverwriteManager;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/GuildChannel.js
var require_GuildChannel = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/GuildChannel.js"(exports2, module2) {
    "use strict";
    var { Channel } = require_Channel();
    var { Error: Error2 } = require_errors2();
    var PermissionOverwriteManager = require_PermissionOverwriteManager();
    var { VoiceBasedChannelTypes } = require_Constants();
    var Permissions2 = require_Permissions();
    var Util = require_Util();
    var GuildChannel = class extends Channel {
      constructor(guild, data, client, immediatePatch = true) {
        super((guild == null ? void 0 : guild.client) ?? client, data, false);
        this.guild = guild;
        this.guildId = (guild == null ? void 0 : guild.id) ?? data.guild_id;
        this.parentId = this.parentId ?? null;
        this.permissionOverwrites = new PermissionOverwriteManager(this);
        if (data && immediatePatch) this._patch(data);
      }
      _patch(data) {
        super._patch(data);
        if ("name" in data) {
          this.name = data.name;
        }
        if ("position" in data) {
          this.rawPosition = data.position;
        }
        if ("guild_id" in data) {
          this.guildId = data.guild_id;
        }
        if ("parent_id" in data) {
          this.parentId = data.parent_id;
        }
        if ("permission_overwrites" in data) {
          this.permissionOverwrites.cache.clear();
          for (const overwrite of data.permission_overwrites) {
            this.permissionOverwrites._add(overwrite);
          }
        }
      }
      _clone() {
        const clone = super._clone();
        clone.permissionOverwrites = new PermissionOverwriteManager(clone, this.permissionOverwrites.cache.values());
        return clone;
      }
      /**
       * The category parent of this channel
       * @type {?CategoryChannel}
       * @readonly
       */
      get parent() {
        return this.guild.channels.resolve(this.parentId);
      }
      /**
       * If the permissionOverwrites match the parent channel, null if no parent
       * @type {?boolean}
       * @readonly
       */
      get permissionsLocked() {
        if (!this.parent) return null;
        const overwriteIds = /* @__PURE__ */ new Set([
          ...this.permissionOverwrites.cache.keys(),
          ...this.parent.permissionOverwrites.cache.keys()
        ]);
        return [...overwriteIds].every((key) => {
          const channelVal = this.permissionOverwrites.cache.get(key);
          const parentVal = this.parent.permissionOverwrites.cache.get(key);
          if (!channelVal && parentVal.deny.bitfield === Permissions2.defaultBit && parentVal.allow.bitfield === Permissions2.defaultBit || !parentVal && channelVal.deny.bitfield === Permissions2.defaultBit && channelVal.allow.bitfield === Permissions2.defaultBit) {
            return true;
          }
          return typeof channelVal !== "undefined" && typeof parentVal !== "undefined" && channelVal.deny.bitfield === parentVal.deny.bitfield && channelVal.allow.bitfield === parentVal.allow.bitfield;
        });
      }
      /**
       * The position of the channel
       * @type {number}
       * @readonly
       */
      get position() {
        const selfIsCategory = this.type === "GUILD_CATEGORY";
        const types = Util.getSortableGroupTypes(this.type);
        let count = 0;
        for (const channel of this.guild.channels.cache.values()) {
          if (!types.includes(channel.type)) continue;
          if (!selfIsCategory && channel.parentId !== this.parentId) continue;
          if (this.rawPosition === channel.rawPosition) {
            if (BigInt(channel.id) < BigInt(this.id)) count++;
          } else if (this.rawPosition > channel.rawPosition) {
            count++;
          }
        }
        return count;
      }
      /**
       * Gets the overall set of permissions for a member or role in this channel, taking into account channel overwrites.
       * @param {GuildMemberResolvable|RoleResolvable} memberOrRole The member or role to obtain the overall permissions for
       * @param {boolean} [checkAdmin=true] Whether having `ADMINISTRATOR` will return all permissions
       * @returns {?Readonly<Permissions>}
       */
      permissionsFor(memberOrRole, checkAdmin = true) {
        const member = this.guild.members.resolve(memberOrRole);
        if (member) return this.memberPermissions(member, checkAdmin);
        const role = this.guild.roles.resolve(memberOrRole);
        return role && this.rolePermissions(role, checkAdmin);
      }
      overwritesFor(member, verified = false, roles = null) {
        if (!verified) member = this.guild.members.resolve(member);
        if (!member) return [];
        roles ?? (roles = member.roles.cache);
        const roleOverwrites = [];
        let memberOverwrites;
        let everyoneOverwrites;
        for (const overwrite of this.permissionOverwrites.cache.values()) {
          if (overwrite.id === this.guild.id) {
            everyoneOverwrites = overwrite;
          } else if (roles.has(overwrite.id)) {
            roleOverwrites.push(overwrite);
          } else if (overwrite.id === member.id) {
            memberOverwrites = overwrite;
          }
        }
        return {
          everyone: everyoneOverwrites,
          roles: roleOverwrites,
          member: memberOverwrites
        };
      }
      /**
       * Gets the overall set of permissions for a member in this channel, taking into account channel overwrites.
       * @param {GuildMember} member The member to obtain the overall permissions for
       * @param {boolean} checkAdmin=true Whether having `ADMINISTRATOR` will return all permissions
       * @returns {Readonly<Permissions>}
       * @private
       */
      memberPermissions(member, checkAdmin) {
        var _a, _b, _c, _d;
        if (checkAdmin && member.id === this.guild.ownerId) return new Permissions2(Permissions2.ALL).freeze();
        const roles = member.roles.cache;
        const permissions = new Permissions2(roles.map((role) => role.permissions));
        if (checkAdmin && permissions.has(Permissions2.FLAGS.ADMINISTRATOR)) {
          return new Permissions2(Permissions2.ALL).freeze();
        }
        const overwrites = this.overwritesFor(member, true, roles);
        return permissions.remove(((_a = overwrites.everyone) == null ? void 0 : _a.deny) ?? Permissions2.defaultBit).add(((_b = overwrites.everyone) == null ? void 0 : _b.allow) ?? Permissions2.defaultBit).remove(overwrites.roles.length > 0 ? overwrites.roles.map((role) => role.deny) : Permissions2.defaultBit).add(overwrites.roles.length > 0 ? overwrites.roles.map((role) => role.allow) : Permissions2.defaultBit).remove(((_c = overwrites.member) == null ? void 0 : _c.deny) ?? Permissions2.defaultBit).add(((_d = overwrites.member) == null ? void 0 : _d.allow) ?? Permissions2.defaultBit).freeze();
      }
      /**
       * Gets the overall set of permissions for a role in this channel, taking into account channel overwrites.
       * @param {Role} role The role to obtain the overall permissions for
       * @param {boolean} checkAdmin Whether having `ADMINISTRATOR` will return all permissions
       * @returns {Readonly<Permissions>}
       * @private
       */
      rolePermissions(role, checkAdmin) {
        if (checkAdmin && role.permissions.has(Permissions2.FLAGS.ADMINISTRATOR)) {
          return new Permissions2(Permissions2.ALL).freeze();
        }
        const everyoneOverwrites = this.permissionOverwrites.cache.get(this.guild.id);
        const roleOverwrites = this.permissionOverwrites.cache.get(role.id);
        return role.permissions.remove((everyoneOverwrites == null ? void 0 : everyoneOverwrites.deny) ?? Permissions2.defaultBit).add((everyoneOverwrites == null ? void 0 : everyoneOverwrites.allow) ?? Permissions2.defaultBit).remove((roleOverwrites == null ? void 0 : roleOverwrites.deny) ?? Permissions2.defaultBit).add((roleOverwrites == null ? void 0 : roleOverwrites.allow) ?? Permissions2.defaultBit).freeze();
      }
      /**
       * Locks in the permission overwrites from the parent channel.
       * @returns {Promise<GuildChannel>}
       */
      lockPermissions() {
        if (!this.parent) return Promise.reject(new Error2("GUILD_CHANNEL_ORPHAN"));
        const permissionOverwrites = this.parent.permissionOverwrites.cache.map((overwrite) => overwrite.toJSON());
        return this.edit({ permissionOverwrites });
      }
      /**
       * A collection of cached members of this channel, mapped by their ids.
       * Members that can view this channel, if the channel is text-based.
       * Members in the channel, if the channel is voice-based.
       * @type {Collection<Snowflake, GuildMember>}
       * @readonly
       */
      get members() {
        return this.guild.members.cache.filter((m) => this.permissionsFor(m).has(Permissions2.FLAGS.VIEW_CHANNEL, false));
      }
      /**
       * Edits the channel.
       * @param {ChannelData} data The new data for the channel
       * @param {string} [reason] Reason for editing this channel
       * @returns {Promise<GuildChannel>}
       * @example
       * // Edit a channel
       * channel.edit({ name: 'new-channel' })
       *   .then(console.log)
       *   .catch(console.error);
       */
      edit(data, reason) {
        return this.guild.channels.edit(this, data, reason);
      }
      /**
       * Sets a new name for the guild channel.
       * @param {string} name The new name for the guild channel
       * @param {string} [reason] Reason for changing the guild channel's name
       * @returns {Promise<GuildChannel>}
       * @example
       * // Set a new channel name
       * channel.setName('not_general')
       *   .then(newChannel => console.log(`Channel's new name is ${newChannel.name}`))
       *   .catch(console.error);
       */
      setName(name, reason) {
        return this.edit({ name }, reason);
      }
      /**
       * Options used to set the parent of a channel.
       * @typedef {Object} SetParentOptions
       * @property {boolean} [lockPermissions=true] Whether to lock the permissions to what the parent's permissions are
       * @property {string} [reason] The reason for modifying the parent of the channel
       */
      /**
       * Sets the parent of this channel.
       * @param {?CategoryChannelResolvable} channel The category channel to set as the parent
       * @param {SetParentOptions} [options={}] The options for setting the parent
       * @returns {Promise<GuildChannel>}
       * @example
       * // Add a parent to a channel
       * message.channel.setParent('355908108431917066', { lockPermissions: false })
       *   .then(channel => console.log(`New parent of ${message.channel.name}: ${channel.name}`))
       *   .catch(console.error);
       */
      setParent(channel, { lockPermissions = true, reason } = {}) {
        return this.edit(
          {
            parent: channel ?? null,
            lockPermissions
          },
          reason
        );
      }
      /**
       * Options used to set the position of a channel.
       * @typedef {Object} SetChannelPositionOptions
       * @property {boolean} [relative=false] Whether or not to change the position relative to its current value
       * @property {string} [reason] The reason for changing the position
       */
      /**
       * Sets a new position for the guild channel.
       * @param {number} position The new position for the guild channel
       * @param {SetChannelPositionOptions} [options] Options for setting position
       * @returns {Promise<GuildChannel>}
       * @example
       * // Set a new channel position
       * channel.setPosition(2)
       *   .then(newChannel => console.log(`Channel's new position is ${newChannel.position}`))
       *   .catch(console.error);
       */
      setPosition(position, options = {}) {
        return this.guild.channels.setPosition(this, position, options);
      }
      /**
       * Options used to clone a guild channel.
       * @typedef {GuildChannelCreateOptions} GuildChannelCloneOptions
       * @property {string} [name=this.name] Name of the new channel
       */
      /**
       * Clones this channel.
       * @param {GuildChannelCloneOptions} [options] The options for cloning this channel
       * @returns {Promise<GuildChannel>}
       */
      clone(options = {}) {
        return this.guild.channels.create(options.name ?? this.name, {
          permissionOverwrites: this.permissionOverwrites.cache,
          topic: this.topic,
          type: this.type,
          nsfw: this.nsfw,
          parent: this.parent,
          bitrate: this.bitrate,
          userLimit: this.userLimit,
          rateLimitPerUser: this.rateLimitPerUser,
          position: this.rawPosition,
          reason: null,
          ...options
        });
      }
      /**
       * Checks if this channel has the same type, topic, position, name, overwrites, and id as another channel.
       * In most cases, a simple `channel.id === channel2.id` will do, and is much faster too.
       * @param {GuildChannel} channel Channel to compare with
       * @returns {boolean}
       */
      equals(channel) {
        let equal = channel && this.id === channel.id && this.type === channel.type && this.topic === channel.topic && this.position === channel.position && this.name === channel.name;
        if (equal) {
          if (this.permissionOverwrites && channel.permissionOverwrites) {
            equal = this.permissionOverwrites.cache.equals(channel.permissionOverwrites.cache);
          } else {
            equal = !this.permissionOverwrites && !channel.permissionOverwrites;
          }
        }
        return equal;
      }
      /**
       * Whether the channel is deletable by the client user
       * @type {boolean}
       * @readonly
       */
      get deletable() {
        return this.manageable && this.guild.rulesChannelId !== this.id && this.guild.publicUpdatesChannelId !== this.id;
      }
      /**
       * Whether the channel is manageable by the client user
       * @type {boolean}
       * @readonly
       */
      get manageable() {
        if (this.client.user.id === this.guild.ownerId) return true;
        const permissions = this.permissionsFor(this.client.user);
        if (!permissions) return false;
        if (permissions.has(Permissions2.FLAGS.ADMINISTRATOR, false)) return true;
        if (this.guild.members.me.communicationDisabledUntilTimestamp > Date.now()) return false;
        const bitfield = VoiceBasedChannelTypes.includes(this.type) ? Permissions2.FLAGS.MANAGE_CHANNELS | Permissions2.FLAGS.CONNECT : Permissions2.FLAGS.VIEW_CHANNEL | Permissions2.FLAGS.MANAGE_CHANNELS;
        return permissions.has(bitfield, false);
      }
      /**
       * Whether the channel is viewable by the client user
       * @type {boolean}
       * @readonly
       */
      get viewable() {
        if (this.client.user.id === this.guild.ownerId) return true;
        const permissions = this.permissionsFor(this.client.user);
        if (!permissions) return false;
        return permissions.has(Permissions2.FLAGS.VIEW_CHANNEL, false);
      }
      /**
       * Deletes this channel.
       * @param {string} [reason] Reason for deleting this channel
       * @returns {Promise<GuildChannel>}
       * @example
       * // Delete the channel
       * channel.delete('making room for new channels')
       *   .then(console.log)
       *   .catch(console.error);
       */
      async delete(reason) {
        await this.guild.channels.delete(this.id, reason);
        return this;
      }
    };
    module2.exports = GuildChannel;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/util/Util.js
var require_Util = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/util/Util.js"(exports2, module2) {
    "use strict";
    var { Agent } = require_node_http();
    var { parse } = require_node_path();
    var process2 = require_node_process();
    var { setTimeout: setTimeout2 } = require_node_timers();
    var { Collection: Collection2 } = require_dist();
    var { fetch } = require_undici();
    var { Colors, Events: Events2 } = require_Constants();
    var { Error: DiscordError, RangeError: RangeError2, TypeError: TypeError2 } = require_errors2();
    var has = (o, k) => Object.prototype.hasOwnProperty.call(o, k);
    var isObject = (d) => typeof d === "object" && d !== null;
    var deprecationEmittedForSplitMessage = false;
    var deprecationEmittedForRemoveMentions = false;
    var deprecationEmittedForResolveAutoArchiveMaxLimit = false;
    var TextSortableGroupTypes = ["GUILD_TEXT", "GUILD_ANNOUCMENT", "GUILD_FORUM"];
    var VoiceSortableGroupTypes = ["GUILD_VOICE", "GUILD_STAGE_VOICE"];
    var CategorySortableGroupTypes = ["GUILD_CATEGORY"];
    var payloadTypes = [
      {
        name: "opus",
        type: "audio",
        priority: 1e3,
        payload_type: 120
      },
      {
        name: "AV1",
        type: "video",
        priority: 1e3,
        payload_type: 101,
        rtx_payload_type: 102,
        encode: false,
        decode: false
      },
      {
        name: "H265",
        type: "video",
        priority: 2e3,
        payload_type: 103,
        rtx_payload_type: 104,
        encode: false,
        decode: false
        // Working but very glitchy
      },
      {
        name: "H264",
        type: "video",
        priority: 3e3,
        payload_type: 105,
        rtx_payload_type: 106,
        encode: true,
        decode: true
      },
      {
        name: "VP8",
        type: "video",
        priority: 4e3,
        payload_type: 107,
        rtx_payload_type: 108,
        encode: true,
        decode: false
      },
      {
        name: "VP9",
        type: "video",
        priority: 5e3,
        payload_type: 109,
        rtx_payload_type: 110,
        encode: false,
        decode: false
      }
    ];
    var Util = class _Util extends null {
      /**
       * Flatten an object. Any properties that are collections will get converted to an array of keys.
       * @param {Object} obj The object to flatten.
       * @param {...Object<string, boolean|string>} [props] Specific properties to include/exclude.
       * @returns {Object}
       */
      static flatten(obj, ...props) {
        if (!isObject(obj)) return obj;
        const objProps = Object.keys(obj).filter((k) => !k.startsWith("_")).map((k) => ({ [k]: true }));
        props = objProps.length ? Object.assign(...objProps, ...props) : Object.assign({}, ...props);
        const out = {};
        for (let [prop, newProp] of Object.entries(props)) {
          if (!newProp) continue;
          newProp = newProp === true ? prop : newProp;
          const element = obj[prop];
          const elemIsObj = isObject(element);
          const valueOf = elemIsObj && typeof element.valueOf === "function" ? element.valueOf() : null;
          const hasToJSON = elemIsObj && typeof element.toJSON === "function";
          if (element instanceof Collection2) out[newProp] = Array.from(element.keys());
          else if (valueOf instanceof Collection2) out[newProp] = Array.from(valueOf.keys());
          else if (Array.isArray(element)) out[newProp] = element.map((e) => {
            var _a;
            return ((_a = e.toJSON) == null ? void 0 : _a.call(e)) ?? _Util.flatten(e);
          });
          else if (typeof valueOf !== "object") out[newProp] = valueOf;
          else if (hasToJSON) out[newProp] = element.toJSON();
          else if (typeof element === "object") out[newProp] = _Util.flatten(element);
          else if (!elemIsObj) out[newProp] = element;
        }
        return out;
      }
      /**
       * Options for splitting a message.
       * @typedef {Object} SplitOptions
       * @property {number} [maxLength=2000] Maximum character length per message piece
       * @property {string|string[]|RegExp|RegExp[]} [char='\n'] Character(s) or Regex(es) to split the message with,
       * an array can be used to split multiple times
       * @property {string} [prepend=''] Text to prepend to every piece except the first
       * @property {string} [append=''] Text to append to every piece except the last
       */
      /**
       * Splits a string into multiple chunks at a designated character that do not exceed a specific length.
       * @param {string} text Content to split
       * @param {SplitOptions} [options] Options controlling the behavior of the split
       * @deprecated This will be removed in the next major version.
       * @returns {string[]}
       */
      static splitMessage(text, { maxLength = 2e3, char = "\n", prepend = "", append = "" } = {}) {
        if (!deprecationEmittedForSplitMessage) {
          process2.emitWarning(
            "The Util.splitMessage method is deprecated and will be removed in the next major version.",
            "DeprecationWarning"
          );
          deprecationEmittedForSplitMessage = true;
        }
        text = _Util.verifyString(text);
        if (text.length <= maxLength) return [text];
        let splitText = [text];
        if (Array.isArray(char)) {
          while (char.length > 0 && splitText.some((elem) => elem.length > maxLength)) {
            const currentChar = char.shift();
            if (currentChar instanceof RegExp) {
              splitText = splitText.flatMap((chunk) => chunk.match(currentChar));
            } else {
              splitText = splitText.flatMap((chunk) => chunk.split(currentChar));
            }
          }
        } else {
          splitText = text.split(char);
        }
        if (splitText.some((elem) => elem.length > maxLength)) throw new RangeError2("SPLIT_MAX_LEN");
        const messages = [];
        let msg = "";
        for (const chunk of splitText) {
          if (msg && (msg + char + chunk + append).length > maxLength) {
            messages.push(msg + append);
            msg = prepend;
          }
          msg += (msg && msg !== prepend ? char : "") + chunk;
        }
        return messages.concat(msg).filter((m) => m);
      }
      /**
       * Options used to escape markdown.
       * @typedef {Object} EscapeMarkdownOptions
       * @property {boolean} [codeBlock=true] Whether to escape code blocks
       * @property {boolean} [inlineCode=true] Whether to escape inline code
       * @property {boolean} [bold=true] Whether to escape bolds
       * @property {boolean} [italic=true] Whether to escape italics
       * @property {boolean} [underline=true] Whether to escape underlines
       * @property {boolean} [strikethrough=true] Whether to escape strikethroughs
       * @property {boolean} [spoiler=true] Whether to escape spoilers
       * @property {boolean} [codeBlockContent=true] Whether to escape text inside code blocks
       * @property {boolean} [inlineCodeContent=true] Whether to escape text inside inline code
       * @property {boolean} [escape=true] Whether to escape escape characters
       * @property {boolean} [heading=false] Whether to escape headings
       * @property {boolean} [bulletedList=false] Whether to escape bulleted lists
       * @property {boolean} [numberedList=false] Whether to escape numbered lists
       * @property {boolean} [maskedLink=false] Whether to escape masked links
       */
      /**
       * Escapes any Discord-flavour markdown in a string.
       * @param {string} text Content to escape
       * @param {EscapeMarkdownOptions} [options={}] Options for escaping the markdown
       * @returns {string}
       */
      static escapeMarkdown(text, {
        codeBlock = true,
        inlineCode = true,
        bold = true,
        italic = true,
        underline = true,
        strikethrough = true,
        spoiler = true,
        codeBlockContent = true,
        inlineCodeContent = true,
        escape = true,
        heading = false,
        bulletedList = false,
        numberedList = false,
        maskedLink = false
      } = {}) {
        if (!codeBlockContent) {
          return text.split("```").map((subString, index, array) => {
            if (index % 2 && index !== array.length - 1) return subString;
            return _Util.escapeMarkdown(subString, {
              inlineCode,
              bold,
              italic,
              underline,
              strikethrough,
              spoiler,
              inlineCodeContent,
              escape,
              heading,
              bulletedList,
              numberedList,
              maskedLink
            });
          }).join(codeBlock ? "\\`\\`\\`" : "```");
        }
        if (!inlineCodeContent) {
          return text.split(new RegExp("(?<=^|[^`])`(?=[^`]|$)", "g")).map((subString, index, array) => {
            if (index % 2 && index !== array.length - 1) return subString;
            return _Util.escapeMarkdown(subString, {
              codeBlock,
              bold,
              italic,
              underline,
              strikethrough,
              spoiler,
              escape,
              heading,
              bulletedList,
              numberedList,
              maskedLink
            });
          }).join(inlineCode ? "\\`" : "`");
        }
        if (escape) text = _Util.escapeEscape(text);
        if (inlineCode) text = _Util.escapeInlineCode(text);
        if (codeBlock) text = _Util.escapeCodeBlock(text);
        if (italic) text = _Util.escapeItalic(text);
        if (bold) text = _Util.escapeBold(text);
        if (underline) text = _Util.escapeUnderline(text);
        if (strikethrough) text = _Util.escapeStrikethrough(text);
        if (spoiler) text = _Util.escapeSpoiler(text);
        if (heading) text = _Util.escapeHeading(text);
        if (bulletedList) text = _Util.escapeBulletedList(text);
        if (numberedList) text = _Util.escapeNumberedList(text);
        if (maskedLink) text = _Util.escapeMaskedLink(text);
        return text;
      }
      /**
       * Escapes code block markdown in a string.
       * @param {string} text Content to escape
       * @returns {string}
       */
      static escapeCodeBlock(text) {
        return text.replaceAll("```", "\\`\\`\\`");
      }
      /**
       * Escapes inline code markdown in a string.
       * @param {string} text Content to escape
       * @returns {string}
       */
      static escapeInlineCode(text) {
        return text.replace(new RegExp("(?<=^|[^`])``?(?=[^`]|$)", "g"), (match) => match.length === 2 ? "\\`\\`" : "\\`");
      }
      /**
       * Escapes italic markdown in a string.
       * @param {string} text Content to escape
       * @returns {string}
       */
      static escapeItalic(text) {
        let i = 0;
        text = text.replace(new RegExp("(?<=^|[^*])\\*([^*]|\\*\\*|$)", "g"), (_, match) => {
          if (match === "**") return ++i % 2 ? `\\*${match}` : `${match}\\*`;
          return `\\*${match}`;
        });
        i = 0;
        return text.replace(new RegExp("(?<=^|[^_])_([^_]|__|$)", "g"), (_, match) => {
          if (match === "__") return ++i % 2 ? `\\_${match}` : `${match}\\_`;
          return `\\_${match}`;
        });
      }
      /**
       * Escapes bold markdown in a string.
       * @param {string} text Content to escape
       * @returns {string}
       */
      static escapeBold(text) {
        let i = 0;
        return text.replace(/\*\*(\*)?/g, (_, match) => {
          if (match) return ++i % 2 ? `${match}\\*\\*` : `\\*\\*${match}`;
          return "\\*\\*";
        });
      }
      /**
       * Escapes underline markdown in a string.
       * @param {string} text Content to escape
       * @returns {string}
       */
      static escapeUnderline(text) {
        let i = 0;
        return text.replace(/__(_)?/g, (_, match) => {
          if (match) return ++i % 2 ? `${match}\\_\\_` : `\\_\\_${match}`;
          return "\\_\\_";
        });
      }
      /**
       * Escapes strikethrough markdown in a string.
       * @param {string} text Content to escape
       * @returns {string}
       */
      static escapeStrikethrough(text) {
        return text.replaceAll("~~", "\\~\\~");
      }
      /**
       * Escapes spoiler markdown in a string.
       * @param {string} text Content to escape
       * @returns {string}
       */
      static escapeSpoiler(text) {
        return text.replaceAll("||", "\\|\\|");
      }
      /**
       * Escapes escape characters in a string.
       * @param {string} text Content to escape
       * @returns {string}
       */
      static escapeEscape(text) {
        return text.replaceAll("\\", "\\\\");
      }
      /**
       * Escapes heading characters in a string.
       * @param {string} text Content to escape
       * @returns {string}
       */
      static escapeHeading(text) {
        return text.replaceAll(/^( {0,2}[*-] +)?(#{1,3} )/gm, "$1\\$2");
      }
      /**
       * Escapes bulleted list characters in a string.
       * @param {string} text Content to escape
       * @returns {string}
       */
      static escapeBulletedList(text) {
        return text.replaceAll(/^( *)[*-]( +)/gm, "$1\\-$2");
      }
      /**
       * Escapes numbered list characters in a string.
       * @param {string} text Content to escape
       * @returns {string}
       */
      static escapeNumberedList(text) {
        return text.replaceAll(/^( *\d+)\./gm, "$1\\.");
      }
      /**
       * Escapes masked link characters in a string.
       * @param {string} text Content to escape
       * @returns {string}
       */
      static escapeMaskedLink(text) {
        return text.replaceAll(/\[.+\]\(.+\)/gm, "\\$&");
      }
      /**
       * @typedef {Object} FetchRecommendedShardsOptions
       * @property {number} [guildsPerShard=1000] Number of guilds assigned per shard
       * @property {number} [multipleOf=1] The multiple the shard count should round up to. (16 for large bot sharding)
       */
      static fetchRecommendedShards() {
        throw new DiscordError("INVALID_USER_API");
      }
      /**
       * Parses emoji info out of a string. The string must be one of:
       * * A UTF-8 emoji (no id)
       * * A URL-encoded UTF-8 emoji (no id)
       * * A Discord custom emoji (`<:name:id>` or `<a:name:id>`)
       * @param {string} text Emoji string to parse
       * @returns {APIEmoji} Object with `animated`, `name`, and `id` properties
       * @private
       */
      static parseEmoji(text) {
        if (text.includes("%")) text = decodeURIComponent(text);
        if (!text.includes(":")) return { animated: false, name: text, id: null };
        const match = text.match(/<?(?:(a):)?(\w{2,32}):(\d{17,19})?>?/);
        return match && { animated: Boolean(match[1]), name: match[2], id: match[3] ?? null };
      }
      /**
       * Resolves a partial emoji object from an {@link EmojiIdentifierResolvable}, without checking a Client.
       * @param {EmojiIdentifierResolvable} emoji Emoji identifier to resolve
       * @returns {?RawEmoji}
       * @private
       */
      static resolvePartialEmoji(emoji) {
        if (!emoji) return null;
        if (typeof emoji === "string") return /^\d{17,19}$/.test(emoji) ? { id: emoji } : _Util.parseEmoji(emoji);
        const { id, name, animated } = emoji;
        if (!id && !name) return null;
        return { id, name, animated: Boolean(animated) };
      }
      /**
       * Shallow-copies an object with its class/prototype intact.
       * @param {Object} obj Object to clone
       * @returns {Object}
       * @private
       */
      static cloneObject(obj) {
        return Object.assign(Object.create(obj), obj);
      }
      /**
       * Sets default properties on an object that aren't already specified.
       * @param {Object} def Default properties
       * @param {Object} given Object to assign defaults to
       * @returns {Object}
       * @private
       */
      static mergeDefault(def, given) {
        if (!given) return def;
        for (const key in def) {
          if (!has(given, key) || given[key] === void 0) {
            given[key] = def[key];
          } else if (given[key] === Object(given[key])) {
            given[key] = _Util.mergeDefault(def[key], given[key]);
          }
        }
        return given;
      }
      /**
       * Options used to make an error object.
       * @typedef {Object} MakeErrorOptions
       * @property {string} name Error type
       * @property {string} message Message for the error
       * @property {string} stack Stack for the error
       */
      /**
       * Makes an Error from a plain info object.
       * @param {MakeErrorOptions} obj Error info
       * @returns {Error}
       * @private
       */
      static makeError(obj) {
        const err = new Error(obj.message);
        err.name = obj.name;
        err.stack = obj.stack;
        return err;
      }
      /**
       * Makes a plain error info object from an Error.
       * @param {Error} err Error to get info from
       * @returns {MakeErrorOptions}
       * @private
       */
      static makePlainError(err) {
        return {
          name: err.name,
          message: err.message,
          stack: err.stack
        };
      }
      /**
       * Moves an element in an array *in place*.
       * @param {Array<*>} array Array to modify
       * @param {*} element Element to move
       * @param {number} newIndex Index or offset to move the element to
       * @param {boolean} [offset=false] Move the element by an offset amount rather than to a set index
       * @returns {number}
       * @private
       */
      static moveElementInArray(array, element, newIndex, offset = false) {
        const index = array.indexOf(element);
        newIndex = (offset ? index : 0) + newIndex;
        if (newIndex > -1 && newIndex < array.length) {
          const removedElement = array.splice(index, 1)[0];
          array.splice(newIndex, 0, removedElement);
        }
        return array.indexOf(element);
      }
      /**
       * Verifies the provided data is a string, otherwise throws provided error.
       * @param {string} data The string resolvable to resolve
       * @param {Function} [error] The Error constructor to instantiate. Defaults to Error
       * @param {string} [errorMessage] The error message to throw with. Defaults to "Expected string, got <data> instead."
       * @param {boolean} [allowEmpty=true] Whether an empty string should be allowed
       * @returns {string}
       */
      static verifyString(data, error2 = Error, errorMessage = `Expected a string, got ${data} instead.`, allowEmpty = true) {
        if (typeof data !== "string") throw new error2(errorMessage);
        if (!allowEmpty && data.length === 0) throw new error2(errorMessage);
        return data;
      }
      /**
       * Can be a number, hex string, a {@link Color}, or an RGB array like:
       * ```js
       * [255, 0, 255] // purple
       * ```
       * @typedef {string|Color|number|number[]} ColorResolvable
       */
      /**
       * Resolves a ColorResolvable into a color number.
       * @param {ColorResolvable} color Color to resolve
       * @returns {number} A color
       */
      static resolveColor(color) {
        if (typeof color === "string") {
          if (color === "RANDOM") return Math.floor(Math.random() * (16777215 + 1));
          if (color === "DEFAULT") return 0;
          color = Colors[color] ?? parseInt(color.replace("#", ""), 16);
        } else if (Array.isArray(color)) {
          color = (color[0] << 16) + (color[1] << 8) + color[2];
        }
        if (color < 0 || color > 16777215) throw new RangeError2("COLOR_RANGE");
        else if (Number.isNaN(color)) throw new TypeError2("COLOR_CONVERT");
        return color;
      }
      /**
       * Sorts by Discord's position and id.
       * @param {Collection} collection Collection of objects to sort
       * @returns {Collection}
       */
      static discordSort(collection) {
        const isGuildChannel = collection.first() instanceof GuildChannel;
        return collection.sorted(
          isGuildChannel ? (a, b) => a.rawPosition - b.rawPosition || Number(BigInt(a.id) - BigInt(b.id)) : (a, b) => a.rawPosition - b.rawPosition || Number(BigInt(b.id) - BigInt(a.id))
        );
      }
      /**
       * Sets the position of a Channel or Role.
       * @param {Channel|Role} item Object to set the position of
       * @param {number} position New position for the object
       * @param {boolean} relative Whether `position` is relative to its current position
       * @param {Collection<string, Channel|Role>} sorted A collection of the objects sorted properly
       * @param {APIRouter} route Route to call PATCH on
       * @param {string} [reason] Reason for the change
       * @returns {Promise<Channel[]|Role[]>} Updated item list, with `id` and `position` properties
       * @private
       */
      static async setPosition(item, position, relative, sorted, route, reason) {
        let updatedItems = [...sorted.values()];
        _Util.moveElementInArray(updatedItems, item, position, relative);
        updatedItems = updatedItems.map((r, i) => ({ id: r.id, position: i }));
        await route.patch({ data: updatedItems, reason });
        return updatedItems;
      }
      /**
       * Alternative to Node's `path.basename`, removing query string after the extension if it exists.
       * @param {string} path Path to get the basename of
       * @param {string} [ext] File extension to remove
       * @returns {string} Basename of the path
       * @private
       */
      static basename(path, ext) {
        const res = parse(path);
        return ext && res.ext.startsWith(ext) ? res.name : res.base.split("?")[0];
      }
      /**
       * Breaks user, role and everyone/here mentions by adding a zero width space after every @ character
       * @param {string} str The string to sanitize
       * @returns {string}
       * @deprecated Use {@link BaseMessageOptions#allowedMentions} instead.
       */
      static removeMentions(str) {
        if (!deprecationEmittedForRemoveMentions) {
          process2.emitWarning(
            "The Util.removeMentions method is deprecated. Use MessageOptions#allowedMentions instead.",
            "DeprecationWarning"
          );
          deprecationEmittedForRemoveMentions = true;
        }
        return _Util._removeMentions(str);
      }
      static _removeMentions(str) {
        return str.replaceAll("@", "@​");
      }
      /**
       * The content to have all mentions replaced by the equivalent text.
       * <warn>When {@link Util.removeMentions} is removed, this method will no longer sanitize mentions.
       * Use {@link BaseMessageOptions#allowedMentions} instead to prevent mentions when sending a message.</warn>
       * @param {string} str The string to be converted
       * @param {TextBasedChannels} channel The channel the string was sent in
       * @returns {string}
       */
      static cleanContent(str, channel) {
        str = str.replace(/<@!?[0-9]+>/g, (input) => {
          var _a;
          const id = input.replace(/<|!|>|@/g, "");
          if (channel.type === "DM") {
            const user = channel.client.users.cache.get(id);
            return user ? _Util._removeMentions(`@${user.username}`) : input;
          }
          const member = (_a = channel.guild) == null ? void 0 : _a.members.cache.get(id);
          if (member) {
            return _Util._removeMentions(`@${member.displayName}`);
          } else {
            const user = channel.client.users.cache.get(id);
            return user ? _Util._removeMentions(`@${user.username}`) : input;
          }
        }).replace(/<#[0-9]+>/g, (input) => {
          const mentionedChannel = channel.client.channels.cache.get(input.replace(/<|#|>/g, ""));
          return mentionedChannel ? `#${mentionedChannel.name}` : input;
        }).replace(/<@&[0-9]+>/g, (input) => {
          if (channel.type === "DM") return input;
          const role = channel.guild.roles.cache.get(input.replace(/<|@|>|&/g, ""));
          return role ? `@${role.name}` : input;
        });
        return str;
      }
      /**
       * The content to put in a code block with all code block fences replaced by the equivalent backticks.
       * @param {string} text The string to be converted
       * @returns {string}
       */
      static cleanCodeBlockContent(text) {
        return text.replaceAll("```", "`​``");
      }
      /**
       * Creates a sweep filter that sweeps archived threads
       * @param {number} [lifetime=14400] How long a thread has to be archived to be valid for sweeping
       * @deprecated When not using with `makeCache` use `Sweepers.archivedThreadSweepFilter` instead
       * @returns {SweepFilter}
       */
      static archivedThreadSweepFilter(lifetime = 14400) {
        const filter = require_Sweepers().archivedThreadSweepFilter(lifetime);
        filter.isDefault = true;
        return filter;
      }
      /**
       * Resolves the maximum time a guild's thread channels should automatically archive in case of no recent activity.
       * @param {Guild} guild The guild to resolve this limit from.
       * @deprecated This will be removed in the next major version.
       * @returns {number}
       */
      static resolveAutoArchiveMaxLimit() {
        if (!deprecationEmittedForResolveAutoArchiveMaxLimit) {
          process2.emitWarning(
            // eslint-disable-next-line max-len
            "The Util.resolveAutoArchiveMaxLimit method and the 'MAX' option are deprecated and will be removed in the next major version.",
            "DeprecationWarning"
          );
          deprecationEmittedForResolveAutoArchiveMaxLimit = true;
        }
        return 10080;
      }
      /**
       * Transforms an API guild forum tag to camel-cased guild forum tag.
       * @param {APIGuildForumTag} tag The tag to transform
       * @returns {GuildForumTag}
       * @ignore
       */
      static transformAPIGuildForumTag(tag) {
        return {
          id: tag.id,
          name: tag.name,
          moderated: tag.moderated,
          emoji: tag.emoji_id ?? tag.emoji_name ? {
            id: tag.emoji_id,
            name: tag.emoji_name
          } : null
        };
      }
      /**
       * Transforms a camel-cased guild forum tag to an API guild forum tag.
       * @param {GuildForumTag} tag The tag to transform
       * @returns {APIGuildForumTag}
       * @ignore
       */
      static transformGuildForumTag(tag) {
        var _a, _b;
        return {
          id: tag.id,
          name: tag.name,
          moderated: tag.moderated,
          emoji_id: ((_a = tag.emoji) == null ? void 0 : _a.id) ?? null,
          emoji_name: ((_b = tag.emoji) == null ? void 0 : _b.name) ?? null
        };
      }
      /**
       * Transforms an API guild forum default reaction object to a
       * camel-cased guild forum default reaction object.
       * @param {APIGuildForumDefaultReactionEmoji} defaultReaction The default reaction to transform
       * @returns {DefaultReactionEmoji}
       * @ignore
       */
      static transformAPIGuildDefaultReaction(defaultReaction) {
        return {
          id: defaultReaction.emoji_id,
          name: defaultReaction.emoji_name
        };
      }
      /**
       * Transforms a camel-cased guild forum default reaction object to an
       * API guild forum default reaction object.
       * @param {DefaultReactionEmoji} defaultReaction The default reaction to transform
       * @returns {APIGuildForumDefaultReactionEmoji}
       * @ignore
       */
      static transformGuildDefaultReaction(defaultReaction) {
        return {
          emoji_id: defaultReaction.id,
          emoji_name: defaultReaction.name
        };
      }
      /**
       * Gets an array of the channel types that can be moved in the channel group. For example, a GuildText channel would
       * return an array containing the types that can be ordered within the text channels (always at the top), and a voice
       * channel would return an array containing the types that can be ordered within the voice channels (always at the
       * bottom).
       * @param {ChannelType} type The type of the channel
       * @returns {ChannelType[]}
       * @ignore
       */
      static getSortableGroupTypes(type) {
        switch (type) {
          case "GUILD_TEXT":
          case "GUILD_ANNOUNCEMENT":
          case "GUILD_FORUM":
            return TextSortableGroupTypes;
          case "GUILD_VOICE":
          case "GUILD_STAGE_VOICE":
            return VoiceSortableGroupTypes;
          case "GUILD_CATEGORY":
            return CategorySortableGroupTypes;
          default:
            return [type];
        }
      }
      /**
       * Calculates the default avatar index for a given user id.
       * @param {Snowflake} userId - The user id to calculate the default avatar index for
       * @returns {number}
       */
      static calculateUserDefaultAvatarIndex(userId) {
        return Number(BigInt(userId) >> 22n) % 6;
      }
      static async getUploadURL(client, channelId, files) {
        if (!files.length) return [];
        files = files.map((file, i) => ({
          filename: file.name,
          // 25MB = 26_214_400bytes
          file_size: Math.floor(26214400 / 10 * Math.random()),
          id: `${i}`
        }));
        const { attachments } = await client.api.channels[channelId].attachments.post({
          data: {
            files
          }
        });
        return attachments;
      }
      static uploadFile(data, url) {
        return new Promise((resolve, reject) => {
          fetch(url, {
            method: "PUT",
            body: data,
            duplex: "half"
            // Node.js v20
          }).then((res) => {
            if (res.ok) {
              resolve(res);
            } else {
              reject(res);
            }
          }).catch(reject);
        });
      }
      /**
       * Lazily evaluates a callback function (yea it's v14 :yay:)
       * @param {Function} cb The callback to lazily evaluate
       * @returns {Function}
       * @example
       * const User = lazy(() => require('./User'));
       * const user = new (User())(client, data);
       */
      static lazy(cb) {
        let defaultValue;
        return () => defaultValue ?? (defaultValue = cb());
      }
      /**
       * Hacking check object instanceof Proxy-agent
       * @param {Object} object any
       * @returns {boolean}
       */
      static verifyProxyAgent(object) {
        return typeof object == "object" && object.httpAgent instanceof Agent && object.httpsAgent instanceof Agent;
      }
      static checkUndiciProxyAgent(data) {
        if (typeof data === "string") {
          return {
            uri: data
          };
        }
        if (data instanceof URL) {
          return {
            uri: data.toString()
          };
        }
        if (typeof data === "object" && typeof data.uri === "string") return data;
        return false;
      }
      static createPromiseInteraction(client, nonce, timeoutMs = 5e3, isHandlerDeferUpdate = false, parent) {
        return new Promise((resolve, reject) => {
          let dataFromInteractionSuccess;
          let dataFromNormal;
          const handler = (data) => {
            var _a;
            if (isHandlerDeferUpdate && ((_a = data.d) == null ? void 0 : _a.nonce) == nonce && data.t == "INTERACTION_SUCCESS") {
              client.removeListener(Events2.MESSAGE_CREATE, handler);
              client.removeListener(Events2.UNHANDLED_PACKET, handler);
              client.removeListener(Events2.INTERACTION_MODAL_CREATE, handler);
              dataFromInteractionSuccess = parent;
            }
            if (data.nonce !== nonce) return;
            clearTimeout(timeout);
            client.removeListener(Events2.MESSAGE_CREATE, handler);
            client.removeListener(Events2.INTERACTION_MODAL_CREATE, handler);
            if (isHandlerDeferUpdate) client.removeListener(Events2.UNHANDLED_PACKET, handler);
            client.decrementMaxListeners();
            dataFromNormal = data;
            resolve(data);
          };
          const timeout = setTimeout2(() => {
            if (dataFromInteractionSuccess || dataFromNormal) {
              resolve(dataFromNormal || dataFromInteractionSuccess);
              return;
            }
            client.removeListener(Events2.MESSAGE_CREATE, handler);
            client.removeListener(Events2.INTERACTION_MODAL_CREATE, handler);
            if (isHandlerDeferUpdate) client.removeListener(Events2.UNHANDLED_PACKET, handler);
            client.decrementMaxListeners();
            reject(new Error("INTERACTION_FAILED"));
          }, timeoutMs).unref();
          client.incrementMaxListeners();
          client.on(Events2.MESSAGE_CREATE, handler);
          client.on(Events2.INTERACTION_MODAL_CREATE, handler);
          if (isHandlerDeferUpdate) client.on(Events2.UNHANDLED_PACKET, handler);
        });
      }
      static clearNullOrUndefinedObject(object) {
        const data = {};
        const keys = Object.keys(object);
        for (const key of keys) {
          const value = object[key];
          if (value === void 0 || value === null || Array.isArray(value) && value.length === 0) {
            continue;
          } else if (!Array.isArray(value) && typeof value === "object") {
            const cleanedValue = _Util.clearNullOrUndefinedObject(value);
            if (cleanedValue !== void 0) {
              data[key] = cleanedValue;
            }
          } else {
            data[key] = value;
          }
        }
        return Object.keys(data).length > 0 ? data : void 0;
      }
      static getAllPayloadType() {
        return payloadTypes;
      }
      static getPayloadType(codecName) {
        return payloadTypes.find((p) => p.name === codecName).payload_type;
      }
      static getSDPCodecName(portUdp, isEnableAudio) {
        let sdpData = `v=0
o=- 0 0 IN IP4 0.0.0.0
s=-
c=IN IP4 0.0.0.0
t=0 0
a=tool:libavformat 61.1.100
m=video ${portUdp} RTP/AVP 105
a=rtpmap:105 H264/90000
a=fmtp:105 profile-level-id=42e01f;sprop-parameter-sets=Z0IAH6tAoAt2AtwEBAaQeJEV,aM4JyA==;packetization-mode=1
${isEnableAudio ? `m=audio ${portUdp + 2} RTP/AVP 120
a=rtpmap:120 opus/48000/2
a=fmtp:120 minptime=10;useinbandfec=1` : ""}
a=extmap:1 urn:ietf:params:rtp-hdrext:ssrc-audio-level
a=extmap:2 http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time
a=extmap:3 http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01
a=extmap:4 urn:ietf:params:rtp-hdrext:sdes:mid
a=extmap:5 http://www.webrtc.org/experiments/rtp-hdrext/playout-delay
a=extmap:6 http://www.webrtc.org/experiments/rtp-hdrext/video-content-type
a=extmap:7 http://www.webrtc.org/experiments/rtp-hdrext/video-timing
a=extmap:8 http://www.webrtc.org/experiments/rtp-hdrext/color-space
a=extmap:10 urn:ietf:params:rtp-hdrext:sdes:rtp-stream-id
a=extmap:11 urn:ietf:params:rtp-hdrext:sdes:repaired-rtp-stream-id
a=extmap:13 urn:3gpp:video-orientation
a=extmap:14 urn:ietf:params:rtp-hdrext:toffset
`;
        return sdpData;
      }
    };
    module2.exports = Util;
    var GuildChannel = require_GuildChannel();
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/rest/APIRequest.js
var require_APIRequest = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/rest/APIRequest.js"(exports2, module2) {
    "use strict";
    var Buffer2 = require_node_buffer().Buffer;
    var { setTimeout: setTimeout2 } = require_node_timers();
    var makeFetchCookie = require_index_wrapper();
    var { CookieJar } = require_cookie();
    var { fetch: fetchOriginal, FormData, buildConnector, Client: Client2, ProxyAgent } = require_undici();
    var { ciphers } = require_Constants();
    var Util = require_Util();
    var cookieJar = new CookieJar();
    var fetch = makeFetchCookie(fetchOriginal, cookieJar);
    var agent = null;
    var APIRequest = class {
      constructor(rest, method, path, options) {
        this.rest = rest;
        this.client = rest.client;
        this.method = method;
        this.route = options.route;
        this.options = options;
        this.retries = 0;
        this.fullUserAgent = this.client.options.http.headers["User-Agent"];
        this.client.options.ws.properties.browser_user_agent = this.fullUserAgent;
        let queryString = "";
        if (options.query) {
          const query = Object.entries(options.query).filter(([, value]) => value !== null && typeof value !== "undefined").flatMap(([key, value]) => Array.isArray(value) ? value.map((v) => [key, v]) : [[key, value]]);
          queryString = new URLSearchParams(query).toString();
        }
        this.path = `${path}${queryString && `?${queryString}`}`;
      }
      make(captchaKey, captchaRqToken) {
        var _a;
        if (!agent) {
          const r_ = Util.checkUndiciProxyAgent(this.client.options.http.agent);
          if (!r_) {
            agent = new Client2("https://discord.com", {
              connect: buildConnector({ ciphers: ciphers.join(":") })
            });
          } else {
            agent = new ProxyAgent({
              ...r_,
              ciphers: ciphers.join(":")
            });
          }
        }
        const API = this.options.versioned === false ? this.client.options.http.api : `${this.client.options.http.api}/v${this.client.options.http.version}`;
        const url = API + this.path;
        let headers = {
          accept: "*/*",
          "accept-language": "en-US",
          "sec-ch-ua": '"Chromium";v="131", "Not_A Brand";v="24"',
          "sec-ch-ua-mobile": "?0",
          "sec-ch-ua-platform": '"Windows"',
          "sec-fetch-dest": "empty",
          "sec-fetch-mode": "cors",
          "sec-fetch-site": "same-origin",
          "x-debug-options": "bugReporterEnabled",
          "x-discord-locale": "en-US",
          "x-discord-timezone": Intl.DateTimeFormat().resolvedOptions().timeZone,
          "x-super-properties": `${Buffer2.from(JSON.stringify(this.client.options.ws.properties), "ascii").toString(
            "base64"
          )}`,
          referer: "https://discord.com/channels/@me",
          origin: "https://discord.com",
          ...this.client.options.http.headers,
          "User-Agent": this.fullUserAgent,
          priority: "u=1, i"
        };
        if (this.options.auth !== false) headers.Authorization = this.rest.getAuth();
        if (this.options.reason) headers["X-Audit-Log-Reason"] = encodeURIComponent(this.options.reason);
        if (this.options.headers) headers = Object.assign(headers, this.options.headers);
        for (const [key, value] of Object.entries(headers)) {
          if (value === void 0) delete headers[key];
        }
        if (this.options.webhook === true) {
          headers = {
            "User-Agent": this.client.options.http.headers["User-Agent"]
          };
        }
        if (this.options.DiscordContext) {
          headers["X-Context-Properties"] = Buffer2.from(JSON.stringify(this.options.DiscordContext), "utf8").toString(
            "base64"
          );
        }
        if (this.options.mfaToken) {
          headers["X-Discord-Mfa-Authorization"] = this.options.mfaToken;
        }
        let body;
        if ((_a = this.options.files) == null ? void 0 : _a.length) {
          body = new FormData();
          for (const [index, file] of this.options.files.entries()) {
            if (file == null ? void 0 : file.file) body.append(file.key ?? `files[${index}]`, file.file, file.name);
          }
          if (typeof this.options.data !== "undefined") {
            if (this.options.dontUsePayloadJSON) {
              for (const [key, value] of Object.entries(this.options.data)) body.append(key, value);
            } else {
              body.append("payload_json", JSON.stringify(this.options.data));
            }
          }
          headers = Object.assign(headers, body.getHeaders());
        } else if (this.options.data != null) {
          if (this.options.usePayloadJSON) {
            body = new FormData();
            body.append("payload_json", JSON.stringify(this.options.data));
          } else {
            body = JSON.stringify(this.options.data);
            headers["Content-Type"] = "application/json";
          }
        }
        if (captchaKey && typeof captchaKey == "string") headers["X-Captcha-Key"] = captchaKey;
        if (captchaRqToken && typeof captchaRqToken == "string") headers["X-Captcha-Rqtoken"] = captchaRqToken;
        const controller = new AbortController();
        const timeout = setTimeout2(() => controller.abort(), this.client.options.restRequestTimeout).unref();
        return fetch(url, {
          method: this.method.toUpperCase(),
          // Undici doesn't normalize "patch" into "PATCH" (which surprisingly follows the spec).
          headers,
          body,
          signal: controller.signal,
          redirect: "follow",
          dispatcher: agent,
          credentials: "include"
        }).finally(() => clearTimeout(timeout));
      }
    };
    module2.exports = APIRequest;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/rest/APIRouter.js
var require_APIRouter = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/rest/APIRouter.js"(exports2, module2) {
    "use strict";
    var noop = () => {
    };
    var methods = ["get", "post", "delete", "patch", "put"];
    var reflectors = [
      "toString",
      "valueOf",
      "inspect",
      "constructor",
      Symbol.toPrimitive,
      Symbol.for("nodejs.util.inspect.custom")
    ];
    function buildRoute(manager) {
      const route = [""];
      const handler = {
        get(target, name) {
          if (reflectors.includes(name)) return () => route.join("/");
          if (methods.includes(name)) {
            const routeBucket = [];
            for (let i = 0; i < route.length; i++) {
              if (route[i - 1] === "reactions") break;
              if (/\d{16,19}/g.test(route[i]) && !/channels|guilds/.test(route[i - 1])) routeBucket.push(":id");
              else routeBucket.push(route[i]);
            }
            return (options) => manager.request(
              name,
              route.join("/"),
              Object.assign(
                {
                  versioned: manager.versioned,
                  route: routeBucket.join("/")
                },
                options
              )
            );
          }
          route.push(name);
          return new Proxy(noop, handler);
        },
        apply(target, _, args) {
          route.push(...args.filter((x) => x != null));
          return new Proxy(noop, handler);
        }
      };
      return new Proxy(noop, handler);
    }
    module2.exports = buildRoute;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/rest/DiscordAPIError.js
var require_DiscordAPIError = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/rest/DiscordAPIError.js"(exports2, module2) {
    "use strict";
    var DiscordAPIError = class extends Error {
      constructor(error2, status, request) {
        super();
        const flattened = this.constructor.flattenErrors(error2.errors ?? error2).join("\n");
        this.name = "DiscordAPIError";
        this.message = error2.message && flattened ? `${error2.message}
${flattened}` : error2.message ?? flattened;
        this.method = request.method;
        this.path = request.path;
        this.code = error2.code;
        this.httpStatus = status;
        this.requestData = {
          json: request.options.data,
          files: request.options.files ?? [],
          headers: request.options.headers
        };
        this.retries = request.retries;
        this.captcha = (error2 == null ? void 0 : error2.captcha_service) ? error2 : null;
      }
      /**
       * A special `40333` JSON error code is returned if your request is blocked by Cloudflare.
       * This may be due to a malformed request or improper user agent.
       * The response resembles a normal error structure:
       * @type {boolean}
       * @example
       * {
       *  "message": "internal network error",
       *  "code": 40333
       * }
       */
      get isBlockedByCloudflare() {
        return this.code === 40333;
      }
      /**
       * Flattens an errors object returned from the API into an array.
       * @param {APIError} obj Discord errors object
       * @param {string} [key] Used internally to determine key names of nested fields
       * @returns {string[]}
       * @private
       */
      static flattenErrors(obj, key = "") {
        let messages = [];
        for (const [k, v] of Object.entries(obj)) {
          if (k === "message") continue;
          const newKey = key ? isNaN(k) ? `${key}.${k}` : `${key}[${k}]` : k;
          if (v._errors) {
            messages.push(`${newKey}: ${v._errors.map((e) => e.message).join(" ")}`);
          } else if (v.code ?? v.message) {
            messages.push(`${v.code ? `${v.code}: ` : ""}${v.message}`.trim());
          } else if (typeof v === "string") {
            messages.push(v);
          } else {
            messages = messages.concat(this.flattenErrors(v, newKey));
          }
        }
        return messages;
      }
    };
    module2.exports = DiscordAPIError;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/rest/HTTPError.js
var require_HTTPError = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/rest/HTTPError.js"(exports2, module2) {
    "use strict";
    var HTTPError = class extends Error {
      constructor(message, name, code, request) {
        super(message);
        this.name = name;
        this.code = code ?? 500;
        this.method = request.method;
        this.path = request.path;
        this.requestData = {
          json: request.options.data,
          files: request.options.files ?? [],
          headers: request.options.headers
        };
      }
    };
    module2.exports = HTTPError;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/rest/RateLimitError.js
var require_RateLimitError = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/rest/RateLimitError.js"(exports2, module2) {
    "use strict";
    var RateLimitError = class extends Error {
      constructor({ timeout, limit, method, path, route, global: global2 }) {
        super(`A ${global2 ? "global " : ""}rate limit was hit on route ${route}`);
        this.name = "RateLimitError";
        this.timeout = timeout;
        this.method = method;
        this.path = path;
        this.route = route;
        this.global = global2;
        this.limit = limit;
      }
    };
    module2.exports = RateLimitError;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/rest/RequestHandler.js
var require_RequestHandler = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/rest/RequestHandler.js"(exports2, module2) {
    "use strict";
    var { setTimeout: setTimeout2 } = require_node_timers();
    var { setTimeout: sleep } = require_promises();
    var { AsyncQueue } = require_cjs();
    var DiscordAPIError = require_DiscordAPIError();
    var HTTPError = require_HTTPError();
    var RateLimitError = require_RateLimitError();
    var {
      Events: { DEBUG, RATE_LIMIT, INVALID_REQUEST_WARNING, API_RESPONSE, API_REQUEST }
    } = require_Constants();
    var captchaMessage = [
      "incorrect-captcha",
      "response-already-used",
      "captcha-required",
      "invalid-input-response",
      "invalid-response",
      "You need to update your app",
      "response-already-used-error",
      "rqkey-mismatch",
      "sitekey-secret-mismatch"
    ];
    function parseResponse(res) {
      var _a;
      if ((_a = res.headers.get("content-type")) == null ? void 0 : _a.startsWith("application/json")) return res.json();
      return res.arrayBuffer();
    }
    function getAPIOffset(serverDate) {
      return new Date(serverDate).getTime() - Date.now();
    }
    function calculateReset(reset, resetAfter, serverDate) {
      if (resetAfter) {
        return Date.now() + Number(resetAfter) * 1e3;
      }
      return new Date(Number(reset) * 1e3).getTime() - getAPIOffset(serverDate);
    }
    var invalidCount = 0;
    var invalidCountResetTime = null;
    var RequestHandler = class {
      constructor(manager) {
        this.manager = manager;
        this.queue = new AsyncQueue();
        this.reset = -1;
        this.remaining = -1;
        this.limit = -1;
      }
      async push(request) {
        await this.queue.wait();
        try {
          return await this.execute(request);
        } finally {
          this.queue.shift();
        }
      }
      get globalLimited() {
        return this.manager.globalRemaining <= 0 && Date.now() < this.manager.globalReset;
      }
      get localLimited() {
        return this.remaining <= 0 && Date.now() < this.reset;
      }
      get limited() {
        return this.globalLimited || this.localLimited;
      }
      get _inactive() {
        return this.queue.remaining === 0 && !this.limited;
      }
      globalDelayFor(ms) {
        return new Promise((resolve) => {
          setTimeout2(() => {
            this.manager.globalDelay = null;
            resolve();
          }, ms).unref();
        });
      }
      /*
       * Determines whether the request should be queued or whether a RateLimitError should be thrown
       */
      async onRateLimit(request, limit, timeout, isGlobal) {
        const { options } = this.manager.client;
        if (!options.rejectOnRateLimit) return;
        const rateLimitData = {
          timeout,
          limit,
          method: request.method,
          path: request.path,
          route: request.route,
          global: isGlobal
        };
        const shouldThrow = typeof options.rejectOnRateLimit === "function" ? await options.rejectOnRateLimit(rateLimitData) : options.rejectOnRateLimit.some((route) => rateLimitData.route.startsWith(route.toLowerCase()));
        if (shouldThrow) {
          throw new RateLimitError(rateLimitData);
        }
      }
      async execute(request, captchaKey, captchaToken) {
        while (this.limited) {
          const isGlobal = this.globalLimited;
          let limit, timeout, delayPromise;
          if (isGlobal) {
            limit = this.manager.globalLimit;
            timeout = this.manager.globalReset + this.manager.client.options.restTimeOffset - Date.now();
          } else {
            limit = this.limit;
            timeout = this.reset + this.manager.client.options.restTimeOffset - Date.now();
          }
          if (this.manager.client.listenerCount(RATE_LIMIT)) {
            this.manager.client.emit(RATE_LIMIT, {
              timeout,
              limit,
              method: request.method,
              path: request.path,
              route: request.route,
              global: isGlobal
            });
          }
          if (isGlobal) {
            if (!this.manager.globalDelay) {
              this.manager.globalDelay = this.globalDelayFor(timeout);
            }
            delayPromise = this.manager.globalDelay;
          } else {
            delayPromise = sleep(timeout);
          }
          await this.onRateLimit(request, limit, timeout, isGlobal);
          await delayPromise;
        }
        if (!this.manager.globalReset || this.manager.globalReset < Date.now()) {
          this.manager.globalReset = Date.now() + 1e3;
          this.manager.globalRemaining = this.manager.globalLimit;
        }
        this.manager.globalRemaining--;
        if (this.manager.client.listenerCount(API_REQUEST)) {
          this.manager.client.emit(API_REQUEST, {
            method: request.method,
            path: request.path,
            route: request.route,
            options: request.options,
            retries: request.retries
          });
        }
        let res;
        try {
          res = await request.make(captchaKey, captchaToken);
        } catch (error2) {
          if (request.retries === this.manager.client.options.retryLimit) {
            throw new HTTPError(error2.message, error2.constructor.name, error2.status, request);
          }
          request.retries++;
          return this.execute(request);
        }
        if (this.manager.client.listenerCount(API_RESPONSE)) {
          this.manager.client.emit(
            API_RESPONSE,
            {
              method: request.method,
              path: request.path,
              route: request.route,
              options: request.options,
              retries: request.retries
            },
            res.clone()
          );
        }
        let sublimitTimeout;
        if (res.headers) {
          const serverDate = res.headers.get("date");
          const limit = res.headers.get("x-ratelimit-limit");
          const remaining = res.headers.get("x-ratelimit-remaining");
          const reset = res.headers.get("x-ratelimit-reset");
          const resetAfter = res.headers.get("x-ratelimit-reset-after");
          this.limit = limit ? Number(limit) : Infinity;
          this.remaining = remaining ? Number(remaining) : 1;
          this.reset = reset || resetAfter ? calculateReset(reset, resetAfter, serverDate) : Date.now();
          if (!resetAfter && request.route.includes("reactions")) {
            this.reset = new Date(serverDate).getTime() - getAPIOffset(serverDate) + 250;
          }
          let retryAfter = res.headers.get("retry-after");
          retryAfter = retryAfter ? Number(retryAfter) * 1e3 : -1;
          if (retryAfter > 0) {
            if (res.headers.get("x-ratelimit-global")) {
              this.manager.globalRemaining = 0;
              this.manager.globalReset = Date.now() + retryAfter;
            } else if (!this.localLimited) {
              sublimitTimeout = retryAfter;
            }
          }
        }
        if (res.status === 401 || res.status === 403 || res.status === 429) {
          if (!invalidCountResetTime || invalidCountResetTime < Date.now()) {
            invalidCountResetTime = Date.now() + 1e3 * 60 * 10;
            invalidCount = 0;
          }
          invalidCount++;
          const emitInvalid = this.manager.client.listenerCount(INVALID_REQUEST_WARNING) && this.manager.client.options.invalidRequestWarningInterval > 0 && invalidCount % this.manager.client.options.invalidRequestWarningInterval === 0;
          if (emitInvalid) {
            this.manager.client.emit(INVALID_REQUEST_WARNING, {
              count: invalidCount,
              remainingTime: invalidCountResetTime - Date.now()
            });
          }
        }
        if (res.ok) {
          return parseResponse(res);
        }
        if (res.status >= 400 && res.status < 500) {
          if (res.status === 429) {
            const isGlobal = this.globalLimited;
            let limit, timeout;
            if (isGlobal) {
              limit = this.manager.globalLimit;
              timeout = this.manager.globalReset + this.manager.client.options.restTimeOffset - Date.now();
            } else {
              limit = this.limit;
              timeout = this.reset + this.manager.client.options.restTimeOffset - Date.now();
            }
            this.manager.client.emit(
              DEBUG,
              `Hit a 429 while executing a request.
    Global  : ${isGlobal}
    Method  : ${request.method}
    Path    : ${request.path}
    Route   : ${request.route}
    Limit   : ${limit}
    Timeout : ${timeout}ms
    Sublimit: ${sublimitTimeout ? `${sublimitTimeout}ms` : "None"}`
            );
            await this.onRateLimit(request, limit, timeout, isGlobal);
            if (sublimitTimeout) {
              await sleep(sublimitTimeout);
            }
            return this.execute(request);
          }
          let data;
          try {
            data = await parseResponse(res);
            if ((data == null ? void 0 : data.captcha_service) && typeof this.manager.client.options.captchaSolver == "function" && request.retries < this.manager.client.options.captchaRetryLimit && captchaMessage.some((s) => data.captcha_key[0].includes(s))) {
              this.manager.client.emit(
                DEBUG,
                `Hit a captcha while executing a request (${data.captcha_key.join(", ")})
    Method  : ${request.method}
    Path    : ${request.path}
    Route   : ${request.route}
    Sitekey : ${data.captcha_sitekey}
    rqToken : ${data.captcha_rqtoken}`
              );
              const captcha = await this.manager.client.options.captchaSolver(data, request.fullUserAgent);
              this.manager.client.emit(
                DEBUG,
                `Captcha details:
    Method  : ${request.method}
    Path    : ${request.path}
    Route   : ${request.route}
    Key     : ${captcha ? `${captcha.slice(0, 120)}...` : "[Captcha not solved]"}
    rqToken : ${data.captcha_rqtoken}`
              );
              request.retries++;
              return this.execute(request, captcha, data.captcha_rqtoken);
            }
            if ((data == null ? void 0 : data.code) && data.code == 60003 && request.options.mfaCode && request.retries < 1) {
              this.manager.client.emit(
                DEBUG,
                `${data.message}
    Method  : ${request.method}
    Path    : ${request.path}
    Route   : ${request.route}
    mfaCode : ${request.options.mfaCode}`
              );
              const mfaData = data.mfa;
              const mfaPost = await this.manager.client.api.mfa.finish.post({
                data: {
                  ticket: mfaData.ticket,
                  data: request.options.mfaCode,
                  mfa_type: "totp"
                }
              });
              request.options.mfaToken = mfaPost.token;
              request.retries++;
              return this.execute(request);
            }
          } catch (err) {
            throw new HTTPError(err.message, err.constructor.name, err.status, request);
          }
          throw new DiscordAPIError(data, res.status, request);
        }
        if (res.status >= 500 && res.status < 600) {
          if (request.retries === this.manager.client.options.retryLimit) {
            throw new HTTPError(res.statusText, res.constructor.name, res.status, request);
          }
          request.retries++;
          return this.execute(request);
        }
        return null;
      }
    };
    module2.exports = RequestHandler;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/rest/RESTManager.js
var require_RESTManager = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/rest/RESTManager.js"(exports2, module2) {
    "use strict";
    var { setInterval: setInterval2 } = require_node_timers();
    var { Collection: Collection2 } = require_dist();
    var APIRequest = require_APIRequest();
    var routeBuilder = require_APIRouter();
    var RequestHandler = require_RequestHandler();
    var { Error: Error2 } = require_errors2();
    var { Endpoints } = require_Constants();
    var RESTManager = class {
      constructor(client) {
        this.client = client;
        this.handlers = new Collection2();
        this.versioned = true;
        this.globalLimit = client.options.restGlobalRateLimit > 0 ? client.options.restGlobalRateLimit : Infinity;
        this.globalRemaining = this.globalLimit;
        this.globalReset = null;
        this.globalDelay = null;
        if (client.options.restSweepInterval > 0) {
          this.sweepInterval = setInterval2(() => {
            this.handlers.sweep((handler) => handler._inactive);
          }, client.options.restSweepInterval * 1e3).unref();
        }
      }
      get api() {
        return routeBuilder(this);
      }
      getAuth() {
        const token = this.client.token ?? this.client.accessToken;
        if (token) return token == null ? void 0 : token.replace(/Bot /g, "");
        throw new Error2("TOKEN_MISSING");
      }
      get cdn() {
        return Endpoints.CDN(this.client.options.http.cdn);
      }
      request(method, url, options = {}) {
        const apiRequest = new APIRequest(this, method, url, options);
        let handler = this.handlers.get(apiRequest.route);
        if (!handler) {
          handler = new RequestHandler(this);
          this.handlers.set(apiRequest.route, handler);
        }
        return handler.push(apiRequest);
      }
      get endpoint() {
        return this.client.options.http.api;
      }
      set endpoint(endpoint) {
        this.client.options.http.api = endpoint;
      }
    };
    module2.exports = RESTManager;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/util/Intents.js
var require_Intents = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/util/Intents.js"(exports2, module2) {
    "use strict";
    var BitField = require_BitField();
    var Intents2 = class extends BitField {
    };
    Intents2.FLAGS = {
      GUILDS: 1 << 0,
      GUILD_MEMBERS: 1 << 1,
      GUILD_BANS: 1 << 2,
      GUILD_EMOJIS_AND_STICKERS: 1 << 3,
      GUILD_INTEGRATIONS: 1 << 4,
      GUILD_WEBHOOKS: 1 << 5,
      GUILD_INVITES: 1 << 6,
      GUILD_VOICE_STATES: 1 << 7,
      GUILD_PRESENCES: 1 << 8,
      GUILD_MESSAGES: 1 << 9,
      GUILD_MESSAGE_REACTIONS: 1 << 10,
      GUILD_MESSAGE_TYPING: 1 << 11,
      DIRECT_MESSAGES: 1 << 12,
      DIRECT_MESSAGE_REACTIONS: 1 << 13,
      DIRECT_MESSAGE_TYPING: 1 << 14,
      MESSAGE_CONTENT: 1 << 15,
      GUILD_SCHEDULED_EVENTS: 1 << 16,
      AUTO_MODERATION_CONFIGURATION: 1 << 20,
      AUTO_MODERATION_EXECUTION: 1 << 21
    };
    Intents2.ALL = Object.values(Intents2.FLAGS).reduce((all, p) => all | p, 0);
    module2.exports = Intents2;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/util/LimitedCollection.js
var require_LimitedCollection = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/util/LimitedCollection.js"(exports2, module2) {
    "use strict";
    var { setInterval: setInterval2 } = require_node_timers();
    var { Collection: Collection2 } = require_dist();
    var { _cleanupSymbol } = require_Constants();
    var Sweepers2 = require_Sweepers();
    var { TypeError: TypeError2 } = require_DJSError();
    var LimitedCollection = class extends Collection2 {
      constructor(options = {}, iterable) {
        if (typeof options !== "object" || options === null) {
          throw new TypeError2("INVALID_TYPE", "options", "object", true);
        }
        const { maxSize = Infinity, keepOverLimit = null, sweepInterval = 0, sweepFilter = null } = options;
        if (typeof maxSize !== "number") {
          throw new TypeError2("INVALID_TYPE", "maxSize", "number");
        }
        if (keepOverLimit !== null && typeof keepOverLimit !== "function") {
          throw new TypeError2("INVALID_TYPE", "keepOverLimit", "function");
        }
        if (typeof sweepInterval !== "number") {
          throw new TypeError2("INVALID_TYPE", "sweepInterval", "number");
        }
        if (sweepFilter !== null && typeof sweepFilter !== "function") {
          throw new TypeError2("INVALID_TYPE", "sweepFilter", "function");
        }
        super(iterable);
        this.maxSize = maxSize;
        this.keepOverLimit = keepOverLimit;
        this.sweepFilter = sweepFilter;
        this.interval = sweepInterval > 0 && sweepInterval !== Infinity && sweepFilter ? setInterval2(() => {
          const sweepFn = this.sweepFilter(this);
          if (sweepFn === null) return;
          if (typeof sweepFn !== "function") throw new TypeError2("SWEEP_FILTER_RETURN");
          this.sweep(sweepFn);
        }, sweepInterval * 1e3).unref() : null;
      }
      set(key, value) {
        var _a;
        if (this.maxSize === 0) return this;
        if (this.size >= this.maxSize && !this.has(key)) {
          for (const [k, v] of this.entries()) {
            const keep = ((_a = this.keepOverLimit) == null ? void 0 : _a.call(this, v, k, this)) ?? false;
            if (!keep) {
              this.delete(k);
              break;
            }
          }
        }
        return super.set(key, value);
      }
      /**
       * Create a sweepFilter function that uses a lifetime to determine sweepability.
       * @param {LifetimeFilterOptions} [options={}] The options used to generate the filter function
       * @deprecated Use {@link Sweepers.filterByLifetime} instead
       * @returns {SweepFilter}
       */
      static filterByLifetime({
        lifetime = 14400,
        getComparisonTimestamp = (e) => e == null ? void 0 : e.createdTimestamp,
        excludeFromSweep = () => false
      } = {}) {
        return Sweepers2.filterByLifetime({ lifetime, getComparisonTimestamp, excludeFromSweep });
      }
      [_cleanupSymbol]() {
        return this.interval ? () => clearInterval(this.interval) : null;
      }
      static get [Symbol.species]() {
        return Collection2;
      }
    };
    module2.exports = LimitedCollection;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/util/Options.js
var require_Options = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/util/Options.js"(exports2, module2) {
    "use strict";
    var { UserAgent } = require_Constants();
    var Intents2 = require_Intents();
    var Options = class extends null {
      /**
       * The default client options.
       * @returns {ClientOptions}
       */
      static createDefault() {
        return {
          DMChannelVoiceStatusSync: 0,
          captchaRetryLimit: 3,
          captchaSolver: () => Promise.reject(new Error("CAPTCHA_SOLVER_NOT_IMPLEMENTED")),
          closeTimeout: 5e3,
          waitGuildTimeout: 15e3,
          shardCount: 1,
          shards: [0],
          makeCache: this.cacheWithLimits(this.defaultMakeCacheSettings),
          messageCacheLifetime: 0,
          messageSweepInterval: 0,
          invalidRequestWarningInterval: 0,
          intents: Intents2.ALL,
          partials: ["USER", "CHANNEL", "GUILD_MEMBER", "MESSAGE", "REACTION", "GUILD_SCHEDULED_EVENT"],
          // Enable the partials
          restWsBridgeTimeout: 5e3,
          restRequestTimeout: 15e3,
          restGlobalRateLimit: 0,
          retryLimit: 1,
          restTimeOffset: 500,
          restSweepInterval: 60,
          failIfNotExists: true,
          presence: { status: "online", since: 0, activities: [], afk: true },
          sweepers: {},
          ws: {
            capabilities: 0,
            // https://discord-userdoccers.vercel.app/topics/gateway#gateway-capabilities
            properties: {
              os: "Windows",
              browser: "Chrome",
              device: "",
              system_locale: "vi-VN",
              browser_user_agent: UserAgent,
              browser_version: "131.0.0.0",
              os_version: "10",
              referrer: "",
              referring_domain: "",
              referrer_current: "",
              referring_domain_current: "",
              release_channel: "stable",
              client_build_number: 353304,
              client_event_source: null
            },
            compress: false,
            client_state: {
              guild_versions: {}
            },
            version: 9,
            agent: {}
          },
          http: {
            agent: {},
            headers: {
              "User-Agent": UserAgent
            },
            version: 9,
            api: "https://discord.com/api",
            cdn: "https://cdn.discordapp.com",
            invite: "https://discord.gg",
            template: "https://discord.new",
            scheduledEvent: "https://discord.com/events"
          }
        };
      }
      /**
       * Create a cache factory using predefined settings to sweep or limit.
       * @param {Object<string, LimitedCollectionOptions|number>} [settings={}] Settings passed to the relevant constructor.
       * If no setting is provided for a manager, it uses Collection.
       * If a number is provided for a manager, it uses that number as the max size for a LimitedCollection.
       * If LimitedCollectionOptions are provided for a manager, it uses those settings to form a LimitedCollection.
       * @returns {CacheFactory}
       * @example
       * // Store up to 200 messages per channel and discard archived threads if they were archived more than 4 hours ago.
       * // Note archived threads will remain in the guild and client caches with these settings
       * Options.cacheWithLimits({
       *    MessageManager: 200,
       *    ThreadManager: {
       *      sweepInterval: 3600,
       *      sweepFilter: LimitedCollection.filterByLifetime({
       *        getComparisonTimestamp: e => e.archiveTimestamp,
       *        excludeFromSweep: e => !e.archived,
       *      }),
       *    },
       *  });
       * @example
       * // Sweep messages every 5 minutes, removing messages that have not been edited or created in the last 30 minutes
       * Options.cacheWithLimits({
       *   // Keep default thread sweeping behavior
       *   ...Options.defaultMakeCacheSettings,
       *   // Override MessageManager
       *   MessageManager: {
       *     sweepInterval: 300,
       *     sweepFilter: LimitedCollection.filterByLifetime({
       *       lifetime: 1800,
       *       getComparisonTimestamp: e => e.editedTimestamp ?? e.createdTimestamp,
       *     })
       *   }
       * });
       */
      static cacheWithLimits(settings = {}) {
        const { Collection: Collection2 } = require_dist();
        const LimitedCollection = require_LimitedCollection();
        return (manager) => {
          const setting = settings[manager.name];
          if (setting == null) {
            return new Collection2();
          }
          if (typeof setting === "number") {
            if (setting === Infinity) {
              return new Collection2();
            }
            return new LimitedCollection({ maxSize: setting });
          }
          const noSweeping = setting.sweepFilter == null || setting.sweepInterval == null || setting.sweepInterval <= 0 || setting.sweepInterval === Infinity;
          const noLimit = setting.maxSize == null || setting.maxSize === Infinity;
          if (noSweeping && noLimit) {
            return new Collection2();
          }
          return new LimitedCollection(setting);
        };
      }
      /**
       * Create a cache factory that always caches everything.
       * @returns {CacheFactory}
       */
      static cacheEverything() {
        const { Collection: Collection2 } = require_dist();
        return () => new Collection2();
      }
      /**
       * The default settings passed to {@link ClientOptions.makeCache}.
       * The caches that this changes are:
       * * `MessageManager` - Limit to 200 messages
       * * `ChannelManager` - Sweep archived threads
       * * `GuildChannelManager` - Sweep archived threads
       * * `ThreadManager` - Sweep archived threads
       * <info>If you want to keep default behavior and add on top of it you can use this object and add on to it, e.g.
       * `makeCache: Options.cacheWithLimits({ ...Options.defaultMakeCacheSettings, ReactionManager: 0 })`</info>
       * @type {Object<string, LimitedCollectionOptions|number>}
       */
      static get defaultMakeCacheSettings() {
        return {
          MessageManager: 200,
          ChannelManager: {
            sweepInterval: 3600,
            sweepFilter: require_Util().archivedThreadSweepFilter()
          },
          GuildChannelManager: {
            sweepInterval: 3600,
            sweepFilter: require_Util().archivedThreadSweepFilter()
          },
          ThreadManager: {
            sweepInterval: 3600,
            sweepFilter: require_Util().archivedThreadSweepFilter()
          }
        };
      }
    };
    Options.defaultSweeperSettings = {
      threads: {
        interval: 3600,
        lifetime: 14400
      }
    };
    module2.exports = Options;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/BaseClient.js
var require_BaseClient = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/BaseClient.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require_node_events();
    var process2 = require_node_process();
    var RESTManager = require_RESTManager();
    var Options = require_Options();
    var Util = require_Util();
    var BaseClient2 = class extends EventEmitter {
      constructor(options = {}) {
        super({ captureRejections: true });
        if (options.intents) {
          process2.emitWarning("Intents is not available.", "DeprecationWarning");
        }
        this.options = Util.mergeDefault(Options.createDefault(), options);
        this.rest = new RESTManager(this);
      }
      /**
       * API shortcut
       * @type {Object}
       * @readonly
       * @private
       */
      get api() {
        return this.rest.api;
      }
      /**
       * Destroys all assets used by the base client.
       * @returns {void}
       */
      destroy() {
        if (this.rest.sweepInterval) clearInterval(this.rest.sweepInterval);
      }
      /**
       * Increments max listeners by one, if they are not zero.
       * @private
       */
      incrementMaxListeners() {
        const maxListeners = this.getMaxListeners();
        if (maxListeners !== 0) {
          this.setMaxListeners(maxListeners + 1);
        }
      }
      /**
       * Decrements max listeners by one, if they are not zero.
       * @private
       */
      decrementMaxListeners() {
        const maxListeners = this.getMaxListeners();
        if (maxListeners !== 0) {
          this.setMaxListeners(maxListeners - 1);
        }
      }
      toJSON(...props) {
        return Util.flatten(this, { domain: false }, ...props);
      }
    };
    module2.exports = BaseClient2;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/actions/Action.js
var require_Action = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/actions/Action.js"(exports2, module2) {
    "use strict";
    var { PartialTypes } = require_Constants();
    var GenericAction = class {
      constructor(client) {
        this.client = client;
      }
      handle(data) {
        return data;
      }
      getPayload(data, manager, id, partialType, cache) {
        const existing = manager.cache.get(id);
        if (!existing && this.client.options.partials.includes(partialType)) {
          return manager._add(data, cache);
        }
        return existing;
      }
      getChannel(data) {
        const payloadData = {};
        const id = data.channel_id ?? data.id;
        if (!("recipients" in data)) {
          const recipient = data.author ?? data.user ?? { id: data.user_id };
          if (recipient.id !== this.client.user.id) payloadData.recipients = [recipient];
        }
        if (id !== void 0) payloadData.id = id;
        return data[this.client.actions.injectedChannel] ?? this.getPayload({ ...data, ...payloadData }, this.client.channels, id, PartialTypes.CHANNEL);
      }
      getMessage(data, channel, cache) {
        var _a;
        const id = data.message_id ?? data.id;
        return data[this.client.actions.injectedMessage] ?? this.getPayload(
          {
            id,
            channel_id: channel.id,
            guild_id: data.guild_id ?? ((_a = channel.guild) == null ? void 0 : _a.id)
          },
          channel.messages,
          id,
          PartialTypes.MESSAGE,
          cache
        );
      }
      getReaction(data, message, user) {
        const id = data.emoji.id ?? decodeURIComponent(data.emoji.name);
        return this.getPayload(
          {
            emoji: data.emoji,
            count: message.partial ? null : 0,
            me: (user == null ? void 0 : user.id) === this.client.user.id
          },
          message.reactions,
          id,
          PartialTypes.REACTION
        );
      }
      getMember(data, guild) {
        return this.getPayload(data, guild.members, data.user.id, PartialTypes.GUILD_MEMBER);
      }
      getUser(data) {
        const id = data.user_id;
        return data[this.client.actions.injectedUser] ?? this.getPayload({ id }, this.client.users, id, PartialTypes.USER);
      }
      getUserFromMember(data) {
        var _a;
        if (data.guild_id && ((_a = data.member) == null ? void 0 : _a.user)) {
          const guild = this.client.guilds.cache.get(data.guild_id);
          if (guild) {
            return guild.members._add(data.member).user;
          } else {
            return this.client.users._add(data.member.user);
          }
        }
        return this.getUser(data);
      }
      getScheduledEvent(data, guild) {
        const id = data.guild_scheduled_event_id ?? data.id;
        return this.getPayload(
          { id, guild_id: data.guild_id ?? guild.id },
          guild.scheduledEvents,
          id,
          PartialTypes.GUILD_SCHEDULED_EVENT
        );
      }
    };
    module2.exports = GenericAction;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/actions/ApplicationCommandPermissionsUpdate.js
var require_ApplicationCommandPermissionsUpdate = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/actions/ApplicationCommandPermissionsUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var { Events: Events2 } = require_Constants();
    var ApplicationCommandPermissionsUpdateAction = class extends Action {
      handle(data) {
        const client = this.client;
        client.emit(Events2.APPLICATION_COMMAND_PERMISSIONS_UPDATE, {
          permissions: data.permissions,
          id: data.id,
          guildId: data.guild_id,
          applicationId: data.application_id
        });
      }
    };
    module2.exports = ApplicationCommandPermissionsUpdateAction;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/AutoModerationActionExecution.js
var require_AutoModerationActionExecution = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/AutoModerationActionExecution.js"(exports2, module2) {
    "use strict";
    var { AutoModerationRuleTriggerTypes } = require_Constants();
    var AutoModerationActionExecution = class {
      constructor(data, guild) {
        this.guild = guild;
        this.action = data.action;
        this.ruleId = data.rule_id;
        this.ruleTriggerType = AutoModerationRuleTriggerTypes[data.rule_trigger_type];
        this.userId = data.user_id;
        this.channelId = data.channel_id ?? null;
        this.messageId = data.message_id ?? null;
        this.alertSystemMessageId = data.alert_system_message_id ?? null;
        this.content = data.content;
        this.matchedKeyword = data.matched_keyword ?? null;
        this.matchedContent = data.matched_content ?? null;
      }
      /**
       * The auto moderation rule this action belongs to.
       * @type {?AutoModerationRule}
       * @readonly
       */
      get autoModerationRule() {
        return this.guild.autoModerationRules.cache.get(this.ruleId) ?? null;
      }
    };
    module2.exports = AutoModerationActionExecution;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/actions/AutoModerationActionExecution.js
var require_AutoModerationActionExecution2 = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/actions/AutoModerationActionExecution.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var AutoModerationActionExecution = require_AutoModerationActionExecution();
    var { Events: Events2 } = require_Constants();
    var AutoModerationActionExecutionAction = class extends Action {
      handle(data) {
        const { client } = this;
        const guild = client.guilds.cache.get(data.guild_id);
        if (guild) {
          client.emit(Events2.AUTO_MODERATION_ACTION_EXECUTION, new AutoModerationActionExecution(data, guild));
        }
        return {};
      }
    };
    module2.exports = AutoModerationActionExecutionAction;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/actions/AutoModerationRuleCreate.js
var require_AutoModerationRuleCreate = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/actions/AutoModerationRuleCreate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var { Events: Events2 } = require_Constants();
    var AutoModerationRuleCreateAction = class extends Action {
      handle(data) {
        const { client } = this;
        const guild = client.guilds.cache.get(data.guild_id);
        if (guild) {
          const autoModerationRule = guild.autoModerationRules._add(data);
          client.emit(Events2.AUTO_MODERATION_RULE_CREATE, autoModerationRule);
        }
        return {};
      }
    };
    module2.exports = AutoModerationRuleCreateAction;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/actions/AutoModerationRuleDelete.js
var require_AutoModerationRuleDelete = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/actions/AutoModerationRuleDelete.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var { Events: Events2 } = require_Constants();
    var AutoModerationRuleDeleteAction = class extends Action {
      handle(data) {
        const { client } = this;
        const guild = client.guilds.cache.get(data.guild_id);
        if (guild) {
          const autoModerationRule = guild.autoModerationRules.cache.get(data.id);
          if (autoModerationRule) {
            guild.autoModerationRules.cache.delete(autoModerationRule.id);
            client.emit(Events2.AUTO_MODERATION_RULE_DELETE, autoModerationRule);
          }
        }
        return {};
      }
    };
    module2.exports = AutoModerationRuleDeleteAction;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/actions/AutoModerationRuleUpdate.js
var require_AutoModerationRuleUpdate = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/actions/AutoModerationRuleUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var { Events: Events2 } = require_Constants();
    var AutoModerationRuleUpdateAction = class extends Action {
      handle(data) {
        var _a;
        const { client } = this;
        const guild = client.guilds.cache.get(data.guild_id);
        if (guild) {
          const oldAutoModerationRule = ((_a = guild.autoModerationRules.cache.get(data.id)) == null ? void 0 : _a._clone()) ?? null;
          const newAutoModerationRule = guild.autoModerationRules._add(data);
          client.emit(Events2.AUTO_MODERATION_RULE_UPDATE, oldAutoModerationRule, newAutoModerationRule);
        }
        return {};
      }
    };
    module2.exports = AutoModerationRuleUpdateAction;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/actions/ChannelCreate.js
var require_ChannelCreate = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/actions/ChannelCreate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var { Events: Events2 } = require_Constants();
    var ChannelCreateAction = class extends Action {
      handle(data) {
        const client = this.client;
        const existing = client.channels.cache.has(data.id);
        const channel = client.channels._add(data);
        if (!existing && channel) {
          client.emit(Events2.CHANNEL_CREATE, channel);
        }
        return { channel };
      }
    };
    module2.exports = ChannelCreateAction;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/actions/ChannelDelete.js
var require_ChannelDelete = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/actions/ChannelDelete.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var { deletedChannels } = require_Channel();
    var DMChannel = require_DMChannel();
    var { deletedMessages } = require_Message();
    var { Events: Events2 } = require_Constants();
    var ChannelDeleteAction = class extends Action {
      constructor(client) {
        super(client);
        this.deleted = /* @__PURE__ */ new Map();
      }
      handle(data) {
        const client = this.client;
        const channel = client.channels.cache.get(data.id);
        if (channel) {
          client.channels._remove(channel.id);
          deletedChannels.add(channel);
          if (channel.messages && !(channel instanceof DMChannel)) {
            for (const message of channel.messages.cache.values()) {
              deletedMessages.add(message);
            }
          }
          client.emit(Events2.CHANNEL_DELETE, channel);
        }
        return { channel };
      }
    };
    module2.exports = ChannelDeleteAction;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/actions/ChannelUpdate.js
var require_ChannelUpdate = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/actions/ChannelUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var { Channel } = require_Channel();
    var { ChannelTypes } = require_Constants();
    var ChannelUpdateAction = class extends Action {
      handle(data) {
        const client = this.client;
        let channel = client.channels.cache.get(data.id);
        if (channel) {
          const old = channel._update(data);
          if (ChannelTypes[channel.type] !== data.type) {
            const newChannel = Channel.create(this.client, data, channel.guild);
            if (!newChannel) {
              this.client.channels.cache.delete(channel.id);
              return {};
            }
            if (channel.isText() && newChannel.isText()) {
              for (const [id, message] of channel.messages.cache) newChannel.messages.cache.set(id, message);
            }
            channel = newChannel;
            this.client.channels.cache.set(channel.id, channel);
          }
          return {
            old,
            updated: channel
          };
        } else {
          client.channels._add(data);
        }
        return {};
      }
    };
    module2.exports = ChannelUpdateAction;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/managers/ApplicationCommandPermissionsManager.js
var require_ApplicationCommandPermissionsManager = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/managers/ApplicationCommandPermissionsManager.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var BaseManager = require_BaseManager();
    var { Error: Error2, TypeError: TypeError2 } = require_errors2();
    var { ApplicationCommandPermissionTypes, APIErrors } = require_Constants();
    var ApplicationCommandPermissionsManager = class extends BaseManager {
      constructor(manager) {
        var _a;
        super(manager.client);
        this.manager = manager;
        this.guild = manager.guild ?? null;
        this.guildId = manager.guildId ?? ((_a = manager.guild) == null ? void 0 : _a.id) ?? null;
        this.commandId = manager.id ?? null;
      }
      /**
       * The APIRouter path to the commands
       * @param {Snowflake} guildId The guild's id to use in the path,
       * @param {Snowflake} [commandId] The application command's id
       * @returns {Object}
       * @private
       */
      permissionsPath(guildId, commandId) {
        return this.client.api.applications(this.client.application.id).guilds(guildId).commands(commandId).permissions;
      }
      /**
       * Data for setting the permissions of an application command.
       * @typedef {Object} ApplicationCommandPermissionData
       * @property {Snowflake} id The role or user's id
       * @property {ApplicationCommandPermissionType|number} type Whether this permission is for a role or a user
       * @property {boolean} permission Whether the role or user has the permission to use this command
       */
      /**
       * The object returned when fetching permissions for an application command.
       * @typedef {Object} ApplicationCommandPermissions
       * @property {Snowflake} id The role or user's id
       * @property {ApplicationCommandPermissionType} type Whether this permission is for a role or a user
       * @property {boolean} permission Whether the role or user has the permission to use this command
       */
      /**
       * Options for managing permissions for one or more Application Commands
       * <warn>When passing these options to a manager where `guildId` is `null`,
       * `guild` is a required parameter</warn>
       * @typedef {Object} BaseApplicationCommandPermissionsOptions
       * @property {GuildResolvable} [guild] The guild to modify / check permissions for
       * <warn>Ignored when the manager has a non-null `guildId` property</warn>
       * @property {ApplicationCommandResolvable} [command] The command to modify / check permissions for
       * <warn>Ignored when the manager has a non-null `commandId` property</warn>
       */
      /**
       * Fetches the permissions for one or multiple commands.
       * @param {BaseApplicationCommandPermissionsOptions} [options] Options used to fetch permissions
       * @returns {Promise<ApplicationCommandPermissions[]|Collection<Snowflake, ApplicationCommandPermissions[]>>}
       * @example
       * // Fetch permissions for one command
       * guild.commands.permissions.fetch({ command: '123456789012345678' })
       *   .then(perms => console.log(`Fetched permissions for ${perms.length} users`))
       *   .catch(console.error);
       * @example
       * // Fetch permissions for all commands in a guild
       * client.application.commands.permissions.fetch({ guild: '123456789012345678' })
       *   .then(perms => console.log(`Fetched permissions for ${perms.size} commands`))
       *   .catch(console.error);
       */
      async fetch({ guild, command } = {}) {
        const { guildId, commandId } = this._validateOptions(guild, command);
        if (commandId) {
          const data2 = await this.permissionsPath(guildId, commandId).get();
          return data2.permissions.map((perm) => this.constructor.transformPermissions(perm, true));
        }
        const data = await this.permissionsPath(guildId).get();
        return data.reduce(
          (coll, perm) => coll.set(
            perm.id,
            perm.permissions.map((p) => this.constructor.transformPermissions(p, true))
          ),
          new Collection2()
        );
      }
      /**
       * Data used for overwriting the permissions for all application commands in a guild.
       * @typedef {Object} GuildApplicationCommandPermissionData
       * @property {Snowflake} id The command's id
       * @property {ApplicationCommandPermissionData[]} permissions The permissions for this command
       */
      /**
       * Options used to set permissions for one or more Application Commands in a guild
       * <warn>One of `command` AND `permissions`, OR `fullPermissions` is required.
       * `fullPermissions` is not a valid option when passing to a manager where `commandId` is non-null</warn>
       * @typedef {BaseApplicationCommandPermissionsOptions} SetApplicationCommandPermissionsOptions
       * @property {ApplicationCommandPermissionData[]} [permissions] The new permissions for the command
       * @property {GuildApplicationCommandPermissionData[]} [fullPermissions] The new permissions for all commands
       * in a guild <warn>When this parameter is set, `permissions` and `command` are ignored</warn>
       */
      /**
       * Sets the permissions for one or more commands.
       * @param {SetApplicationCommandPermissionsOptions} options Options used to set permissions
       * @returns {Promise<ApplicationCommandPermissions[]|Collection<Snowflake, ApplicationCommandPermissions[]>>}
       * @example
       * // Set the permissions for one command
       * client.application.commands.permissions.set({ guild: '892455839386304532', command: '123456789012345678',
       *  permissions: [
       *    {
       *      id: '876543210987654321',
       *      type: 'USER',
       *      permission: false,
       *    },
       * ]})
       *   .then(console.log)
       *   .catch(console.error);
       * @example
       * // Set the permissions for all commands
       * guild.commands.permissions.set({ fullPermissions: [
       *   {
       *     id: '123456789012345678',
       *     permissions: [{
       *       id: '876543210987654321',
       *       type: 'USER',
       *       permission: false,
       *     }],
       *   },
       * ]})
       *   .then(console.log)
       *   .catch(console.error);
       */
      async set({ guild, command, permissions, fullPermissions } = {}) {
        const { guildId, commandId } = this._validateOptions(guild, command);
        if (commandId) {
          if (!Array.isArray(permissions)) {
            throw new TypeError2("INVALID_TYPE", "permissions", "Array of ApplicationCommandPermissionData", true);
          }
          const data2 = await this.permissionsPath(guildId, commandId).put({
            data: { permissions: permissions.map((perm) => this.constructor.transformPermissions(perm)) }
          });
          return data2.permissions.map((perm) => this.constructor.transformPermissions(perm, true));
        }
        if (!Array.isArray(fullPermissions)) {
          throw new TypeError2("INVALID_TYPE", "fullPermissions", "Array of GuildApplicationCommandPermissionData", true);
        }
        const APIPermissions = [];
        for (const perm of fullPermissions) {
          if (!Array.isArray(perm.permissions)) throw new TypeError2("INVALID_ELEMENT", "Array", "fullPermissions", perm);
          APIPermissions.push({
            id: perm.id,
            permissions: perm.permissions.map((p) => this.constructor.transformPermissions(p))
          });
        }
        const data = await this.permissionsPath(guildId).put({
          data: APIPermissions
        });
        return data.reduce(
          (coll, perm) => coll.set(
            perm.id,
            perm.permissions.map((p) => this.constructor.transformPermissions(p, true))
          ),
          new Collection2()
        );
      }
      /**
       * Options used to add permissions to a command
       * <warn>The `command` parameter is not optional when the managers `commandId` is `null`</warn>
       * @typedef {BaseApplicationCommandPermissionsOptions} AddApplicationCommandPermissionsOptions
       * @property {ApplicationCommandPermissionData[]} permissions The permissions to add to the command
       */
      /**
       * Add permissions to a command.
       * @param {AddApplicationCommandPermissionsOptions} options Options used to add permissions
       * @returns {Promise<ApplicationCommandPermissions[]>}
       * @example
       * // Block a role from the command permissions
       * guild.commands.permissions.add({ command: '123456789012345678', permissions: [
       *   {
       *     id: '876543211234567890',
       *     type: 'ROLE',
       *     permission: false
       *   },
       * ]})
       *   .then(console.log)
       *   .catch(console.error);
       */
      async add({ guild, command, permissions }) {
        const { guildId, commandId } = this._validateOptions(guild, command);
        if (!commandId) throw new TypeError2("INVALID_TYPE", "command", "ApplicationCommandResolvable");
        if (!Array.isArray(permissions)) {
          throw new TypeError2("INVALID_TYPE", "permissions", "Array of ApplicationCommandPermissionData", true);
        }
        let existing = [];
        try {
          existing = await this.fetch({ guild: guildId, command: commandId });
        } catch (error2) {
          if (error2.code !== APIErrors.UNKNOWN_APPLICATION_COMMAND_PERMISSIONS) throw error2;
        }
        const newPermissions = permissions.slice();
        for (const perm of existing) {
          if (!newPermissions.some((x) => x.id === perm.id)) {
            newPermissions.push(perm);
          }
        }
        return this.set({ guild: guildId, command: commandId, permissions: newPermissions });
      }
      /**
       * Options used to remove permissions from a command
       * <warn>The `command` parameter is not optional when the managers `commandId` is `null`</warn>
       * @typedef {BaseApplicationCommandPermissionsOptions} RemoveApplicationCommandPermissionsOptions
       * @property {UserResolvable|UserResolvable[]} [users] The user(s) to remove from the command permissions
       * <warn>One of `users` or `roles` is required</warn>
       * @property {RoleResolvable|RoleResolvable[]} [roles] The role(s) to remove from the command permissions
       * <warn>One of `users` or `roles` is required</warn>
       */
      /**
       * Remove permissions from a command.
       * @param {RemoveApplicationCommandPermissionsOptions} options Options used to remove permissions
       * @returns {Promise<ApplicationCommandPermissions[]>}
       * @example
       * // Remove a user permission from this command
       * guild.commands.permissions.remove({ command: '123456789012345678', users: '876543210123456789' })
       *   .then(console.log)
       *   .catch(console.error);
       * @example
       * // Remove multiple roles from this command
       * guild.commands.permissions.remove({
       *   command: '123456789012345678', roles: ['876543210123456789', '765432101234567890']
       * })
       *    .then(console.log)
       *    .catch(console.error);
       */
      async remove({ guild, command, users, roles }) {
        const { guildId, commandId } = this._validateOptions(guild, command);
        if (!commandId) throw new TypeError2("INVALID_TYPE", "command", "ApplicationCommandResolvable");
        if (!users && !roles) throw new TypeError2("INVALID_TYPE", "users OR roles", "Array or Resolvable", true);
        let resolvedIds = [];
        if (Array.isArray(users)) {
          users.forEach((user) => {
            const userId = this.client.users.resolveId(user);
            if (!userId) throw new TypeError2("INVALID_ELEMENT", "Array", "users", user);
            resolvedIds.push(userId);
          });
        } else if (users) {
          const userId = this.client.users.resolveId(users);
          if (!userId) {
            throw new TypeError2("INVALID_TYPE", "users", "Array or UserResolvable");
          }
          resolvedIds.push(userId);
        }
        if (Array.isArray(roles)) {
          roles.forEach((role) => {
            if (typeof role === "string") {
              resolvedIds.push(role);
              return;
            }
            if (!this.guild) throw new Error2("GUILD_UNCACHED_ROLE_RESOLVE");
            const roleId = this.guild.roles.resolveId(role);
            if (!roleId) throw new TypeError2("INVALID_ELEMENT", "Array", "users", role);
            resolvedIds.push(roleId);
          });
        } else if (roles) {
          if (typeof roles === "string") {
            resolvedIds.push(roles);
          } else {
            if (!this.guild) throw new Error2("GUILD_UNCACHED_ROLE_RESOLVE");
            const roleId = this.guild.roles.resolveId(roles);
            if (!roleId) {
              throw new TypeError2("INVALID_TYPE", "users", "Array or RoleResolvable");
            }
            resolvedIds.push(roleId);
          }
        }
        let existing = [];
        try {
          existing = await this.fetch({ guild: guildId, command: commandId });
        } catch (error2) {
          if (error2.code !== APIErrors.UNKNOWN_APPLICATION_COMMAND_PERMISSIONS) throw error2;
        }
        const permissions = existing.filter((perm) => !resolvedIds.includes(perm.id));
        return this.set({ guild: guildId, command: commandId, permissions });
      }
      /**
       * Options used to check the existence of permissions on a command
       * <warn>The `command` parameter is not optional when the managers `commandId` is `null`</warn>
       * @typedef {BaseApplicationCommandPermissionsOptions} HasApplicationCommandPermissionsOptions
       * @property {UserResolvable|RoleResolvable} permissionId The user or role to check if a permission exists for
       * on this command.
       */
      /**
       * Check whether a permission exists for a user or role
       * @param {AddApplicationCommandPermissionsOptions} options Options used to check permissions
       * @returns {Promise<boolean>}
       * @example
       * // Check whether a user has permission to use a command
       * guild.commands.permissions.has({ command: '123456789012345678', permissionId: '876543210123456789' })
       *  .then(console.log)
       *  .catch(console.error);
       */
      async has({ guild, command, permissionId }) {
        const { guildId, commandId } = this._validateOptions(guild, command);
        if (!commandId) throw new TypeError2("INVALID_TYPE", "command", "ApplicationCommandResolvable");
        if (!permissionId) throw new TypeError2("INVALID_TYPE", "permissionId", "UserResolvable or RoleResolvable");
        let resolvedId = permissionId;
        if (typeof permissionId !== "string") {
          resolvedId = this.client.users.resolveId(permissionId);
          if (!resolvedId) {
            if (!this.guild) throw new Error2("GUILD_UNCACHED_ROLE_RESOLVE");
            resolvedId = this.guild.roles.resolveId(permissionId);
          }
          if (!resolvedId) {
            throw new TypeError2("INVALID_TYPE", "permissionId", "UserResolvable or RoleResolvable");
          }
        }
        let existing = [];
        try {
          existing = await this.fetch({ guild: guildId, command: commandId });
        } catch (error2) {
          if (error2.code !== APIErrors.UNKNOWN_APPLICATION_COMMAND_PERMISSIONS) throw error2;
        }
        return existing.some((perm) => perm.id === resolvedId);
      }
      _validateOptions(guild, command) {
        var _a, _b, _c;
        const guildId = this.guildId ?? this.client.guilds.resolveId(guild);
        if (!guildId) throw new Error2("GLOBAL_COMMAND_PERMISSIONS");
        let commandId = this.commandId;
        if (command && !commandId) {
          commandId = (_b = (_a = this.manager).resolveId) == null ? void 0 : _b.call(_a, command);
          if (!commandId && this.guild) {
            commandId = this.guild.commands.resolveId(command);
          }
          commandId ?? (commandId = (_c = this.client.application) == null ? void 0 : _c.commands.resolveId(command));
          if (!commandId) {
            throw new TypeError2("INVALID_TYPE", "command", "ApplicationCommandResolvable", true);
          }
        }
        return { guildId, commandId };
      }
      /**
       * Transforms an {@link ApplicationCommandPermissionData} object into something that can be used with the API.
       * @param {ApplicationCommandPermissionData} permissions The permissions to transform
       * @param {boolean} [received] Whether these permissions have been received from Discord
       * @returns {APIApplicationCommandPermissions}
       * @private
       */
      static transformPermissions(permissions, received) {
        return {
          id: permissions.id,
          permission: permissions.permission,
          type: typeof permissions.type === "number" && !received ? permissions.type : ApplicationCommandPermissionTypes[permissions.type]
        };
      }
    };
    module2.exports = ApplicationCommandPermissionsManager;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/ApplicationCommand.js
var require_ApplicationCommand = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/ApplicationCommand.js"(exports2, module2) {
    "use strict";
    var Base = require_Base();
    var ApplicationCommandPermissionsManager = require_ApplicationCommandPermissionsManager();
    var { ApplicationCommandOptionTypes, ApplicationCommandTypes, ChannelTypes } = require_Constants();
    var Permissions2 = require_Permissions();
    var SnowflakeUtil = require_SnowflakeUtil();
    var ApplicationCommand = class extends Base {
      constructor(client, data, guild, guildId) {
        super(client);
        this.id = data.id;
        this.applicationId = data.application_id;
        this.guild = guild ?? null;
        this.guildId = (guild == null ? void 0 : guild.id) ?? guildId ?? null;
        this.permissions = new ApplicationCommandPermissionsManager(this);
        this.type = ApplicationCommandTypes[data.type];
        this._patch(data);
      }
      _patch(data) {
        if ("name" in data) {
          this.name = data.name;
        }
        if ("name_localizations" in data) {
          this.nameLocalizations = data.name_localizations;
        } else {
          this.nameLocalizations ?? (this.nameLocalizations = null);
        }
        if ("name_localized" in data) {
          this.nameLocalized = data.name_localized;
        } else {
          this.nameLocalized ?? (this.nameLocalized = null);
        }
        if ("description" in data) {
          this.description = data.description;
        }
        if ("description_localizations" in data) {
          this.descriptionLocalizations = data.description_localizations;
        } else {
          this.descriptionLocalizations ?? (this.descriptionLocalizations = null);
        }
        if ("description_localized" in data) {
          this.descriptionLocalized = data.description_localized;
        } else {
          this.descriptionLocalized ?? (this.descriptionLocalized = null);
        }
        if ("options" in data) {
          this.options = data.options.map((o) => this.constructor.transformOption(o, true));
        } else {
          this.options ?? (this.options = []);
        }
        if ("default_permission" in data) {
          this.defaultPermission = data.default_permission;
        }
        if ("default_member_permissions" in data) {
          this.defaultMemberPermissions = data.default_member_permissions ? new Permissions2(BigInt(data.default_member_permissions)).freeze() : null;
        } else {
          this.defaultMemberPermissions ?? (this.defaultMemberPermissions = null);
        }
        if ("dm_permission" in data) {
          this.dmPermission = data.dm_permission;
        } else {
          this.dmPermission ?? (this.dmPermission = null);
        }
        if ("version" in data) {
          this.version = data.version;
        }
      }
      /**
       * The timestamp the command was created at
       * @type {number}
       * @readonly
       */
      get createdTimestamp() {
        return SnowflakeUtil.timestampFrom(this.id);
      }
      /**
       * The time the command was created at
       * @type {Date}
       * @readonly
       */
      get createdAt() {
        return new Date(this.createdTimestamp);
      }
      /**
       * The manager that this command belongs to
       * @type {ApplicationCommandManager}
       * @readonly
       */
      get manager() {
        return (this.guild ?? this.client.application).commands;
      }
      /**
       * Data for creating or editing an application command.
       * @typedef {Object} ApplicationCommandData
       * @property {string} name The name of the command
       * @property {Object<Locale, string>} [nameLocalizations] The localizations for the command name
       * @property {string} description The description of the command
       * @property {Object<Locale, string>} [descriptionLocalizations] The localizations for the command description
       * @property {ApplicationCommandType} [type] The type of the command
       * @property {ApplicationCommandOptionData[]} [options] Options for the command
       * @property {boolean} [defaultPermission] Whether the command is enabled by default when the app is added to a guild
       * @property {?PermissionResolvable} [defaultMemberPermissions] The bitfield used to determine the default permissions
       * a member needs in order to run the command
       * @property {boolean} [dmPermission] Whether the command is enabled in DMs
       */
      /**
       * An option for an application command or subcommand.
       * <info>In addition to the listed properties, when used as a parameter,
       * API style `snake_case` properties can be used for compatibility with generators like `@discordjs/builders`.</info>
       * <warn>Note that providing a value for the `camelCase` counterpart for any `snake_case` property
       * will discard the provided `snake_case` property.</warn>
       * @typedef {Object} ApplicationCommandOptionData
       * @property {ApplicationCommandOptionType|number} type The type of the option
       * @property {string} name The name of the option
       * @property {Object<Locale, string>} [nameLocalizations] The name localizations for the option
       * @property {string} description The description of the option
       * @property {Object<Locale, string>} [descriptionLocalizations] The description localizations for the option
       * @property {boolean} [autocomplete] Whether the option is an autocomplete option
       * @property {boolean} [required] Whether the option is required
       * @property {ApplicationCommandOptionChoiceData[]} [choices] The choices of the option for the user to pick from
       * @property {ApplicationCommandOptionData[]} [options] Additional options if this option is a subcommand (group)
       * @property {ChannelType[]|number[]} [channelTypes] When the option type is channel,
       * the allowed types of channels that can be selected
       * @property {number} [minValue] The minimum value for an `INTEGER` or `NUMBER` option
       * @property {number} [maxValue] The maximum value for an `INTEGER` or `NUMBER` option
       * @property {number} [minLength] The minimum length for a `STRING` option
       * (maximum of `6000`)
       * @property {number} [maxLength] The maximum length for a `STRING` option
       * (maximum of `6000`)
       */
      /**
       * @typedef {Object} ApplicationCommandOptionChoiceData
       * @property {string} name The name of the choice
       * @property {Object<Locale, string>} [nameLocalizations] The localized names for this choice
       * @property {string|number} value The value of the choice
       */
      /**
       * Edits this application command.
       * @param {Partial<ApplicationCommandData>} data The data to update the command with
       * @returns {Promise<ApplicationCommand>}
       * @example
       * // Edit the description of this command
       * command.edit({
       *   description: 'New description',
       * })
       *   .then(console.log)
       *   .catch(console.error);
       */
      edit(data) {
        return this.manager.edit(this, data, this.guildId);
      }
      /**
       * Edits the name of this ApplicationCommand
       * @param {string} name The new name of the command
       * @returns {Promise<ApplicationCommand>}
       */
      setName(name) {
        return this.edit({ name });
      }
      /**
       * Edits the localized names of this ApplicationCommand
       * @param {Object<Locale, string>} nameLocalizations The new localized names for the command
       * @returns {Promise<ApplicationCommand>}
       * @example
       * // Edit the name localizations of this command
       * command.setLocalizedNames({
       *   'en-GB': 'test',
       *   'pt-BR': 'teste',
       * })
       *   .then(console.log)
       *   .catch(console.error)
       */
      setNameLocalizations(nameLocalizations) {
        return this.edit({ nameLocalizations });
      }
      /**
       * Edits the description of this ApplicationCommand
       * @param {string} description The new description of the command
       * @returns {Promise<ApplicationCommand>}
       */
      setDescription(description) {
        return this.edit({ description });
      }
      /**
       * Edits the localized descriptions of this ApplicationCommand
       * @param {Object<Locale, string>} descriptionLocalizations The new localized descriptions for the command
       * @returns {Promise<ApplicationCommand>}
       * @example
       * // Edit the description localizations of this command
       * command.setLocalizedDescriptions({
       *   'en-GB': 'A test command',
       *   'pt-BR': 'Um comando de teste',
       * })
       *   .then(console.log)
       *   .catch(console.error)
       */
      setDescriptionLocalizations(descriptionLocalizations) {
        return this.edit({ descriptionLocalizations });
      }
      /* eslint-disable max-len */
      /**
       * Edits the default permission of this ApplicationCommand
       * @param {boolean} [defaultPermission=true] The default permission for this command
       * @returns {Promise<ApplicationCommand>}
       * @deprecated Use {@link ApplicationCommand#setDefaultMemberPermissions} and {@link ApplicationCommand#setDMPermission} instead.
       */
      setDefaultPermission(defaultPermission = true) {
        return this.edit({ defaultPermission });
      }
      /* eslint-enable max-len */
      /**
       * Edits the default member permissions of this ApplicationCommand
       * @param {?PermissionResolvable} defaultMemberPermissions The default member permissions required to run this command
       * @returns {Promise<ApplicationCommand>}
       */
      setDefaultMemberPermissions(defaultMemberPermissions) {
        return this.edit({ defaultMemberPermissions });
      }
      /**
       * Edits the DM permission of this ApplicationCommand
       * @param {boolean} [dmPermission=true] Whether the command can be used in DMs
       * @returns {Promise<ApplicationCommand>}
       */
      setDMPermission(dmPermission = true) {
        return this.edit({ dmPermission });
      }
      /**
       * Edits the options of this ApplicationCommand
       * @param {ApplicationCommandOptionData[]} options The options to set for this command
       * @returns {Promise<ApplicationCommand>}
       */
      setOptions(options) {
        return this.edit({ options });
      }
      /**
       * Deletes this command.
       * @returns {Promise<ApplicationCommand>}
       * @example
       * // Delete this command
       * command.delete()
       *   .then(console.log)
       *   .catch(console.error);
       */
      delete() {
        return this.manager.delete(this, this.guildId);
      }
      /**
       * Whether this command equals another command. It compares all properties, so for most operations
       * it is advisable to just compare `command.id === command2.id` as it is much faster and is often
       * what most users need.
       * @param {ApplicationCommand|ApplicationCommandData|APIApplicationCommand} command The command to compare with
       * @param {boolean} [enforceOptionOrder=false] Whether to strictly check that options and choices are in the same
       * order in the array <info>The client may not always respect this ordering!</info>
       * @returns {boolean}
       */
      equals(command, enforceOptionOrder = false) {
        var _a, _b, _c;
        if (command.id && this.id !== command.id) return false;
        let defaultMemberPermissions = null;
        let dmPermission = command.dmPermission ?? command.dm_permission;
        if ("default_member_permissions" in command) {
          defaultMemberPermissions = command.default_member_permissions ? new Permissions2(BigInt(command.default_member_permissions)).bitfield : null;
        }
        if ("defaultMemberPermissions" in command) {
          defaultMemberPermissions = command.defaultMemberPermissions !== null ? new Permissions2(command.defaultMemberPermissions).bitfield : null;
        }
        const commandType = typeof command.type === "string" ? command.type : ApplicationCommandTypes[command.type];
        if (command.name !== this.name || "description" in command && command.description !== this.description || "version" in command && command.version !== this.version || "autocomplete" in command && command.autocomplete !== this.autocomplete || commandType && commandType !== this.type || defaultMemberPermissions !== (((_a = this.defaultMemberPermissions) == null ? void 0 : _a.bitfield) ?? null) || typeof dmPermission !== "undefined" && dmPermission !== this.dmPermission || // Future proof for options being nullable
        // TODO: remove ?? 0 on each when nullable
        (((_b = command.options) == null ? void 0 : _b.length) ?? 0) !== (((_c = this.options) == null ? void 0 : _c.length) ?? 0) || (command.defaultPermission ?? command.default_permission ?? true) !== this.defaultPermission) {
          return false;
        }
        if (command.options) {
          return this.constructor.optionsEqual(this.options, command.options, enforceOptionOrder);
        }
        return true;
      }
      /**
       * Recursively checks that all options for an {@link ApplicationCommand} are equal to the provided options.
       * In most cases it is better to compare using {@link ApplicationCommand#equals}
       * @param {ApplicationCommandOptionData[]} existing The options on the existing command,
       * should be {@link ApplicationCommand#options}
       * @param {ApplicationCommandOptionData[]|APIApplicationCommandOption[]} options The options to compare against
       * @param {boolean} [enforceOptionOrder=false] Whether to strictly check that options and choices are in the same
       * order in the array <info>The client may not always respect this ordering!</info>
       * @returns {boolean}
       */
      static optionsEqual(existing, options, enforceOptionOrder = false) {
        if (existing.length !== options.length) return false;
        if (enforceOptionOrder) {
          return existing.every((option, index) => this._optionEquals(option, options[index], enforceOptionOrder));
        }
        const newOptions = new Map(options.map((option) => [option.name, option]));
        for (const option of existing) {
          const foundOption = newOptions.get(option.name);
          if (!foundOption || !this._optionEquals(option, foundOption)) return false;
        }
        return true;
      }
      /**
       * Checks that an option for an {@link ApplicationCommand} is equal to the provided option
       * In most cases it is better to compare using {@link ApplicationCommand#equals}
       * @param {ApplicationCommandOptionData} existing The option on the existing command,
       * should be from {@link ApplicationCommand#options}
       * @param {ApplicationCommandOptionData|APIApplicationCommandOption} option The option to compare against
       * @param {boolean} [enforceOptionOrder=false] Whether to strictly check that options or choices are in the same
       * order in their array <info>The client may not always respect this ordering!</info>
       * @returns {boolean}
       * @private
       */
      static _optionEquals(existing, option, enforceOptionOrder = false) {
        var _a, _b, _c, _d, _e, _f;
        const optionType = typeof option.type === "string" ? option.type : ApplicationCommandOptionTypes[option.type];
        if (option.name !== existing.name || optionType !== existing.type || option.description !== existing.description || option.autocomplete !== existing.autocomplete || (option.required ?? (["SUB_COMMAND", "SUB_COMMAND_GROUP"].includes(optionType) ? void 0 : false)) !== existing.required || ((_a = option.choices) == null ? void 0 : _a.length) !== ((_b = existing.choices) == null ? void 0 : _b.length) || ((_c = option.options) == null ? void 0 : _c.length) !== ((_d = existing.options) == null ? void 0 : _d.length) || ((_e = option.channelTypes ?? option.channel_types) == null ? void 0 : _e.length) !== ((_f = existing.channelTypes) == null ? void 0 : _f.length) || (option.minValue ?? option.min_value) !== existing.minValue || (option.maxValue ?? option.max_value) !== existing.maxValue || (option.minLength ?? option.min_length) !== existing.minLength || (option.maxLength ?? option.max_length) !== existing.maxLength) {
          return false;
        }
        if (existing.choices) {
          if (enforceOptionOrder && !existing.choices.every(
            (choice, index) => choice.name === option.choices[index].name && choice.value === option.choices[index].value
          )) {
            return false;
          }
          if (!enforceOptionOrder) {
            const newChoices = new Map(option.choices.map((choice) => [choice.name, choice]));
            for (const choice of existing.choices) {
              const foundChoice = newChoices.get(choice.name);
              if (!foundChoice || foundChoice.value !== choice.value) return false;
            }
          }
        }
        if (existing.channelTypes) {
          const newTypes = (option.channelTypes ?? option.channel_types).map(
            (type) => typeof type === "number" ? ChannelTypes[type] : type
          );
          for (const type of existing.channelTypes) {
            if (!newTypes.includes(type)) return false;
          }
        }
        if (existing.options) {
          return this.optionsEqual(existing.options, option.options, enforceOptionOrder);
        }
        return true;
      }
      /**
       * An option for an application command or subcommand.
       * @typedef {Object} ApplicationCommandOption
       * @property {ApplicationCommandOptionType} type The type of the option
       * @property {string} name The name of the option
       * @property {Object<string, string>} [nameLocalizations] The localizations for the option name
       * @property {string} [nameLocalized] The localized name for this option
       * @property {string} description The description of the option
       * @property {Object<string, string>} [descriptionLocalizations] The localizations for the option description
       * @property {string} [descriptionLocalized] The localized description for this option
       * @property {boolean} [required] Whether the option is required
       * @property {boolean} [autocomplete] Whether the option is an autocomplete option
       * @property {ApplicationCommandOptionChoice[]} [choices] The choices of the option for the user to pick from
       * @property {ApplicationCommandOption[]} [options] Additional options if this option is a subcommand (group)
       * @property {ChannelType[]} [channelTypes] When the option type is channel,
       * the allowed types of channels that can be selected
       * @property {number} [minValue] The minimum value for an `INTEGER` or `NUMBER` option
       * @property {number} [maxValue] The maximum value for an `INTEGER` or `NUMBER` option
       * @property {number} [minLength] The minimum length for a `STRING` option
       * (maximum of `6000`)
       * @property {number} [maxLength] The maximum length for a `STRING` option
       * (maximum of `6000`)
       */
      /**
       * A choice for an application command option.
       * @typedef {Object} ApplicationCommandOptionChoice
       * @property {string} name The name of the choice
       * @property {?string} nameLocalized The localized name of the choice in the provided locale, if any
       * @property {?Object<string, string>} [nameLocalizations] The localized names for this choice
       * @property {string|number} value The value of the choice
       */
      /**
       * Transforms an {@link ApplicationCommandOptionData} object into something that can be used with the API.
       * @param {ApplicationCommandOptionData|ApplicationCommandOption} option The option to transform
       * @param {boolean} [received] Whether this option has been received from Discord
       * @returns {APIApplicationCommandOption}
       * @private
       */
      static transformOption(option, received) {
        var _a, _b, _c, _d;
        const stringType = typeof option.type === "string" ? option.type : ApplicationCommandOptionTypes[option.type];
        const channelTypesKey = received ? "channelTypes" : "channel_types";
        const minValueKey = received ? "minValue" : "min_value";
        const maxValueKey = received ? "maxValue" : "max_value";
        const minLengthKey = received ? "minLength" : "min_length";
        const maxLengthKey = received ? "maxLength" : "max_length";
        const nameLocalizationsKey = received ? "nameLocalizations" : "name_localizations";
        const nameLocalizedKey = received ? "nameLocalized" : "name_localized";
        const descriptionLocalizationsKey = received ? "descriptionLocalizations" : "description_localizations";
        const descriptionLocalizedKey = received ? "descriptionLocalized" : "description_localized";
        return {
          type: typeof option.type === "number" && !received ? option.type : ApplicationCommandOptionTypes[option.type],
          name: option.name,
          [nameLocalizationsKey]: option.nameLocalizations ?? option.name_localizations,
          [nameLocalizedKey]: option.nameLocalized ?? option.name_localized,
          description: option.description,
          [descriptionLocalizationsKey]: option.descriptionLocalizations ?? option.description_localizations,
          [descriptionLocalizedKey]: option.descriptionLocalized ?? option.description_localized,
          required: option.required ?? (stringType === "SUB_COMMAND" || stringType === "SUB_COMMAND_GROUP" ? void 0 : false),
          autocomplete: option.autocomplete,
          choices: (_a = option.choices) == null ? void 0 : _a.map((choice) => ({
            name: choice.name,
            [nameLocalizedKey]: choice.nameLocalized ?? choice.name_localized,
            [nameLocalizationsKey]: choice.nameLocalizations ?? choice.name_localizations,
            value: choice.value
          })),
          options: (_b = option.options) == null ? void 0 : _b.map((o) => this.transformOption(o, received)),
          [channelTypesKey]: received ? (_c = option.channel_types) == null ? void 0 : _c.map((type) => ChannelTypes[type]) : ((_d = option.channelTypes) == null ? void 0 : _d.map((type) => typeof type === "string" ? ChannelTypes[type] : type)) ?? // When transforming to API data, accept API data
          option.channel_types,
          [minValueKey]: option.minValue ?? option.min_value,
          [maxValueKey]: option.maxValue ?? option.max_value,
          [minLengthKey]: option.minLength ?? option.min_length,
          [maxLengthKey]: option.maxLength ?? option.max_length
        };
      }
    };
    module2.exports = ApplicationCommand;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/AutoModerationRule.js
var require_AutoModerationRule = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/AutoModerationRule.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var Base = require_Base();
    var {
      AutoModerationRuleKeywordPresetTypes,
      AutoModerationRuleTriggerTypes,
      AutoModerationRuleEventTypes,
      AutoModerationActionTypes
    } = require_Constants();
    var AutoModerationRule = class extends Base {
      constructor(client, data, guild) {
        super(client);
        this.id = data.id;
        this.guild = guild;
        this.creatorId = data.creator_id;
        this.triggerType = AutoModerationRuleTriggerTypes[data.trigger_type];
        this._patch(data);
      }
      _patch(data) {
        var _a;
        if ("name" in data) {
          this.name = data.name;
        }
        if ("event_type" in data) {
          this.eventType = AutoModerationRuleEventTypes[data.event_type];
        }
        if ("trigger_metadata" in data) {
          this.triggerMetadata = {
            keywordFilter: data.trigger_metadata.keyword_filter ?? [],
            regexPatterns: data.trigger_metadata.regex_patterns ?? [],
            presets: ((_a = data.trigger_metadata.presets) == null ? void 0 : _a.map((preset) => AutoModerationRuleKeywordPresetTypes[preset])) ?? [],
            allowList: data.trigger_metadata.allow_list ?? [],
            mentionTotalLimit: data.trigger_metadata.mention_total_limit ?? null,
            mentionRaidProtectionEnabled: data.trigger_metadata.mention_raid_protection_enabled ?? false
          };
        }
        if ("actions" in data) {
          this.actions = data.actions.map((action) => ({
            type: AutoModerationActionTypes[action.type],
            metadata: {
              durationSeconds: action.metadata.duration_seconds ?? null,
              channelId: action.metadata.channel_id ?? null,
              customMessage: action.metadata.custom_message ?? null
            }
          }));
        }
        if ("enabled" in data) {
          this.enabled = data.enabled;
        }
        if ("exempt_roles" in data) {
          this.exemptRoles = new Collection2(
            data.exempt_roles.map((exemptRole) => [exemptRole, this.guild.roles.cache.get(exemptRole)])
          );
        }
        if ("exempt_channels" in data) {
          this.exemptChannels = new Collection2(
            data.exempt_channels.map((exemptChannel) => [exemptChannel, this.guild.channels.cache.get(exemptChannel)])
          );
        }
      }
      /**
       * Edits this auto moderation rule.
       * @param {AutoModerationRuleEditOptions} options Options for editing this auto moderation rule
       * @returns {Promise<AutoModerationRule>}
       */
      edit(options) {
        return this.guild.autoModerationRules.edit(this.id, options);
      }
      /**
       * Deletes this auto moderation rule.
       * @param {string} [reason] The reason for deleting this auto moderation rule
       * @returns {Promise<void>}
       */
      delete(reason) {
        return this.guild.autoModerationRules.delete(this.id, reason);
      }
      /**
       * Sets the name for this auto moderation rule.
       * @param {string} name The name of this auto moderation rule
       * @param {string} [reason] The reason for changing the name of this auto moderation rule
       * @returns {Promise<AutoModerationRule>}
       */
      setName(name, reason) {
        return this.edit({ name, reason });
      }
      /**
       * Sets the event type for this auto moderation rule.
       * @param {AutoModerationRuleEventType} eventType The event type of this auto moderation rule
       * @param {string} [reason] The reason for changing the event type of this auto moderation rule
       * @returns {Promise<AutoModerationRule>}
       */
      setEventType(eventType, reason) {
        return this.edit({ eventType, reason });
      }
      /**
       * Sets the keyword filter for this auto moderation rule.
       * @param {string[]} keywordFilter The keyword filter of this auto moderation rule
       * @param {string} [reason] The reason for changing the keyword filter of this auto moderation rule
       * @returns {Promise<AutoModerationRule>}
       */
      setKeywordFilter(keywordFilter, reason) {
        return this.edit({ triggerMetadata: { ...this.triggerMetadata, keywordFilter }, reason });
      }
      /**
       * Sets the regular expression patterns for this auto moderation rule.
       * @param {string[]} regexPatterns The regular expression patterns of this auto moderation rule
       * <info>Only Rust-flavored regular expressions are supported.</info>
       * @param {string} [reason] The reason for changing the regular expression patterns of this auto moderation rule
       * @returns {Promise<AutoModerationRule>}
       */
      setRegexPatterns(regexPatterns, reason) {
        return this.edit({ triggerMetadata: { ...this.triggerMetadata, regexPatterns }, reason });
      }
      /**
       * Sets the presets for this auto moderation rule.
       * @param {AutoModerationRuleKeywordPresetType[]} presets The presets of this auto moderation rule
       * @param {string} [reason] The reason for changing the presets of this auto moderation rule
       * @returns {Promise<AutoModerationRule>}
       */
      setPresets(presets, reason) {
        return this.edit({ triggerMetadata: { ...this.triggerMetadata, presets }, reason });
      }
      /**
       * Sets the allow list for this auto moderation rule.
       * @param {string[]} allowList The allow list of this auto moderation rule
       * @param {string} [reason] The reason for changing the allow list of this auto moderation rule
       * @returns {Promise<AutoModerationRule>}
       */
      setAllowList(allowList, reason) {
        return this.edit({ triggerMetadata: { ...this.triggerMetadata, allowList }, reason });
      }
      /**
       * Sets the mention total limit for this auto moderation rule.
       * @param {number} mentionTotalLimit The mention total limit of this auto moderation rule
       * @param {string} [reason] The reason for changing the mention total limit of this auto moderation rule
       * @returns {Promise<AutoModerationRule>}
       */
      setMentionTotalLimit(mentionTotalLimit, reason) {
        return this.edit({ triggerMetadata: { ...this.triggerMetadata, mentionTotalLimit }, reason });
      }
      /**
       * Sets whether to enable mention raid protection for this auto moderation rule.
       * @param {boolean} mentionRaidProtectionEnabled
       * Whether to enable mention raid protection for this auto moderation rule
       * @param {string} [reason] The reason for changing the mention raid protection of this auto moderation rule
       * @returns {Promise<AutoModerationRule>}
       */
      setMentionRaidProtectionEnabled(mentionRaidProtectionEnabled, reason) {
        return this.edit({ triggerMetadata: { ...this.triggerMetadata, mentionRaidProtectionEnabled }, reason });
      }
      /**
       * Sets the actions for this auto moderation rule.
       * @param {AutoModerationActionOptions[]} actions The actions of this auto moderation rule
       * @param {string} [reason] The reason for changing the actions of this auto moderation rule
       * @returns {Promise<AutoModerationRule>}
       */
      setActions(actions, reason) {
        return this.edit({ actions, reason });
      }
      /**
       * Sets whether this auto moderation rule should be enabled.
       * @param {boolean} [enabled=true] Whether to enable this auto moderation rule
       * @param {string} [reason] The reason for enabling or disabling this auto moderation rule
       * @returns {Promise<AutoModerationRule>}
       */
      setEnabled(enabled = true, reason) {
        return this.edit({ enabled, reason });
      }
      /**
       * Sets the exempt roles for this auto moderation rule.
       * @param {Collection<Snowflake, Role>|RoleResolvable[]} [exemptRoles] The exempt roles of this auto moderation rule
       * @param {string} [reason] The reason for changing the exempt roles of this auto moderation rule
       * @returns {Promise<AutoModerationRule>}
       */
      setExemptRoles(exemptRoles, reason) {
        return this.edit({ exemptRoles, reason });
      }
      /**
       * Sets the exempt channels for this auto moderation rule.
       * @param {Collection<Snowflake, GuildChannel|ThreadChannel>|GuildChannelResolvable[]} [exemptChannels]
       * The exempt channels of this auto moderation rule
       * @param {string} [reason] The reason for changing the exempt channels of this auto moderation rule
       * @returns {Promise<AutoModerationRule>}
       */
      setExemptChannels(exemptChannels, reason) {
        return this.edit({ exemptChannels, reason });
      }
    };
    module2.exports = AutoModerationRule;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/Integration.js
var require_Integration = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/Integration.js"(exports2, module2) {
    "use strict";
    var Base = require_Base();
    var IntegrationApplication = require_IntegrationApplication();
    var Integration = class extends Base {
      constructor(client, data, guild) {
        super(client);
        this.guild = guild;
        this.id = data.id;
        this.name = data.name;
        this.type = data.type;
        this.enabled = data.enabled;
        this.syncing = data.syncing;
        this.role = this.guild.roles.cache.get(data.role_id);
        if ("enable_emoticons" in data) {
          this.enableEmoticons = data.enable_emoticons;
        } else {
          this.enableEmoticons ?? (this.enableEmoticons = null);
        }
        if (data.user) {
          this.user = this.client.users._add(data.user);
        } else {
          this.user = null;
        }
        this.account = data.account;
        this.syncedAt = data.synced_at;
        if ("subscriber_count" in data) {
          this.subscriberCount = data.subscriber_count;
        } else {
          this.subscriberCount ?? (this.subscriberCount = null);
        }
        if ("revoked" in data) {
          this.revoked = data.revoked;
        } else {
          this.revoked ?? (this.revoked = null);
        }
        this._patch(data);
      }
      /**
       * All roles that are managed by this integration
       * @type {Collection<Snowflake, Role>}
       * @readonly
       */
      get roles() {
        const roles = this.guild.roles.cache;
        return roles.filter((role) => {
          var _a;
          return ((_a = role.tags) == null ? void 0 : _a.integrationId) === this.id;
        });
      }
      _patch(data) {
        if ("expire_behavior" in data) {
          this.expireBehavior = data.expire_behavior;
        }
        if ("expire_grace_period" in data) {
          this.expireGracePeriod = data.expire_grace_period;
        }
        if ("application" in data) {
          if (this.application) {
            this.application._patch(data.application);
          } else {
            this.application = new IntegrationApplication(this.client, data.application);
          }
        } else {
          this.application ?? (this.application = null);
        }
      }
      /**
       * Deletes this integration.
       * @returns {Promise<Integration>}
       * @param {string} [reason] Reason for deleting this integration
       */
      async delete(reason) {
        await this.client.api.guilds(this.guild.id).integrations(this.id).delete({ reason });
        return this;
      }
      toJSON() {
        return super.toJSON({
          role: "roleId",
          guild: "guildId",
          user: "userId"
        });
      }
    };
    module2.exports = Integration;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/StageInstance.js
var require_StageInstance = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/StageInstance.js"(exports2) {
    "use strict";
    var process2 = require_node_process();
    var Base = require_Base();
    var { PrivacyLevels } = require_Constants();
    var SnowflakeUtil = require_SnowflakeUtil();
    var deletedStageInstances = /* @__PURE__ */ new WeakSet();
    var deprecationEmittedForDeleted = false;
    var StageInstance = class extends Base {
      constructor(client, data) {
        super(client);
        this.id = data.id;
        this._patch(data);
      }
      _patch(data) {
        if ("guild_id" in data) {
          this.guildId = data.guild_id;
        }
        if ("channel_id" in data) {
          this.channelId = data.channel_id;
        }
        if ("topic" in data) {
          this.topic = data.topic;
        }
        if ("privacy_level" in data) {
          this.privacyLevel = PrivacyLevels[data.privacy_level];
        }
        if ("discoverable_disabled" in data) {
          this.discoverableDisabled = data.discoverable_disabled;
        } else {
          this.discoverableDisabled ?? (this.discoverableDisabled = null);
        }
        if ("guild_scheduled_event_id" in data) {
          this.guildScheduledEventId = data.guild_scheduled_event_id;
        } else {
          this.guildScheduledEventId ?? (this.guildScheduledEventId = null);
        }
      }
      /**
       * The stage channel associated with this stage instance
       * @type {?StageChannel}
       * @readonly
       */
      get channel() {
        return this.client.channels.resolve(this.channelId);
      }
      /**
       * The associated guild scheduled event of this stage instance
       * @type {?GuildScheduledEvent}
       * @readonly
       */
      get guildScheduledEvent() {
        var _a;
        return ((_a = this.guild) == null ? void 0 : _a.scheduledEvents.resolve(this.guildScheduledEventId)) ?? null;
      }
      /**
       * Whether or not the stage instance has been deleted
       * @type {boolean}
       * @deprecated This will be removed in the next major version, see https://github.com/discordjs/discord.js/issues/7091
       */
      get deleted() {
        if (!deprecationEmittedForDeleted) {
          deprecationEmittedForDeleted = true;
          process2.emitWarning(
            "StageInstance#deleted is deprecated, see https://github.com/discordjs/discord.js/issues/7091.",
            "DeprecationWarning"
          );
        }
        return deletedStageInstances.has(this);
      }
      set deleted(value) {
        if (!deprecationEmittedForDeleted) {
          deprecationEmittedForDeleted = true;
          process2.emitWarning(
            "StageInstance#deleted is deprecated, see https://github.com/discordjs/discord.js/issues/7091.",
            "DeprecationWarning"
          );
        }
        if (value) deletedStageInstances.add(this);
        else deletedStageInstances.delete(this);
      }
      /**
       * The guild this stage instance belongs to
       * @type {?Guild}
       * @readonly
       */
      get guild() {
        return this.client.guilds.resolve(this.guildId);
      }
      /**
       * Edits this stage instance.
       * @param {StageInstanceEditOptions} options The options to edit the stage instance
       * @returns {Promise<StageInstance>}
       * @example
       * // Edit a stage instance
       * stageInstance.edit({ topic: 'new topic' })
       *  .then(stageInstance => console.log(stageInstance))
       *  .catch(console.error)
       */
      edit(options) {
        return this.guild.stageInstances.edit(this.channelId, options);
      }
      /**
       * Deletes this stage instance.
       * @returns {Promise<StageInstance>}
       * @example
       * // Delete a stage instance
       * stageInstance.delete()
       *  .then(stageInstance => console.log(stageInstance))
       *  .catch(console.error);
       */
      async delete() {
        await this.guild.stageInstances.delete(this.channelId);
        const clone = this._clone();
        deletedStageInstances.add(clone);
        return clone;
      }
      /**
       * Sets the topic of this stage instance.
       * @param {string} topic The topic for the stage instance
       * @returns {Promise<StageInstance>}
       * @example
       * // Set topic of a stage instance
       * stageInstance.setTopic('new topic')
       *  .then(stageInstance => console.log(`Set the topic to: ${stageInstance.topic}`))
       *  .catch(console.error);
       */
      setTopic(topic) {
        return this.guild.stageInstances.edit(this.channelId, { topic });
      }
      /**
       * The timestamp this stage instances was created at
       * @type {number}
       * @readonly
       */
      get createdTimestamp() {
        return SnowflakeUtil.timestampFrom(this.id);
      }
      /**
       * The time this stage instance was created at
       * @type {Date}
       * @readonly
       */
      get createdAt() {
        return new Date(this.createdTimestamp);
      }
    };
    exports2.StageInstance = StageInstance;
    exports2.deletedStageInstances = deletedStageInstances;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/GuildAuditLogs.js
var require_GuildAuditLogs = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/GuildAuditLogs.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var ApplicationCommand = require_ApplicationCommand();
    var AutoModerationRule = require_AutoModerationRule();
    var { GuildScheduledEvent } = require_GuildScheduledEvent();
    var Integration = require_Integration();
    var Invite2 = require_Invite();
    var { StageInstance } = require_StageInstance();
    var { Sticker: Sticker2 } = require_Sticker();
    var Webhook2 = require_Webhook();
    var { OverwriteTypes, PartialTypes, AutoModerationRuleTriggerTypes } = require_Constants();
    var SnowflakeUtil = require_SnowflakeUtil();
    var Util = require_Util();
    var Targets = {
      ALL: "ALL",
      GUILD: "GUILD",
      GUILD_SCHEDULED_EVENT: "GUILD_SCHEDULED_EVENT",
      CHANNEL: "CHANNEL",
      USER: "USER",
      ROLE: "ROLE",
      INVITE: "INVITE",
      WEBHOOK: "WEBHOOK",
      EMOJI: "EMOJI",
      MESSAGE: "MESSAGE",
      INTEGRATION: "INTEGRATION",
      STAGE_INSTANCE: "STAGE_INSTANCE",
      STICKER: "STICKER",
      THREAD: "THREAD",
      APPLICATION_COMMAND: "APPLICATION_COMMAND",
      AUTO_MODERATION: "AUTO_MODERATION",
      UNKNOWN: "UNKNOWN"
    };
    var Actions = {
      ALL: null,
      GUILD_UPDATE: 1,
      CHANNEL_CREATE: 10,
      CHANNEL_UPDATE: 11,
      CHANNEL_DELETE: 12,
      CHANNEL_OVERWRITE_CREATE: 13,
      CHANNEL_OVERWRITE_UPDATE: 14,
      CHANNEL_OVERWRITE_DELETE: 15,
      MEMBER_KICK: 20,
      MEMBER_PRUNE: 21,
      MEMBER_BAN_ADD: 22,
      MEMBER_BAN_REMOVE: 23,
      MEMBER_UPDATE: 24,
      MEMBER_ROLE_UPDATE: 25,
      MEMBER_MOVE: 26,
      MEMBER_DISCONNECT: 27,
      BOT_ADD: 28,
      ROLE_CREATE: 30,
      ROLE_UPDATE: 31,
      ROLE_DELETE: 32,
      INVITE_CREATE: 40,
      INVITE_UPDATE: 41,
      INVITE_DELETE: 42,
      WEBHOOK_CREATE: 50,
      WEBHOOK_UPDATE: 51,
      WEBHOOK_DELETE: 52,
      EMOJI_CREATE: 60,
      EMOJI_UPDATE: 61,
      EMOJI_DELETE: 62,
      MESSAGE_DELETE: 72,
      MESSAGE_BULK_DELETE: 73,
      MESSAGE_PIN: 74,
      MESSAGE_UNPIN: 75,
      INTEGRATION_CREATE: 80,
      INTEGRATION_UPDATE: 81,
      INTEGRATION_DELETE: 82,
      STAGE_INSTANCE_CREATE: 83,
      STAGE_INSTANCE_UPDATE: 84,
      STAGE_INSTANCE_DELETE: 85,
      STICKER_CREATE: 90,
      STICKER_UPDATE: 91,
      STICKER_DELETE: 92,
      GUILD_SCHEDULED_EVENT_CREATE: 100,
      GUILD_SCHEDULED_EVENT_UPDATE: 101,
      GUILD_SCHEDULED_EVENT_DELETE: 102,
      THREAD_CREATE: 110,
      THREAD_UPDATE: 111,
      THREAD_DELETE: 112,
      APPLICATION_COMMAND_PERMISSION_UPDATE: 121,
      AUTO_MODERATION_RULE_CREATE: 140,
      AUTO_MODERATION_RULE_UPDATE: 141,
      AUTO_MODERATION_RULE_DELETE: 142,
      AUTO_MODERATION_BLOCK_MESSAGE: 143,
      AUTO_MODERATION_FLAG_TO_CHANNEL: 144,
      AUTO_MODERATION_USER_COMMUNICATION_DISABLED: 145
    };
    var GuildAuditLogs = class _GuildAuditLogs {
      constructor(guild, data) {
        if (data.users) for (const user of data.users) guild.client.users._add(user);
        if (data.threads) for (const thread of data.threads) guild.client.channels._add(thread, guild);
        this.webhooks = new Collection2();
        if (data.webhooks) {
          for (const hook of data.webhooks) {
            this.webhooks.set(hook.id, new Webhook2(guild.client, hook));
          }
        }
        this.integrations = new Collection2();
        if (data.integrations) {
          for (const integration of data.integrations) {
            this.integrations.set(integration.id, new Integration(guild.client, integration, guild));
          }
        }
        this.applicationCommands = new Collection2();
        if (data.application_commands) {
          for (const command of data.application_commands) {
            this.applicationCommands.set(command.id, new ApplicationCommand(guild.client, command, guild));
          }
        }
        this.autoModerationRules = data.auto_moderation_rules.reduce(
          (autoModerationRules, autoModerationRule) => autoModerationRules.set(autoModerationRule.id, guild.autoModerationRules._add(autoModerationRule)),
          new Collection2()
        );
        this.entries = new Collection2();
        for (const item of data.audit_log_entries) {
          const entry = new GuildAuditLogsEntry(guild, item, this);
          this.entries.set(entry.id, entry);
        }
      }
      /**
       * Handles possible promises for entry targets.
       * @returns {Promise<GuildAuditLogs>}
       */
      static async build(...args) {
        const logs = new _GuildAuditLogs(...args);
        await Promise.all(logs.entries.map((e) => e.target));
        return logs;
      }
      /**
       * The target of an entry. It can be one of:
       * * A guild
       * * A channel
       * * A user
       * * A role
       * * An invite
       * * A webhook
       * * An emoji
       * * A message
       * * An integration
       * * A stage instance
       * * A sticker
       * * A guild scheduled event
       * * A thread
       * * An application command
       * * An auto moderation rule
       * * An object with an id key if target was deleted
       * * An object where the keys represent either the new value or the old value
       * @typedef {?(Object|Guild|Channel|User|Role|Invite|Webhook|GuildEmoji|Message|Integration|StageInstance|Sticker|
       * GuildScheduledEvent|ApplicationCommand|AutoModerationRule)} AuditLogEntryTarget
       */
      /**
       * Finds the target type from the entry action.
       * @param {AuditLogAction} target The action target
       * @returns {AuditLogTargetType}
       */
      static targetType(target) {
        if (target < 10) return Targets.GUILD;
        if (target < 20) return Targets.CHANNEL;
        if (target < 30) return Targets.USER;
        if (target < 40) return Targets.ROLE;
        if (target < 50) return Targets.INVITE;
        if (target < 60) return Targets.WEBHOOK;
        if (target < 70) return Targets.EMOJI;
        if (target < 80) return Targets.MESSAGE;
        if (target < 83) return Targets.INTEGRATION;
        if (target < 86) return Targets.STAGE_INSTANCE;
        if (target < 100) return Targets.STICKER;
        if (target < 110) return Targets.GUILD_SCHEDULED_EVENT;
        if (target < 120) return Targets.THREAD;
        if (target < 130) return Targets.APPLICATION_COMMAND;
        if (target >= 140 && target < 150) return Targets.AUTO_MODERATION;
        return Targets.UNKNOWN;
      }
      /**
       * The action type of an entry, e.g. `CREATE`. Here are the available types:
       * * CREATE
       * * DELETE
       * * UPDATE
       * * ALL
       * @typedef {string} AuditLogActionType
       */
      /**
       * Finds the action type from the entry action.
       * @param {AuditLogAction} action The action target
       * @returns {AuditLogActionType}
       */
      static actionType(action) {
        if ([
          Actions.CHANNEL_CREATE,
          Actions.CHANNEL_OVERWRITE_CREATE,
          Actions.MEMBER_BAN_REMOVE,
          Actions.BOT_ADD,
          Actions.ROLE_CREATE,
          Actions.INVITE_CREATE,
          Actions.WEBHOOK_CREATE,
          Actions.EMOJI_CREATE,
          Actions.MESSAGE_PIN,
          Actions.INTEGRATION_CREATE,
          Actions.STAGE_INSTANCE_CREATE,
          Actions.STICKER_CREATE,
          Actions.GUILD_SCHEDULED_EVENT_CREATE,
          Actions.THREAD_CREATE,
          Actions.AUTO_MODERATION_RULE_CREATE,
          Actions.AUTO_MODERATION_BLOCK_MESSAGE
        ].includes(action)) {
          return "CREATE";
        }
        if ([
          Actions.CHANNEL_DELETE,
          Actions.CHANNEL_OVERWRITE_DELETE,
          Actions.MEMBER_KICK,
          Actions.MEMBER_PRUNE,
          Actions.MEMBER_BAN_ADD,
          Actions.MEMBER_DISCONNECT,
          Actions.ROLE_DELETE,
          Actions.INVITE_DELETE,
          Actions.WEBHOOK_DELETE,
          Actions.EMOJI_DELETE,
          Actions.MESSAGE_DELETE,
          Actions.MESSAGE_BULK_DELETE,
          Actions.MESSAGE_UNPIN,
          Actions.INTEGRATION_DELETE,
          Actions.STAGE_INSTANCE_DELETE,
          Actions.STICKER_DELETE,
          Actions.GUILD_SCHEDULED_EVENT_DELETE,
          Actions.THREAD_DELETE,
          Actions.AUTO_MODERATION_RULE_DELETE
        ].includes(action)) {
          return "DELETE";
        }
        if ([
          Actions.GUILD_UPDATE,
          Actions.CHANNEL_UPDATE,
          Actions.CHANNEL_OVERWRITE_UPDATE,
          Actions.MEMBER_UPDATE,
          Actions.MEMBER_ROLE_UPDATE,
          Actions.MEMBER_MOVE,
          Actions.ROLE_UPDATE,
          Actions.INVITE_UPDATE,
          Actions.WEBHOOK_UPDATE,
          Actions.EMOJI_UPDATE,
          Actions.INTEGRATION_UPDATE,
          Actions.STAGE_INSTANCE_UPDATE,
          Actions.STICKER_UPDATE,
          Actions.GUILD_SCHEDULED_EVENT_UPDATE,
          Actions.THREAD_UPDATE,
          Actions.APPLICATION_COMMAND_PERMISSION_UPDATE,
          Actions.AUTO_MODERATION_RULE_UPDATE
        ].includes(action)) {
          return "UPDATE";
        }
        return "ALL";
      }
      toJSON() {
        return Util.flatten(this);
      }
    };
    var GuildAuditLogsEntry = class {
      constructor(guild, data, logs) {
        var _a, _b, _c, _d, _e, _f, _g;
        const targetType = GuildAuditLogs.targetType(data.action_type);
        this.targetType = targetType;
        this.actionType = GuildAuditLogs.actionType(data.action_type);
        this.action = Object.keys(Actions).find((k) => Actions[k] === data.action_type);
        this.reason = data.reason ?? null;
        this.executorId = data.user_id;
        this.executor = data.user_id ? guild.client.options.partials.includes(PartialTypes.USER) ? guild.client.users._add({ id: data.user_id }) : guild.client.users.cache.get(data.user_id) ?? null : null;
        this.changes = ((_a = data.changes) == null ? void 0 : _a.map((change) => ({
          key: change.key,
          ..."old_value" in change ? { old: change.old_value } : {},
          ..."new_value" in change ? { new: change.new_value } : {}
        }))) ?? [];
        this.id = data.id;
        this.extra = null;
        switch (data.action_type) {
          case Actions.MEMBER_PRUNE:
            this.extra = {
              removed: Number(data.options.members_removed),
              days: Number(data.options.delete_member_days)
            };
            break;
          case Actions.MEMBER_MOVE:
          case Actions.MESSAGE_DELETE:
          case Actions.MESSAGE_BULK_DELETE:
            this.extra = {
              channel: guild.channels.cache.get(data.options.channel_id) ?? { id: data.options.channel_id },
              count: Number(data.options.count)
            };
            break;
          case Actions.MESSAGE_PIN:
          case Actions.MESSAGE_UNPIN:
            this.extra = {
              channel: guild.client.channels.cache.get(data.options.channel_id) ?? { id: data.options.channel_id },
              messageId: data.options.message_id
            };
            break;
          case Actions.MEMBER_DISCONNECT:
            this.extra = {
              count: Number(data.options.count)
            };
            break;
          case Actions.CHANNEL_OVERWRITE_CREATE:
          case Actions.CHANNEL_OVERWRITE_UPDATE:
          case Actions.CHANNEL_OVERWRITE_DELETE:
            switch (Number(data.options.type)) {
              case OverwriteTypes.role:
                this.extra = guild.roles.cache.get(data.options.id) ?? {
                  id: data.options.id,
                  name: data.options.role_name,
                  type: OverwriteTypes[OverwriteTypes.role]
                };
                break;
              case OverwriteTypes.member:
                this.extra = guild.members.cache.get(data.options.id) ?? {
                  id: data.options.id,
                  type: OverwriteTypes[OverwriteTypes.member]
                };
                break;
              default:
                break;
            }
            break;
          case Actions.STAGE_INSTANCE_CREATE:
          case Actions.STAGE_INSTANCE_DELETE:
          case Actions.STAGE_INSTANCE_UPDATE:
            this.extra = {
              channel: guild.client.channels.cache.get((_b = data.options) == null ? void 0 : _b.channel_id) ?? { id: (_c = data.options) == null ? void 0 : _c.channel_id }
            };
            break;
          case Actions.APPLICATION_COMMAND_PERMISSION_UPDATE:
            this.extra = {
              applicationId: data.options.application_id
            };
            break;
          case Actions.AUTO_MODERATION_BLOCK_MESSAGE:
          case Actions.AUTO_MODERATION_FLAG_TO_CHANNEL:
          case Actions.AUTO_MODERATION_USER_COMMUNICATION_DISABLED:
            this.extra = {
              autoModerationRuleName: data.options.auto_moderation_rule_name,
              autoModerationRuleTriggerType: AutoModerationRuleTriggerTypes[data.options.auto_moderation_rule_trigger_type],
              channel: guild.client.channels.cache.get((_d = data.options) == null ? void 0 : _d.channel_id) ?? { id: (_e = data.options) == null ? void 0 : _e.channel_id }
            };
            break;
          default:
            break;
        }
        this.targetId = data.target_id;
        this.target = null;
        if (targetType === Targets.UNKNOWN) {
          this.target = this.changes.reduce((o, c) => {
            o[c.key] = c.new ?? c.old;
            return o;
          }, {});
          this.target.id = data.target_id;
        } else if (targetType === Targets.USER && data.target_id) {
          this.target = guild.client.options.partials.includes(PartialTypes.USER) ? guild.client.users._add({ id: data.target_id }) : guild.client.users.cache.get(data.target_id) ?? null;
        } else if (targetType === Targets.GUILD) {
          this.target = guild.client.guilds.cache.get(data.target_id);
        } else if (targetType === Targets.WEBHOOK) {
          this.target = (logs == null ? void 0 : logs.webhooks.get(data.target_id)) ?? new Webhook2(
            guild.client,
            this.changes.reduce(
              (o, c) => {
                o[c.key] = c.new ?? c.old;
                return o;
              },
              {
                id: data.target_id,
                guild_id: guild.id
              }
            )
          );
        } else if (targetType === Targets.INVITE) {
          let change = this.changes.find((c) => c.key === "code");
          change = change.new ?? change.old;
          this.target = guild.invites.cache.get(change) ?? new Invite2(
            guild.client,
            this.changes.reduce(
              (o, c) => {
                o[c.key] = c.new ?? c.old;
                return o;
              },
              { guild }
            )
          );
        } else if (targetType === Targets.MESSAGE) {
          this.target = data.action_type === Actions.MESSAGE_BULK_DELETE ? guild.channels.cache.get(data.target_id) ?? { id: data.target_id } : guild.client.users.cache.get(data.target_id) ?? null;
        } else if (targetType === Targets.INTEGRATION) {
          this.target = (logs == null ? void 0 : logs.integrations.get(data.target_id)) ?? new Integration(
            guild.client,
            this.changes.reduce(
              (o, c) => {
                o[c.key] = c.new ?? c.old;
                return o;
              },
              { id: data.target_id }
            ),
            guild
          );
        } else if (targetType === Targets.CHANNEL || targetType === Targets.THREAD) {
          this.target = guild.channels.cache.get(data.target_id) ?? this.changes.reduce(
            (o, c) => {
              o[c.key] = c.new ?? c.old;
              return o;
            },
            { id: data.target_id }
          );
        } else if (targetType === Targets.STAGE_INSTANCE) {
          this.target = guild.stageInstances.cache.get(data.target_id) ?? new StageInstance(
            guild.client,
            this.changes.reduce(
              (o, c) => {
                o[c.key] = c.new ?? c.old;
                return o;
              },
              {
                id: data.target_id,
                channel_id: (_f = data.options) == null ? void 0 : _f.channel_id,
                guild_id: guild.id
              }
            )
          );
        } else if (targetType === Targets.STICKER) {
          this.target = guild.stickers.cache.get(data.target_id) ?? new Sticker2(
            guild.client,
            this.changes.reduce(
              (o, c) => {
                o[c.key] = c.new ?? c.old;
                return o;
              },
              { id: data.target_id }
            )
          );
        } else if (targetType === Targets.GUILD_SCHEDULED_EVENT) {
          this.target = guild.scheduledEvents.cache.get(data.target_id) ?? new GuildScheduledEvent(
            guild.client,
            this.changes.reduce(
              (o, c) => {
                o[c.key] = c.new ?? c.old;
                return o;
              },
              { id: data.target_id, guild_id: guild.id }
            )
          );
        } else if (targetType === Targets.APPLICATION_COMMAND) {
          this.target = (logs == null ? void 0 : logs.applicationCommands.get(data.target_id)) ?? { id: data.target_id };
        } else if (targetType === Targets.AUTO_MODERATION) {
          this.target = guild.autoModerationRules.cache.get(data.target_id) ?? new AutoModerationRule(
            guild.client,
            this.changes.reduce(
              (o, c) => {
                o[c.key] = c.new ?? c.old;
                return o;
              },
              { id: data.target_id, guild_id: guild.id }
            ),
            guild
          );
        } else if (data.target_id) {
          this.target = ((_g = guild[`${targetType.toLowerCase()}s`]) == null ? void 0 : _g.cache.get(data.target_id)) ?? { id: data.target_id };
        }
      }
      /**
       * The timestamp this entry was created at
       * @type {number}
       * @readonly
       */
      get createdTimestamp() {
        return SnowflakeUtil.timestampFrom(this.id);
      }
      /**
       * The time this entry was created at
       * @type {Date}
       * @readonly
       */
      get createdAt() {
        return new Date(this.createdTimestamp);
      }
      toJSON() {
        return Util.flatten(this, { createdTimestamp: true });
      }
    };
    GuildAuditLogs.Actions = Actions;
    GuildAuditLogs.Targets = Targets;
    GuildAuditLogs.Entry = GuildAuditLogsEntry;
    module2.exports = GuildAuditLogs;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/actions/GuildAuditLogEntryCreate.js
var require_GuildAuditLogEntryCreate = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/actions/GuildAuditLogEntryCreate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var GuildAuditLogsEntry = require_GuildAuditLogs().Entry;
    var { Events: Events2 } = require_Constants();
    var GuildAuditLogEntryCreateAction = class extends Action {
      handle(data) {
        const client = this.client;
        const guild = client.guilds.cache.get(data.guild_id);
        let auditLogEntry;
        if (guild) {
          auditLogEntry = new GuildAuditLogsEntry(guild, data);
          client.emit(Events2.GUILD_AUDIT_LOG_ENTRY_CREATE, auditLogEntry, guild);
        }
        return { auditLogEntry };
      }
    };
    module2.exports = GuildAuditLogEntryCreateAction;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/actions/GuildBanAdd.js
var require_GuildBanAdd = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/actions/GuildBanAdd.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var { Events: Events2 } = require_Constants();
    var GuildBanAdd = class extends Action {
      handle(data) {
        const client = this.client;
        const guild = client.guilds.cache.get(data.guild_id);
        if (guild) client.emit(Events2.GUILD_BAN_ADD, guild.bans._add(data));
      }
    };
    module2.exports = GuildBanAdd;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/GuildBan.js
var require_GuildBan = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/GuildBan.js"(exports2, module2) {
    "use strict";
    var Base = require_Base();
    var GuildBan = class extends Base {
      constructor(client, data, guild) {
        super(client);
        this.guild = guild;
        this._patch(data);
      }
      _patch(data) {
        if ("user" in data) {
          this.user = this.client.users._add(data.user, true);
        }
        if ("reason" in data) {
          this.reason = data.reason;
        }
      }
      /**
       * Whether this GuildBan is partial. If the reason is not provided the value is null
       * @type {boolean}
       * @readonly
       */
      get partial() {
        return !("reason" in this);
      }
      /**
       * Fetches this GuildBan.
       * @param {boolean} [force=true] Whether to skip the cache check and request the API
       * @returns {Promise<GuildBan>}
       */
      fetch(force = true) {
        return this.guild.bans.fetch({ user: this.user, cache: true, force });
      }
    };
    module2.exports = GuildBan;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/actions/GuildBanRemove.js
var require_GuildBanRemove = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/actions/GuildBanRemove.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var GuildBan = require_GuildBan();
    var { Events: Events2 } = require_Constants();
    var GuildBanRemove = class extends Action {
      handle(data) {
        const client = this.client;
        const guild = client.guilds.cache.get(data.guild_id);
        if (guild) {
          const ban = guild.bans.cache.get(data.user.id) ?? new GuildBan(client, data, guild);
          guild.bans.cache.delete(ban.user.id);
          client.emit(Events2.GUILD_BAN_REMOVE, ban);
        }
      }
    };
    module2.exports = GuildBanRemove;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/actions/GuildChannelsPositionUpdate.js
var require_GuildChannelsPositionUpdate = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/actions/GuildChannelsPositionUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var GuildChannelsPositionUpdate = class extends Action {
      handle(data) {
        const client = this.client;
        const guild = client.guilds.cache.get(data.guild_id);
        if (guild) {
          for (const partialChannel of data.channels) {
            const channel = guild.channels.cache.get(partialChannel.id);
            if (channel) channel.rawPosition = partialChannel.position;
          }
        }
        return { guild };
      }
    };
    module2.exports = GuildChannelsPositionUpdate;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/GuildPreviewEmoji.js
var require_GuildPreviewEmoji = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/GuildPreviewEmoji.js"(exports2, module2) {
    "use strict";
    var BaseGuildEmoji = require_BaseGuildEmoji();
    var GuildPreviewEmoji = class extends BaseGuildEmoji {
      /**
       * The public guild this emoji is part of
       * @type {GuildPreview}
       * @name GuildPreviewEmoji#guild
       */
      constructor(client, data, guild) {
        super(client, data, guild);
        this.roles = data.roles;
      }
    };
    module2.exports = GuildPreviewEmoji;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/GuildPreview.js
var require_GuildPreview = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/GuildPreview.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var Base = require_Base();
    var GuildPreviewEmoji = require_GuildPreviewEmoji();
    var { Sticker: Sticker2 } = require_Sticker();
    var SnowflakeUtil = require_SnowflakeUtil();
    var GuildPreview2 = class extends Base {
      constructor(client, data) {
        super(client);
        if (!data) return;
        this._patch(data);
      }
      _patch(data) {
        this.id = data.id;
        if ("name" in data) {
          this.name = data.name;
        }
        if ("icon" in data) {
          this.icon = data.icon;
        }
        if ("splash" in data) {
          this.splash = data.splash;
        }
        if ("discovery_splash" in data) {
          this.discoverySplash = data.discovery_splash;
        }
        if ("features" in data) {
          this.features = data.features;
        }
        if ("approximate_member_count" in data) {
          this.approximateMemberCount = data.approximate_member_count;
        }
        if ("approximate_presence_count" in data) {
          this.approximatePresenceCount = data.approximate_presence_count;
        }
        if ("description" in data) {
          this.description = data.description;
        } else {
          this.description ?? (this.description = null);
        }
        if (!this.emojis) {
          this.emojis = new Collection2();
        } else {
          this.emojis.clear();
        }
        for (const emoji of data.emojis) {
          this.emojis.set(emoji.id, new GuildPreviewEmoji(this.client, emoji, this));
        }
        this.stickers = data.stickers.reduce(
          (stickers, sticker) => stickers.set(sticker.id, new Sticker2(this.client, sticker)),
          new Collection2()
        );
      }
      /**
       * The timestamp this guild was created at
       * @type {number}
       * @readonly
       */
      get createdTimestamp() {
        return SnowflakeUtil.timestampFrom(this.id);
      }
      /**
       * The time this guild was created at
       * @type {Date}
       * @readonly
       */
      get createdAt() {
        return new Date(this.createdTimestamp);
      }
      /**
       * The URL to this guild's splash.
       * @param {StaticImageURLOptions} [options={}] Options for the Image URL
       * @returns {?string}
       */
      splashURL({ format, size } = {}) {
        return this.splash && this.client.rest.cdn.Splash(this.id, this.splash, format, size);
      }
      /**
       * The URL to this guild's discovery splash.
       * @param {StaticImageURLOptions} [options={}] Options for the Image URL
       * @returns {?string}
       */
      discoverySplashURL({ format, size } = {}) {
        return this.discoverySplash && this.client.rest.cdn.DiscoverySplash(this.id, this.discoverySplash, format, size);
      }
      /**
       * The URL to this guild's icon.
       * @param {ImageURLOptions} [options={}] Options for the Image URL
       * @returns {?string}
       */
      iconURL({ format, size, dynamic } = {}) {
        return this.icon && this.client.rest.cdn.Icon(this.id, this.icon, format, size, dynamic);
      }
      /**
       * Fetches this guild.
       * @returns {Promise<GuildPreview>}
       */
      async fetch() {
        const data = await this.client.api.guilds(this.id).preview.get();
        this._patch(data);
        return this;
      }
      /**
       * When concatenated with a string, this automatically returns the guild's name instead of the Guild object.
       * @returns {string}
       * @example
       * // Logs: Hello from My Guild!
       * console.log(`Hello from ${previewGuild}!`);
       */
      toString() {
        return this.name;
      }
      toJSON() {
        const json = super.toJSON();
        json.iconURL = this.iconURL();
        json.splashURL = this.splashURL();
        return json;
      }
    };
    module2.exports = GuildPreview2;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/managers/AutoModerationRuleManager.js
var require_AutoModerationRuleManager = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/managers/AutoModerationRuleManager.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var CachedManager = require_CachedManager();
    var AutoModerationRule = require_AutoModerationRule();
    var {
      AutoModerationRuleEventTypes,
      AutoModerationRuleTriggerTypes,
      AutoModerationActionTypes,
      AutoModerationRuleKeywordPresetTypes
    } = require_Constants();
    var AutoModerationRuleManager = class extends CachedManager {
      constructor(guild, iterable) {
        super(guild.client, AutoModerationRule, iterable);
        this.guild = guild;
      }
      /**
       * Resolves an {@link AutoModerationRuleResolvable} to an {@link AutoModerationRule} object.
       * @method resolve
       * @memberof AutoModerationRuleManager
       * @instance
       * @param {AutoModerationRuleResolvable} autoModerationRule The AutoModerationRule resolvable to resolve
       * @returns {?AutoModerationRule}
       */
      /**
       * Resolves an {@link AutoModerationRuleResolvable} to a {@link AutoModerationRule} id.
       * @method resolveId
       * @memberof AutoModerationRuleManager
       * @instance
       * @param {AutoModerationRuleResolvable} autoModerationRule The AutoModerationRule resolvable to resolve
       * @returns {?Snowflake}
       */
      _add(data, cache) {
        return super._add(data, cache, { extras: [this.guild] });
      }
      /**
       * Options used to set the trigger metadata of an auto moderation rule.
       * @typedef {Object} AutoModerationTriggerMetadataOptions
       * @property {string[]} [keywordFilter] The substrings that will be searched for in the content
       * @property {string[]} [regexPatterns] The regular expression patterns which will be matched against the content
       * <info>Only Rust-flavored regular expressions are supported.</info>
       * @property {AutoModerationRuleKeywordPresetType[]} [presets]
       * The internally pre-defined wordsets which will be searched for in the content
       * @property {string[]} [allowList] The substrings that will be exempt from triggering
       * {@link AutoModerationRuleTriggerType.KEYWORD} and {@link AutoModerationRuleTriggerType.KEYWORD_PRESET}
       * @property {?number} [mentionTotalLimit] The total number of role & user mentions allowed per message
       * @property {boolean} [mentionRaidProtectionEnabled] Whether to automatically detect mention raids
       */
      /**
       * Options used to set the actions of an auto moderation rule.
       * @typedef {Object} AutoModerationActionOptions
       * @property {AutoModerationActionType} type The type of this auto moderation rule action
       * @property {AutoModerationActionMetadataOptions} [metadata] Additional metadata needed during execution
       * <info>This property is required if using a `type` of
       * {@link AutoModerationActionType.SEND_ALERT_MESSAGE} or {@link AutoModerationActionType.TIMEOUT}.</info>
       */
      /**
       * Options used to set the metadata of an auto moderation rule action.
       * @typedef {Object} AutoModerationActionMetadataOptions
       * @property {GuildTextChannelResolvable|ThreadChannel} [channel] The channel to which content will be logged
       * @property {number} [durationSeconds] The timeout duration in seconds
       * @property {string} [customMessage] The custom message that is shown whenever a message is blocked
       */
      /**
       * Options used to create an auto moderation rule.
       * @typedef {Object} AutoModerationRuleCreateOptions
       * @property {string} name The name of the auto moderation rule
       * @property {AutoModerationRuleEventType} eventType The event type of the auto moderation rule
       * @property {AutoModerationRuleTriggerType} triggerType The trigger type of the auto moderation rule
       * @property {AutoModerationTriggerMetadataOptions} [triggerMetadata] The trigger metadata of the auto moderation rule
       * <info>This property is required if the following `triggerType`s are used:
       * * {@link AutoModerationRuleTriggerType.KEYWORD KEYWORD}
       * * {@link AutoModerationRuleTriggerType.KEYWORD_PRESET KEYWORD_PRESET}
       * * {@link AutoModerationRuleTriggerType.MENTION_SPAM MENTION_SPAM}
       * </info>
       * @property {AutoModerationActionOptions[]} actions
       * The actions that will execute when the auto moderation rule is triggered
       * @property {boolean} [enabled] Whether the auto moderation rule should be enabled
       * @property {Collection<Snowflake, Role>|RoleResolvable[]} [exemptRoles]
       * The roles that should not be affected by the auto moderation rule
       * @property {Collection<Snowflake, GuildChannel|ThreadChannel>|GuildChannelResolvable[]} [exemptChannels]
       * The channels that should not be affected by the auto moderation rule
       * @property {string} [reason] The reason for creating the auto moderation rule
       */
      /**
       * Creates a new auto moderation rule.
       * @param {AutoModerationRuleCreateOptions} options Options for creating the auto moderation rule
       * @returns {Promise<AutoModerationRule>}
       */
      async create({
        name,
        eventType,
        triggerType,
        triggerMetadata,
        actions,
        enabled,
        exemptRoles,
        exemptChannels,
        reason
      }) {
        var _a;
        const data = await this.client.api.guilds(this.guild.id)["auto-moderation"].rules.post({
          data: {
            name,
            event_type: typeof eventType === "number" ? eventType : AutoModerationRuleEventTypes[eventType],
            trigger_type: typeof triggerType === "number" ? triggerType : AutoModerationRuleTriggerTypes[triggerType],
            trigger_metadata: triggerMetadata && {
              keyword_filter: triggerMetadata.keywordFilter,
              regex_patterns: triggerMetadata.regexPatterns,
              presets: (_a = triggerMetadata.presets) == null ? void 0 : _a.map(
                (preset) => typeof preset === "number" ? preset : AutoModerationRuleKeywordPresetTypes[preset]
              ),
              allow_list: triggerMetadata.allowList,
              mention_total_limit: triggerMetadata.mentionTotalLimit,
              mention_raid_protection_enabled: triggerMetadata.mentionRaidProtectionEnabled
            },
            actions: actions.map((action) => {
              var _a2, _b, _c;
              return {
                type: typeof action.type === "number" ? action.type : AutoModerationActionTypes[action.type],
                metadata: {
                  duration_seconds: (_a2 = action.metadata) == null ? void 0 : _a2.durationSeconds,
                  channel_id: ((_b = action.metadata) == null ? void 0 : _b.channel) && this.guild.channels.resolveId(action.metadata.channel),
                  custom_message: (_c = action.metadata) == null ? void 0 : _c.customMessage
                }
              };
            }),
            enabled,
            exempt_roles: exemptRoles == null ? void 0 : exemptRoles.map((exemptRole) => this.guild.roles.resolveId(exemptRole)),
            exempt_channels: exemptChannels == null ? void 0 : exemptChannels.map((exemptChannel) => this.guild.channels.resolveId(exemptChannel))
          },
          reason
        });
        return this._add(data);
      }
      /**
       * Options used to edit an auto moderation rule.
       * @typedef {Object} AutoModerationRuleEditOptions
       * @property {string} [name] The name of the auto moderation rule
       * @property {AutoModerationRuleEventType} [eventType] The event type of the auto moderation rule
       * @property {AutoModerationTriggerMetadataOptions} [triggerMetadata] The trigger metadata of the auto moderation rule
       * @property {AutoModerationActionOptions[]} [actions]
       * The actions that will execute when the auto moderation rule is triggered
       * @property {boolean} [enabled] Whether the auto moderation rule should be enabled
       * @property {Collection<Snowflake, Role>|RoleResolvable[]} [exemptRoles]
       * The roles that should not be affected by the auto moderation rule
       * @property {Collection<Snowflake, GuildChannel|ThreadChannel>|GuildChannelResolvable[]} [exemptChannels]
       * The channels that should not be affected by the auto moderation rule
       * @property {string} [reason] The reason for creating the auto moderation rule
       */
      /**
       * Edits an auto moderation rule.
       * @param {AutoModerationRuleResolvable} autoModerationRule The auto moderation rule to edit
       * @param {AutoModerationRuleEditOptions} options Options for editing the auto moderation rule
       * @returns {Promise<AutoModerationRule>}
       */
      async edit(autoModerationRule, { name, eventType, triggerMetadata, actions, enabled, exemptRoles, exemptChannels, reason }) {
        var _a;
        const autoModerationRuleId = this.resolveId(autoModerationRule);
        const data = await this.client.api.guilds(this.guild.id)("auto-moderation").rules(autoModerationRuleId).patch({
          data: {
            name,
            event_type: typeof eventType === "number" ? eventType : AutoModerationRuleEventTypes[eventType],
            trigger_metadata: triggerMetadata && {
              keyword_filter: triggerMetadata.keywordFilter,
              regex_patterns: triggerMetadata.regexPatterns,
              presets: (_a = triggerMetadata.presets) == null ? void 0 : _a.map(
                (preset) => typeof preset === "number" ? preset : AutoModerationRuleKeywordPresetTypes[preset]
              ),
              allow_list: triggerMetadata.allowList,
              mention_total_limit: triggerMetadata.mentionTotalLimit,
              mention_raid_protection_enabled: triggerMetadata.mentionRaidProtectionEnabled
            },
            actions: actions == null ? void 0 : actions.map((action) => {
              var _a2, _b, _c;
              return {
                type: typeof action.type === "number" ? action.type : AutoModerationActionTypes[action.type],
                metadata: {
                  duration_seconds: (_a2 = action.metadata) == null ? void 0 : _a2.durationSeconds,
                  channel_id: ((_b = action.metadata) == null ? void 0 : _b.channel) && this.guild.channels.resolveId(action.metadata.channel),
                  custom_message: (_c = action.metadata) == null ? void 0 : _c.customMessage
                }
              };
            }),
            enabled,
            exempt_roles: exemptRoles == null ? void 0 : exemptRoles.map((exemptRole) => this.guild.roles.resolveId(exemptRole)),
            exempt_channels: exemptChannels == null ? void 0 : exemptChannels.map((exemptChannel) => this.guild.channels.resolveId(exemptChannel))
          },
          reason
        });
        return this._add(data);
      }
      /**
       * Data that can be resolved to give an AutoModerationRule object. This can be:
       * * An AutoModerationRule
       * * A Snowflake
       * @typedef {AutoModerationRule|Snowflake} AutoModerationRuleResolvable
       */
      /**
       * Options used to fetch a single auto moderation rule from a guild.
       * @typedef {BaseFetchOptions} FetchAutoModerationRuleOptions
       * @property {AutoModerationRuleResolvable} autoModerationRule The auto moderation rule to fetch
       */
      /**
       * Options used to fetch all auto moderation rules from a guild.
       * @typedef {Object} FetchAutoModerationRulesOptions
       * @property {boolean} [cache] Whether to cache the fetched auto moderation rules
       */
      /**
       * Fetches auto moderation rules from Discord.
       * @param {AutoModerationRuleResolvable|FetchAutoModerationRuleOptions|FetchAutoModerationRulesOptions} [options]
       * Options for fetching auto moderation rule(s)
       * @returns {Promise<AutoModerationRule|Collection<Snowflake, AutoModerationRule>>}
       * @example
       * // Fetch all auto moderation rules from a guild without caching
       * guild.autoModerationRules.fetch({ cache: false })
       *   .then(console.log)
       *   .catch(console.error);
       * @example
       * // Fetch a single auto moderation rule
       * guild.autoModerationRules.fetch('979083472868098119')
       *   .then(console.log)
       *   .catch(console.error);
       * @example
       * // Fetch a single auto moderation rule without checking cache and without caching
       * guild.autoModerationRules.fetch({ autoModerationRule: '979083472868098119', cache: false, force: true })
       *   .then(console.log)
       *   .catch(console.error)
       */
      fetch(options) {
        if (!options) return this._fetchMany();
        const { autoModerationRule, cache, force } = options;
        const resolvedAutoModerationRule = this.resolveId(autoModerationRule ?? options);
        if (resolvedAutoModerationRule) {
          return this._fetchSingle({ autoModerationRule: resolvedAutoModerationRule, cache, force });
        }
        return this._fetchMany(options);
      }
      async _fetchSingle({ autoModerationRule, cache, force = false }) {
        if (!force) {
          const existing = this.cache.get(autoModerationRule);
          if (existing) return existing;
        }
        const data = await this.client.api.guilds(this.guild.id)("auto-moderation").rules(autoModerationRule).get();
        return this._add(data, cache);
      }
      async _fetchMany(options = {}) {
        const data = await this.client.api.guilds(this.guild.id)("auto-moderation").rules.get();
        return data.reduce(
          (col, autoModerationRule) => col.set(autoModerationRule.id, this._add(autoModerationRule, options.cache)),
          new Collection2()
        );
      }
      /**
       * Deletes an auto moderation rule.
       * @param {AutoModerationRuleResolvable} autoModerationRule The auto moderation rule to delete
       * @param {string} [reason] The reason for deleting the auto moderation rule
       * @returns {Promise<void>}
       */
      async delete(autoModerationRule, reason) {
        const autoModerationRuleId = this.resolveId(autoModerationRule);
        await this.client.api.guilds(this.guild.id)("auto-moderation").rules(autoModerationRuleId).delete({ reason });
      }
    };
    module2.exports = AutoModerationRuleManager;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/managers/GuildBanManager.js
var require_GuildBanManager = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/managers/GuildBanManager.js"(exports2, module2) {
    "use strict";
    var process2 = require_node_process();
    var { Collection: Collection2 } = require_dist();
    var CachedManager = require_CachedManager();
    var { TypeError: TypeError2, Error: Error2 } = require_errors2();
    var GuildBan = require_GuildBan();
    var { GuildMember } = require_GuildMember();
    var deprecationEmittedForDays = false;
    var GuildBanManager = class extends CachedManager {
      constructor(guild, iterable) {
        super(guild.client, GuildBan, iterable);
        this.guild = guild;
      }
      /**
       * The cache of this Manager
       * @type {Collection<Snowflake, GuildBan>}
       * @name GuildBanManager#cache
       */
      _add(data, cache) {
        return super._add(data, cache, { id: data.user.id, extras: [this.guild] });
      }
      /**
       * Data that resolves to give a GuildBan object. This can be:
       * * A GuildBan object
       * * A User resolvable
       * @typedef {GuildBan|UserResolvable} GuildBanResolvable
       */
      /**
       * Resolves a GuildBanResolvable to a GuildBan object.
       * @param {GuildBanResolvable} ban The ban that is in the guild
       * @returns {?GuildBan}
       */
      resolve(ban) {
        return super.resolve(ban) ?? super.resolve(this.client.users.resolveId(ban));
      }
      /**
       * Options used to fetch a single ban from a guild.
       * @typedef {BaseFetchOptions} FetchBanOptions
       * @property {UserResolvable} user The ban to fetch
       */
      /**
       * Options used to fetch multiple bans from a guild.
       * @typedef {Object} FetchBansOptions
       * @property {number} [limit] The maximum number of bans to return
       * @property {Snowflake} [before] Consider only bans before this id
       * @property {Snowflake} [after] Consider only bans after this id
       * @property {boolean} [cache] Whether to cache the fetched bans
       */
      /**
       * Fetches ban(s) from Discord.
       * @param {UserResolvable|FetchBanOptions|FetchBansOptions} [options] Options for fetching guild ban(s)
       * @returns {Promise<GuildBan|Collection<Snowflake, GuildBan>>}
       * @example
       * // Fetch multiple bans from a guild
       * guild.bans.fetch()
       *   .then(console.log)
       *   .catch(console.error);
       * @example
       * // Fetch a maximum of 5 bans from a guild without caching
       * guild.bans.fetch({ limit: 5, cache: false })
       *   .then(console.log)
       *   .catch(console.error);
       * @example
       * // Fetch a single ban
       * guild.bans.fetch('351871113346809860')
       *   .then(console.log)
       *   .catch(console.error);
       * @example
       * // Fetch a single ban without checking cache
       * guild.bans.fetch({ user, force: true })
       *   .then(console.log)
       *   .catch(console.error)
       * @example
       * // Fetch a single ban without caching
       * guild.bans.fetch({ user, cache: false })
       *   .then(console.log)
       *   .catch(console.error);
       */
      fetch(options) {
        if (!options) return this._fetchMany();
        const { user, cache, force, limit, before, after } = options;
        const resolvedUser = this.client.users.resolveId(user ?? options);
        if (resolvedUser) return this._fetchSingle({ user: resolvedUser, cache, force });
        if (!before && !after && !limit && typeof cache === "undefined") {
          return Promise.reject(new Error2("FETCH_BAN_RESOLVE_ID"));
        }
        return this._fetchMany(options);
      }
      async _fetchSingle({ user, cache, force = false }) {
        if (!force) {
          const existing = this.cache.get(user);
          if (existing && !existing.partial) return existing;
        }
        const data = await this.client.api.guilds(this.guild.id).bans(user).get();
        return this._add(data, cache);
      }
      async _fetchMany(options = {}) {
        const data = await this.client.api.guilds(this.guild.id).bans.get({
          query: options
        });
        return data.reduce((col, ban) => col.set(ban.user.id, this._add(ban, options.cache)), new Collection2());
      }
      /**
       * Options used to ban a user from a guild.
       * @typedef {Object} BanOptions
       * @property {number} [days=0] Number of days of messages to delete, must be between 0 and 7, inclusive
       * <warn>This property is deprecated. Use `deleteMessageSeconds` instead.</warn>
       * @property {number} [deleteMessageSeconds] Number of seconds of messages to delete,
       * must be between 0 and 604800 (7 days), inclusive
       * @property {string} [reason] The reason for the ban
       */
      /**
       * Bans a user from the guild.
       * @param {UserResolvable} user The user to ban
       * @param {BanOptions} [options] Options for the ban
       * @returns {Promise<GuildMember|User|Snowflake>} Result object will be resolved as specifically as possible.
       * If the GuildMember cannot be resolved, the User will instead be attempted to be resolved. If that also cannot
       * be resolved, the user id will be the result.
       * @example
       * // Ban a user by id (or with a user/guild member object)
       * guild.bans.create('84484653687267328')
       *   .then(banInfo => console.log(`Banned ${banInfo.user?.tag ?? banInfo.tag ?? banInfo}`))
       *   .catch(console.error);
       */
      async create(user, options = {}) {
        if (typeof options !== "object") throw new TypeError2("INVALID_TYPE", "options", "object", true);
        const id = this.client.users.resolveId(user);
        if (!id) throw new Error2("BAN_RESOLVE_ID", true);
        if (typeof options.days !== "undefined" && !deprecationEmittedForDays) {
          process2.emitWarning(
            "The days option for GuildBanManager#create() is deprecated. Use the deleteMessageSeconds option instead.",
            "DeprecationWarning"
          );
          deprecationEmittedForDays = true;
        }
        await this.client.api.guilds(this.guild.id).bans(id).put({
          data: {
            delete_message_seconds: typeof options.deleteMessageSeconds !== "undefined" ? options.deleteMessageSeconds : (options.days ?? 0) * 24 * 60 * 60
          },
          reason: options.reason
        });
        if (user instanceof GuildMember) return user;
        const _user = this.client.users.resolve(id);
        if (_user) {
          return this.guild.members.resolve(_user) ?? _user;
        }
        return id;
      }
      /**
       * Unbans a user from the guild.
       * @param {UserResolvable} user The user to unban
       * @param {string} [reason] Reason for unbanning user
       * @returns {Promise<?User>}
       * @example
       * // Unban a user by id (or with a user/guild member object)
       * guild.bans.remove('84484653687267328')
       *   .then(user => console.log(`Unbanned ${user.username} from ${guild.name}`))
       *   .catch(console.error);
       */
      async remove(user, reason) {
        const id = this.client.users.resolveId(user);
        if (!id) throw new Error2("BAN_RESOLVE_ID");
        await this.client.api.guilds(this.guild.id).bans(id).delete({ reason });
        return this.client.users.resolve(user);
      }
      /**
       * Options used for bulk banning users from a guild.
       * @typedef {Object} BulkBanOptions
       * @property {number} [deleteMessageSeconds] Number of seconds of messages to delete,
       * must be between 0 and 604800 (7 days), inclusive
       * @property {string} [reason] The reason for the bans
       */
      /**
       * Result of bulk banning users from a guild.
       * @typedef {Object} BulkBanResult
       * @property {Snowflake[]} bannedUsers IDs of the banned users
       * @property {Snowflake[]} failedUsers IDs of the users that could not be banned or were already banned
       */
      /**
       * Bulk ban users from a guild, and optionally delete previous messages sent by them.
       * @param {Collection<Snowflake, UserResolvable>|UserResolvable[]} users The users to ban
       * @param {BulkBanOptions} [options] The options for bulk banning users
       * @returns {Promise<BulkBanResult>} Returns an object with `bannedUsers` key containing the IDs of the banned users
       * and the key `failedUsers` with the IDs that could not be banned or were already banned.
       * @example
       * // Bulk ban users by ids (or with user/guild member objects) and delete all their messages from the past 7 days
       * guild.bans.bulkCreate(['84484653687267328'], { deleteMessageSeconds: 7 * 24 * 60 * 60 })
       *   .then(result => {
       *     console.log(`Banned ${result.bannedUsers.length} users, failed to ban ${result.failedUsers.length} users.`)
       *   })
       *   .catch(console.error);
       * @deprecated This method will not be usable until an effective MFA implementation is in place.
       */
      async bulkCreate(users, options = {}) {
        if (!users || !(Array.isArray(users) || users instanceof Collection2)) {
          throw new TypeError2("INVALID_TYPE", "users", "Array or Collection of UserResolvable", true);
        }
        if (typeof options !== "object") throw new TypeError2("INVALID_TYPE", "options", "object", true);
        const userIds = users.map((user) => this.client.users.resolveId(user));
        if (userIds.length === 0) throw new Error2("BULK_BAN_USERS_OPTION_EMPTY");
        const result = await this.client.api.guilds(this.guild.id)["bulk-ban"].post({
          data: { delete_message_days: options.deleteMessageSeconds, user_ids: userIds },
          reason: options.reason
        });
        return { bannedUsers: result.banned_users, failedUsers: result.failed_users };
      }
    };
    module2.exports = GuildBanManager;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/managers/GuildChannelManager.js
var require_GuildChannelManager = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/managers/GuildChannelManager.js"(exports2, module2) {
    "use strict";
    var process2 = require_node_process();
    var { Collection: Collection2 } = require_dist();
    var CachedManager = require_CachedManager();
    var { Error: Error2, TypeError: TypeError2 } = require_errors2();
    var GuildChannel = require_GuildChannel();
    var PermissionOverwrites = require_PermissionOverwrites();
    var ThreadChannel = require_ThreadChannel();
    var Webhook2 = require_Webhook();
    var ChannelFlags = require_ChannelFlags();
    var {
      ThreadChannelTypes,
      ChannelTypes,
      VideoQualityModes,
      SortOrderTypes,
      ForumLayoutTypes
    } = require_Constants();
    var DataResolver2 = require_DataResolver();
    var Util = require_Util();
    var { resolveAutoArchiveMaxLimit, transformGuildForumTag, transformGuildDefaultReaction } = require_Util();
    var cacheWarningEmitted = false;
    var storeChannelDeprecationEmitted = false;
    var GuildChannelManager = class extends CachedManager {
      constructor(guild, iterable) {
        super(guild.client, GuildChannel, iterable);
        const defaultCaching = this._cache.constructor.name === "Collection" || (this._cache.maxSize === void 0 || this._cache.maxSize === Infinity) && (this._cache.sweepFilter === void 0 || this._cache.sweepFilter.isDefault);
        if (!cacheWarningEmitted && !defaultCaching) {
          cacheWarningEmitted = true;
          process2.emitWarning(
            `Overriding the cache handling for ${this.constructor.name} is unsupported and breaks functionality.`,
            "UnsupportedCacheOverwriteWarning"
          );
        }
        this.guild = guild;
      }
      /**
       * The number of channels in this managers cache excluding thread channels
       * that do not count towards a guild's maximum channels restriction.
       * @type {number}
       * @readonly
       */
      get channelCountWithoutThreads() {
        return this.cache.reduce((acc, channel) => {
          if (ThreadChannelTypes.includes(channel.type)) return acc;
          return ++acc;
        }, 0);
      }
      /**
       * The cache of this Manager
       * @type {Collection<Snowflake, GuildChannel|ThreadChannel>}
       * @name GuildChannelManager#cache
       */
      _add(channel) {
        const existing = this.cache.get(channel.id);
        if (existing) return existing;
        this.cache.set(channel.id, channel);
        return channel;
      }
      /**
       * Data that can be resolved to give a Guild Channel object. This can be:
       * * A GuildChannel object
       * * A ThreadChannel object
       * * A Snowflake
       * @typedef {GuildChannel|ThreadChannel|Snowflake} GuildChannelResolvable
       */
      /**
       * Resolves a GuildChannelResolvable to a Channel object.
       * @param {GuildChannelResolvable} channel The GuildChannel resolvable to resolve
       * @returns {?(GuildChannel|ThreadChannel)}
       */
      resolve(channel) {
        if (channel instanceof ThreadChannel) return super.resolve(channel.id);
        return super.resolve(channel);
      }
      /**
       * Resolves a GuildChannelResolvable to a channel id.
       * @param {GuildChannelResolvable} channel The GuildChannel resolvable to resolve
       * @returns {?Snowflake}
       */
      resolveId(channel) {
        if (channel instanceof ThreadChannel) return super.resolveId(channel.id);
        return super.resolveId(channel);
      }
      /**
       * Options used to create a new channel in a guild.
       * @typedef {CategoryCreateChannelOptions} GuildChannelCreateOptions
       * @property {CategoryChannelResolvable} [parent] Parent of the new channel
       */
      /**
       * Creates a new channel in the guild.
       * @param {string} name The name of the new channel
       * @param {GuildChannelCreateOptions} [options={}] Options for creating the new channel
       * @returns {Promise<GuildChannel>}
       * @example
       * // Create a new text channel
       * guild.channels.create('new-general', { reason: 'Needed a cool new channel' })
       *   .then(console.log)
       *   .catch(console.error);
       * @example
       * // Create a new channel with permission overwrites
       * guild.channels.create('new-voice', {
       *   type: 'GUILD_VOICE',
       *   permissionOverwrites: [
       *      {
       *        id: message.author.id,
       *        deny: [Permissions.FLAGS.VIEW_CHANNEL],
       *     },
       *   ],
       * })
       */
      async create(name, {
        type,
        topic,
        nsfw,
        bitrate,
        userLimit,
        parent,
        permissionOverwrites,
        position,
        rateLimitPerUser,
        rtcRegion,
        videoQualityMode,
        availableTags,
        defaultReactionEmoji,
        defaultSortOrder,
        defaultForumLayout,
        defaultThreadRateLimitPerUser,
        reason
      } = {}) {
        parent && (parent = this.client.channels.resolveId(parent));
        permissionOverwrites && (permissionOverwrites = permissionOverwrites.map((o) => PermissionOverwrites.resolve(o, this.guild)));
        const intType = typeof type === "number" ? type : ChannelTypes[type] ?? ChannelTypes.GUILD_TEXT;
        const videoMode = typeof videoQualityMode === "number" ? videoQualityMode : VideoQualityModes[videoQualityMode];
        const sortMode = typeof defaultSortOrder === "number" ? defaultSortOrder : SortOrderTypes[defaultSortOrder];
        const layoutMode = typeof defaultForumLayout === "number" ? defaultForumLayout : ForumLayoutTypes[defaultForumLayout];
        if (intType === ChannelTypes.GUILD_STORE && !storeChannelDeprecationEmitted) {
          storeChannelDeprecationEmitted = true;
          process2.emitWarning(
            // eslint-disable-next-line max-len
            "Creating store channels is deprecated by Discord and will stop working in March 2022. Check the docs for more info.",
            "DeprecationWarning"
          );
        }
        const data = await this.client.api.guilds(this.guild.id).channels.post({
          data: {
            name,
            topic,
            type: intType,
            nsfw,
            bitrate,
            user_limit: userLimit,
            parent_id: parent,
            position,
            permission_overwrites: permissionOverwrites,
            rate_limit_per_user: rateLimitPerUser,
            rtc_region: rtcRegion,
            video_quality_mode: videoMode,
            available_tags: availableTags == null ? void 0 : availableTags.map((availableTag) => transformGuildForumTag(availableTag)),
            default_reaction_emoji: defaultReactionEmoji && transformGuildDefaultReaction(defaultReactionEmoji),
            default_sort_order: sortMode,
            default_forum_layout: layoutMode,
            default_thread_rate_limit_per_user: defaultThreadRateLimitPerUser
          },
          reason
        });
        return this.client.actions.ChannelCreate.handle(data).channel;
      }
      /**
       * Creates a webhook for the channel.
       * @param {GuildChannelResolvable} channel The channel to create the webhook for
       * @param {string} name The name of the webhook
       * @param {ChannelWebhookCreateOptions} [options] Options for creating the webhook
       * @returns {Promise<Webhook>} Returns the created Webhook
       * @example
       * // Create a webhook for the current channel
       * guild.channels.createWebhook('222197033908436994', 'Snek', {
       *   avatar: 'https://i.imgur.com/mI8XcpG.jpg',
       *   reason: 'Needed a cool new Webhook'
       * })
       *   .then(console.log)
       *   .catch(console.error)
       */
      async createWebhook(channel, name, { avatar, reason } = {}) {
        const id = this.resolveId(channel);
        if (!id) throw new TypeError2("INVALID_TYPE", "channel", "GuildChannelResolvable");
        if (typeof avatar === "string" && !avatar.startsWith("data:")) {
          avatar = await DataResolver2.resolveImage(avatar);
        }
        const data = await this.client.api.channels[id].webhooks.post({
          data: {
            name,
            avatar
          },
          reason
        });
        return new Webhook2(this.client, data);
      }
      /**
       * Adds the target channel to a channel's followers.
       * @param {NewsChannel|Snowflake} channel The channel to follow
       * @param {TextChannelResolvable} targetChannel The channel where published announcements will be posted at
       * @param {string} [reason] Reason for creating the webhook
       * @returns {Promise<Snowflake>} Returns created target webhook id.
       */
      async addFollower(channel, targetChannel, reason) {
        const channelId = this.resolveId(channel);
        const targetChannelId = this.resolveId(targetChannel);
        if (!channelId || !targetChannelId) throw new Error2("GUILD_CHANNEL_RESOLVE");
        const { webhook_id } = await this.client.api.channels[channelId].followers.post({
          data: { webhook_channel_id: targetChannelId },
          reason
        });
        return webhook_id;
      }
      /**
       * The data for a guild channel.
       * @typedef {Object} ChannelData
       * @property {string} [name] The name of the channel
       * @property {ChannelType} [type] The type of the channel (only conversion between text and news is supported)
       * @property {number} [position] The position of the channel
       * @property {string} [topic] The topic of the text channel
       * @property {boolean} [nsfw] Whether the channel is NSFW
       * @property {number} [bitrate] The bitrate of the voice channel
       * @property {number} [userLimit] The user limit of the voice channel
       * @property {?CategoryChannelResolvable} [parent] The parent of the channel
       * @property {boolean} [lockPermissions]
       * Lock the permissions of the channel to what the parent's permissions are
       * @property {OverwriteResolvable[]|Collection<Snowflake, OverwriteResolvable>} [permissionOverwrites]
       * Permission overwrites for the channel
       * @property {number} [rateLimitPerUser] The rate limit per user (slowmode) for the channel in seconds
       * @property {ThreadAutoArchiveDuration} [defaultAutoArchiveDuration]
       * The default auto archive duration for all new threads in this channel
       * @property {?string} [rtcRegion] The RTC region of the channel
       * @property {?VideoQualityMode|number} [videoQualityMode] The camera video quality mode of the channel
       * @property {ChannelFlagsResolvable} [flags] The flags to set on the channel
       * @property {GuildForumTagData[]} [availableTags] The tags to set as available in a forum channel
       * @property {?DefaultReactionEmoji} [defaultReactionEmoji] The emoji to set as the default reaction emoji
       * @property {number} [defaultThreadRateLimitPerUser] The rate limit per user (slowmode) to set on forum posts
       * @property {?SortOrderType} [defaultSortOrder] The default sort order mode to set on the channel
       */
      /**
       * Edits the channel.
       * @param {GuildChannelResolvable} channel The channel to edit
       * @param {ChannelData} data The new data for the channel
       * @param {string} [reason] Reason for editing this channel
       * @returns {Promise<GuildChannel>}
       * @example
       * // Edit a channel
       * guild.channels.edit('222197033908436994', { name: 'new-channel' })
       *   .then(console.log)
       *   .catch(console.error);
       */
      async edit(channel, data, reason) {
        var _a, _b;
        channel = this.resolve(channel);
        if (!channel) throw new TypeError2("INVALID_TYPE", "channel", "GuildChannelResolvable");
        const parent = data.parent && this.client.channels.resolveId(data.parent);
        if (typeof data.position !== "undefined") await this.setPosition(channel, data.position, { reason });
        let permission_overwrites = (_a = data.permissionOverwrites) == null ? void 0 : _a.map((o) => PermissionOverwrites.resolve(o, this.guild));
        if (data.lockPermissions) {
          if (parent) {
            const newParent = this.guild.channels.resolve(parent);
            if ((newParent == null ? void 0 : newParent.type) === "GUILD_CATEGORY") {
              permission_overwrites = newParent.permissionOverwrites.cache.map(
                (o) => PermissionOverwrites.resolve(o, this.guild)
              );
            }
          } else if (channel.parent) {
            permission_overwrites = channel.parent.permissionOverwrites.cache.map(
              (o) => PermissionOverwrites.resolve(o, this.guild)
            );
          }
        }
        let defaultAutoArchiveDuration = data.defaultAutoArchiveDuration;
        if (defaultAutoArchiveDuration === "MAX") defaultAutoArchiveDuration = resolveAutoArchiveMaxLimit(this.guild);
        const newData = await this.client.api.channels(channel.id).patch({
          data: {
            name: (data.name ?? channel.name).trim(),
            type: data.type,
            topic: data.topic,
            nsfw: data.nsfw,
            bitrate: data.bitrate ?? channel.bitrate,
            user_limit: data.userLimit ?? channel.userLimit,
            rtc_region: "rtcRegion" in data ? data.rtcRegion : channel.rtcRegion,
            video_quality_mode: typeof data.videoQualityMode === "string" ? VideoQualityModes[data.videoQualityMode] : data.videoQualityMode,
            parent_id: parent,
            lock_permissions: data.lockPermissions,
            rate_limit_per_user: data.rateLimitPerUser,
            default_auto_archive_duration: defaultAutoArchiveDuration,
            permission_overwrites,
            available_tags: (_b = data.availableTags) == null ? void 0 : _b.map((availableTag) => transformGuildForumTag(availableTag)),
            default_reaction_emoji: data.defaultReactionEmoji && transformGuildDefaultReaction(data.defaultReactionEmoji),
            default_thread_rate_limit_per_user: data.defaultThreadRateLimitPerUser,
            flags: "flags" in data ? ChannelFlags.resolve(data.flags) : void 0,
            default_sort_order: typeof data.defaultSortOrder === "string" ? SortOrderTypes[data.defaultSortOrder] : data.defaultSortOrder
          },
          reason
        });
        return this.client.actions.ChannelUpdate.handle(newData).updated;
      }
      /**
       * Sets a new position for the guild channel.
       * @param {GuildChannelResolvable} channel The channel to set the position for
       * @param {number} position The new position for the guild channel
       * @param {SetChannelPositionOptions} [options] Options for setting position
       * @returns {Promise<GuildChannel>}
       * @example
       * // Set a new channel position
       * guild.channels.setPosition('222078374472843266', 2)
       *   .then(newChannel => console.log(`Channel's new position is ${newChannel.position}`))
       *   .catch(console.error);
       */
      async setPosition(channel, position, { relative, reason } = {}) {
        channel = this.resolve(channel);
        if (!channel) throw new TypeError2("INVALID_TYPE", "channel", "GuildChannelResolvable");
        const updatedChannels = await Util.setPosition(
          channel,
          position,
          relative,
          this.guild._sortedChannels(channel),
          this.client.api.guilds(this.guild.id).channels,
          reason
        );
        this.client.actions.GuildChannelsPositionUpdate.handle({
          guild_id: this.guild.id,
          channels: updatedChannels
        });
        return channel;
      }
      /**
       * Obtains one or more guild channels from Discord, or the channel cache if they're already available.
       * @param {Snowflake} [id] The channel's id
       * @param {BaseFetchOptions} [options] Additional options for this fetch
       * @returns {Promise<?GuildChannel|ThreadChannel|Collection<Snowflake, ?GuildChannel>>}
       * @example
       * // Fetch all channels from the guild (excluding threads)
       * message.guild.channels.fetch()
       *   .then(channels => console.log(`There are ${channels.size} channels.`))
       *   .catch(console.error);
       * @example
       * // Fetch a single channel
       * message.guild.channels.fetch('222197033908436994')
       *   .then(channel => console.log(`The channel name is: ${channel.name}`))
       *   .catch(console.error);
       */
      async fetch(id, { cache = true, force = false } = {}) {
        if (id && !force) {
          const existing = this.cache.get(id);
          if (existing) return existing;
        }
        if (id) {
          const data2 = await this.client.api.channels(id).get();
          if (this.guild.id !== data2.guild_id) throw new Error2("GUILD_CHANNEL_UNOWNED");
          return this.client.channels._add(data2, this.guild, { cache });
        }
        const data = await this.client.api.guilds(this.guild.id).channels.get();
        const channels = new Collection2();
        for (const channel of data) channels.set(channel.id, this.client.channels._add(channel, this.guild, { cache }));
        return channels;
      }
      /**
       * Fetches all webhooks for the channel.
       * @param {GuildChannelResolvable} channel The channel to fetch webhooks for
       * @returns {Promise<Collection<Snowflake, Webhook>>}
       * @example
       * // Fetch webhooks
       * guild.channels.fetchWebhooks('769862166131245066')
       *   .then(hooks => console.log(`This channel has ${hooks.size} hooks`))
       *   .catch(console.error);
       */
      async fetchWebhooks(channel) {
        const id = this.resolveId(channel);
        if (!id) throw new TypeError2("INVALID_TYPE", "channel", "GuildChannelResolvable");
        const data = await this.client.api.channels[id].webhooks.get();
        return data.reduce((hooks, hook) => hooks.set(hook.id, new Webhook2(this.client, hook)), new Collection2());
      }
      /**
       * Data that can be resolved to give a Category Channel object. This can be:
       * * A CategoryChannel object
       * * A Snowflake
       * @typedef {CategoryChannel|Snowflake} CategoryChannelResolvable
       */
      /**
       * The data needed for updating a channel's position.
       * @typedef {Object} ChannelPosition
       * @property {GuildChannel|Snowflake} channel Channel to update
       * @property {number} [position] New position for the channel
       * @property {CategoryChannelResolvable} [parent] Parent channel for this channel
       * @property {boolean} [lockPermissions] If the overwrites should be locked to the parents overwrites
       */
      /**
       * Batch-updates the guild's channels' positions.
       * <info>Only one channel's parent can be changed at a time</info>
       * @param {ChannelPosition[]} channelPositions Channel positions to update
       * @returns {Promise<Guild>}
       * @example
       * guild.channels.setPositions([{ channel: channelId, position: newChannelIndex }])
       *   .then(guild => console.log(`Updated channel positions for ${guild}`))
       *   .catch(console.error);
       */
      async setPositions(channelPositions) {
        channelPositions = channelPositions.map((r) => ({
          id: this.client.channels.resolveId(r.channel),
          position: r.position,
          lock_permissions: r.lockPermissions,
          parent_id: typeof r.parent !== "undefined" ? this.resolveId(r.parent) : void 0
        }));
        await this.client.api.guilds(this.guild.id).channels.patch({ data: channelPositions });
        return this.client.actions.GuildChannelsPositionUpdate.handle({
          guild_id: this.guild.id,
          channels: channelPositions
        }).guild;
      }
      /**
       * Deletes the channel.
       * @param {GuildChannelResolvable} channel The channel to delete
       * @param {string} [reason] Reason for deleting this channel
       * @returns {Promise<void>}
       * @example
       * // Delete the channel
       * guild.channels.delete('858850993013260338', 'making room for new channels')
       *   .then(console.log)
       *   .catch(console.error);
       */
      async delete(channel, reason) {
        const id = this.resolveId(channel);
        if (!id) throw new TypeError2("INVALID_TYPE", "channel", "GuildChannelResolvable");
        await this.client.api.channels(id).delete({ reason });
      }
    };
    module2.exports = GuildChannelManager;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/managers/BaseGuildEmojiManager.js
var require_BaseGuildEmojiManager = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/managers/BaseGuildEmojiManager.js"(exports2, module2) {
    "use strict";
    var CachedManager = require_CachedManager();
    var GuildEmoji = require_GuildEmoji();
    var ReactionEmoji = require_ReactionEmoji();
    var { parseEmoji } = require_Util();
    var BaseGuildEmojiManager2 = class extends CachedManager {
      constructor(client, iterable) {
        super(client, GuildEmoji, iterable);
      }
      /**
       * The cache of GuildEmojis
       * @type {Collection<Snowflake, GuildEmoji>}
       * @name BaseGuildEmojiManager#cache
       */
      /**
       * Data that can be resolved into a GuildEmoji object. This can be:
       * * A Snowflake
       * * A GuildEmoji object
       * * A ReactionEmoji object
       * @typedef {Snowflake|GuildEmoji|ReactionEmoji} EmojiResolvable
       */
      /**
       * Resolves an EmojiResolvable to an Emoji object.
       * @param {EmojiResolvable} emoji The Emoji resolvable to identify
       * @returns {?GuildEmoji}
       */
      resolve(emoji) {
        if (emoji instanceof ReactionEmoji) return super.resolve(emoji.id);
        return super.resolve(emoji);
      }
      /**
       * Resolves an EmojiResolvable to an Emoji id string.
       * @param {EmojiResolvable} emoji The Emoji resolvable to identify
       * @returns {?Snowflake}
       */
      resolveId(emoji) {
        if (emoji instanceof ReactionEmoji) return emoji.id;
        return super.resolveId(emoji);
      }
      /**
       * Data that can be resolved to give an emoji identifier. This can be:
       * * An EmojiResolvable
       * * The `<a:name:id>`, `<:name:id>`, `a:name:id` or `name:id` emoji identifier string of an emoji
       * * The Unicode representation of an emoji
       * @typedef {string|EmojiResolvable} EmojiIdentifierResolvable
       */
      /**
       * Resolves an EmojiResolvable to an emoji identifier.
       * @param {EmojiIdentifierResolvable} emoji The emoji resolvable to resolve
       * @returns {?string}
       */
      resolveIdentifier(emoji) {
        const emojiResolvable = this.resolve(emoji);
        if (emojiResolvable) return emojiResolvable.identifier;
        if (emoji instanceof ReactionEmoji) return emoji.identifier;
        if (typeof emoji === "string") {
          const res = parseEmoji(emoji);
          if (res == null ? void 0 : res.name.length) {
            emoji = `${res.animated ? "a:" : ""}${res.name}${res.id ? `:${res.id}` : ""}`;
          }
          if (!emoji.includes("%")) return encodeURIComponent(emoji);
          return emoji;
        }
        return null;
      }
    };
    module2.exports = BaseGuildEmojiManager2;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/managers/GuildEmojiManager.js
var require_GuildEmojiManager = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/managers/GuildEmojiManager.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var BaseGuildEmojiManager2 = require_BaseGuildEmojiManager();
    var { Error: Error2, TypeError: TypeError2 } = require_errors2();
    var DataResolver2 = require_DataResolver();
    var Permissions2 = require_Permissions();
    var GuildEmojiManager = class extends BaseGuildEmojiManager2 {
      constructor(guild, iterable) {
        super(guild.client, iterable);
        this.guild = guild;
      }
      _add(data, cache) {
        return super._add(data, cache, { extras: [this.guild] });
      }
      /**
       * Options used for creating an emoji in a guild.
       * @typedef {Object} GuildEmojiCreateOptions
       * @property {Collection<Snowflake, Role>|RoleResolvable[]} [roles] The roles to limit the emoji to
       * @property {string} [reason] The reason for creating the emoji
       */
      /**
       * Creates a new custom emoji in the guild.
       * @param {BufferResolvable|Base64Resolvable} attachment The image for the emoji
       * @param {string} name The name for the emoji
       * @param {GuildEmojiCreateOptions} [options] Options for creating the emoji
       * @returns {Promise<Emoji>} The created emoji
       * @example
       * // Create a new emoji from a URL
       * guild.emojis.create('https://i.imgur.com/w3duR07.png', 'rip')
       *   .then(emoji => console.log(`Created new emoji with name ${emoji.name}!`))
       *   .catch(console.error);
       * @example
       * // Create a new emoji from a file on your computer
       * guild.emojis.create('./memes/banana.png', 'banana')
       *   .then(emoji => console.log(`Created new emoji with name ${emoji.name}!`))
       *   .catch(console.error);
       */
      async create(attachment, name, { roles, reason } = {}) {
        attachment = await DataResolver2.resolveImage(attachment);
        if (!attachment) throw new TypeError2("REQ_RESOURCE_TYPE");
        const data = { image: attachment, name };
        if (roles) {
          if (!Array.isArray(roles) && !(roles instanceof Collection2)) {
            throw new TypeError2("INVALID_TYPE", "options.roles", "Array or Collection of Roles or Snowflakes", true);
          }
          data.roles = [];
          for (const role of roles.values()) {
            const resolvedRole = this.guild.roles.resolveId(role);
            if (!resolvedRole) throw new TypeError2("INVALID_ELEMENT", "Array or Collection", "options.roles", role);
            data.roles.push(resolvedRole);
          }
        }
        const emoji = await this.client.api.guilds(this.guild.id).emojis.post({ data, reason });
        return this.client.actions.GuildEmojiCreate.handle(this.guild, emoji).emoji;
      }
      /**
       * Obtains one or more emojis from Discord, or the emoji cache if they're already available.
       * @param {Snowflake} [id] The emoji's id
       * @param {BaseFetchOptions} [options] Additional options for this fetch
       * @returns {Promise<GuildEmoji|Collection<Snowflake, GuildEmoji>>}
       * @example
       * // Fetch all emojis from the guild
       * message.guild.emojis.fetch()
       *   .then(emojis => console.log(`There are ${emojis.size} emojis.`))
       *   .catch(console.error);
       * @example
       * // Fetch a single emoji
       * message.guild.emojis.fetch('222078108977594368')
       *   .then(emoji => console.log(`The emoji name is: ${emoji.name}`))
       *   .catch(console.error);
       */
      async fetch(id, { cache = true, force = false } = {}) {
        if (id) {
          if (!force) {
            const existing = this.cache.get(id);
            if (existing) return existing;
          }
          const emoji = await this.client.api.guilds(this.guild.id).emojis(id).get();
          return this._add(emoji, cache);
        }
        const data = await this.client.api.guilds(this.guild.id).emojis.get();
        const emojis = new Collection2();
        for (const emoji of data) emojis.set(emoji.id, this._add(emoji, cache));
        return emojis;
      }
      /**
       * Deletes an emoji.
       * @param {EmojiResolvable} emoji The Emoji resolvable to delete
       * @param {string} [reason] Reason for deleting the emoji
       * @returns {Promise<void>}
       */
      async delete(emoji, reason) {
        const id = this.resolveId(emoji);
        if (!id) throw new TypeError2("INVALID_TYPE", "emoji", "EmojiResolvable", true);
        await this.client.api.guilds(this.guild.id).emojis(id).delete({ reason });
      }
      /**
       * Edits an emoji.
       * @param {EmojiResolvable} emoji The Emoji resolvable to edit
       * @param {GuildEmojiEditData} data The new data for the emoji
       * @param {string} [reason] Reason for editing this emoji
       * @returns {Promise<GuildEmoji>}
       */
      async edit(emoji, data, reason) {
        var _a;
        const id = this.resolveId(emoji);
        if (!id) throw new TypeError2("INVALID_TYPE", "emoji", "EmojiResolvable", true);
        const roles = (_a = data.roles) == null ? void 0 : _a.map((r) => this.guild.roles.resolveId(r));
        const newData = await this.client.api.guilds(this.guild.id).emojis(id).patch({
          data: {
            name: data.name,
            roles
          },
          reason
        });
        const existing = this.cache.get(id);
        if (existing) {
          const clone = existing._clone();
          clone._patch(newData);
          return clone;
        }
        return this._add(newData);
      }
      /**
       * Fetches the author for this emoji
       * @param {EmojiResolvable} emoji The emoji to fetch the author of
       * @returns {Promise<User>}
       */
      async fetchAuthor(emoji) {
        emoji = this.resolve(emoji);
        if (!emoji) throw new TypeError2("INVALID_TYPE", "emoji", "EmojiResolvable", true);
        if (emoji.managed) {
          throw new Error2("EMOJI_MANAGED");
        }
        const { me } = this.guild.members;
        if (!me) throw new Error2("GUILD_UNCACHED_ME");
        if (!me.permissions.has(Permissions2.FLAGS.MANAGE_EMOJIS_AND_STICKERS)) {
          throw new Error2("MISSING_MANAGE_EMOJIS_AND_STICKERS_PERMISSION", this.guild);
        }
        const data = await this.client.api.guilds(this.guild.id).emojis(emoji.id).get();
        emoji._patch(data);
        return emoji.author;
      }
    };
    module2.exports = GuildEmojiManager;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/managers/GuildInviteManager.js
var require_GuildInviteManager = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/managers/GuildInviteManager.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var CachedManager = require_CachedManager();
    var { Error: Error2 } = require_errors2();
    var Invite2 = require_Invite();
    var DataResolver2 = require_DataResolver();
    var GuildInviteManager = class extends CachedManager {
      constructor(guild, iterable) {
        super(guild.client, Invite2, iterable);
        this.guild = guild;
      }
      /**
       * The cache of this Manager
       * @type {Collection<string, Invite>}
       * @name GuildInviteManager#cache
       */
      _add(data, cache) {
        return super._add(data, cache, { id: data.code, extras: [this.guild] });
      }
      /**
       * Data that resolves to give an Invite object. This can be:
       * * An invite code
       * * An invite URL
       * @typedef {string} InviteResolvable
       */
      /**
       * Data that can be resolved to a channel that an invite can be created on. This can be:
       * * TextChannel
       * * VoiceChannel
       * * NewsChannel
       * * StoreChannel
       * * StageChannel
       * * Snowflake
       * @typedef {TextChannel|VoiceChannel|NewsChannel|StoreChannel|StageChannel|Snowflake}
       * GuildInvitableChannelResolvable
       */
      /**
       * Resolves an InviteResolvable to an Invite object.
       * @method resolve
       * @memberof GuildInviteManager
       * @instance
       * @param {InviteResolvable} invite The invite resolvable to resolve
       * @returns {?Invite}
       */
      /**
       * Resolves an InviteResolvable to an invite code string.
       * @method resolveId
       * @memberof GuildInviteManager
       * @instance
       * @param {InviteResolvable} invite The invite resolvable to resolve
       * @returns {?string}
       */
      /**
       * Options used to fetch a single invite from a guild.
       * @typedef {Object} FetchInviteOptions
       * @property {InviteResolvable} code The invite to fetch
       * @property {boolean} [cache=true] Whether or not to cache the fetched invite
       * @property {boolean} [force=false] Whether to skip the cache check and request the API
       */
      /**
       * Options used to fetch all invites from a guild.
       * @typedef {Object} FetchInvitesOptions
       * @property {GuildInvitableChannelResolvable} [channelId]
       * The channel to fetch all invites from
       * @property {boolean} [cache=true] Whether or not to cache the fetched invites
       */
      /**
       * Fetches invite(s) from Discord.
       * @param {InviteResolvable|FetchInviteOptions|FetchInvitesOptions} [options] Options for fetching guild invite(s)
       * @returns {Promise<Invite|Collection<string, Invite>>}
       * @example
       * // Fetch all invites from a guild
       * guild.invites.fetch()
       *   .then(console.log)
       *   .catch(console.error);
       * @example
       * // Fetch all invites from a guild without caching
       * guild.invites.fetch({ cache: false })
       *   .then(console.log)
       *   .catch(console.error);
       * @example
       * // Fetch all invites from a channel
       * guild.invites.fetch({ channelId: '222197033908436994' })
       *   .then(console.log)
       *   .catch(console.error);
       * @example
       * // Fetch a single invite
       * guild.invites.fetch('bRCvFy9')
       *   .then(console.log)
       *   .catch(console.error);
       * @example
       * // Fetch a single invite without checking cache
       * guild.invites.fetch({ code: 'bRCvFy9', force: true })
       *   .then(console.log)
       *   .catch(console.error)
       * @example
       * // Fetch a single invite without caching
       * guild.invites.fetch({ code: 'bRCvFy9', cache: false })
       *   .then(console.log)
       *   .catch(console.error);
       */
      fetch(options) {
        if (!options) return this._fetchMany();
        if (typeof options === "string") {
          const code = DataResolver2.resolveInviteCode(options);
          if (!code) return Promise.reject(new Error2("INVITE_RESOLVE_CODE"));
          return this._fetchSingle({ code, cache: true });
        }
        if (!options.code) {
          if (options.channelId) {
            const id = this.guild.channels.resolveId(options.channelId);
            if (!id) return Promise.reject(new Error2("GUILD_CHANNEL_RESOLVE"));
            return this._fetchChannelMany(id, options.cache);
          }
          if ("cache" in options) return this._fetchMany(options.cache);
          return Promise.reject(new Error2("INVITE_RESOLVE_CODE"));
        }
        return this._fetchSingle({
          ...options,
          code: DataResolver2.resolveInviteCode(options.code)
        });
      }
      async _fetchSingle({ code, cache, force = false }) {
        if (!force) {
          const existing = this.cache.get(code);
          if (existing) return existing;
        }
        const invites = await this._fetchMany(cache);
        const invite = invites.get(code);
        if (!invite) throw new Error2("INVITE_NOT_FOUND");
        return invite;
      }
      async _fetchMany(cache) {
        const data = await this.client.api.guilds(this.guild.id).invites.get();
        return data.reduce((col, invite) => col.set(invite.code, this._add(invite, cache)), new Collection2());
      }
      async _fetchChannelMany(channelId, cache) {
        const data = await this.client.api.channels(channelId).invites.get();
        return data.reduce((col, invite) => col.set(invite.code, this._add(invite, cache)), new Collection2());
      }
      /**
       * Create an invite to the guild from the provided channel.
       * @param {GuildInvitableChannelResolvable} channel The options for creating the invite from a channel.
       * @param {CreateInviteOptions} [options={}] The options for creating the invite from a channel.
       * @returns {Promise<Invite>}
       * @example
       * // Create an invite to a selected channel
       * guild.invites.create('599942732013764608')
       *   .then(console.log)
       *   .catch(console.error);
       */
      async create(channel, { temporary = false, maxAge = 86400, maxUses = 0, unique, targetUser, targetApplication, targetType, reason } = {}) {
        const id = this.guild.channels.resolveId(channel);
        if (!id) throw new Error2("GUILD_CHANNEL_RESOLVE");
        const invite = await this.client.api.channels(id).invites.post({
          data: {
            temporary,
            max_age: maxAge,
            max_uses: maxUses,
            unique,
            target_user_id: this.client.users.resolveId(targetUser),
            target_application_id: (targetApplication == null ? void 0 : targetApplication.id) ?? (targetApplication == null ? void 0 : targetApplication.applicationId) ?? targetApplication,
            target_type: targetType
          },
          reason
        });
        return new Invite2(this.client, invite);
      }
      /**
       * Deletes an invite.
       * @param {InviteResolvable} invite The invite to delete
       * @param {string} [reason] Reason for deleting the invite
       * @returns {Promise<void>}
       */
      async delete(invite, reason) {
        const code = DataResolver2.resolveInviteCode(invite);
        await this.client.api.invites(code).delete({ reason });
      }
    };
    module2.exports = GuildInviteManager;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/managers/GuildMemberManager.js
var require_GuildMemberManager = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/managers/GuildMemberManager.js"(exports2, module2) {
    "use strict";
    var { Buffer: Buffer2 } = require_node_buffer();
    var { setTimeout: setTimeout2 } = require_node_timers();
    var { Collection: Collection2 } = require_dist();
    var CachedManager = require_CachedManager();
    var { Error: Error2, TypeError: TypeError2, RangeError: RangeError2 } = require_errors2();
    var BaseGuildVoiceChannel = require_BaseGuildVoiceChannel();
    var { GuildMember } = require_GuildMember();
    var { Role } = require_Role();
    var { Events: Events2, Opcodes } = require_Constants();
    var { PartialTypes } = require_Constants();
    var DataResolver2 = require_DataResolver();
    var GuildMemberFlags = require_GuildMemberFlags();
    var SnowflakeUtil = require_SnowflakeUtil();
    var GuildMemberManager = class extends CachedManager {
      constructor(guild, iterable) {
        super(guild.client, GuildMember, iterable);
        this.guild = guild;
      }
      /**
       * The cache of this Manager
       * @type {Collection<Snowflake, GuildMember>}
       * @name GuildMemberManager#cache
       */
      _add(data, cache = true) {
        return super._add(data, cache, { id: data.user.id, extras: [this.guild] });
      }
      /**
       * Data that resolves to give a GuildMember object. This can be:
       * * A GuildMember object
       * * A User resolvable
       * @typedef {GuildMember|UserResolvable} GuildMemberResolvable
       */
      /**
       * Resolves a {@link GuildMemberResolvable} to a {@link GuildMember} object.
       * @param {GuildMemberResolvable} member The user that is part of the guild
       * @returns {?GuildMember}
       */
      resolve(member) {
        const memberResolvable = super.resolve(member);
        if (memberResolvable) return memberResolvable;
        const userResolvable = this.client.users.resolveId(member);
        if (userResolvable) return super.resolve(userResolvable);
        return null;
      }
      /**
       * Resolves a {@link GuildMemberResolvable} to a member id.
       * @param {GuildMemberResolvable} member The user that is part of the guild
       * @returns {?Snowflake}
       */
      resolveId(member) {
        const memberResolvable = super.resolveId(member);
        if (memberResolvable) return memberResolvable;
        const userResolvable = this.client.users.resolveId(member);
        return this.cache.has(userResolvable) ? userResolvable : null;
      }
      /**
       * Options used to add a user to a guild using OAuth2.
       * @typedef {Object} AddGuildMemberOptions
       * @property {string} accessToken An OAuth2 access token for the user with the `guilds.join` scope granted to the
       * bot's application
       * @property {string} [nick] The nickname to give to the member (requires `MANAGE_NICKNAMES`)
       * @property {Collection<Snowflake, Role>|RoleResolvable[]} [roles] The roles to add to the member
       * (requires `MANAGE_ROLES`)
       * @property {boolean} [mute] Whether the member should be muted (requires `MUTE_MEMBERS`)
       * @property {boolean} [deaf] Whether the member should be deafened (requires `DEAFEN_MEMBERS`)
       * @property {boolean} [force] Whether to skip the cache check and call the API directly
       * @property {boolean} [fetchWhenExisting=true] Whether to fetch the user if not cached and already a member
       */
      /**
       * Adds a user to the guild using OAuth2. Requires the `CREATE_INSTANT_INVITE` permission.
       * @param {UserResolvable} user The user to add to the guild
       * @param {AddGuildMemberOptions} options Options for adding the user to the guild
       * @returns {Promise<GuildMember|null>}
       */
      async add(user, options) {
        const userId = this.client.users.resolveId(user);
        if (!userId) throw new TypeError2("INVALID_TYPE", "user", "UserResolvable");
        if (!options.force) {
          const cachedUser = this.cache.get(userId);
          if (cachedUser) return cachedUser;
        }
        const resolvedOptions = {
          access_token: options.accessToken,
          nick: options.nick,
          mute: options.mute,
          deaf: options.deaf
        };
        if (options.roles) {
          if (!Array.isArray(options.roles) && !(options.roles instanceof Collection2)) {
            throw new TypeError2("INVALID_TYPE", "options.roles", "Array or Collection of Roles or Snowflakes", true);
          }
          const resolvedRoles = [];
          for (const role of options.roles.values()) {
            const resolvedRole = this.guild.roles.resolveId(role);
            if (!resolvedRole) throw new TypeError2("INVALID_ELEMENT", "Array or Collection", "options.roles", role);
            resolvedRoles.push(resolvedRole);
          }
          resolvedOptions.roles = resolvedRoles;
        }
        const data = await this.client.api.guilds(this.guild.id).members(userId).put({ data: resolvedOptions });
        return data instanceof Buffer2 ? options.fetchWhenExisting === false ? null : this.fetch(userId) : this._add(data);
      }
      /**
       * The client user as a GuildMember of this guild
       * @type {?GuildMember}
       * @readonly
       */
      get me() {
        return this.resolve(this.client.user.id) ?? (this.client.options.partials.includes(PartialTypes.GUILD_MEMBER) ? this._add({ user: { id: this.client.user.id } }, true) : null);
      }
      /**
       * Options used to fetch a single member from a guild.
       * @typedef {BaseFetchOptions} FetchMemberOptions
       * @property {UserResolvable} user The user to fetch
       */
      /**
       * Options used to fetch multiple members from a guild.
       * @typedef {Object} FetchMembersOptions
       * @property {UserResolvable|UserResolvable[]} user The user(s) to fetch
       * @property {?string} query Limit fetch to members with similar usernames
       * @property {number} [limit=0] Maximum number of members to request
       * @property {boolean} [withPresences=false] Whether or not to include the presences
       * @property {number} [time=120e3] Timeout for receipt of members
       * @property {?string} nonce Nonce for this request (32 characters max - default to base 16 now timestamp)
       * @property {boolean} [force=false] Whether to skip the cache check and request the API
       */
      /**
       * Fetches member(s) from Discord, even if they're offline.
       * @param {UserResolvable|FetchMemberOptions|FetchMembersOptions} [options] If a UserResolvable, the user to fetch.
       * If undefined, fetches all members.
       * If a query, it limits the results to users with similar usernames.
       * @returns {Promise<GuildMember|Collection<Snowflake, GuildMember>>}
       * @example
       * // Fetch all members from a guild
       * guild.members.fetch()
       *   .then(console.log)
       *   .catch(console.error);
       * @example
       * // Fetch a single member
       * guild.members.fetch('66564597481480192')
       *   .then(console.log)
       *   .catch(console.error);
       * @example
       * // Fetch a single member without checking cache
       * guild.members.fetch({ user, force: true })
       *   .then(console.log)
       *   .catch(console.error)
       * @example
       * // Fetch a single member without caching
       * guild.members.fetch({ user, cache: false })
       *   .then(console.log)
       *   .catch(console.error);
       * @example
       * // Fetch by an array of users including their presences
       * guild.members.fetch({ user: ['66564597481480192', '191615925336670208'], withPresences: true })
       *   .then(console.log)
       *   .catch(console.error);
       * @example
       * // Fetch by query
       * guild.members.fetch({ query: 'hydra', limit: 1 })
       *   .then(console.log)
       *   .catch(console.error);
       */
      fetch(options) {
        if (!options) {
          if (this.me.permissions.has("KICK_MEMBERS") || this.me.permissions.has("BAN_MEMBERS") || this.me.permissions.has("MANAGE_ROLES")) {
            return this._fetchMany();
          } else {
            return this.fetchByMemberSafety();
          }
        }
        const user = this.client.users.resolveId(options);
        if (user) return this._fetchSingle({ user, cache: true });
        if (options.user) {
          if (Array.isArray(options.user)) {
            options.user = options.user.map((u) => this.client.users.resolveId(u));
            return this._fetchMany(options);
          } else {
            options.user = this.client.users.resolveId(options.user);
          }
          if (!options.limit && !options.withPresences) return this._fetchSingle(options);
        }
        return this._fetchMany(options);
      }
      /**
       * Fetches the client user as a GuildMember of the guild.
       * @param {BaseFetchOptions} [options] The options for fetching the member
       * @returns {Promise<GuildMember>}
       */
      fetchMe(options) {
        return this.fetch({ ...options, user: this.client.user.id });
      }
      /**
       * Options used for searching guild members.
       * @typedef {Object} GuildSearchMembersOptions
       * @property {string} query Filter members whose username or nickname start with this query
       * @property {number} [limit=1] Maximum number of members to search
       * @property {boolean} [cache=true] Whether or not to cache the fetched member(s)
       */
      /**
       * Searches for members in the guild based on a query.
       * @param {GuildSearchMembersOptions} options Options for searching members
       * @returns {Promise<Collection<Snowflake, GuildMember>>}
       */
      async search({ query, limit = 1, cache = true } = {}) {
        const data = await this.client.api.guilds(this.guild.id).members.search.get({ query: { query, limit } });
        return data.reduce((col, member) => col.set(member.user.id, this._add(member, cache)), new Collection2());
      }
      /**
       * Options used for listing guild members.
       * @typedef {Object} GuildListMembersOptions
       * @property {Snowflake} [after] Limit fetching members to those with an id greater than the supplied id
       * @property {number} [limit=1] Maximum number of members to list
       * @property {boolean} [cache=true] Whether or not to cache the fetched member(s)
       */
      /**
       * Lists up to 1000 members of the guild.
       * @param {GuildListMembersOptions} [options] Options for listing members
       * @returns {Promise<Collection<Snowflake, GuildMember>>}
       */
      async list({ after, limit = 1, cache = true } = {}) {
        const data = await this.client.api.guilds(this.guild.id).members.get({ query: { after, limit } });
        return data.reduce((col, member) => col.set(member.user.id, this._add(member, cache)), new Collection2());
      }
      /**
       * The data for editing a guild member.
       * @typedef {Object} GuildMemberEditData
       * @property {?string} [nick] The nickname to set for the member
       * @property {Collection<Snowflake, Role>|RoleResolvable[]} [roles] The roles or role ids to apply
       * @property {boolean} [mute] Whether or not the member should be muted
       * @property {boolean} [deaf] Whether or not the member should be deafened
       * @property {GuildVoiceChannelResolvable|null} [channel] Channel to move the member to
       * (if they are connected to voice), or `null` if you want to disconnect them from voice
       * @property {DateResolvable|null} [communicationDisabledUntil] The date or timestamp
       * for the member's communication to be disabled until. Provide `null` to enable communication again.
       * @property {GuildMemberFlagsResolvable} [flags] The flags to set for the member
       * @property {?(BufferResolvable|Base64Resolvable)} [avatar] The new guild avatar
       * @property {?(BufferResolvable|Base64Resolvable)} [banner] The new guild banner
       * @property {?string} [bio] The new guild about me
       */
      /**
       * Edits a member of the guild.
       * <info>The user must be a member of the guild</info>
       * @param {UserResolvable} user The member to edit
       * @param {GuildMemberEditData} data The data to edit the member with
       * @param {string} [reason] Reason for editing this user
       * @returns {Promise<GuildMember>}
       */
      async edit(user, data, reason) {
        var _a;
        const id = this.client.users.resolveId(user);
        if (!id) throw new TypeError2("INVALID_TYPE", "user", "UserResolvable");
        const _data = { ...data };
        if (_data.channel) {
          _data.channel = this.guild.channels.resolve(_data.channel);
          if (!(_data.channel instanceof BaseGuildVoiceChannel)) {
            throw new Error2("GUILD_VOICE_CHANNEL_RESOLVE");
          }
          _data.channel_id = _data.channel.id;
          _data.channel = void 0;
        } else if (_data.channel === null) {
          _data.channel_id = null;
          _data.channel = void 0;
        }
        _data.roles && (_data.roles = _data.roles.map((role) => role instanceof Role ? role.id : role));
        _data.communication_disabled_until = _data.communicationDisabledUntil && new Date(_data.communicationDisabledUntil).toISOString();
        _data.flags = _data.flags && GuildMemberFlags.resolve(_data.flags);
        if (typeof _data.avatar !== "undefined") {
          _data.avatar = await DataResolver2.resolveImage(_data.avatar);
        }
        if (typeof _data.banner !== "undefined") {
          _data.banner = await DataResolver2.resolveImage(_data.banner);
        }
        let endpoint = this.client.api.guilds(this.guild.id);
        if (id === this.client.user.id) {
          const keys = Object.keys(data);
          if (keys.length === 1 && ["nick", "avatar", "banner", "bio"].includes(keys[0])) {
            endpoint = endpoint.members("@me");
          } else {
            endpoint = endpoint.members(id);
          }
        } else {
          endpoint = endpoint.members(id);
        }
        const d = await endpoint.patch({ data: _data, reason });
        const clone = (_a = this.cache.get(id)) == null ? void 0 : _a._clone();
        clone == null ? void 0 : clone._patch(d);
        return clone ?? this._add(d, false);
      }
      /**
       * Options used for pruning guild members.
       * <info>It's recommended to set {@link GuildPruneMembersOptions#count options.count}
       * to `false` for large guilds.</info>
       * @typedef {Object} GuildPruneMembersOptions
       * @property {number} [days=7] Number of days of inactivity required to kick
       * @property {boolean} [dry=false] Get the number of users that will be kicked, without actually kicking them
       * @property {boolean} [count=true] Whether or not to return the number of users that have been kicked.
       * @property {RoleResolvable[]} [roles] Array of roles to bypass the "...and no roles" constraint when pruning
       * @property {string} [reason] Reason for this prune
       */
      /**
       * Prunes members from the guild based on how long they have been inactive.
       * @param {GuildPruneMembersOptions} [options] Options for pruning
       * @returns {Promise<number|null>} The number of members that were/will be kicked
       * @example
       * // See how many members will be pruned
       * guild.members.prune({ dry: true })
       *   .then(pruned => console.log(`This will prune ${pruned} people!`))
       *   .catch(console.error);
       * @example
       * // Actually prune the members
       * guild.members.prune({ days: 1, reason: 'too many people!' })
       *   .then(pruned => console.log(`I just pruned ${pruned} people!`))
       *   .catch(console.error);
       * @example
       * // Include members with a specified role
       * guild.members.prune({ days: 7, roles: ['657259391652855808'] })
       *    .then(pruned => console.log(`I just pruned ${pruned} people!`))
       *    .catch(console.error);
       */
      async prune({ days = 7, dry = false, count: compute_prune_count = true, roles = [], reason } = {}) {
        if (typeof days !== "number") throw new TypeError2("PRUNE_DAYS_TYPE");
        const query = { days };
        const resolvedRoles = [];
        for (const role of roles) {
          const resolvedRole = this.guild.roles.resolveId(role);
          if (!resolvedRole) {
            throw new TypeError2("INVALID_ELEMENT", "Array", "options.roles", role);
          }
          resolvedRoles.push(resolvedRole);
        }
        if (resolvedRoles.length) {
          query.include_roles = dry ? resolvedRoles.join(",") : resolvedRoles;
        }
        const endpoint = this.client.api.guilds(this.guild.id).prune;
        const { pruned } = await (dry ? endpoint.get({ query, reason }) : endpoint.post({ data: { ...query, compute_prune_count }, reason }));
        return pruned;
      }
      /**
       * Kicks a user from the guild.
       * <info>The user must be a member of the guild</info>
       * @param {UserResolvable} user The member to kick
       * @param {string} [reason] Reason for kicking
       * @returns {Promise<GuildMember|User|Snowflake>} Result object will be resolved as specifically as possible.
       * If the GuildMember cannot be resolved, the User will instead be attempted to be resolved. If that also cannot
       * be resolved, the user's id will be the result.
       * @example
       * // Kick a user by id (or with a user/guild member object)
       * guild.members.kick('84484653687267328')
       *   .then(kickInfo => console.log(`Kicked ${kickInfo.user?.tag ?? kickInfo.tag ?? kickInfo}`))
       *   .catch(console.error);
       */
      async kick(user, reason) {
        const id = this.client.users.resolveId(user);
        if (!id) return Promise.reject(new TypeError2("INVALID_TYPE", "user", "UserResolvable"));
        await this.client.api.guilds(this.guild.id).members(id).delete({ reason });
        return this.resolve(user) ?? this.client.users.resolve(user) ?? id;
      }
      /**
       * Bans a user from the guild.
       * @param {UserResolvable} user The user to ban
       * @param {BanOptions} [options] Options for the ban
       * @returns {Promise<GuildMember|User|Snowflake>} Result object will be resolved as specifically as possible.
       * If the GuildMember cannot be resolved, the User will instead be attempted to be resolved. If that also cannot
       * be resolved, the user id will be the result.
       * Internally calls the GuildBanManager#create method.
       * @example
       * // Ban a user by id (or with a user/guild member object)
       * guild.members.ban('84484653687267328')
       *   .then(banInfo => console.log(`Banned ${banInfo.user?.tag ?? banInfo.tag ?? banInfo}`))
       *   .catch(console.error);
       */
      ban(user, options) {
        return this.guild.bans.create(user, options);
      }
      /**
       * Unbans a user from the guild. Internally calls the {@link GuildBanManager#remove} method.
       * @param {UserResolvable} user The user to unban
       * @param {string} [reason] Reason for unbanning user
       * @returns {Promise<?User>} The user that was unbanned
       * @example
       * // Unban a user by id (or with a user/guild member object)
       * guild.members.unban('84484653687267328')
       *   .then(user => console.log(`Unbanned ${user.username} from ${guild.name}`))
       *   .catch(console.error);
       */
      unban(user, reason) {
        return this.guild.bans.remove(user, reason);
      }
      async _fetchSingle({ user, cache, force = false }) {
        if (!force) {
          const existing = this.cache.get(user);
          if (existing && !existing.partial) return existing;
        }
        const data = await this.client.api.guilds(this.guild.id).members(user).get();
        return this._add(data, cache);
      }
      /**
       * Adds a role to a member.
       * @param {GuildMemberResolvable} user The user to add the role from
       * @param {RoleResolvable} role The role to add
       * @param {string} [reason] Reason for adding the role
       * @returns {Promise<GuildMember|User|Snowflake>}
       */
      async addRole(user, role, reason) {
        const userId = this.guild.members.resolveId(user);
        const roleId = this.guild.roles.resolveId(role);
        await this.client.api.guilds(this.guild.id).members(userId).roles(roleId).put({ reason });
        return this.resolve(user) ?? this.client.users.resolve(user) ?? userId;
      }
      /**
       * Removes a role from a member.
       * @param {UserResolvable} user The user to remove the role from
       * @param {RoleResolvable} role The role to remove
       * @param {string} [reason] Reason for removing the role
       * @returns {Promise<GuildMember|User|Snowflake>}
       */
      async removeRole(user, role, reason) {
        const userId = this.guild.members.resolveId(user);
        const roleId = this.guild.roles.resolveId(role);
        await this.client.api.guilds(this.guild.id).members(userId).roles(roleId).delete({ reason });
        return this.resolve(user) ?? this.client.users.resolve(user) ?? userId;
      }
      /**
       * Experimental method to fetch members from the guild.
       * <info>Lists up to 10000 members of the guild.</info>
       * @param {number} [timeout=15_000] Timeout for receipt of members in ms
       * @returns {Promise<Collection<Snowflake, GuildMember>>}
       */
      fetchByMemberSafety(timeout = 15e3) {
        return new Promise((resolve) => {
          const nonce = SnowflakeUtil.generate();
          const fetchedMembers = new Collection2();
          let timeout_ = setTimeout2(() => {
            this.client.removeListener(Events2.GUILD_MEMBERS_CHUNK, handler);
            resolve(fetchedMembers);
          }, timeout).unref();
          const handler = (members, guild, chunk) => {
            var _a;
            if (guild.id == this.guild.id && chunk.nonce == nonce) {
              if (members.size > 0) {
                for (const member of members.values()) {
                  fetchedMembers.set(member.id, member);
                }
                this.client.ws.broadcast({
                  op: Opcodes.SEARCH_RECENT_MEMBERS,
                  d: {
                    guild_id: this.guild.id,
                    query: "",
                    continuation_token: (_a = members.first()) == null ? void 0 : _a.id,
                    nonce
                  }
                });
              } else {
                clearTimeout(timeout_);
                this.client.removeListener(Events2.GUILD_MEMBERS_CHUNK, handler);
                resolve(fetchedMembers);
              }
            }
          };
          this.client.on(Events2.GUILD_MEMBERS_CHUNK, handler);
          this.client.ws.broadcast({
            op: Opcodes.SEARCH_RECENT_MEMBERS,
            d: {
              guild_id: this.guild.id,
              query: "",
              continuation_token: null,
              nonce
            }
          });
        });
      }
      _fetchMany({
        limit = 0,
        withPresences: presences = true,
        user: user_ids,
        query,
        time = 12e4,
        nonce = SnowflakeUtil.generate()
      } = {}) {
        return new Promise((resolve, reject) => {
          if (!query && !user_ids) query = "";
          if (nonce.length > 32) throw new RangeError2("MEMBER_FETCH_NONCE_LENGTH");
          this.guild.shard.send({
            op: Opcodes.REQUEST_GUILD_MEMBERS,
            d: {
              guild_id: this.guild.id,
              presences,
              user_ids,
              query,
              nonce,
              limit
            }
          });
          const fetchedMembers = new Collection2();
          let i = 0;
          const handler = (members, _, chunk) => {
            timeout.refresh();
            if (chunk.nonce !== nonce) return;
            i++;
            for (const member of members.values()) {
              fetchedMembers.set(member.id, member);
            }
            if (members.size < 1e3 || limit && fetchedMembers.size >= limit || i === chunk.count) {
              clearTimeout(timeout);
              this.client.removeListener(Events2.GUILD_MEMBERS_CHUNK, handler);
              this.client.decrementMaxListeners();
              let fetched = fetchedMembers;
              if (user_ids && !Array.isArray(user_ids) && fetched.size) fetched = fetched.first();
              resolve(fetched);
            }
          };
          const timeout = setTimeout2(() => {
            this.client.removeListener(Events2.GUILD_MEMBERS_CHUNK, handler);
            this.client.decrementMaxListeners();
            reject(new Error2("GUILD_MEMBERS_TIMEOUT"));
          }, time).unref();
          this.client.incrementMaxListeners();
          this.client.on(Events2.GUILD_MEMBERS_CHUNK, handler);
        });
      }
      /**
       * Bulk ban users from a guild, and optionally delete previous messages sent by them.
       * @param {Collection<Snowflake, UserResolvable>|UserResolvable[]} users The users to ban
       * @param {BulkBanOptions} [options] The options for bulk banning users
       * @returns {Promise<BulkBanResult>} Returns an object with `bannedUsers` key containing the IDs of the banned users
       * and the key `failedUsers` with the IDs that could not be banned or were already banned.
       * Internally calls the GuildBanManager#bulkCreate method.
       * @example
       * // Bulk ban users by ids (or with user/guild member objects) and delete all their messages from the past 7 days
       * guild.members.bulkBan(['84484653687267328'], { deleteMessageSeconds: 7 * 24 * 60 * 60 })
       *   .then(result => {
       *     console.log(`Banned ${result.bannedUsers.length} users, failed to ban ${result.failedUsers.length} users.`)
       *   })
       *   .catch(console.error);
       * @deprecated This method will not be usable until an effective MFA implementation is in place.
       */
      bulkBan(users, options = {}) {
        return this.guild.bans.bulkCreate(users, options);
      }
    };
    module2.exports = GuildMemberManager;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/managers/GuildScheduledEventManager.js
var require_GuildScheduledEventManager = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/managers/GuildScheduledEventManager.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var CachedManager = require_CachedManager();
    var { TypeError: TypeError2, Error: Error2 } = require_errors2();
    var { GuildScheduledEvent } = require_GuildScheduledEvent();
    var { PrivacyLevels, GuildScheduledEventEntityTypes, GuildScheduledEventStatuses } = require_Constants();
    var DataResolver2 = require_DataResolver();
    var GuildScheduledEventManager = class extends CachedManager {
      constructor(guild, iterable) {
        super(guild.client, GuildScheduledEvent, iterable);
        this.guild = guild;
      }
      /**
       * The cache of this manager
       * @type {Collection<Snowflake, GuildScheduledEvent>}
       * @name GuildScheduledEventManager#cache
       */
      /**
       * Data that resolves to give a GuildScheduledEvent object. This can be:
       * * A Snowflake
       * * A GuildScheduledEvent object
       * @typedef {Snowflake|GuildScheduledEvent} GuildScheduledEventResolvable
       */
      /**
       * Options used to create a guild scheduled event.
       * @typedef {Object} GuildScheduledEventCreateOptions
       * @property {string} name The name of the guild scheduled event
       * @property {DateResolvable} scheduledStartTime The time to schedule the event at
       * @property {DateResolvable} [scheduledEndTime] The time to end the event at
       * <warn>This is required if `entityType` is 'EXTERNAL'</warn>
       * @property {PrivacyLevel|number} privacyLevel The privacy level of the guild scheduled event
       * @property {GuildScheduledEventEntityType|number} entityType The scheduled entity type of the event
       * @property {string} [description] The description of the guild scheduled event
       * @property {GuildVoiceChannelResolvable} [channel] The channel of the guild scheduled event
       * <warn>This is required if `entityType` is 'STAGE_INSTANCE' or `VOICE`</warn>
       * @property {GuildScheduledEventEntityMetadataOptions} [entityMetadata] The entity metadata of the
       * guild scheduled event
       * <warn>This is required if `entityType` is 'EXTERNAL'</warn>
       * @property {?(BufferResolvable|Base64Resolvable)} [image] The cover image of the guild scheduled event
       * @property {string} [reason] The reason for creating the guild scheduled event
       */
      /**
       * Options used to set entity metadata of a guild scheduled event.
       * @typedef {Object} GuildScheduledEventEntityMetadataOptions
       * @property {string} [location] The location of the guild scheduled event
       * <warn>This is required if `entityType` is 'EXTERNAL'</warn>
       */
      /**
       * Creates a new guild scheduled event.
       * @param {GuildScheduledEventCreateOptions} options Options for creating the guild scheduled event
       * @returns {Promise<GuildScheduledEvent>}
       */
      async create(options) {
        if (typeof options !== "object") throw new TypeError2("INVALID_TYPE", "options", "object", true);
        let {
          privacyLevel,
          entityType,
          channel,
          name,
          scheduledStartTime,
          description,
          scheduledEndTime,
          entityMetadata,
          reason,
          image
        } = options;
        if (typeof privacyLevel === "string") privacyLevel = PrivacyLevels[privacyLevel];
        if (typeof entityType === "string") entityType = GuildScheduledEventEntityTypes[entityType];
        let entity_metadata, channel_id;
        if (entityType === GuildScheduledEventEntityTypes.EXTERNAL) {
          channel_id = typeof channel === "undefined" ? channel : null;
          entity_metadata = { location: entityMetadata == null ? void 0 : entityMetadata.location };
        } else {
          channel_id = this.guild.channels.resolveId(channel);
          if (!channel_id) throw new Error2("GUILD_VOICE_CHANNEL_RESOLVE");
          entity_metadata = typeof entityMetadata === "undefined" ? entityMetadata : null;
        }
        const data = await this.client.api.guilds(this.guild.id, "scheduled-events").post({
          data: {
            channel_id,
            name,
            privacy_level: privacyLevel,
            scheduled_start_time: new Date(scheduledStartTime).toISOString(),
            scheduled_end_time: scheduledEndTime ? new Date(scheduledEndTime).toISOString() : scheduledEndTime,
            description,
            image: image && await DataResolver2.resolveImage(image),
            entity_type: entityType,
            entity_metadata
          },
          reason
        });
        return this._add(data);
      }
      /**
       * Options used to fetch a single guild scheduled event from a guild.
       * @typedef {BaseFetchOptions} FetchGuildScheduledEventOptions
       * @property {GuildScheduledEventResolvable} guildScheduledEvent The guild scheduled event to fetch
       * @property {boolean} [withUserCount=true] Whether to fetch the number of users subscribed to the scheduled event
       */
      /**
       * Options used to fetch multiple guild scheduled events from a guild.
       * @typedef {Object} FetchGuildScheduledEventsOptions
       * @property {boolean} [cache] Whether or not to cache the fetched guild scheduled events
       * @property {boolean} [withUserCount=true] Whether to fetch the number of users subscribed to each scheduled event
       * should be returned
       */
      /**
       * Obtains one or more guild scheduled events from Discord, or the guild cache if it's already available.
       * @param {GuildScheduledEventResolvable|FetchGuildScheduledEventOptions|FetchGuildScheduledEventsOptions} [options]
       * The id of the guild scheduled event or options
       * @returns {Promise<GuildScheduledEvent|Collection<Snowflake, GuildScheduledEvent>>}
       */
      async fetch(options = {}) {
        const id = this.resolveId(options.guildScheduledEvent ?? options);
        if (id) {
          if (!options.force) {
            const existing = this.cache.get(id);
            if (existing) return existing;
          }
          const data2 = await this.client.api.guilds(this.guild.id, "scheduled-events", id).get({ query: { with_user_count: options.withUserCount ?? true } });
          return this._add(data2, options.cache);
        }
        const data = await this.client.api.guilds(this.guild.id, "scheduled-events").get({ query: { with_user_count: options.withUserCount ?? true } });
        return data.reduce(
          (coll, rawGuildScheduledEventData) => coll.set(
            rawGuildScheduledEventData.id,
            this.guild.scheduledEvents._add(rawGuildScheduledEventData, options.cache)
          ),
          new Collection2()
        );
      }
      /**
       * Options used to edit a guild scheduled event.
       * @typedef {Object} GuildScheduledEventEditOptions
       * @property {string} [name] The name of the guild scheduled event
       * @property {DateResolvable} [scheduledStartTime] The time to schedule the event at
       * @property {DateResolvable} [scheduledEndTime] The time to end the event at
       * @property {PrivacyLevel|number} [privacyLevel] The privacy level of the guild scheduled event
       * @property {GuildScheduledEventEntityType|number} [entityType] The scheduled entity type of the event
       * @property {string} [description] The description of the guild scheduled event
       * @property {?GuildVoiceChannelResolvable} [channel] The channel of the guild scheduled event
       * @property {GuildScheduledEventStatus|number} [status] The status of the guild scheduled event
       * @property {GuildScheduledEventEntityMetadataOptions} [entityMetadata] The entity metadata of the
       * guild scheduled event
       * <warn>This can be modified only if `entityType` of the `GuildScheduledEvent` to be edited is 'EXTERNAL'</warn>
       * @property {?(BufferResolvable|Base64Resolvable)} [image] The cover image of the guild scheduled event
       * @property {string} [reason] The reason for editing the guild scheduled event
       */
      /**
       * Edits a guild scheduled event.
       * @param {GuildScheduledEventResolvable} guildScheduledEvent The guild scheduled event to edit
       * @param {GuildScheduledEventEditOptions} options Options to edit the guild scheduled event
       * @returns {Promise<GuildScheduledEvent>}
       */
      async edit(guildScheduledEvent, options) {
        const guildScheduledEventId = this.resolveId(guildScheduledEvent);
        if (!guildScheduledEventId) throw new Error2("GUILD_SCHEDULED_EVENT_RESOLVE");
        if (typeof options !== "object") throw new TypeError2("INVALID_TYPE", "options", "object", true);
        let {
          privacyLevel,
          entityType,
          channel,
          status,
          name,
          scheduledStartTime,
          description,
          scheduledEndTime,
          entityMetadata,
          reason,
          image
        } = options;
        if (typeof privacyLevel === "string") privacyLevel = PrivacyLevels[privacyLevel];
        if (typeof entityType === "string") entityType = GuildScheduledEventEntityTypes[entityType];
        if (typeof status === "string") status = GuildScheduledEventStatuses[status];
        let entity_metadata;
        if (entityMetadata) {
          entity_metadata = {
            location: entityMetadata.location
          };
        }
        const data = await this.client.api.guilds(this.guild.id, "scheduled-events", guildScheduledEventId).patch({
          data: {
            channel_id: typeof channel === "undefined" ? channel : this.guild.channels.resolveId(channel),
            name,
            privacy_level: privacyLevel,
            scheduled_start_time: scheduledStartTime ? new Date(scheduledStartTime).toISOString() : void 0,
            scheduled_end_time: scheduledEndTime ? new Date(scheduledEndTime).toISOString() : scheduledEndTime,
            description,
            entity_type: entityType,
            status,
            image: image && await DataResolver2.resolveImage(image),
            entity_metadata
          },
          reason
        });
        return this._add(data);
      }
      /**
       * Deletes a guild scheduled event.
       * @param {GuildScheduledEventResolvable} guildScheduledEvent The guild scheduled event to delete
       * @returns {Promise<void>}
       */
      async delete(guildScheduledEvent) {
        const guildScheduledEventId = this.resolveId(guildScheduledEvent);
        if (!guildScheduledEventId) throw new Error2("GUILD_SCHEDULED_EVENT_RESOLVE");
        await this.client.api.guilds(this.guild.id, "scheduled-events", guildScheduledEventId).delete();
      }
      /**
       * Options used to fetch subscribers of a guild scheduled event
       * @typedef {Object} FetchGuildScheduledEventSubscribersOptions
       * @property {number} [limit] The maximum numbers of users to fetch
       * @property {boolean} [withMember] Whether to fetch guild member data of the users
       * @property {Snowflake} [before] Consider only users before this user id
       * @property {Snowflake} [after] Consider only users after this user id
       * <warn>If both `before` and `after` are provided, only `before` is respected</warn>
       */
      /**
       * Represents a subscriber of a {@link GuildScheduledEvent}
       * @typedef {Object} GuildScheduledEventUser
       * @property {Snowflake} guildScheduledEventId The id of the guild scheduled event which the user subscribed to
       * @property {User} user The user that subscribed to the guild scheduled event
       * @property {?GuildMember} member The guild member associated with the user, if any
       */
      /**
       * Fetches subscribers of a guild scheduled event.
       * @param {GuildScheduledEventResolvable} guildScheduledEvent The guild scheduled event to fetch subscribers of
       * @param {FetchGuildScheduledEventSubscribersOptions} [options={}] Options for fetching the subscribers
       * @returns {Promise<Collection<Snowflake, GuildScheduledEventUser>>}
       */
      async fetchSubscribers(guildScheduledEvent, options = {}) {
        const guildScheduledEventId = this.resolveId(guildScheduledEvent);
        if (!guildScheduledEventId) throw new Error2("GUILD_SCHEDULED_EVENT_RESOLVE");
        let { limit, withMember, before, after } = options;
        const data = await this.client.api.guilds(this.guild.id, "scheduled-events", guildScheduledEventId).users.get({
          query: { limit, with_member: withMember, before, after }
        });
        return data.reduce(
          (coll, rawData) => coll.set(rawData.user.id, {
            guildScheduledEventId: rawData.guild_scheduled_event_id,
            user: this.client.users._add(rawData.user),
            member: rawData.member ? this.guild.members._add({ ...rawData.member, user: rawData.user }) : null
          }),
          new Collection2()
        );
      }
    };
    module2.exports = GuildScheduledEventManager;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/managers/GuildSettingManager.js
var require_GuildSettingManager = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/managers/GuildSettingManager.js"(exports2, module2) {
    "use strict";
    var BaseManager = require_BaseManager();
    var _rawSetting;
    var GuildSettingManager = class extends BaseManager {
      constructor(guild) {
        super(guild.client);
        __privateAdd(this, _rawSetting, {});
        this.guildId = guild.id;
      }
      /**
       * Raw data
       * @type {Object}
       */
      get raw() {
        return __privateGet(this, _rawSetting);
      }
      /**
       * Get the guild
       * @type {?Guild}
       * @readonly
       */
      get guild() {
        return this.client.guilds.cache.get(this.guildId);
      }
      /**
       * Patch data file
       * @private
       * @param {Object} data Raw Data to patch
       */
      _patch(data = {}) {
        __privateSet(this, _rawSetting, Object.assign(__privateGet(this, _rawSetting), data));
        this.client.emit("debug", `[SETTING > Guild ${this.guildId}] Sync setting`);
        if ("suppress_everyone" in data) {
          this.suppressEveryone = data.suppress_everyone;
        }
        if ("suppress_roles" in data) {
          this.suppressRoles = data.suppress_roles;
        }
        if ("mute_scheduled_events" in data) {
          this.muteScheduledEvents = data.mute_scheduled_events;
        }
        if ("message_notifications" in data) {
          this.messageNotifications = data.message_notifications;
        }
        if ("flags" in data) {
          this.flags = data.flags;
        }
        if ("mobile_push" in data) {
          this.mobilePush = data.mobile_push;
        }
        if ("muted" in data) {
          this.muted = data.muted;
        }
        if ("mute_config" in data && data.mute_config !== null) {
          this.muteConfig = {
            endTime: new Date(data.mute_config.end_time),
            selectedTimeWindow: data.mute_config.selected_time_window
          };
        } else {
          this.muteConfig = null;
        }
        if ("hide_muted_channels" in data) {
          this.hideMutedChannels = data.hide_muted_channels;
        }
        if ("channel_overrides" in data) {
          this.channelOverrides = data.channel_overrides;
        }
        if ("notify_highlights" in data) {
          this.notifyHighlights = data.notify_highlights;
        }
        if ("version" in data) {
          this.version = data.version;
        }
      }
      /**
       * Edit guild settings
       * @param {Object} data Data to edit
       * @returns {Promise<GuildSettingManager>}
       */
      async edit(data) {
        const data_ = await this.client.api.users("@me").settings.patch(data);
        this._patch(data_);
        return this;
      }
    };
    _rawSetting = new WeakMap();
    module2.exports = GuildSettingManager;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/managers/GuildStickerManager.js
var require_GuildStickerManager = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/managers/GuildStickerManager.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var CachedManager = require_CachedManager();
    var { TypeError: TypeError2 } = require_errors2();
    var MessagePayload = require_MessagePayload();
    var { Sticker: Sticker2 } = require_Sticker();
    var GuildStickerManager = class extends CachedManager {
      constructor(guild, iterable) {
        super(guild.client, Sticker2, iterable);
        this.guild = guild;
      }
      /**
       * The cache of Guild Stickers
       * @type {Collection<Snowflake, Sticker>}
       * @name GuildStickerManager#cache
       */
      _add(data, cache) {
        return super._add(data, cache, { extras: [this.guild] });
      }
      /**
       * Options for creating a guild sticker.
       * @typedef {Object} GuildStickerCreateOptions
       * @property {?string} [description] The description for the sticker
       * @property {string} [reason] Reason for creating the sticker
       */
      /**
       * Creates a new custom sticker in the guild.
       * @param {BufferResolvable|Stream|FileOptions|MessageAttachment} file The file for the sticker
       * @param {string} name The name for the sticker
       * @param {string} tags The Discord name of a unicode emoji representing the sticker's expression
       * @param {GuildStickerCreateOptions} [options] Options
       * @returns {Promise<Sticker>} The created sticker
       * @example
       * // Create a new sticker from a URL
       * guild.stickers.create('https://i.imgur.com/w3duR07.png', 'rip', 'headstone')
       *   .then(sticker => console.log(`Created new sticker with name ${sticker.name}!`))
       *   .catch(console.error);
       * @example
       * // Create a new sticker from a file on your computer
       * guild.stickers.create('./memes/banana.png', 'banana', 'banana')
       *   .then(sticker => console.log(`Created new sticker with name ${sticker.name}!`))
       *   .catch(console.error);
       */
      async create(file, name, tags, { description, reason } = {}) {
        const resolvedFile = await MessagePayload.resolveFile(file);
        if (!resolvedFile) throw new TypeError2("REQ_RESOURCE_TYPE");
        file = { ...resolvedFile, key: "file" };
        const data = { name, tags, description: description ?? "" };
        const sticker = await this.client.api.guilds(this.guild.id).stickers.post({ data, files: [file], reason, dontUsePayloadJSON: true });
        return this.client.actions.GuildStickerCreate.handle(this.guild, sticker).sticker;
      }
      /**
       * Data that resolves to give a Sticker object. This can be:
       * * A Sticker object
       * * A Snowflake
       * @typedef {Sticker|Snowflake} StickerResolvable
       */
      /**
       * Resolves a StickerResolvable to a Sticker object.
       * @method resolve
       * @memberof GuildStickerManager
       * @instance
       * @param {StickerResolvable} sticker The Sticker resolvable to identify
       * @returns {?Sticker}
       */
      /**
       * Resolves a StickerResolvable to a Sticker id string.
       * @method resolveId
       * @memberof GuildStickerManager
       * @instance
       * @param {StickerResolvable} sticker The Sticker resolvable to identify
       * @returns {?Snowflake}
       */
      /**
       * Edits a sticker.
       * @param {StickerResolvable} sticker The sticker to edit
       * @param {GuildStickerEditData} [data] The new data for the sticker
       * @param {string} [reason] Reason for editing this sticker
       * @returns {Promise<Sticker>}
       */
      async edit(sticker, data, reason) {
        const stickerId = this.resolveId(sticker);
        if (!stickerId) throw new TypeError2("INVALID_TYPE", "sticker", "StickerResolvable");
        const d = await this.client.api.guilds(this.guild.id).stickers(stickerId).patch({
          data,
          reason
        });
        const existing = this.cache.get(stickerId);
        if (existing) {
          const clone = existing._clone();
          clone._patch(d);
          return clone;
        }
        return this._add(d);
      }
      /**
       * Deletes a sticker.
       * @param {StickerResolvable} sticker The sticker to delete
       * @param {string} [reason] Reason for deleting this sticker
       * @returns {Promise<void>}
       */
      async delete(sticker, reason) {
        sticker = this.resolveId(sticker);
        if (!sticker) throw new TypeError2("INVALID_TYPE", "sticker", "StickerResolvable");
        await this.client.api.guilds(this.guild.id).stickers(sticker).delete({ reason });
      }
      /**
       * Obtains one or more stickers from Discord, or the sticker cache if they're already available.
       * @param {Snowflake} [id] The Sticker's id
       * @param {BaseFetchOptions} [options] Additional options for this fetch
       * @returns {Promise<Sticker|Collection<Snowflake, Sticker>>}
       * @example
       * // Fetch all stickers from the guild
       * message.guild.stickers.fetch()
       *   .then(stickers => console.log(`There are ${stickers.size} stickers.`))
       *   .catch(console.error);
       * @example
       * // Fetch a single sticker
       * message.guild.stickers.fetch('222078108977594368')
       *   .then(sticker => console.log(`The sticker name is: ${sticker.name}`))
       *   .catch(console.error);
       */
      async fetch(id, { cache = true, force = false } = {}) {
        if (id) {
          if (!force) {
            const existing = this.cache.get(id);
            if (existing) return existing;
          }
          const sticker = await this.client.api.guilds(this.guild.id).stickers(id).get();
          return this._add(sticker, cache);
        }
        const data = await this.client.api.guilds(this.guild.id).stickers.get();
        return new Collection2(data.map((sticker) => [sticker.id, this._add(sticker, cache)]));
      }
      /**
       * Fetches the user who uploaded this sticker, if this is a guild sticker.
       * @param {StickerResolvable} sticker The sticker to fetch the user for
       * @returns {Promise<?User>}
       */
      async fetchUser(sticker) {
        sticker = this.resolve(sticker);
        if (!sticker) throw new TypeError2("INVALID_TYPE", "sticker", "StickerResolvable");
        const data = await this.client.api.guilds(this.guild.id).stickers(sticker.id).get();
        sticker._patch(data);
        return sticker.user;
      }
    };
    module2.exports = GuildStickerManager;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/Presence.js
var require_Presence = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/Presence.js"(exports2) {
    "use strict";
    var { randomUUID } = require_node_crypto();
    var Base = require_Base();
    var ActivityFlags = require_ActivityFlags();
    var { ActivityTypes } = require_Constants();
    var Util = require_Util();
    var Presence = class extends Base {
      constructor(client, data = {}) {
        super(client);
        this.userId = data.user.id;
        this.guild = data.guild ?? null;
        this._patch(data);
      }
      /**
       * The user of this presence
       * @type {?User}
       * @readonly
       */
      get user() {
        return this.client.users.resolve(this.userId);
      }
      /**
       * The member of this presence
       * @type {?GuildMember}
       * @readonly
       */
      get member() {
        return this.guild.members.resolve(this.userId);
      }
      _patch(data) {
        if ("status" in data) {
          this.status = data.status;
        } else {
          this.status ?? (this.status = "offline");
        }
        if ("activities" in data) {
          this.activities = data.activities.map((activity) => {
            if (this.userId == this.client.user.id) {
              if ([ActivityTypes.CUSTOM, "CUSTOM"].includes(activity.type)) {
                return new CustomStatus(this.client, activity);
              } else if (activity.id == "spotify:1") {
                return new SpotifyRPC(this.client, activity);
              } else {
                return new RichPresence(this.client, activity);
              }
            } else {
              return new Activity(this, activity);
            }
          });
        } else {
          this.activities ?? (this.activities = []);
        }
        if ("client_status" in data) {
          this.clientStatus = data.client_status;
        } else {
          this.clientStatus ?? (this.clientStatus = null);
        }
        if ("last_modified" in data) {
          this.lastModified = data.last_modified;
        }
        if ("afk" in data) {
          this.afk = data.afk;
        } else {
          this.afk ?? (this.afk = false);
        }
        if ("since" in data) {
          this.since = data.since;
        } else {
          this.since ?? (this.since = 0);
        }
        return this;
      }
      _clone() {
        const clone = Object.assign(Object.create(this), this);
        clone.activities = this.activities.map((activity) => activity._clone());
        return clone;
      }
      /**
       * Whether this presence is equal to another.
       * @param {Presence} presence The presence to compare with
       * @returns {boolean}
       */
      equals(presence) {
        var _a, _b, _c, _d, _e, _f;
        return this === presence || presence && this.status === presence.status && ((_a = this.clientStatus) == null ? void 0 : _a.web) === ((_b = presence.clientStatus) == null ? void 0 : _b.web) && ((_c = this.clientStatus) == null ? void 0 : _c.mobile) === ((_d = presence.clientStatus) == null ? void 0 : _d.mobile) && ((_e = this.clientStatus) == null ? void 0 : _e.desktop) === ((_f = presence.clientStatus) == null ? void 0 : _f.desktop) && this.activities.length === presence.activities.length && this.activities.every((activity, index) => activity.equals(presence.activities[index]));
      }
      toJSON() {
        return Util.flatten(this);
      }
    };
    var Activity = class {
      constructor(presence, data) {
        if (!(presence instanceof Presence)) {
          throw new Error("Class constructor Activity cannot be invoked without 'presence'");
        }
        Object.defineProperty(this, "presence", { value: presence });
        this._patch(data);
      }
      _patch(data = {}) {
        var _a;
        if ("id" in data) {
          this.id = data.id;
        }
        if ("name" in data) {
          this.name = data.name;
        }
        if ("type" in data) {
          this.type = typeof data.type === "number" ? ActivityTypes[data.type] : data.type;
        }
        if ("url" in data) {
          this.url = data.url;
        } else {
          this.url = null;
        }
        if ("created_at" in data || "createdTimestamp" in data) {
          this.createdTimestamp = data.created_at || data.createdTimestamp;
        }
        if ("session_id" in data) {
          this.sessionId = data.session_id;
        } else {
          this.sessionId = (_a = this.presence.client) == null ? void 0 : _a.sessionId;
        }
        if ("platform" in data) {
          this.platform = data.platform;
        } else {
          this.platform = null;
        }
        if ("timestamps" in data && data.timestamps) {
          this.timestamps = {
            start: data.timestamps.start ? new Date(data.timestamps.start).getTime() : null,
            end: data.timestamps.end ? new Date(data.timestamps.end).getTime() : null
          };
        } else {
          this.timestamps = null;
        }
        if ("application_id" in data || "applicationId" in data) {
          this.applicationId = data.application_id || data.applicationId;
        } else {
          this.applicationId = null;
        }
        if ("details" in data) {
          this.details = data.details;
        } else {
          this.details = null;
        }
        if ("state" in data) {
          this.state = data.state;
        } else {
          this.state = null;
        }
        if ("sync_id" in data || "syncId" in data) {
          this.syncId = data.sync_id || data.syncId;
        } else {
          this.syncId = null;
        }
        if ("flags" in data) {
          this.flags = new ActivityFlags(data.flags).freeze();
        } else {
          this.flags = new ActivityFlags().freeze();
        }
        if ("buttons" in data) {
          this.buttons = data.buttons;
        } else {
          this.buttons = [];
        }
        if ("emoji" in data && data.emoji) {
          this.emoji = Util.resolvePartialEmoji(data.emoji);
        } else {
          this.emoji = null;
        }
        if ("party" in data) {
          this.party = data.party;
        } else {
          this.party = null;
        }
        this.assets = new RichPresenceAssets(this, data.assets);
      }
      /**
       * Whether this activity is equal to another activity.
       * @param {Activity} activity The activity to compare with
       * @returns {boolean}
       */
      equals(activity) {
        var _a, _b, _c, _d;
        return this === activity || activity && this.name === activity.name && this.type === activity.type && this.url === activity.url && this.state === activity.state && this.details === activity.details && ((_a = this.emoji) == null ? void 0 : _a.id) === ((_b = activity.emoji) == null ? void 0 : _b.id) && ((_c = this.emoji) == null ? void 0 : _c.name) === ((_d = activity.emoji) == null ? void 0 : _d.name);
      }
      /**
       * The time the activity was created at
       * @type {Date}
       * @readonly
       */
      get createdAt() {
        return new Date(this.createdTimestamp);
      }
      /**
       * When concatenated with a string, this automatically returns the activities' name instead of the Activity object.
       * @returns {string}
       */
      toString() {
        return this.name;
      }
      _clone() {
        return Object.assign(Object.create(this), this);
      }
      toJSON(...props) {
        return Util.clearNullOrUndefinedObject({
          ...Util.flatten(this, ...props),
          type: typeof this.type === "number" ? this.type : ActivityTypes[this.type]
        });
      }
    };
    var RichPresenceAssets = class _RichPresenceAssets {
      constructor(activity, assets) {
        Object.defineProperty(this, "activity", { value: activity });
        this._patch(assets);
      }
      _patch(assets = {}) {
        if ("large_text" in assets || "largeText" in assets) {
          this.largeText = assets.large_text || assets.largeText;
        } else {
          this.largeText = null;
        }
        if ("small_text" in assets || "smallText" in assets) {
          this.smallText = assets.small_text || assets.smallText;
        } else {
          this.smallText = null;
        }
        if ("large_image" in assets || "largeImage" in assets) {
          this.largeImage = assets.large_image || assets.largeImage;
        } else {
          this.largeImage = null;
        }
        if ("small_image" in assets || "smallImage" in assets) {
          this.smallImage = assets.small_image || assets.smallImage;
        } else {
          this.smallImage = null;
        }
      }
      /**
       * Gets the URL of the small image asset
       * @param {StaticImageURLOptions} [options] Options for the image URL
       * @returns {?string}
       */
      smallImageURL({ format, size } = {}) {
        if (!this.smallImage) return null;
        if (this.smallImage.includes(":")) {
          const [platform, id] = this.smallImage.split(":");
          switch (platform) {
            case "mp":
              return `https://media.discordapp.net/${id}`;
            case "spotify":
              return `https://i.scdn.co/image/${id}`;
            case "youtube":
              return `https://i.ytimg.com/vi/${id}/hqdefault_live.jpg`;
            case "twitch":
              return `https://static-cdn.jtvnw.net/previews-ttv/live_user_${id}.png`;
            default:
              return null;
          }
        }
        return this.activity.presence.client.rest.cdn.AppAsset(this.activity.applicationId, this.smallImage, {
          format,
          size
        });
      }
      /**
       * Gets the URL of the large image asset
       * @param {StaticImageURLOptions} [options] Options for the image URL
       * @returns {?string}
       */
      largeImageURL({ format, size } = {}) {
        if (!this.largeImage) return null;
        if (this.largeImage.includes(":")) {
          const [platform, id] = this.largeImage.split(":");
          switch (platform) {
            case "mp":
              return `https://media.discordapp.net/${id}`;
            case "spotify":
              return `https://i.scdn.co/image/${id}`;
            case "youtube":
              return `https://i.ytimg.com/vi/${id}/hqdefault_live.jpg`;
            case "twitch":
              return `https://static-cdn.jtvnw.net/previews-ttv/live_user_${id}.png`;
            default:
              return null;
          }
        }
        return this.activity.presence.client.rest.cdn.AppAsset(this.activity.applicationId, this.largeImage, {
          format,
          size
        });
      }
      static parseImage(image) {
        if (typeof image != "string") {
          image = null;
        } else if (URL.canParse(image) && ["http:", "https:"].includes(new URL(image).protocol)) {
          image = image.replace("https://cdn.discordapp.com/", "mp:").replace("http://cdn.discordapp.com/", "mp:").replace("https://media.discordapp.net/", "mp:").replace("http://media.discordapp.net/", "mp:");
          if (!image.startsWith("mp:")) {
            throw new Error("INVALID_URL");
          }
        } else if (/^[0-9]{17,19}$/.test(image)) {
        } else if (["mp:", "youtube:", "spotify:", "twitch:"].some((v) => image.startsWith(v))) {
        } else if (image.startsWith("external/")) {
          image = `mp:${image}`;
        }
        return image;
      }
      toJSON() {
        if (!this.largeImage && !this.largeText && !this.smallImage && !this.smallText) return null;
        return {
          large_image: _RichPresenceAssets.parseImage(this.largeImage),
          large_text: this.largeText,
          small_image: _RichPresenceAssets.parseImage(this.smallImage),
          small_text: this.smallText
        };
      }
      /**
       * @typedef {string} RichPresenceImage
       * Support:
       * - cdn.discordapp.com
       * - media.discordapp.net
       * - Assets ID (https://discord.com/api/v9/oauth2/applications/{application_id}/assets)
       * - Media Proxy (mp:external/{hash})
       * - Twitch (twitch:{username})
       * - YouTube (youtube:{video_id})
       * - Spotify (spotify:{image_id})
       */
      /**
       * Set the large image of this activity
       * @param {?RichPresenceImage} image The large image asset's id
       * @returns {RichPresenceAssets}
       */
      setLargeImage(image) {
        image = _RichPresenceAssets.parseImage(image);
        this.largeImage = image;
        return this;
      }
      /**
       * Set the small image of this activity
       * @param {?RichPresenceImage} image The small image asset's id
       * @returns {RichPresenceAssets}
       */
      setSmallImage(image) {
        image = _RichPresenceAssets.parseImage(image);
        this.smallImage = image;
        return this;
      }
      /**
       * Hover text for the large image
       * @param {string} text Assets text
       * @returns {RichPresenceAssets}
       */
      setLargeText(text) {
        this.largeText = text;
        return this;
      }
      /**
       * Hover text for the small image
       * @param {string} text Assets text
       * @returns {RichPresenceAssets}
       */
      setSmallText(text) {
        this.smallText = text;
        return this;
      }
    };
    var CustomStatus = class extends Activity {
      /**
       * @typedef {Object} CustomStatusOptions
       * @property {string} [state] The state to be displayed
       * @property {EmojiIdentifierResolvable} [emoji] The emoji to be displayed
       */
      /**
       * @param {Client} client Discord Client
       * @param {CustomStatus|CustomStatusOptions} [data={}] CustomStatus to clone or raw data
       */
      constructor(client, data = {}) {
        if (!client) throw new Error("Class constructor CustomStatus cannot be invoked without 'client'");
        super("presence" in client ? client.presence : client, {
          name: " ",
          type: ActivityTypes.CUSTOM,
          ...data
        });
      }
      /**
       * Set the emoji of this activity
       * @param {EmojiIdentifierResolvable} emoji The emoji to be displayed
       * @returns {CustomStatus}
       */
      setEmoji(emoji) {
        this.emoji = Util.resolvePartialEmoji(emoji);
        return this;
      }
      /**
       * Set state of this activity
       * @param {string | null} state The state to be displayed
       * @returns {CustomStatus}
       */
      setState(state) {
        if (typeof state == "string" && state.length > 128) throw new Error("State must be less than 128 characters");
        this.state = state;
        return this;
      }
      /**
       * Returns an object that can be used to set the status
       * @returns {CustomStatus}
       */
      toJSON() {
        if (!this.emoji & !this.state) throw new Error("CustomStatus must have at least one of emoji or state");
        return {
          name: this.name,
          emoji: this.emoji,
          type: ActivityTypes.CUSTOM,
          state: this.state
        };
      }
    };
    var RichPresence = class extends Activity {
      /**
       * @param {Client} client Discord client
       * @param {RichPresence} [data={}] RichPresence to clone or raw data
       */
      constructor(client, data = {}) {
        if (!client) throw new Error("Class constructor RichPresence cannot be invoked without 'client'");
        super("presence" in client ? client.presence : client, { type: 0, ...data });
        this.setup(data);
      }
      /**
       * Sets the status from a JSON object
       * @param {RichPresence} data data
       * @private
       */
      setup(data = {}) {
        this.secrets = "secrets" in data ? data.secrets : {};
        this.metadata = "metadata" in data ? data.metadata : {};
      }
      /**
       * Set the large image of this activity
       * @param {?RichPresenceImage} image The large image asset's id
       * @returns {RichPresence}
       */
      setAssetsLargeImage(image) {
        this.assets.setLargeImage(image);
        return this;
      }
      /**
       * Set the small image of this activity
       * @param {?RichPresenceImage} image The small image asset's id
       * @returns {RichPresence}
       */
      setAssetsSmallImage(image) {
        this.assets.setSmallImage(image);
        return this;
      }
      /**
       * Hover text for the large image
       * @param {string} text Assets text
       * @returns {RichPresence}
       */
      setAssetsLargeText(text) {
        this.assets.setLargeText(text);
        return this;
      }
      /**
       * Hover text for the small image
       * @param {string} text Assets text
       * @returns {RichPresence}
       */
      setAssetsSmallText(text) {
        this.assets.setSmallText(text);
        return this;
      }
      /**
       * Set the name of the activity
       * @param {?string} name The activity's name
       * @returns {RichPresence}
       */
      setName(name) {
        this.name = name;
        return this;
      }
      /**
       * If the activity is being streamed, a link to the stream
       * @param {?string} url URL of the stream
       * @returns {RichPresence}
       */
      setURL(url) {
        if (typeof url == "string" && !URL.canParse(url)) throw new Error("URL must be a valid URL");
        this.url = url;
        return this;
      }
      /**
       * The activity status's type
       * @param {?ActivityTypes} type The type of activity
       * @returns {RichPresence}
       */
      setType(type) {
        this.type = typeof type == "number" ? type : ActivityTypes[type];
        return this;
      }
      /**
       * Set the application id of this activity
       * @param {?Snowflake} id Bot's id
       * @returns {RichPresence}
       */
      setApplicationId(id) {
        this.applicationId = id;
        return this;
      }
      /**
       * Set the state of the activity
       * @param {?string} state The state of the activity
       * @returns {RichPresence}
       */
      setState(state) {
        this.state = state;
        return this;
      }
      /**
       * Set the details of the activity
       * @param {?string} details The details of the activity
       * @returns {RichPresence}
       */
      setDetails(details) {
        this.details = details;
        return this;
      }
      /**
       * @typedef {Object} RichParty
       * @property {string} id The id of the party
       * @property {number} max The maximum number of members in the party
       * @property {number} current The current number of members in the party
       */
      /**
       * Set the party of this activity
       * @param {?RichParty} party The party to be displayed
       * @returns {RichPresence}
       */
      setParty(party) {
        if (typeof party == "object") {
          if (!party.max || typeof party.max != "number") throw new Error("Party must have max number");
          if (!party.current || typeof party.current != "number") throw new Error("Party must have current");
          if (party.current > party.max) throw new Error("Party current must be less than max number");
          if (!party.id || typeof party.id != "string") party.id = randomUUID();
          this.party = {
            size: [party.current, party.max],
            id: party.id
          };
        } else {
          this.party = null;
        }
        return this;
      }
      /**
       * Sets the start timestamp of the activity
       * @param {Date|number|null} timestamp The timestamp of the start of the activity
       * @returns {RichPresence}
       */
      setStartTimestamp(timestamp) {
        if (!this.timestamps) this.timestamps = {};
        if (timestamp instanceof Date) timestamp = timestamp.getTime();
        this.timestamps.start = timestamp;
        return this;
      }
      /**
       * Sets the end timestamp of the activity
       * @param {Date|number|null} timestamp The timestamp of the end of the activity
       * @returns {RichPresence}
       */
      setEndTimestamp(timestamp) {
        if (!this.timestamps) this.timestamps = {};
        if (timestamp instanceof Date) timestamp = timestamp.getTime();
        this.timestamps.end = timestamp;
        return this;
      }
      /**
       * @typedef {object} RichButton
       * @property {string} name The name of the button
       * @property {string} url The url of the button
       */
      /**
       * Set the buttons of the rich presence
       * @param  {...?RichButton} button A list of buttons to set
       * @returns {RichPresence}
       */
      setButtons(...button) {
        if (button.length == 0) {
          this.buttons = [];
          delete this.metadata.button_urls;
          return this;
        } else if (button.length > 2) {
          throw new Error("RichPresence can only have up to 2 buttons");
        }
        this.buttons = [];
        this.metadata.button_urls = [];
        button.flat(2).forEach((b) => {
          if (b.name && b.url) {
            this.buttons.push(b.name);
            if (!URL.canParse(b.url)) throw new Error("Button url must be a valid url");
            this.metadata.button_urls.push(b.url);
          } else {
            throw new Error("Button must have name and url");
          }
        });
        return this;
      }
      /**
       * The platform the activity is being played on
       * @param {ActivityPlatform | null} platform Any platform
       * @returns {RichPresence}
       */
      setPlatform(platform) {
        this.platform = platform;
        return this;
      }
      /**
       * Secrets for rich presence joining and spectating (send-only)
       * @param {?string} join Secrets for rich presence joining
       * @returns {RichPresence}
       */
      setJoinSecret(join) {
        this.secrets.join = join;
        return this;
      }
      /**
       * Add a button to the rich presence
       * @param {string} name The name of the button
       * @param {string} url The url of the button
       * @returns {RichPresence}
       */
      addButton(name, url) {
        if (!name || !url) {
          throw new Error("Button must have name and url");
        }
        if (typeof name !== "string") throw new Error("Button name must be a string");
        if (!URL.canParse(url)) throw new Error("Button url must be a valid url");
        this.buttons.push(name);
        if (Array.isArray(this.metadata.button_urls)) this.metadata.button_urls.push(url);
        else this.metadata.button_urls = [url];
        return this;
      }
      /**
       * Convert the rich presence to a JSON object
       * @returns {Object}
       */
      toJSON(...props) {
        return super.toJSON(
          {
            applicationId: "application_id",
            sessionId: "session_id",
            syncId: "sync_id",
            createdTimestamp: "created_at"
          },
          ...props
        );
      }
      /**
       * @typedef {Object} ExternalAssets
       * @property {?string} url Orginal url of the image
       * @property {?string} external_asset_path Proxy url of the image (Using to RPC)
       */
      /**
       * Get Assets from a RichPresence (Util)
       * @param {Client} client Discord Client
       * @param {Snowflake} applicationId Application id
       * @param {string} image1 URL image 1 (not from Discord)
       * @param {string} image2 URL image 2 (not from Discord)
       * @returns {ExternalAssets[]}
       */
      static async getExternal(client, applicationId, image1 = "", image2 = "") {
        if (!client || !client.token || !client.api) throw new Error("Client must be set");
        if (!/^[0-9]{17,19}$/.test(applicationId)) {
          throw new Error("Application id must be a Discord Snowflake");
        }
        if (image1 && image1.length > 0 && !URL.canParse(image1)) {
          throw new Error("Image 1 must be a valid url");
        }
        if (image2 && image2.length > 0 && !URL.canParse(image2)) {
          throw new Error("Image 2 must be a valid url");
        }
        const data_ = [];
        if (image1) data_.push(image1);
        if (image2) data_.push(image2);
        const res = await client.api.applications[applicationId]["external-assets"].post({
          data: {
            urls: data_
          }
        });
        return res;
      }
      /**
       * When concatenated with a string, this automatically returns the activities' name instead of the Activity object.
       * @returns {string}
       */
      toString() {
        return this.name;
      }
      _clone() {
        return Object.assign(Object.create(this), this);
      }
    };
    var SpotifyRPC = class extends RichPresence {
      /**
       * Create a new RichPresence (Spotify style)
       * @param {Client} client Discord Client
       * @param {SpotifyRPC} [options] Options for the Spotify RPC
       */
      constructor(client, options = {}) {
        if (!client) throw new Error("Class constructor SpotifyRPC cannot be invoked without 'client'");
        super(client, {
          name: "Spotify",
          type: ActivityTypes.LISTENING,
          party: {
            id: `spotify:${client.user.id}`
          },
          id: "spotify:1",
          flags: 48,
          // Sync + Play (ActivityFlags)
          ...options
        });
        this.setup(options);
      }
      /**
       * Sets the status from a JSON object
       * @param {SpotifyRPC} options data
       * @private
       */
      setup(options) {
        var _a, _b, _c;
        this.metadata = {
          album_id: ((_a = options.metadata) == null ? void 0 : _a.album_id) || null,
          artist_ids: ((_b = options.metadata) == null ? void 0 : _b.artist_ids) || [],
          context_uri: ((_c = options.metadata) == null ? void 0 : _c.context_uri) || null
        };
      }
      /**
       * Set Spotify song id to sync with
       * @param {string} id Song id
       * @returns {SpotifyRPC}
       */
      setSongId(id) {
        this.syncId = id;
        return this;
      }
      /**
       * Add the artist id
       * @param {string} id Artist id
       * @returns {SpotifyRPC}
       */
      addArtistId(id) {
        if (!this.metadata.artist_ids) this.metadata.artist_ids = [];
        this.metadata.artist_ids.push(id);
        return this;
      }
      /**
       * Set the artist ids
       * @param {string | Array<string>} ids Artist ids
       * @returns {SpotifyRPC}
       */
      setArtistIds(...ids) {
        if (!(ids == null ? void 0 : ids.length)) {
          this.metadata.artist_ids = [];
          return this;
        }
        if (!this.metadata.artist_ids) this.metadata.artist_ids = [];
        ids.flat(2).forEach((id) => this.metadata.artist_ids.push(id));
        return this;
      }
      /**
       * Set the album id
       * @param {string} id Album id
       * @returns {SpotifyRPC}
       */
      setAlbumId(id) {
        this.metadata.album_id = id;
        this.metadata.context_uri = `spotify:album:${id}`;
        return this;
      }
      toJSON() {
        return super.toJSON({ id: false, emoji: false, platform: false, buttons: false });
      }
    };
    exports2.Presence = Presence;
    exports2.Activity = Activity;
    exports2.RichPresenceAssets = RichPresenceAssets;
    exports2.CustomStatus = CustomStatus;
    exports2.RichPresence = RichPresence;
    exports2.SpotifyRPC = SpotifyRPC;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/managers/PresenceManager.js
var require_PresenceManager = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/managers/PresenceManager.js"(exports2, module2) {
    "use strict";
    var CachedManager = require_CachedManager();
    var { Presence } = require_Presence();
    var PresenceManager2 = class extends CachedManager {
      constructor(client, iterable) {
        super(client, Presence, iterable);
      }
      /**
       * The cache of Presences
       * @type {Collection<Snowflake, Presence>}
       * @name PresenceManager#cache
       */
      _add(data, cache) {
        return super._add(data, cache, { id: data.user.id });
      }
      /**
       * Data that can be resolved to a Presence object. This can be:
       * * A Presence
       * * A UserResolvable
       * * A Snowflake
       * @typedef {Presence|UserResolvable|Snowflake} PresenceResolvable
       */
      /**
       * Resolves a {@link PresenceResolvable} to a {@link Presence} object.
       * @param {PresenceResolvable} presence The presence resolvable to resolve
       * @returns {?Presence}
       */
      resolve(presence) {
        const presenceResolvable = super.resolve(presence);
        if (presenceResolvable) return presenceResolvable;
        const UserResolvable = this.client.users.resolveId(presence);
        return super.resolve(UserResolvable);
      }
      /**
       * Resolves a {@link PresenceResolvable} to a {@link Presence} id.
       * @param {PresenceResolvable} presence The presence resolvable to resolve
       * @returns {?Snowflake}
       */
      resolveId(presence) {
        const presenceResolvable = super.resolveId(presence);
        if (presenceResolvable) return presenceResolvable;
        const userResolvable = this.client.users.resolveId(presence);
        return this.cache.has(userResolvable) ? userResolvable : null;
      }
    };
    module2.exports = PresenceManager2;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/managers/RoleManager.js
var require_RoleManager = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/managers/RoleManager.js"(exports2, module2) {
    "use strict";
    var process2 = require_node_process();
    var { Collection: Collection2 } = require_dist();
    var CachedManager = require_CachedManager();
    var { TypeError: TypeError2 } = require_errors2();
    var { Role } = require_Role();
    var DataResolver2 = require_DataResolver();
    var Permissions2 = require_Permissions();
    var { resolveColor } = require_Util();
    var Util = require_Util();
    var cacheWarningEmitted = false;
    var RoleManager = class extends CachedManager {
      constructor(guild, iterable) {
        super(guild.client, Role, iterable);
        if (!cacheWarningEmitted && this._cache.constructor.name !== "Collection") {
          cacheWarningEmitted = true;
          process2.emitWarning(
            `Overriding the cache handling for ${this.constructor.name} is unsupported and breaks functionality.`,
            "UnsupportedCacheOverwriteWarning"
          );
        }
        this.guild = guild;
      }
      /**
       * The role cache of this manager
       * @type {Collection<Snowflake, Role>}
       * @name RoleManager#cache
       */
      _add(data, cache) {
        return super._add(data, cache, { extras: [this.guild] });
      }
      /**
       * Obtains a role from Discord, or the role cache if they're already available.
       * @param {Snowflake} [id] The role's id
       * @param {BaseFetchOptions} [options] Additional options for this fetch
       * @returns {Promise<?Role|Collection<Snowflake, Role>>}
       * @example
       * // Fetch all roles from the guild
       * message.guild.roles.fetch()
       *   .then(roles => console.log(`There are ${roles.size} roles.`))
       *   .catch(console.error);
       * @example
       * // Fetch a single role
       * message.guild.roles.fetch('222078108977594368')
       *   .then(role => console.log(`The role color is: ${role.color}`))
       *   .catch(console.error);
       */
      async fetch(id, { cache = true, force = false } = {}) {
        if (id && !force) {
          const existing = this.cache.get(id);
          if (existing) return existing;
        }
        const data = await this.client.api.guilds(this.guild.id).roles.get();
        const roles = new Collection2();
        for (const role of data) roles.set(role.id, this._add(role, cache));
        return id ? roles.get(id) ?? null : roles;
      }
      /**
       * Data that can be resolved to a Role object. This can be:
       * * A Role
       * * A Snowflake
       * @typedef {Role|Snowflake} RoleResolvable
       */
      /**
       * Resolves a {@link RoleResolvable} to a {@link Role} object.
       * @method resolve
       * @memberof RoleManager
       * @instance
       * @param {RoleResolvable} role The role resolvable to resolve
       * @returns {?Role}
       */
      /**
       * Resolves a {@link RoleResolvable} to a {@link Role} id.
       * @method resolveId
       * @memberof RoleManager
       * @instance
       * @param {RoleResolvable} role The role resolvable to resolve
       * @returns {?Snowflake}
       */
      /**
       * Options used to create a new role.
       * @typedef {Object} CreateRoleOptions
       * @property {string} [name] The name of the new role
       * @property {ColorResolvable} [color] The data to create the role with
       * @property {boolean} [hoist] Whether or not the new role should be hoisted
       * @property {PermissionResolvable} [permissions] The permissions for the new role
       * @property {number} [position] The position of the new role
       * @property {boolean} [mentionable] Whether or not the new role should be mentionable
       * @property {?(BufferResolvable|Base64Resolvable|EmojiResolvable)} [icon] The icon for the role
       * <warn>The `EmojiResolvable` should belong to the same guild as the role.
       * If not, pass the emoji's URL directly</warn>
       * @property {?string} [unicodeEmoji] The unicode emoji for the role
       * @property {string} [reason] The reason for creating this role
       */
      /**
       * Creates a new role in the guild with given information.
       * <warn>The position will silently reset to 1 if an invalid one is provided, or none.</warn>
       * @param {CreateRoleOptions} [options] Options for creating the new role
       * @returns {Promise<Role>}
       * @example
       * // Create a new role
       * guild.roles.create()
       *   .then(console.log)
       *   .catch(console.error);
       * @example
       * // Create a new role with data and a reason
       * guild.roles.create({
       *   name: 'Super Cool Blue People',
       *   color: 'BLUE',
       *   reason: 'we needed a role for Super Cool People',
       * })
       *   .then(console.log)
       *   .catch(console.error);
       */
      async create(options = {}) {
        var _a;
        let { name, color, hoist, permissions, position, mentionable, reason, icon, unicodeEmoji } = options;
        color && (color = resolveColor(color));
        if (typeof permissions !== "undefined") permissions = new Permissions2(permissions);
        if (icon) {
          const guildEmojiURL = (_a = this.guild.emojis.resolve(icon)) == null ? void 0 : _a.url;
          icon = guildEmojiURL ? await DataResolver2.resolveImage(guildEmojiURL) : await DataResolver2.resolveImage(icon);
          if (typeof icon !== "string") icon = void 0;
        }
        const data = await this.client.api.guilds(this.guild.id).roles.post({
          data: {
            name,
            color,
            hoist,
            permissions,
            mentionable,
            icon,
            unicode_emoji: unicodeEmoji
          },
          reason
        });
        const { role } = this.client.actions.GuildRoleCreate.handle({
          guild_id: this.guild.id,
          role: data
        });
        if (position) return this.setPosition(role, position, { reason });
        return role;
      }
      /**
       * Edits a role of the guild.
       * @param {RoleResolvable} role The role to edit
       * @param {RoleData} data The new data for the role
       * @param {string} [reason] Reason for editing this role
       * @returns {Promise<Role>}
       * @example
       * // Edit a role
       * guild.roles.edit('222079219327434752', { name: 'buddies' })
       *   .then(updated => console.log(`Edited role name to ${updated.name}`))
       *   .catch(console.error);
       */
      async edit(role, data, reason) {
        var _a;
        role = this.resolve(role);
        if (!role) throw new TypeError2("INVALID_TYPE", "role", "RoleResolvable");
        if (typeof data.position === "number") await this.setPosition(role, data.position, { reason });
        let icon = data.icon;
        if (icon) {
          const guildEmojiURL = (_a = this.guild.emojis.resolve(icon)) == null ? void 0 : _a.url;
          icon = guildEmojiURL ? await DataResolver2.resolveImage(guildEmojiURL) : await DataResolver2.resolveImage(icon);
          if (typeof icon !== "string") icon = void 0;
        }
        const _data = {
          name: data.name,
          color: typeof data.color === "undefined" ? void 0 : resolveColor(data.color),
          hoist: data.hoist,
          permissions: typeof data.permissions === "undefined" ? void 0 : new Permissions2(data.permissions),
          mentionable: data.mentionable,
          icon,
          unicode_emoji: data.unicodeEmoji
        };
        const d = await this.client.api.guilds(this.guild.id).roles(role.id).patch({ data: _data, reason });
        const clone = role._clone();
        clone._patch(d);
        return clone;
      }
      /**
       * Deletes a role.
       * @param {RoleResolvable} role The role to delete
       * @param {string} [reason] Reason for deleting the role
       * @returns {Promise<void>}
       * @example
       * // Delete a role
       * guild.roles.delete('222079219327434752', 'The role needed to go')
       *   .then(() => console.log('Deleted the role.'))
       *   .catch(console.error);
       */
      async delete(role, reason) {
        const id = this.resolveId(role);
        await this.client.api.guilds[this.guild.id].roles[id].delete({ reason });
        this.client.actions.GuildRoleDelete.handle({ guild_id: this.guild.id, role_id: id });
      }
      /**
       * Sets the new position of the role.
       * @param {RoleResolvable} role The role to change the position of
       * @param {number} position The new position for the role
       * @param {SetRolePositionOptions} [options] Options for setting the position
       * @returns {Promise<Role>}
       * @example
       * // Set the position of the role
       * guild.roles.setPosition('222197033908436994', 1)
       *   .then(updated => console.log(`Role position: ${updated.position}`))
       *   .catch(console.error);
       */
      async setPosition(role, position, { relative, reason } = {}) {
        role = this.resolve(role);
        if (!role) throw new TypeError2("INVALID_TYPE", "role", "RoleResolvable");
        const updatedRoles = await Util.setPosition(
          role,
          position,
          relative,
          this.guild._sortedRoles(),
          this.client.api.guilds(this.guild.id).roles,
          reason
        );
        this.client.actions.GuildRolesPositionUpdate.handle({
          guild_id: this.guild.id,
          roles: updatedRoles
        });
        return role;
      }
      /**
       * The data needed for updating a guild role's position
       * @typedef {Object} GuildRolePosition
       * @property {RoleResolvable} role The role's id
       * @property {number} position The position to update
       */
      /**
       * Batch-updates the guild's role positions
       * @param {GuildRolePosition[]} rolePositions Role positions to update
       * @returns {Promise<Guild>}
       * @example
       * guild.roles.setPositions([{ role: roleId, position: updatedRoleIndex }])
       *  .then(guild => console.log(`Role positions updated for ${guild}`))
       *  .catch(console.error);
       */
      async setPositions(rolePositions) {
        rolePositions = rolePositions.map((o) => ({
          id: this.resolveId(o.role),
          position: o.position
        }));
        await this.client.api.guilds(this.guild.id).roles.patch({
          data: rolePositions
        });
        return this.client.actions.GuildRolesPositionUpdate.handle({
          guild_id: this.guild.id,
          roles: rolePositions
        }).guild;
      }
      /**
       * Compares the positions of two roles.
       * @param {RoleResolvable} role1 First role to compare
       * @param {RoleResolvable} role2 Second role to compare
       * @returns {number} Negative number if the first role's position is lower (second role's is higher),
       * positive number if the first's is higher (second's is lower), 0 if equal
       */
      comparePositions(role1, role2) {
        const resolvedRole1 = this.resolve(role1);
        const resolvedRole2 = this.resolve(role2);
        if (!resolvedRole1 || !resolvedRole2) throw new TypeError2("INVALID_TYPE", "role", "Role nor a Snowflake");
        const role1Position = resolvedRole1.position;
        const role2Position = resolvedRole2.position;
        if (role1Position === role2Position) {
          return Number(BigInt(resolvedRole2.id) - BigInt(resolvedRole1.id));
        }
        return role1Position - role2Position;
      }
      /**
       * Gets the managed role a user created when joining the guild, if any
       * <info>Only ever available for bots</info>
       * @param {UserResolvable} user The user to access the bot role for
       * @returns {?Role}
       */
      botRoleFor(user) {
        const userId = this.client.users.resolveId(user);
        if (!userId) return null;
        return this.cache.find((role) => {
          var _a;
          return ((_a = role.tags) == null ? void 0 : _a.botId) === userId;
        }) ?? null;
      }
      /**
       * The `@everyone` role of the guild
       * @type {Role}
       * @readonly
       */
      get everyone() {
        return this.cache.get(this.guild.id);
      }
      /**
       * The premium subscriber role of the guild, if any
       * @type {?Role}
       * @readonly
       */
      get premiumSubscriberRole() {
        return this.cache.find((role) => {
          var _a;
          return (_a = role.tags) == null ? void 0 : _a.premiumSubscriberRole;
        }) ?? null;
      }
      /**
       * The role with the highest position in the cache
       * @type {Role}
       * @readonly
       */
      get highest() {
        return this.cache.reduce((prev, role) => role.comparePositionTo(prev) > 0 ? role : prev, this.cache.first());
      }
    };
    module2.exports = RoleManager;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/managers/StageInstanceManager.js
var require_StageInstanceManager = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/managers/StageInstanceManager.js"(exports2, module2) {
    "use strict";
    var CachedManager = require_CachedManager();
    var { TypeError: TypeError2, Error: Error2 } = require_errors2();
    var { StageInstance } = require_StageInstance();
    var { PrivacyLevels } = require_Constants();
    var StageInstanceManager = class extends CachedManager {
      constructor(guild, iterable) {
        super(guild.client, StageInstance, iterable);
        this.guild = guild;
      }
      /**
       * The cache of this Manager
       * @type {Collection<Snowflake, StageInstance>}
       * @name StageInstanceManager#cache
       */
      /**
       * Options used to create a stage instance.
       * @typedef {Object} StageInstanceCreateOptions
       * @property {string} topic The topic of the stage instance
       * @property {PrivacyLevel|number} [privacyLevel] The privacy level of the stage instance
       * @property {boolean} [sendStartNotification] Whether to notify `@everyone` that the stage instance has started
       * @property {GuildScheduledEventResolvable} [guildScheduledEvent]
       * The guild scheduled event associated with the stage instance
       */
      /**
       * Data that can be resolved to a Stage Channel object. This can be:
       * * A StageChannel
       * * A Snowflake
       * @typedef {StageChannel|Snowflake} StageChannelResolvable
       */
      /**
       * Creates a new stage instance.
       * @param {StageChannelResolvable} channel The stage channel to associate the created stage instance to
       * @param {StageInstanceCreateOptions} options The options to create the stage instance
       * @returns {Promise<StageInstance>}
       * @example
       * // Create a stage instance
       * guild.stageInstances.create('1234567890123456789', {
       *  topic: 'A very creative topic',
       *  privacyLevel: 'GUILD_ONLY'
       * })
       *  .then(stageInstance => console.log(stageInstance))
       *  .catch(console.error);
       */
      async create(channel, options) {
        const channelId = this.guild.channels.resolveId(channel);
        if (!channelId) throw new Error2("STAGE_CHANNEL_RESOLVE");
        if (typeof options !== "object") throw new TypeError2("INVALID_TYPE", "options", "object", true);
        let { guildScheduledEvent, topic, privacyLevel, sendStartNotification } = options;
        privacyLevel && (privacyLevel = typeof privacyLevel === "number" ? privacyLevel : PrivacyLevels[privacyLevel]);
        const guildScheduledEventId = guildScheduledEvent && this.resolveId(guildScheduledEvent);
        const data = await this.client.api["stage-instances"].post({
          data: {
            channel_id: channelId,
            topic,
            privacy_level: privacyLevel,
            send_start_notification: sendStartNotification,
            guild_scheduled_event_id: guildScheduledEventId
          }
        });
        return this._add(data);
      }
      /**
       * Fetches the stage instance associated with a stage channel, if it exists.
       * @param {StageChannelResolvable} channel The stage channel whose associated stage instance is to be fetched
       * @param {BaseFetchOptions} [options] Additional options for this fetch
       * @returns {Promise<StageInstance>}
       * @example
       * // Fetch a stage instance
       * guild.stageInstances.fetch('1234567890123456789')
       *  .then(stageInstance => console.log(stageInstance))
       *  .catch(console.error);
       */
      async fetch(channel, { cache = true, force = false } = {}) {
        const channelId = this.guild.channels.resolveId(channel);
        if (!channelId) throw new Error2("STAGE_CHANNEL_RESOLVE");
        if (!force) {
          const existing = this.cache.find((stageInstance) => stageInstance.channelId === channelId);
          if (existing) return existing;
        }
        const data = await this.client.api("stage-instances", channelId).get();
        return this._add(data, cache);
      }
      /**
       * Options used to edit an existing stage instance.
       * @typedef {Object} StageInstanceEditOptions
       * @property {string} [topic] The new topic of the stage instance
       * @property {PrivacyLevel|number} [privacyLevel] The new privacy level of the stage instance
       */
      /**
       * Edits an existing stage instance.
       * @param {StageChannelResolvable} channel The stage channel whose associated stage instance is to be edited
       * @param {StageInstanceEditOptions} options The options to edit the stage instance
       * @returns {Promise<StageInstance>}
       * @example
       * // Edit a stage instance
       * guild.stageInstances.edit('1234567890123456789', { topic: 'new topic' })
       *  .then(stageInstance => console.log(stageInstance))
       *  .catch(console.error);
       */
      async edit(channel, options) {
        if (typeof options !== "object") throw new TypeError2("INVALID_TYPE", "options", "object", true);
        const channelId = this.guild.channels.resolveId(channel);
        if (!channelId) throw new Error2("STAGE_CHANNEL_RESOLVE");
        let { topic, privacyLevel } = options;
        privacyLevel && (privacyLevel = typeof privacyLevel === "number" ? privacyLevel : PrivacyLevels[privacyLevel]);
        const data = await this.client.api("stage-instances", channelId).patch({
          data: {
            topic,
            privacy_level: privacyLevel
          }
        });
        if (this.cache.has(data.id)) {
          const clone = this.cache.get(data.id)._clone();
          clone._patch(data);
          return clone;
        }
        return this._add(data);
      }
      /**
       * Deletes an existing stage instance.
       * @param {StageChannelResolvable} channel The stage channel whose associated stage instance is to be deleted
       * @returns {Promise<void>}
       */
      async delete(channel) {
        const channelId = this.guild.channels.resolveId(channel);
        if (!channelId) throw new Error2("STAGE_CHANNEL_RESOLVE");
        await this.client.api("stage-instances", channelId).delete();
      }
    };
    module2.exports = StageInstanceManager;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/managers/VoiceStateManager.js
var require_VoiceStateManager = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/managers/VoiceStateManager.js"(exports2, module2) {
    "use strict";
    var CachedManager = require_CachedManager();
    var VoiceState = require_VoiceState();
    var VoiceStateManager2 = class extends CachedManager {
      constructor(guild, iterable) {
        super(guild.client, VoiceState, iterable);
        this.guild = guild;
      }
      /**
       * The cache of this manager
       * @type {Collection<Snowflake, VoiceState>}
       * @name VoiceStateManager#cache
       */
      _add(data, cache = true) {
        const existing = this.cache.get(data.user_id);
        if (existing) return existing._patch(data);
        const entry = new this.holds(this.guild, data);
        if (cache) this.cache.set(data.user_id, entry);
        return entry;
      }
      /**
       * Obtains a user's voice state from discord or from the cache if it's already available.
       * @param {GuildMemberResolvable|'@me'} member The member whose voice state is to be fetched
       * @param {BaseFetchOptions} [options] Additional options for this fetch
       * @returns {Promise<VoiceState>}
       * @example
       * // Fetch a member's voice state
       * guild.voiceStates.fetch("66564597481480192")
       *    .then(console.log)
       *    .catch(console.error);
       */
      async fetch(member, { cache = true, force = false } = {}) {
        var _a;
        if (!((_a = this.guild) == null ? void 0 : _a.id)) throw new Error("Guild is not defined");
        const id = member === "@me" ? member : this.guild.members.resolveId(member);
        if (!force) {
          const existing = this.cache.get(id === "@me" ? this.client.user.id : id);
          if (existing) return existing;
        }
        const data = await this.client.api.guilds(this.guild.id)["voice-states"][id].get();
        return this._add(data, cache);
      }
    };
    module2.exports = VoiceStateManager2;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/util/SystemChannelFlags.js
var require_SystemChannelFlags = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/util/SystemChannelFlags.js"(exports2, module2) {
    "use strict";
    var BitField = require_BitField();
    var SystemChannelFlags = class extends BitField {
    };
    SystemChannelFlags.FLAGS = {
      SUPPRESS_JOIN_NOTIFICATIONS: 1 << 0,
      SUPPRESS_PREMIUM_SUBSCRIPTIONS: 1 << 1,
      SUPPRESS_GUILD_REMINDER_NOTIFICATIONS: 1 << 2,
      SUPPRESS_JOIN_NOTIFICATION_REPLIES: 1 << 3,
      SUPPRESS_ROLE_SUBSCRIPTION_PURCHASE_NOTIFICATIONS: 1 << 4,
      SUPPRESS_ROLE_SUBSCRIPTION_PURCHASE_NOTIFICATION_REPLIES: 1 << 5
    };
    module2.exports = SystemChannelFlags;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/Guild.js
var require_Guild = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/Guild.js"(exports2) {
    "use strict";
    var process2 = require_node_process();
    var { Collection: Collection2 } = require_dist();
    var AnonymousGuild = require_AnonymousGuild();
    var GuildAuditLogs = require_GuildAuditLogs();
    var GuildPreview2 = require_GuildPreview();
    var GuildTemplate2 = require_GuildTemplate();
    var Integration = require_Integration();
    var Webhook2 = require_Webhook();
    var WelcomeScreen = require_WelcomeScreen();
    var { Error: Error2 } = require_errors2();
    var AutoModerationRuleManager = require_AutoModerationRuleManager();
    var GuildBanManager = require_GuildBanManager();
    var GuildChannelManager = require_GuildChannelManager();
    var GuildEmojiManager = require_GuildEmojiManager();
    var GuildInviteManager = require_GuildInviteManager();
    var GuildMemberManager = require_GuildMemberManager();
    var GuildScheduledEventManager = require_GuildScheduledEventManager();
    var GuildSettingManager = require_GuildSettingManager();
    var GuildStickerManager = require_GuildStickerManager();
    var PresenceManager2 = require_PresenceManager();
    var RoleManager = require_RoleManager();
    var StageInstanceManager = require_StageInstanceManager();
    var VoiceStateManager2 = require_VoiceStateManager();
    var {
      ChannelTypes,
      DefaultMessageNotificationLevels,
      VerificationLevels,
      ExplicitContentFilterLevels,
      Status: Status2,
      MFALevels,
      PremiumTiers
    } = require_Constants();
    var DataResolver2 = require_DataResolver();
    var SystemChannelFlags = require_SystemChannelFlags();
    var Util = require_Util();
    var deprecationEmittedForSetChannelPositions = false;
    var deprecationEmittedForSetRolePositions = false;
    var deprecationEmittedForDeleted = false;
    var deprecationEmittedForMe = false;
    var deletedGuilds = /* @__PURE__ */ new WeakSet();
    var Guild = class extends AnonymousGuild {
      constructor(client, data) {
        super(client, data, false);
        this.members = new GuildMemberManager(this);
        this.channels = new GuildChannelManager(this);
        this.bans = new GuildBanManager(this);
        this.roles = new RoleManager(this);
        this.presences = new PresenceManager2(this.client);
        this.voiceStates = new VoiceStateManager2(this);
        this.stageInstances = new StageInstanceManager(this);
        this.invites = new GuildInviteManager(this);
        this.scheduledEvents = new GuildScheduledEventManager(this);
        this.autoModerationRules = new AutoModerationRuleManager(this);
        this.settings = new GuildSettingManager(this);
        if (!data) return;
        if (data.unavailable) {
          this.available = false;
        } else {
          this._patch(data);
          if (!data.channels) this.available = false;
        }
        this.shardId = data.shardId;
      }
      /**
       * Whether or not the structure has been deleted
       * @type {boolean}
       * @deprecated This will be removed in the next major version, see https://github.com/discordjs/discord.js/issues/7091
       */
      get deleted() {
        if (!deprecationEmittedForDeleted) {
          deprecationEmittedForDeleted = true;
          process2.emitWarning(
            "Guild#deleted is deprecated, see https://github.com/discordjs/discord.js/issues/7091.",
            "DeprecationWarning"
          );
        }
        return deletedGuilds.has(this);
      }
      set deleted(value) {
        if (!deprecationEmittedForDeleted) {
          deprecationEmittedForDeleted = true;
          process2.emitWarning(
            "Guild#deleted is deprecated, see https://github.com/discordjs/discord.js/issues/7091.",
            "DeprecationWarning"
          );
        }
        if (value) deletedGuilds.add(this);
        else deletedGuilds.delete(this);
      }
      /**
       * The Shard this Guild belongs to.
       * @type {WebSocketShard}
       * @readonly
       */
      get shard() {
        return this.client.ws.shards.get(this.shardId);
      }
      _patch(data) {
        super._patch(data);
        this.id = data.id;
        if ("name" in data) this.name = data.name;
        if ("icon" in data) this.icon = data.icon;
        if ("unavailable" in data) {
          this.available = !data.unavailable;
        } else {
          this.available ?? (this.available = true);
        }
        if ("discovery_splash" in data) {
          this.discoverySplash = data.discovery_splash;
        }
        if ("member_count" in data) {
          this.memberCount = data.member_count;
        }
        if ("large" in data) {
          this.large = Boolean(data.large);
        }
        if ("premium_progress_bar_enabled" in data) {
          this.premiumProgressBarEnabled = data.premium_progress_bar_enabled;
        }
        if ("application_id" in data) {
          this.applicationId = data.application_id;
        }
        if ("afk_timeout" in data) {
          this.afkTimeout = data.afk_timeout;
        }
        if ("afk_channel_id" in data) {
          this.afkChannelId = data.afk_channel_id;
        }
        if ("system_channel_id" in data) {
          this.systemChannelId = data.system_channel_id;
        }
        if ("premium_tier" in data) {
          this.premiumTier = PremiumTiers[data.premium_tier];
        }
        if ("widget_enabled" in data) {
          this.widgetEnabled = data.widget_enabled;
        }
        if ("widget_channel_id" in data) {
          this.widgetChannelId = data.widget_channel_id;
        }
        if ("explicit_content_filter" in data) {
          this.explicitContentFilter = ExplicitContentFilterLevels[data.explicit_content_filter];
        }
        if ("mfa_level" in data) {
          this.mfaLevel = MFALevels[data.mfa_level];
        }
        if ("joined_at" in data) {
          this.joinedTimestamp = new Date(data.joined_at).getTime();
        }
        if ("default_message_notifications" in data) {
          this.defaultMessageNotifications = DefaultMessageNotificationLevels[data.default_message_notifications];
        }
        if ("system_channel_flags" in data) {
          this.systemChannelFlags = new SystemChannelFlags(data.system_channel_flags).freeze();
        }
        if ("max_members" in data) {
          this.maximumMembers = data.max_members;
        } else {
          this.maximumMembers ?? (this.maximumMembers = null);
        }
        if ("max_presences" in data) {
          this.maximumPresences = data.max_presences ?? 25e3;
        } else {
          this.maximumPresences ?? (this.maximumPresences = null);
        }
        if ("max_video_channel_users" in data) {
          this.maxVideoChannelUsers = data.max_video_channel_users;
        } else {
          this.maxVideoChannelUsers ?? (this.maxVideoChannelUsers = null);
        }
        if ("max_stage_video_channel_users" in data) {
          this.maxStageVideoChannelUsers = data.max_stage_video_channel_users;
        } else {
          this.maxStageVideoChannelUsers ?? (this.maxStageVideoChannelUsers = null);
        }
        if ("approximate_member_count" in data) {
          this.approximateMemberCount = data.approximate_member_count;
        } else {
          this.approximateMemberCount ?? (this.approximateMemberCount = null);
        }
        if ("approximate_presence_count" in data) {
          this.approximatePresenceCount = data.approximate_presence_count;
        } else {
          this.approximatePresenceCount ?? (this.approximatePresenceCount = null);
        }
        this.vanityURLUses ?? (this.vanityURLUses = null);
        if ("rules_channel_id" in data) {
          this.rulesChannelId = data.rules_channel_id;
        }
        if ("public_updates_channel_id" in data) {
          this.publicUpdatesChannelId = data.public_updates_channel_id;
        }
        if ("preferred_locale" in data) {
          this.preferredLocale = data.preferred_locale;
        }
        if ("safety_alerts_channel_id" in data) {
          this.safetyAlertsChannelId = data.safety_alerts_channel_id;
        } else {
          this.safetyAlertsChannelId ?? (this.safetyAlertsChannelId = null);
        }
        if (data.channels) {
          this.channels.cache.clear();
          for (const rawChannel of data.channels) {
            this.client.channels._add(rawChannel, this);
          }
        }
        if (data.threads) {
          for (const rawThread of data.threads) {
            this.client.channels._add(rawThread, this);
          }
        }
        if (data.roles) {
          this.roles.cache.clear();
          for (const role of data.roles) this.roles._add(role);
        }
        if (data.members) {
          this.members.cache.clear();
          for (const guildUser of data.members) this.members._add(guildUser);
        }
        if ("owner_id" in data) {
          this.ownerId = data.owner_id;
        }
        if (data.presences) {
          for (const presence of data.presences) {
            this.presences._add(Object.assign(presence, { guild: this }));
          }
        }
        if (data.stage_instances) {
          this.stageInstances.cache.clear();
          for (const stageInstance of data.stage_instances) {
            this.stageInstances._add(stageInstance);
          }
        }
        if (data.guild_scheduled_events) {
          this.scheduledEvents.cache.clear();
          for (const scheduledEvent of data.guild_scheduled_events) {
            this.scheduledEvents._add(scheduledEvent);
          }
        }
        if (data.voice_states) {
          this.voiceStates.cache.clear();
          for (const voiceState of data.voice_states) {
            this.voiceStates._add(voiceState);
          }
        }
        if (!this.emojis) {
          this.emojis = new GuildEmojiManager(this);
          if (data.emojis) for (const emoji of data.emojis) this.emojis._add(emoji);
        } else if (data.emojis) {
          this.client.actions.GuildEmojisUpdate.handle({
            guild_id: this.id,
            emojis: data.emojis
          });
        }
        if (!this.stickers) {
          this.stickers = new GuildStickerManager(this);
          if (data.stickers) for (const sticker of data.stickers) this.stickers._add(sticker);
        } else if (data.stickers) {
          this.client.actions.GuildStickersUpdate.handle({
            guild_id: this.id,
            stickers: data.stickers
          });
        }
      }
      /**
       * The time the client user joined the guild
       * @type {Date}
       * @readonly
       */
      get joinedAt() {
        return new Date(this.joinedTimestamp);
      }
      /**
       * The URL to this guild's discovery splash image.
       * @param {StaticImageURLOptions} [options={}] Options for the Image URL
       * @returns {?string}
       */
      discoverySplashURL({ format, size } = {}) {
        return this.discoverySplash && this.client.rest.cdn.DiscoverySplash(this.id, this.discoverySplash, format, size);
      }
      /**
       * Fetches the owner of the guild.
       * If the member object isn't needed, use {@link Guild#ownerId} instead.
       * @param {BaseFetchOptions} [options] The options for fetching the member
       * @returns {Promise<GuildMember>}
       */
      fetchOwner(options) {
        return this.members.fetch({ ...options, user: this.ownerId });
      }
      /**
       * AFK voice channel for this guild
       * @type {?VoiceChannel}
       * @readonly
       */
      get afkChannel() {
        return this.client.channels.resolve(this.afkChannelId);
      }
      /**
       * System channel for this guild
       * @type {?TextChannel}
       * @readonly
       */
      get systemChannel() {
        return this.client.channels.resolve(this.systemChannelId);
      }
      /**
       * Safety alerts channel for this guild
       * @type {?TextChannel}
       * @readonly
       */
      get safetyAlertsChannel() {
        return this.client.channels.resolve(this.safetyAlertsChannelId);
      }
      /**
       * Widget channel for this guild
       * @type {?(TextChannel|NewsChannel|VoiceChannel|StageChannel|ForumChannel|MediaChannel)}
       * @readonly
       */
      get widgetChannel() {
        return this.client.channels.resolve(this.widgetChannelId);
      }
      /**
       * Rules channel for this guild
       * @type {?TextChannel}
       * @readonly
       */
      get rulesChannel() {
        return this.client.channels.resolve(this.rulesChannelId);
      }
      /**
       * Public updates channel for this guild
       * @type {?TextChannel}
       * @readonly
       */
      get publicUpdatesChannel() {
        return this.client.channels.resolve(this.publicUpdatesChannelId);
      }
      /**
       * The client user as a GuildMember of this guild
       * @type {?GuildMember}
       * @deprecated Use {@link GuildMemberManager#me} instead.
       * @readonly
       */
      get me() {
        if (!deprecationEmittedForMe) {
          process2.emitWarning("Guild#me is deprecated. Use Guild#members#me instead.", "DeprecationWarning");
          deprecationEmittedForMe = true;
        }
        return this.members.me;
      }
      /**
       * The maximum bitrate available for this guild
       * @type {number}
       * @readonly
       */
      get maximumBitrate() {
        if (this.features.includes("VIP_REGIONS")) {
          return 384e3;
        }
        switch (PremiumTiers[this.premiumTier]) {
          case PremiumTiers.TIER_1:
            return 128e3;
          case PremiumTiers.TIER_2:
            return 256e3;
          case PremiumTiers.TIER_3:
            return 384e3;
          default:
            return 96e3;
        }
      }
      /**
       * Fetches a collection of integrations to this guild.
       * Resolves with a collection mapping integrations by their ids.
       * @returns {Promise<Collection<Snowflake|string, Integration>>}
       * @example
       * // Fetch integrations
       * guild.fetchIntegrations()
       *   .then(integrations => console.log(`Fetched ${integrations.size} integrations`))
       *   .catch(console.error);
       */
      async fetchIntegrations() {
        const data = await this.client.api.guilds(this.id).integrations.get();
        return data.reduce(
          (collection, integration) => collection.set(integration.id, new Integration(this.client, integration, this)),
          new Collection2()
        );
      }
      /**
       * Fetches a collection of templates from this guild.
       * Resolves with a collection mapping templates by their codes.
       * @returns {Promise<Collection<string, GuildTemplate>>}
       */
      async fetchTemplates() {
        const templates = await this.client.api.guilds(this.id).templates.get();
        return templates.reduce((col, data) => col.set(data.code, new GuildTemplate2(this.client, data)), new Collection2());
      }
      /**
       * Fetches the welcome screen for this guild.
       * @returns {Promise<WelcomeScreen>}
       */
      async fetchWelcomeScreen() {
        const data = await this.client.api.guilds(this.id, "welcome-screen").get();
        return new WelcomeScreen(this, data);
      }
      /**
       * Creates a template for the guild.
       * @param {string} name The name for the template
       * @param {string} [description] The description for the template
       * @returns {Promise<GuildTemplate>}
       */
      async createTemplate(name, description) {
        const data = await this.client.api.guilds(this.id).templates.post({ data: { name, description } });
        return new GuildTemplate2(this.client, data);
      }
      /**
       * Obtains a guild preview for this guild from Discord.
       * @returns {Promise<GuildPreview>}
       */
      async fetchPreview() {
        const data = await this.client.api.guilds(this.id).preview.get();
        return new GuildPreview2(this.client, data);
      }
      /**
       * An object containing information about a guild's vanity invite.
       * @typedef {Object} Vanity
       * @property {?string} code Vanity invite code
       * @property {number} uses How many times this invite has been used
       */
      /**
       * Fetches the vanity URL invite object to this guild.
       * Resolves with an object containing the vanity URL invite code and the use count
       * @returns {Promise<Vanity>}
       * @example
       * // Fetch invite data
       * guild.fetchVanityData()
       *   .then(res => {
       *     console.log(`Vanity URL: https://discord.gg/${res.code} with ${res.uses} uses`);
       *   })
       *   .catch(console.error);
       */
      async fetchVanityData() {
        const data = await this.client.api.guilds(this.id, "vanity-url").get();
        this.vanityURLCode = data.code;
        this.vanityURLUses = data.uses;
        return data;
      }
      /**
       * Fetches all webhooks for the guild.
       * @returns {Promise<Collection<Snowflake, Webhook>>}
       * @example
       * // Fetch webhooks
       * guild.fetchWebhooks()
       *   .then(webhooks => console.log(`Fetched ${webhooks.size} webhooks`))
       *   .catch(console.error);
       */
      async fetchWebhooks() {
        const apiHooks = await this.client.api.guilds(this.id).webhooks.get();
        const hooks = new Collection2();
        for (const hook of apiHooks) hooks.set(hook.id, new Webhook2(this.client, hook));
        return hooks;
      }
      /**
       * Fetches the guild widget data, requires the widget to be enabled.
       * @returns {Promise<Widget>}
       * @example
       * // Fetches the guild widget data
       * guild.fetchWidget()
       *   .then(widget => console.log(`The widget shows ${widget.channels.size} channels`))
       *   .catch(console.error);
       */
      fetchWidget() {
        return this.client.fetchGuildWidget(this.id);
      }
      /**
       * Data for the Guild Widget Settings object
       * @typedef {Object} GuildWidgetSettings
       * @property {boolean} enabled Whether the widget is enabled
       * @property {?GuildChannel} channel The widget invite channel
       */
      /**
       * The Guild Widget Settings object
       * @typedef {Object} GuildWidgetSettingsData
       * @property {boolean} enabled Whether the widget is enabled
       * @property {?GuildChannelResolvable} channel The widget invite channel
       */
      /**
       * Fetches the guild widget settings.
       * @returns {Promise<GuildWidgetSettings>}
       * @example
       * // Fetches the guild widget settings
       * guild.fetchWidgetSettings()
       *   .then(widget => console.log(`The widget is ${widget.enabled ? 'enabled' : 'disabled'}`))
       *   .catch(console.error);
       */
      async fetchWidgetSettings() {
        const data = await this.client.api.guilds(this.id).widget.get();
        this.widgetEnabled = data.enabled;
        this.widgetChannelId = data.channel_id;
        return {
          enabled: data.enabled,
          channel: data.channel_id ? this.channels.cache.get(data.channel_id) : null
        };
      }
      /**
       * Options used to fetch audit logs.
       * @typedef {Object} GuildAuditLogsFetchOptions
       * @property {Snowflake|GuildAuditLogsEntry} [before] Consider only entries before this entry
       * @property {Snowflake|GuildAuditLogsEntry} [after] Consider only entries after this entry
       * @property {number} [limit] The number of entries to return
       * @property {UserResolvable} [user] Only return entries for actions made by this user
       * @property {AuditLogAction|number} [type] Only return entries for this action type
       */
      /**
       * Fetches audit logs for this guild.
       * @param {GuildAuditLogsFetchOptions} [options={}] Options for fetching audit logs
       * @returns {Promise<GuildAuditLogs>}
       * @example
       * // Output audit log entries
       * guild.fetchAuditLogs()
       *   .then(audit => console.log(audit.entries.first()))
       *   .catch(console.error);
       */
      async fetchAuditLogs({ before, after, limit, user, type } = {}) {
        const data = await this.client.api.guilds(this.id)["audit-logs"].get({
          query: {
            before: (before == null ? void 0 : before.id) ?? before,
            after: (after == null ? void 0 : after.id) ?? after,
            limit,
            user_id: this.client.users.resolveId(user),
            action_type: typeof type === "string" ? GuildAuditLogs.Actions[type] : type
          }
        });
        return GuildAuditLogs.build(this, data);
      }
      /**
       * The data for editing a guild.
       * @typedef {Object} GuildEditData
       * @property {string} [name] The name of the guild
       * @property {?(VerificationLevel|number)} [verificationLevel] The verification level of the guild
       * @property {?(ExplicitContentFilterLevel|number)} [explicitContentFilter] The level of the explicit content filter
       * @property {?VoiceChannelResolvable} [afkChannel] The AFK channel of the guild
       * @property {?TextChannelResolvable} [systemChannel] The system channel of the guild
       * @property {number} [afkTimeout] The AFK timeout of the guild
       * @property {?(BufferResolvable|Base64Resolvable)} [icon] The icon of the guild
       * @property {GuildMemberResolvable} [owner] The owner of the guild
       * @property {?(BufferResolvable|Base64Resolvable)} [splash] The invite splash image of the guild
       * @property {?(BufferResolvable|Base64Resolvable)} [discoverySplash] The discovery splash image of the guild
       * @property {?(BufferResolvable|Base64Resolvable)} [banner] The banner of the guild
       * @property {?(DefaultMessageNotificationLevel|number)} [defaultMessageNotifications] The default message
       * notification level of the guild
       * @property {SystemChannelFlagsResolvable} [systemChannelFlags] The system channel flags of the guild
       * @property {?TextChannelResolvable} [rulesChannel] The rules channel of the guild
       * @property {?TextChannelResolvable} [publicUpdatesChannel] The community updates channel of the guild
       * @property {?string} [preferredLocale] The preferred locale of the guild
       * @property {?TextChannelResolvable} [safetyAlertsChannel] The safety alerts channel of the guild
       * @property {boolean} [premiumProgressBarEnabled] Whether the guild's premium progress bar is enabled
       * @property {?string} [description] The discovery description of the guild
       * @property {Features[]} [features] The features of the guild
       */
      /**
       * Data that can be resolved to a Text Channel object. This can be:
       * * A TextChannel
       * * A Snowflake
       * @typedef {TextChannel|Snowflake} TextChannelResolvable
       */
      /**
       * Data that can be resolved to a Voice Channel object. This can be:
       * * A VoiceChannel
       * * A Snowflake
       * @typedef {VoiceChannel|Snowflake} VoiceChannelResolvable
       */
      /**
       * Updates the guild with new information - e.g. a new name.
       * @param {GuildEditData} data The data to update the guild with
       * @param {string} [reason] Reason for editing this guild
       * @returns {Promise<Guild>}
       * @example
       * // Set the guild name
       * guild.edit({
       *   name: 'Discord Guild',
       * })
       *   .then(updated => console.log(`New guild name ${updated}`))
       *   .catch(console.error);
       */
      async edit(data, reason) {
        const _data = {};
        if (data.name) _data.name = data.name;
        if (typeof data.verificationLevel !== "undefined") {
          _data.verification_level = typeof data.verificationLevel === "number" ? data.verificationLevel : VerificationLevels[data.verificationLevel];
        }
        if (typeof data.afkChannel !== "undefined") {
          _data.afk_channel_id = this.client.channels.resolveId(data.afkChannel);
        }
        if (typeof data.systemChannel !== "undefined") {
          _data.system_channel_id = this.client.channels.resolveId(data.systemChannel);
        }
        if (data.afkTimeout) _data.afk_timeout = Number(data.afkTimeout);
        if (typeof data.icon !== "undefined") _data.icon = await DataResolver2.resolveImage(data.icon);
        if (data.owner) _data.owner_id = this.client.users.resolveId(data.owner);
        if (typeof data.splash !== "undefined") _data.splash = await DataResolver2.resolveImage(data.splash);
        if (typeof data.discoverySplash !== "undefined") {
          _data.discovery_splash = await DataResolver2.resolveImage(data.discoverySplash);
        }
        if (typeof data.banner !== "undefined") _data.banner = await DataResolver2.resolveImage(data.banner);
        if (typeof data.explicitContentFilter !== "undefined") {
          _data.explicit_content_filter = typeof data.explicitContentFilter === "number" ? data.explicitContentFilter : ExplicitContentFilterLevels[data.explicitContentFilter];
        }
        if (typeof data.defaultMessageNotifications !== "undefined") {
          _data.default_message_notifications = typeof data.defaultMessageNotifications === "number" ? data.defaultMessageNotifications : DefaultMessageNotificationLevels[data.defaultMessageNotifications];
        }
        if (typeof data.systemChannelFlags !== "undefined") {
          _data.system_channel_flags = SystemChannelFlags.resolve(data.systemChannelFlags);
        }
        if (typeof data.rulesChannel !== "undefined") {
          _data.rules_channel_id = this.client.channels.resolveId(data.rulesChannel);
        }
        if (typeof data.publicUpdatesChannel !== "undefined") {
          _data.public_updates_channel_id = this.client.channels.resolveId(data.publicUpdatesChannel);
        }
        if (typeof data.features !== "undefined") {
          _data.features = data.features;
        }
        if (typeof data.description !== "undefined") {
          _data.description = data.description;
        }
        if (typeof data.preferredLocale !== "undefined") _data.preferred_locale = data.preferredLocale;
        if (typeof data.safetyAlertsChannel !== "undefined") {
          _data.safety_alerts_channel_id = this.client.channels.resolveId(data.safetyAlertsChannel);
        }
        if ("premiumProgressBarEnabled" in data) _data.premium_progress_bar_enabled = data.premiumProgressBarEnabled;
        const newData = await this.client.api.guilds(this.id).patch({ data: _data, reason });
        return this.client.actions.GuildUpdate.handle(newData).updated;
      }
      /**
       * Welcome channel data
       * @typedef {Object} WelcomeChannelData
       * @property {string} description The description to show for this welcome channel
       * @property {TextChannel|NewsChannel|StoreChannel|Snowflake} channel The channel to link for this welcome channel
       * @property {EmojiIdentifierResolvable} [emoji] The emoji to display for this welcome channel
       */
      /**
       * Welcome screen edit data
       * @typedef {Object} WelcomeScreenEditData
       * @property {boolean} [enabled] Whether the welcome screen is enabled
       * @property {string} [description] The description for the welcome screen
       * @property {WelcomeChannelData[]} [welcomeChannels] The welcome channel data for the welcome screen
       */
      /**
       * Data that can be resolved to a GuildTextChannel object. This can be:
       * * A TextChannel
       * * A NewsChannel
       * * A Snowflake
       * @typedef {TextChannel|NewsChannel|Snowflake} GuildTextChannelResolvable
       */
      /**
       * Data that can be resolved to a GuildVoiceChannel object. This can be:
       * * A VoiceChannel
       * * A StageChannel
       * * A Snowflake
       * @typedef {VoiceChannel|StageChannel|Snowflake} GuildVoiceChannelResolvable
       */
      /**
       * Updates the guild's welcome screen
       * @param {WelcomeScreenEditData} data Data to edit the welcome screen with
       * @returns {Promise<WelcomeScreen>}
       * @example
       * guild.editWelcomeScreen({
       *   description: 'Hello World',
       *   enabled: true,
       *   welcomeChannels: [
       *     {
       *       description: 'foobar',
       *       channel: '222197033908436994',
       *     }
       *   ],
       * })
       */
      async editWelcomeScreen(data) {
        const { enabled, description, welcomeChannels } = data;
        const welcome_channels = welcomeChannels == null ? void 0 : welcomeChannels.map((welcomeChannelData) => {
          const emoji = this.emojis.resolve(welcomeChannelData.emoji);
          return {
            emoji_id: emoji == null ? void 0 : emoji.id,
            emoji_name: (emoji == null ? void 0 : emoji.name) ?? welcomeChannelData.emoji,
            channel_id: this.channels.resolveId(welcomeChannelData.channel),
            description: welcomeChannelData.description
          };
        });
        const patchData = await this.client.api.guilds(this.id, "welcome-screen").patch({
          data: {
            welcome_channels,
            description,
            enabled
          }
        });
        return new WelcomeScreen(this, patchData);
      }
      /**
       * Edits the level of the explicit content filter.
       * @param {?(ExplicitContentFilterLevel|number)} explicitContentFilter The new level of the explicit content filter
       * @param {string} [reason] Reason for changing the level of the guild's explicit content filter
       * @returns {Promise<Guild>}
       */
      setExplicitContentFilter(explicitContentFilter, reason) {
        return this.edit({ explicitContentFilter }, reason);
      }
      /* eslint-disable max-len */
      /**
       * Edits the setting of the default message notifications of the guild.
       * @param {?(DefaultMessageNotificationLevel|number)} defaultMessageNotifications The new default message notification level of the guild
       * @param {string} [reason] Reason for changing the setting of the default message notifications
       * @returns {Promise<Guild>}
       */
      setDefaultMessageNotifications(defaultMessageNotifications, reason) {
        return this.edit({ defaultMessageNotifications }, reason);
      }
      /* eslint-enable max-len */
      /**
       * Edits the flags of the default message notifications of the guild.
       * @param {SystemChannelFlagsResolvable} systemChannelFlags The new flags for the default message notifications
       * @param {string} [reason] Reason for changing the flags of the default message notifications
       * @returns {Promise<Guild>}
       */
      setSystemChannelFlags(systemChannelFlags, reason) {
        return this.edit({ systemChannelFlags }, reason);
      }
      /**
       * Edits the name of the guild.
       * @param {string} name The new name of the guild
       * @param {string} [reason] Reason for changing the guild's name
       * @returns {Promise<Guild>}
       * @example
       * // Edit the guild name
       * guild.setName('Discord Guild')
       *  .then(updated => console.log(`Updated guild name to ${updated.name}`))
       *  .catch(console.error);
       */
      setName(name, reason) {
        return this.edit({ name }, reason);
      }
      /**
       * Edits the verification level of the guild.
       * @param {?(VerificationLevel|number)} verificationLevel The new verification level of the guild
       * @param {string} [reason] Reason for changing the guild's verification level
       * @returns {Promise<Guild>}
       * @example
       * // Edit the guild verification level
       * guild.setVerificationLevel(1)
       *  .then(updated => console.log(`Updated guild verification level to ${guild.verificationLevel}`))
       *  .catch(console.error);
       */
      setVerificationLevel(verificationLevel, reason) {
        return this.edit({ verificationLevel }, reason);
      }
      /**
       * Edits the AFK channel of the guild.
       * @param {?VoiceChannelResolvable} afkChannel The new AFK channel
       * @param {string} [reason] Reason for changing the guild's AFK channel
       * @returns {Promise<Guild>}
       * @example
       * // Edit the guild AFK channel
       * guild.setAFKChannel(channel)
       *  .then(updated => console.log(`Updated guild AFK channel to ${guild.afkChannel.name}`))
       *  .catch(console.error);
       */
      setAFKChannel(afkChannel, reason) {
        return this.edit({ afkChannel }, reason);
      }
      /**
       * Edits the system channel of the guild.
       * @param {?TextChannelResolvable} systemChannel The new system channel
       * @param {string} [reason] Reason for changing the guild's system channel
       * @returns {Promise<Guild>}
       * @example
       * // Edit the guild system channel
       * guild.setSystemChannel(channel)
       *  .then(updated => console.log(`Updated guild system channel to ${guild.systemChannel.name}`))
       *  .catch(console.error);
       */
      setSystemChannel(systemChannel, reason) {
        return this.edit({ systemChannel }, reason);
      }
      /**
       * Edits the AFK timeout of the guild.
       * @param {number} afkTimeout The time in seconds that a user must be idle to be considered AFK
       * @param {string} [reason] Reason for changing the guild's AFK timeout
       * @returns {Promise<Guild>}
       * @example
       * // Edit the guild AFK channel
       * guild.setAFKTimeout(60)
       *  .then(updated => console.log(`Updated guild AFK timeout to ${guild.afkTimeout}`))
       *  .catch(console.error);
       */
      setAFKTimeout(afkTimeout, reason) {
        return this.edit({ afkTimeout }, reason);
      }
      /**
       * Sets a new guild icon.
       * @param {?(Base64Resolvable|BufferResolvable)} icon The new icon of the guild
       * @param {string} [reason] Reason for changing the guild's icon
       * @returns {Promise<Guild>}
       * @example
       * // Edit the guild icon
       * guild.setIcon('./icon.png')
       *  .then(updated => console.log('Updated the guild icon'))
       *  .catch(console.error);
       */
      setIcon(icon, reason) {
        return this.edit({ icon }, reason);
      }
      /**
       * Sets a new owner of the guild.
       * @param {GuildMemberResolvable} owner The new owner of the guild
       * @param {string} [reason] Reason for setting the new owner
       * @returns {Promise<Guild>}
       * @example
       * // Edit the guild owner
       * guild.setOwner(guild.members.cache.first())
       *  .then(guild => guild.fetchOwner())
       *  .then(owner => console.log(`Updated the guild owner to ${owner.displayName}`))
       *  .catch(console.error);
       */
      setOwner(owner, reason) {
        return this.edit({ owner }, reason);
      }
      /**
       * Sets a new guild invite splash image.
       * @param {?(Base64Resolvable|BufferResolvable)} splash The new invite splash image of the guild
       * @param {string} [reason] Reason for changing the guild's invite splash image
       * @returns {Promise<Guild>}
       * @example
       * // Edit the guild splash
       * guild.setSplash('./splash.png')
       *  .then(updated => console.log('Updated the guild splash'))
       *  .catch(console.error);
       */
      setSplash(splash, reason) {
        return this.edit({ splash }, reason);
      }
      /**
       * Sets a new guild discovery splash image.
       * @param {?(Base64Resolvable|BufferResolvable)} discoverySplash The new discovery splash image of the guild
       * @param {string} [reason] Reason for changing the guild's discovery splash image
       * @returns {Promise<Guild>}
       * @example
       * // Edit the guild discovery splash
       * guild.setDiscoverySplash('./discoverysplash.png')
       *   .then(updated => console.log('Updated the guild discovery splash'))
       *   .catch(console.error);
       */
      setDiscoverySplash(discoverySplash, reason) {
        return this.edit({ discoverySplash }, reason);
      }
      /**
       * Sets a new guild banner.
       * @param {?(Base64Resolvable|BufferResolvable)} banner The new banner of the guild
       * @param {string} [reason] Reason for changing the guild's banner
       * @returns {Promise<Guild>}
       * @example
       * guild.setBanner('./banner.png')
       *  .then(updated => console.log('Updated the guild banner'))
       *  .catch(console.error);
       */
      setBanner(banner, reason) {
        return this.edit({ banner }, reason);
      }
      /**
       * Edits the rules channel of the guild.
       * @param {?TextChannelResolvable} rulesChannel The new rules channel
       * @param {string} [reason] Reason for changing the guild's rules channel
       * @returns {Promise<Guild>}
       * @example
       * // Edit the guild rules channel
       * guild.setRulesChannel(channel)
       *  .then(updated => console.log(`Updated guild rules channel to ${guild.rulesChannel.name}`))
       *  .catch(console.error);
       */
      setRulesChannel(rulesChannel, reason) {
        return this.edit({ rulesChannel }, reason);
      }
      /**
       * Edits the community updates channel of the guild.
       * @param {?TextChannelResolvable} publicUpdatesChannel The new community updates channel
       * @param {string} [reason] Reason for changing the guild's community updates channel
       * @returns {Promise<Guild>}
       * @example
       * // Edit the guild community updates channel
       * guild.setPublicUpdatesChannel(channel)
       *  .then(updated => console.log(`Updated guild community updates channel to ${guild.publicUpdatesChannel.name}`))
       *  .catch(console.error);
       */
      setPublicUpdatesChannel(publicUpdatesChannel, reason) {
        return this.edit({ publicUpdatesChannel }, reason);
      }
      /**
       * Edits the preferred locale of the guild.
       * @param {?string} preferredLocale The new preferred locale of the guild
       * @param {string} [reason] Reason for changing the guild's preferred locale
       * @returns {Promise<Guild>}
       * @example
       * // Edit the guild preferred locale
       * guild.setPreferredLocale('en-US')
       *  .then(updated => console.log(`Updated guild preferred locale to ${guild.preferredLocale}`))
       *  .catch(console.error);
       */
      setPreferredLocale(preferredLocale, reason) {
        return this.edit({ preferredLocale }, reason);
      }
      /**
       * Edits the safety alerts channel of the guild.
       * @param {?TextChannelResolvable} safetyAlertsChannel The new safety alerts channel
       * @param {string} [reason] Reason for changing the guild's safety alerts channel
       * @returns {Promise<Guild>}
       * @example
       * // Edit the guild safety alerts channel
       * guild.setSafetyAlertsChannel(channel)
       *  .then(updated => console.log(`Updated guild safety alerts channel to ${updated.safetyAlertsChannel.name}`))
       *  .catch(console.error);
       */
      setSafetyAlertsChannel(safetyAlertsChannel, reason) {
        return this.edit({ safetyAlertsChannel }, reason);
      }
      /**
       * Edits the enabled state of the guild's premium progress bar
       * @param {boolean} [enabled=true] The new enabled state of the guild's premium progress bar
       * @param {string} [reason] Reason for changing the state of the guild's premium progress bar
       * @returns {Promise<Guild>}
       */
      setPremiumProgressBarEnabled(enabled = true, reason) {
        return this.edit({ premiumProgressBarEnabled: enabled }, reason);
      }
      /**
       * Data that can be resolved to give a Category Channel object. This can be:
       * * A CategoryChannel object
       * * A Snowflake
       * @typedef {CategoryChannel|Snowflake} CategoryChannelResolvable
       */
      /**
       * The data needed for updating a channel's position.
       * @typedef {Object} ChannelPosition
       * @property {GuildChannel|Snowflake} channel Channel to update
       * @property {number} [position] New position for the channel
       * @property {CategoryChannelResolvable} [parent] Parent channel for this channel
       * @property {boolean} [lockPermissions] If the overwrites should be locked to the parents overwrites
       */
      /**
       * Batch-updates the guild's channels' positions.
       * <info>Only one channel's parent can be changed at a time</info>
       * @param {ChannelPosition[]} channelPositions Channel positions to update
       * @returns {Promise<Guild>}
       * @deprecated Use {@link GuildChannelManager#setPositions} instead
       * @example
       * guild.setChannelPositions([{ channel: channelId, position: newChannelIndex }])
       *   .then(guild => console.log(`Updated channel positions for ${guild}`))
       *   .catch(console.error);
       */
      setChannelPositions(channelPositions) {
        if (!deprecationEmittedForSetChannelPositions) {
          process2.emitWarning(
            "The Guild#setChannelPositions method is deprecated. Use GuildChannelManager#setPositions instead.",
            "DeprecationWarning"
          );
          deprecationEmittedForSetChannelPositions = true;
        }
        return this.channels.setPositions(channelPositions);
      }
      /**
       * The data needed for updating a guild role's position
       * @typedef {Object} GuildRolePosition
       * @property {RoleResolvable} role The role's id
       * @property {number} position The position to update
       */
      /**
       * Batch-updates the guild's role positions
       * @param {GuildRolePosition[]} rolePositions Role positions to update
       * @returns {Promise<Guild>}
       * @deprecated Use {@link RoleManager#setPositions} instead
       * @example
       * guild.setRolePositions([{ role: roleId, position: updatedRoleIndex }])
       *  .then(guild => console.log(`Role positions updated for ${guild}`))
       *  .catch(console.error);
       */
      setRolePositions(rolePositions) {
        if (!deprecationEmittedForSetRolePositions) {
          process2.emitWarning(
            "The Guild#setRolePositions method is deprecated. Use RoleManager#setPositions instead.",
            "DeprecationWarning"
          );
          deprecationEmittedForSetRolePositions = true;
        }
        return this.roles.setPositions(rolePositions);
      }
      /**
       * Edits the guild's widget settings.
       * @param {GuildWidgetSettingsData} settings The widget settings for the guild
       * @param {string} [reason] Reason for changing the guild's widget settings
       * @returns {Promise<Guild>}
       */
      async setWidgetSettings(settings, reason) {
        await this.client.api.guilds(this.id).widget.patch({
          data: {
            enabled: settings.enabled,
            channel_id: this.channels.resolveId(settings.channel)
          },
          reason
        });
        return this;
      }
      /**
       * Sets whether this guild's invites are disabled.
       * @param {boolean} [disabled=true] Whether the invites are disabled
       * @returns {Promise<Guild>}
       */
      disableInvites(disabled = true) {
        const features = this.features.filter((feature) => feature !== "INVITES_DISABLED");
        if (disabled) features.push("INVITES_DISABLED");
        return this.edit({ features });
      }
      /**
       * Leaves the guild.
       * @returns {Promise<Guild>}
       * @example
       * // Leave a guild
       * guild.leave()
       *   .then(guild => console.log(`Left the guild: ${guild.name}`))
       *   .catch(console.error);
       */
      async leave() {
        if (this.ownerId === this.client.user.id) throw new Error2("GUILD_OWNED");
        await this.client.api.users("@me").guilds(this.id).delete();
        return this.client.actions.GuildDelete.handle({ id: this.id }).guild;
      }
      /**
       * Deletes the guild.
       * @returns {Promise<Guild>}
       * @example
       * // Delete a guild
       * guild.delete()
       *   .then(g => console.log(`Deleted the guild ${g}`))
       *   .catch(console.error);
       */
      async delete() {
        await this.client.api.guilds(this.id).delete();
        return this.client.actions.GuildDelete.handle({ id: this.id }).guild;
      }
      /**
       * Whether this guild equals another guild. It compares all properties, so for most operations
       * it is advisable to just compare `guild.id === guild2.id` as it is much faster and is often
       * what most users need.
       * @param {Guild} guild The guild to compare with
       * @returns {boolean}
       */
      equals(guild) {
        return guild && guild instanceof this.constructor && this.id === guild.id && this.available === guild.available && this.splash === guild.splash && this.discoverySplash === guild.discoverySplash && this.name === guild.name && this.memberCount === guild.memberCount && this.large === guild.large && this.icon === guild.icon && this.ownerId === guild.ownerId && this.verificationLevel === guild.verificationLevel && (this.features === guild.features || this.features.length === guild.features.length && this.features.every((feat, i) => feat === guild.features[i]));
      }
      toJSON() {
        const json = super.toJSON({
          available: false,
          createdTimestamp: true,
          nameAcronym: true,
          presences: false,
          voiceStates: false
        });
        json.iconURL = this.iconURL();
        json.splashURL = this.splashURL();
        json.discoverySplashURL = this.discoverySplashURL();
        json.bannerURL = this.bannerURL();
        return json;
      }
      /**
       * Marks the guild as read.
       * @returns {Promise<void>}
       * @example
       * const guild = client.guilds.cache.get('id');
       * guild.markAsRead();
       */
      markAsRead() {
        return this.client.api.guilds(this.id).ack.post();
      }
      /**
       * Set Community Feature.
       * @param {boolean} stats True / False to enable / disable Community Feature
       * @param {GuildTextChannelResolvable} [publicUpdatesChannel] The community updates channel of the guild
       * @param {GuildTextChannelResolvable} [rulesChannel] The new rules channel
       * @param {string} [reason] Reason for changing the community feature
       * @returns {Promise<Guild>}
       */
      async setCommunity(stats = true, publicUpdatesChannel, rulesChannel, reason) {
        if (stats) {
          const everyoneRole = this.roles.everyone;
          if (everyoneRole.mentionable) {
            await everyoneRole.setMentionable(false, reason);
          }
          return this.edit(
            {
              defaultMessageNotifications: "ONLY_MENTIONS",
              explicitContentFilter: "ALL_MEMBERS",
              features: [...this.features, "COMMUNITY"],
              publicUpdatesChannel: this.channels.resolveId(publicUpdatesChannel) || "1",
              rulesChannel: this.channels.resolveId(rulesChannel) || "1",
              verificationLevel: VerificationLevels[this.verificationLevel] < 1 ? "LOW" : this.verificationLevel
              // Email
            },
            reason
          );
        } else {
          return this.edit(
            {
              publicUpdatesChannel: null,
              rulesChannel: null,
              features: this.features.filter((f) => f !== "COMMUNITY"),
              preferredLocale: this.preferredLocale,
              description: this.description
            },
            reason
          );
        }
      }
      /**
       * Get the top emojis of this guild.
       * @returns {Promise<Collection<number, GuildEmoji>>}
       */
      topEmojis() {
        return new Promise((resolve, reject) => {
          this.client.api.guilds(this.id)["top-emojis"].get().then((data) => {
            const emojis = new Collection2();
            for (const emoji of data.items) {
              emojis.set(emoji.emoji_rank, this.emojis.cache.get(emoji.emoji_id));
            }
            resolve(emojis);
          }).catch(reject);
        });
      }
      /**
       * Set the vanity URL to this guild.
       * Resolves with an object containing the vanity URL invite code and the use count.
       * @param {string} [code=''] Vanity URL code
       * @param {string|number} [mfaCode = null] Two-factor authentication code
       * After you enter the mfaCode, you will receive a `__Secure-recent_mfa` cookie, which is valid for about
       * 5 minutes, during which you won't need to enter MFA again.
       * @returns {Promise<Vanity>}
       * @example
       * // Set invite code
       * guild.setVanityCode('elysia', '123456')
       *   .then(res => {
       *     console.log(`Vanity URL: https://discord.gg/${res.code} with ${res.uses} uses`);
       *   })
       *   .catch(console.error);
       */
      async setVanityCode(code = "", mfaCode = null) {
        if (typeof code !== "string") throw new TypeError("INVALID_VANITY_URL_CODE");
        const data = await this.client.api.guilds(this.id, "vanity-url").patch({
          data: { code },
          mfaCode
        });
        this.vanityURLCode = data.code;
        this.vanityURLUses = data.uses;
        return data;
      }
      /**
       * The voice state adapter for this guild that can be used with @discordjs/voice to play audio in voice
       * and stage channels.
       * @type {Function}
       * @readonly
       */
      get voiceAdapterCreator() {
        return (methods) => {
          this.client.voice.adapters.set(this.id, methods);
          return {
            sendPayload: (data) => {
              if (this.shard.status !== Status2.READY) return false;
              this.shard.send(data);
              return true;
            },
            destroy: () => {
              this.client.voice.adapters.delete(this.id);
            }
          };
        };
      }
      /**
       * Creates a collection of this guild's roles, sorted by their position and ids.
       * @returns {Collection<Snowflake, Role>}
       * @private
       */
      _sortedRoles() {
        return Util.discordSort(this.roles.cache);
      }
      /**
       * Creates a collection of this guild's or a specific category's channels, sorted by their position and ids.
       * @param {GuildChannel} [channel] Category to get the channels of
       * @returns {Collection<Snowflake, GuildChannel>}
       * @private
       */
      _sortedChannels(channel) {
        const category = channel.type === ChannelTypes.GUILD_CATEGORY;
        return Util.discordSort(
          this.channels.cache.filter(
            (c) => (["GUILD_TEXT", "GUILD_NEWS", "GUILD_STORE"].includes(channel.type) ? ["GUILD_TEXT", "GUILD_NEWS", "GUILD_STORE"].includes(c.type) : c.type === channel.type) && (category || c.parent === channel.parent)
          )
        );
      }
    };
    exports2.Guild = Guild;
    exports2.deletedGuilds = deletedGuilds;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/actions/GuildDelete.js
var require_GuildDelete = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/actions/GuildDelete.js"(exports2, module2) {
    "use strict";
    var { setTimeout: setTimeout2 } = require_node_timers();
    var Action = require_Action();
    var { deletedGuilds } = require_Guild();
    var { Events: Events2 } = require_Constants();
    var GuildDeleteAction = class extends Action {
      constructor(client) {
        super(client);
        this.deleted = /* @__PURE__ */ new Map();
      }
      handle(data) {
        var _a;
        const client = this.client;
        let guild = client.guilds.cache.get(data.id);
        if (guild) {
          if (data.unavailable) {
            guild.available = false;
            client.emit(Events2.GUILD_UNAVAILABLE, guild);
            return {
              guild: null
            };
          }
          for (const channel of guild.channels.cache.values()) this.client.channels._remove(channel.id);
          (_a = client.voice.adapters.get(data.id)) == null ? void 0 : _a.destroy();
          client.guilds.cache.delete(guild.id);
          deletedGuilds.add(guild);
          client.emit(Events2.GUILD_DELETE, guild);
          this.deleted.set(guild.id, guild);
          this.scheduleForDeletion(guild.id);
        } else {
          guild = this.deleted.get(data.id) ?? null;
        }
        return { guild };
      }
      scheduleForDeletion(id) {
        setTimeout2(() => this.deleted.delete(id), this.client.options.restWsBridgeTimeout).unref();
      }
    };
    module2.exports = GuildDeleteAction;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/actions/GuildEmojiCreate.js
var require_GuildEmojiCreate = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/actions/GuildEmojiCreate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var { Events: Events2 } = require_Constants();
    var GuildEmojiCreateAction = class extends Action {
      handle(guild, createdEmoji) {
        const already = guild.emojis.cache.has(createdEmoji.id);
        const emoji = guild.emojis._add(createdEmoji);
        if (!already) this.client.emit(Events2.GUILD_EMOJI_CREATE, emoji);
        return { emoji };
      }
    };
    module2.exports = GuildEmojiCreateAction;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/actions/GuildEmojiDelete.js
var require_GuildEmojiDelete = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/actions/GuildEmojiDelete.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var { deletedEmojis } = require_Emoji();
    var { Events: Events2 } = require_Constants();
    var GuildEmojiDeleteAction = class extends Action {
      handle(emoji) {
        emoji.guild.emojis.cache.delete(emoji.id);
        deletedEmojis.add(emoji);
        this.client.emit(Events2.GUILD_EMOJI_DELETE, emoji);
        return { emoji };
      }
    };
    module2.exports = GuildEmojiDeleteAction;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/actions/GuildEmojiUpdate.js
var require_GuildEmojiUpdate = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/actions/GuildEmojiUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var { Events: Events2 } = require_Constants();
    var GuildEmojiUpdateAction = class extends Action {
      handle(current, data) {
        const old = current._update(data);
        this.client.emit(Events2.GUILD_EMOJI_UPDATE, old, current);
        return { emoji: current };
      }
    };
    module2.exports = GuildEmojiUpdateAction;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/actions/GuildEmojisUpdate.js
var require_GuildEmojisUpdate = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/actions/GuildEmojisUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var GuildEmojisUpdateAction = class extends Action {
      handle(data) {
        const guild = this.client.guilds.cache.get(data.guild_id);
        if (!(guild == null ? void 0 : guild.emojis)) return;
        const deletions = new Map(guild.emojis.cache);
        for (const emoji of data.emojis) {
          const cachedEmoji = guild.emojis.cache.get(emoji.id);
          if (cachedEmoji) {
            deletions.delete(emoji.id);
            if (!cachedEmoji.equals(emoji)) {
              this.client.actions.GuildEmojiUpdate.handle(cachedEmoji, emoji);
            }
          } else {
            this.client.actions.GuildEmojiCreate.handle(guild, emoji);
          }
        }
        for (const emoji of deletions.values()) {
          this.client.actions.GuildEmojiDelete.handle(emoji);
        }
      }
    };
    module2.exports = GuildEmojisUpdateAction;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/actions/GuildIntegrationsUpdate.js
var require_GuildIntegrationsUpdate = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/actions/GuildIntegrationsUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var { Events: Events2 } = require_Constants();
    var GuildIntegrationsUpdate = class extends Action {
      handle(data) {
        const client = this.client;
        const guild = client.guilds.cache.get(data.guild_id);
        if (guild) client.emit(Events2.GUILD_INTEGRATIONS_UPDATE, guild);
      }
    };
    module2.exports = GuildIntegrationsUpdate;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/actions/GuildMemberRemove.js
var require_GuildMemberRemove = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/actions/GuildMemberRemove.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var { deletedGuildMembers } = require_GuildMember();
    var { Events: Events2, Status: Status2 } = require_Constants();
    var GuildMemberRemoveAction = class extends Action {
      handle(data, shard) {
        const client = this.client;
        const guild = client.guilds.cache.get(data.guild_id);
        let member = null;
        if (guild) {
          member = this.getMember({ user: data.user }, guild);
          guild.memberCount--;
          if (member) {
            deletedGuildMembers.add(member);
            guild.members.cache.delete(member.id);
            if (shard.status === Status2.READY) client.emit(Events2.GUILD_MEMBER_REMOVE, member);
          }
          guild.presences.cache.delete(data.user.id);
          guild.voiceStates.cache.delete(data.user.id);
        }
        return { guild, member };
      }
    };
    module2.exports = GuildMemberRemoveAction;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/actions/GuildMemberUpdate.js
var require_GuildMemberUpdate = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/actions/GuildMemberUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var { Status: Status2, Events: Events2 } = require_Constants();
    var GuildMemberUpdateAction = class extends Action {
      handle(data, shard) {
        const { client } = this;
        if (data.user.username) {
          const user = client.users.cache.get(data.user.id);
          if (!user) {
            client.users._add(data.user);
          } else if (!user._equals(data.user)) {
            client.actions.UserUpdate.handle(data.user);
          }
        }
        const guild = client.guilds.cache.get(data.guild_id);
        if (guild) {
          const member = this.getMember({ user: data.user }, guild);
          if (member) {
            const old = member._update(data);
            if (shard.status === Status2.READY && !member.equals(old)) client.emit(Events2.GUILD_MEMBER_UPDATE, old, member);
          } else {
            const newMember = guild.members._add(data);
            this.client.emit(Events2.GUILD_MEMBER_AVAILABLE, newMember);
          }
        }
      }
    };
    module2.exports = GuildMemberUpdateAction;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/actions/GuildRoleCreate.js
var require_GuildRoleCreate = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/actions/GuildRoleCreate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var { Events: Events2 } = require_Constants();
    var GuildRoleCreate = class extends Action {
      handle(data) {
        const client = this.client;
        const guild = client.guilds.cache.get(data.guild_id);
        let role;
        if (guild) {
          const already = guild.roles.cache.has(data.role.id);
          role = guild.roles._add(data.role);
          if (!already) client.emit(Events2.GUILD_ROLE_CREATE, role);
        }
        return { role };
      }
    };
    module2.exports = GuildRoleCreate;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/actions/GuildRoleDelete.js
var require_GuildRoleDelete = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/actions/GuildRoleDelete.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var { deletedRoles } = require_Role();
    var { Events: Events2 } = require_Constants();
    var GuildRoleDeleteAction = class extends Action {
      handle(data) {
        const client = this.client;
        const guild = client.guilds.cache.get(data.guild_id);
        let role;
        if (guild) {
          role = guild.roles.cache.get(data.role_id);
          if (role) {
            guild.roles.cache.delete(data.role_id);
            deletedRoles.add(role);
            client.emit(Events2.GUILD_ROLE_DELETE, role);
          }
        }
        return { role };
      }
    };
    module2.exports = GuildRoleDeleteAction;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/actions/GuildRoleUpdate.js
var require_GuildRoleUpdate = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/actions/GuildRoleUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var { Events: Events2 } = require_Constants();
    var GuildRoleUpdateAction = class extends Action {
      handle(data) {
        const client = this.client;
        const guild = client.guilds.cache.get(data.guild_id);
        if (guild) {
          let old = null;
          const role = guild.roles.cache.get(data.role.id);
          if (role) {
            old = role._update(data.role);
            client.emit(Events2.GUILD_ROLE_UPDATE, old, role);
          }
          return {
            old,
            updated: role
          };
        }
        return {
          old: null,
          updated: null
        };
      }
    };
    module2.exports = GuildRoleUpdateAction;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/actions/GuildRolesPositionUpdate.js
var require_GuildRolesPositionUpdate = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/actions/GuildRolesPositionUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var GuildRolesPositionUpdate = class extends Action {
      handle(data) {
        const client = this.client;
        const guild = client.guilds.cache.get(data.guild_id);
        if (guild) {
          for (const partialRole of data.roles) {
            const role = guild.roles.cache.get(partialRole.id);
            if (role) role.rawPosition = partialRole.position;
          }
        }
        return { guild };
      }
    };
    module2.exports = GuildRolesPositionUpdate;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/actions/GuildScheduledEventCreate.js
var require_GuildScheduledEventCreate = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/actions/GuildScheduledEventCreate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var { Events: Events2 } = require_Constants();
    var GuildScheduledEventCreateAction = class extends Action {
      handle(data) {
        const client = this.client;
        const guild = client.guilds.cache.get(data.guild_id);
        if (guild) {
          const guildScheduledEvent = guild.scheduledEvents._add(data);
          client.emit(Events2.GUILD_SCHEDULED_EVENT_CREATE, guildScheduledEvent);
          return { guildScheduledEvent };
        }
        return {};
      }
    };
    module2.exports = GuildScheduledEventCreateAction;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/actions/GuildScheduledEventDelete.js
var require_GuildScheduledEventDelete = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/actions/GuildScheduledEventDelete.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var { Events: Events2 } = require_Constants();
    var GuildScheduledEventDeleteAction = class extends Action {
      handle(data) {
        const client = this.client;
        const guild = client.guilds.cache.get(data.guild_id);
        if (guild) {
          const guildScheduledEvent = this.getScheduledEvent(data, guild);
          if (guildScheduledEvent) {
            guild.scheduledEvents.cache.delete(guildScheduledEvent.id);
            client.emit(Events2.GUILD_SCHEDULED_EVENT_DELETE, guildScheduledEvent);
            return { guildScheduledEvent };
          }
        }
        return {};
      }
    };
    module2.exports = GuildScheduledEventDeleteAction;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/actions/GuildScheduledEventUpdate.js
var require_GuildScheduledEventUpdate = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/actions/GuildScheduledEventUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var { Events: Events2 } = require_Constants();
    var GuildScheduledEventUpdateAction = class extends Action {
      handle(data) {
        var _a;
        const client = this.client;
        const guild = client.guilds.cache.get(data.guild_id);
        if (guild) {
          const oldGuildScheduledEvent = ((_a = guild.scheduledEvents.cache.get(data.id)) == null ? void 0 : _a._clone()) ?? null;
          const newGuildScheduledEvent = guild.scheduledEvents._add(data);
          client.emit(Events2.GUILD_SCHEDULED_EVENT_UPDATE, oldGuildScheduledEvent, newGuildScheduledEvent);
          return { oldGuildScheduledEvent, newGuildScheduledEvent };
        }
        return {};
      }
    };
    module2.exports = GuildScheduledEventUpdateAction;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/actions/GuildScheduledEventUserAdd.js
var require_GuildScheduledEventUserAdd = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/actions/GuildScheduledEventUserAdd.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var { Events: Events2 } = require_Constants();
    var GuildScheduledEventUserAddAction = class extends Action {
      handle(data) {
        const client = this.client;
        const guild = client.guilds.cache.get(data.guild_id);
        if (guild) {
          const guildScheduledEvent = this.getScheduledEvent(data, guild);
          const user = this.getUser(data);
          if (guildScheduledEvent && user) {
            client.emit(Events2.GUILD_SCHEDULED_EVENT_USER_ADD, guildScheduledEvent, user);
            return { guildScheduledEvent, user };
          }
        }
        return {};
      }
    };
    module2.exports = GuildScheduledEventUserAddAction;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/actions/GuildScheduledEventUserRemove.js
var require_GuildScheduledEventUserRemove = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/actions/GuildScheduledEventUserRemove.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var { Events: Events2 } = require_Constants();
    var GuildScheduledEventUserRemoveAction = class extends Action {
      handle(data) {
        const client = this.client;
        const guild = client.guilds.cache.get(data.guild_id);
        if (guild) {
          const guildScheduledEvent = this.getScheduledEvent(data, guild);
          const user = this.getUser(data);
          if (guildScheduledEvent && user) {
            client.emit(Events2.GUILD_SCHEDULED_EVENT_USER_REMOVE, guildScheduledEvent, user);
            return { guildScheduledEvent, user };
          }
        }
        return {};
      }
    };
    module2.exports = GuildScheduledEventUserRemoveAction;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/actions/GuildStickerCreate.js
var require_GuildStickerCreate = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/actions/GuildStickerCreate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var { Events: Events2 } = require_Constants();
    var GuildStickerCreateAction = class extends Action {
      handle(guild, createdSticker) {
        const already = guild.stickers.cache.has(createdSticker.id);
        const sticker = guild.stickers._add(createdSticker);
        if (!already) this.client.emit(Events2.GUILD_STICKER_CREATE, sticker);
        return { sticker };
      }
    };
    module2.exports = GuildStickerCreateAction;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/actions/GuildStickerDelete.js
var require_GuildStickerDelete = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/actions/GuildStickerDelete.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var { deletedStickers } = require_Sticker();
    var { Events: Events2 } = require_Constants();
    var GuildStickerDeleteAction = class extends Action {
      handle(sticker) {
        sticker.guild.stickers.cache.delete(sticker.id);
        deletedStickers.add(sticker);
        this.client.emit(Events2.GUILD_STICKER_DELETE, sticker);
        return { sticker };
      }
    };
    module2.exports = GuildStickerDeleteAction;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/actions/GuildStickerUpdate.js
var require_GuildStickerUpdate = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/actions/GuildStickerUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var { Events: Events2 } = require_Constants();
    var GuildStickerUpdateAction = class extends Action {
      handle(current, data) {
        const old = current._update(data);
        this.client.emit(Events2.GUILD_STICKER_UPDATE, old, current);
        return { sticker: current };
      }
    };
    module2.exports = GuildStickerUpdateAction;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/actions/GuildStickersUpdate.js
var require_GuildStickersUpdate = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/actions/GuildStickersUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var GuildStickersUpdateAction = class extends Action {
      handle(data) {
        const guild = this.client.guilds.cache.get(data.guild_id);
        if (!(guild == null ? void 0 : guild.stickers)) return;
        const deletions = new Map(guild.stickers.cache);
        for (const sticker of data.stickers) {
          const cachedSticker = guild.stickers.cache.get(sticker.id);
          if (cachedSticker) {
            deletions.delete(sticker.id);
            if (!cachedSticker.equals(sticker)) {
              this.client.actions.GuildStickerUpdate.handle(cachedSticker, sticker);
            }
          } else {
            this.client.actions.GuildStickerCreate.handle(guild, sticker);
          }
        }
        for (const sticker of deletions.values()) {
          this.client.actions.GuildStickerDelete.handle(sticker);
        }
      }
    };
    module2.exports = GuildStickersUpdateAction;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/actions/GuildUpdate.js
var require_GuildUpdate = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/actions/GuildUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var { Events: Events2 } = require_Constants();
    var GuildUpdateAction = class extends Action {
      handle(data) {
        const client = this.client;
        const guild = client.guilds.cache.get(data.id);
        if (guild) {
          const old = guild._update(data);
          client.emit(Events2.GUILD_UPDATE, old, guild);
          return {
            old,
            updated: guild
          };
        }
        return {
          old: null,
          updated: null
        };
      }
    };
    module2.exports = GuildUpdateAction;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/actions/InviteCreate.js
var require_InviteCreate = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/actions/InviteCreate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var { Events: Events2 } = require_Constants();
    var InviteCreateAction = class extends Action {
      handle(data) {
        const client = this.client;
        const channel = client.channels.cache.get(data.channel_id);
        const guild = client.guilds.cache.get(data.guild_id);
        if (!channel) return false;
        const inviteData = Object.assign(data, { channel, guild });
        const invite = guild.invites._add(inviteData);
        client.emit(Events2.INVITE_CREATE, invite);
        return { invite };
      }
    };
    module2.exports = InviteCreateAction;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/actions/InviteDelete.js
var require_InviteDelete = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/actions/InviteDelete.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Invite2 = require_Invite();
    var { Events: Events2 } = require_Constants();
    var InviteDeleteAction = class extends Action {
      handle(data) {
        const client = this.client;
        const channel = client.channels.cache.get(data.channel_id);
        const guild = client.guilds.cache.get(data.guild_id);
        if (!channel) return false;
        const inviteData = Object.assign(data, { channel, guild });
        const invite = new Invite2(client, inviteData);
        guild.invites.cache.delete(invite.code);
        client.emit(Events2.INVITE_DELETE, invite);
        return { invite };
      }
    };
    module2.exports = InviteDeleteAction;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/actions/MessageCreate.js
var require_MessageCreate = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/actions/MessageCreate.js"(exports2, module2) {
    "use strict";
    var process2 = require_node_process();
    var Action = require_Action();
    var { Events: Events2 } = require_Constants();
    var deprecationEmitted = false;
    var MessageCreateAction = class extends Action {
      handle(data) {
        var _a;
        const client = this.client;
        const channel = this.getChannel({
          id: data.channel_id,
          author: data.author,
          ..."guild_id" in data && { guild_id: data.guild_id }
        });
        if (channel) {
          if (!channel.isText()) return {};
          const existing = channel.messages.cache.get(data.id);
          if (existing && ((_a = existing.author) == null ? void 0 : _a.id) !== this.client.user.id) return { message: existing };
          const message = existing ?? channel.messages._add(data);
          channel.lastMessageId = data.id;
          client.emit(Events2.MESSAGE_CREATE, message);
          if (client.emit("message", message) && !deprecationEmitted) {
            deprecationEmitted = true;
            process2.emitWarning("The message event is deprecated. Use messageCreate instead", "DeprecationWarning");
          }
          return { message };
        }
        return {};
      }
    };
    module2.exports = MessageCreateAction;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/actions/MessageDelete.js
var require_MessageDelete = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/actions/MessageDelete.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var { deletedMessages } = require_Message();
    var { Events: Events2 } = require_Constants();
    var MessageDeleteAction = class extends Action {
      handle(data) {
        const client = this.client;
        const channel = this.getChannel({ id: data.channel_id, ..."guild_id" in data && { guild_id: data.guild_id } });
        let message;
        if (channel) {
          if (!channel.isText()) return {};
          message = this.getMessage(data, channel);
          if (message) {
            channel.messages.cache.delete(message.id);
            deletedMessages.add(message);
            client.emit(Events2.MESSAGE_DELETE, message);
          }
        }
        return { message };
      }
    };
    module2.exports = MessageDeleteAction;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/actions/MessageDeleteBulk.js
var require_MessageDeleteBulk = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/actions/MessageDeleteBulk.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var Action = require_Action();
    var { deletedMessages } = require_Message();
    var { Events: Events2 } = require_Constants();
    var MessageDeleteBulkAction = class extends Action {
      handle(data) {
        const client = this.client;
        const channel = client.channels.cache.get(data.channel_id);
        if (channel) {
          if (!channel.isText()) return {};
          const ids = data.ids;
          const messages = new Collection2();
          for (const id of ids) {
            const message = this.getMessage(
              {
                id,
                guild_id: data.guild_id
              },
              channel,
              false
            );
            if (message) {
              deletedMessages.add(message);
              messages.set(message.id, message);
              channel.messages.cache.delete(id);
            }
          }
          if (messages.size > 0) client.emit(Events2.MESSAGE_BULK_DELETE, messages);
          return { messages };
        }
        return {};
      }
    };
    module2.exports = MessageDeleteBulkAction;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/actions/MessagePollVoteAdd.js
var require_MessagePollVoteAdd = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/actions/MessagePollVoteAdd.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var { Events: Events2 } = require_Constants();
    var MessagePollVoteAddAction = class extends Action {
      handle(data) {
        const channel = this.getChannel(data);
        if (!(channel == null ? void 0 : channel.isText())) return false;
        const message = this.getMessage(data, channel);
        if (!message) return false;
        const { poll } = message;
        const answer = poll == null ? void 0 : poll.answers.get(data.answer_id);
        if (!answer) return false;
        answer.voteCount++;
        this.client.emit(Events2.MESSAGE_POLL_VOTE_ADD, answer, data.user_id);
        return { poll };
      }
    };
    module2.exports = MessagePollVoteAddAction;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/actions/MessagePollVoteRemove.js
var require_MessagePollVoteRemove = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/actions/MessagePollVoteRemove.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var { Events: Events2 } = require_Constants();
    var MessagePollVoteRemoveAction = class extends Action {
      handle(data) {
        const channel = this.getChannel(data);
        if (!(channel == null ? void 0 : channel.isText())) return false;
        const message = this.getMessage(data, channel);
        if (!message) return false;
        const { poll } = message;
        const answer = poll == null ? void 0 : poll.answers.get(data.answer_id);
        if (!answer) return false;
        answer.voteCount--;
        this.client.emit(Events2.MESSAGE_POLL_VOTE_REMOVE, answer, data.user_id);
        return { poll };
      }
    };
    module2.exports = MessagePollVoteRemoveAction;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/actions/MessageReactionAdd.js
var require_MessageReactionAdd = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/actions/MessageReactionAdd.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var { Events: Events2 } = require_Constants();
    var { PartialTypes } = require_Constants();
    var MessageReactionAdd = class extends Action {
      handle(data, fromStructure = false) {
        if (!data.emoji) return false;
        const user = this.getUserFromMember(data);
        if (!user) return false;
        const channel = this.getChannel({
          id: data.channel_id,
          user_id: data.user_id,
          ..."guild_id" in data && { guild_id: data.guild_id }
        });
        if (!channel || !channel.isText()) return false;
        const message = this.getMessage(data, channel);
        if (!message) return false;
        const includePartial = this.client.options.partials.includes(PartialTypes.REACTION);
        if (message.partial && !includePartial) return false;
        const reaction = message.reactions._add({
          emoji: data.emoji,
          count: message.partial ? null : 0,
          me: user.id === this.client.user.id,
          ...data
        });
        if (!reaction) return false;
        reaction._add(user, data.burst);
        if (fromStructure) return { message, reaction, user };
        this.client.emit(Events2.MESSAGE_REACTION_ADD, reaction, user, { burst: data.burst });
        return { message, reaction, user };
      }
    };
    module2.exports = MessageReactionAdd;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/actions/MessageReactionRemove.js
var require_MessageReactionRemove = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/actions/MessageReactionRemove.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var { Events: Events2 } = require_Constants();
    var MessageReactionRemove = class extends Action {
      handle(data) {
        if (!data.emoji) return false;
        const user = this.getUser(data);
        if (!user) return false;
        const channel = this.getChannel({
          id: data.channel_id,
          user_id: data.user_id,
          ..."guild_id" in data && { guild_id: data.guild_id }
        });
        if (!channel || !channel.isText()) return false;
        const message = this.getMessage(data, channel);
        if (!message) return false;
        const reaction = this.getReaction(data, message, user);
        if (!reaction) return false;
        reaction._remove(user, data.burst);
        this.client.emit(Events2.MESSAGE_REACTION_REMOVE, reaction, user, { burst: data.burst });
        return { message, reaction, user };
      }
    };
    module2.exports = MessageReactionRemove;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/actions/MessageReactionRemoveAll.js
var require_MessageReactionRemoveAll = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/actions/MessageReactionRemoveAll.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var { Events: Events2 } = require_Constants();
    var MessageReactionRemoveAll = class extends Action {
      handle(data) {
        const channel = this.getChannel({ id: data.channel_id, ..."guild_id" in data && { guild_id: data.guild_id } });
        if (!channel || !channel.isText()) return false;
        const message = this.getMessage(data, channel);
        if (!message) return false;
        const removed = message.reactions.cache.clone();
        message.reactions.cache.clear();
        this.client.emit(Events2.MESSAGE_REACTION_REMOVE_ALL, message, removed);
        return { message };
      }
    };
    module2.exports = MessageReactionRemoveAll;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/actions/MessageReactionRemoveEmoji.js
var require_MessageReactionRemoveEmoji = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/actions/MessageReactionRemoveEmoji.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var { Events: Events2 } = require_Constants();
    var MessageReactionRemoveEmoji = class extends Action {
      handle(data) {
        const channel = this.getChannel({ id: data.channel_id, ..."guild_id" in data && { guild_id: data.guild_id } });
        if (!channel || !channel.isText()) return false;
        const message = this.getMessage(data, channel);
        if (!message) return false;
        const reaction = this.getReaction(data, message);
        if (!reaction) return false;
        if (!message.partial) message.reactions.cache.delete(reaction.emoji.id ?? reaction.emoji.name);
        this.client.emit(Events2.MESSAGE_REACTION_REMOVE_EMOJI, reaction);
        return { reaction };
      }
    };
    module2.exports = MessageReactionRemoveEmoji;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/actions/MessageUpdate.js
var require_MessageUpdate = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/actions/MessageUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var MessageUpdateAction = class extends Action {
      handle(data) {
        const channel = this.getChannel({ id: data.channel_id, ..."guild_id" in data && { guild_id: data.guild_id } });
        if (channel) {
          if (!channel.isText()) return {};
          const { id, channel_id, guild_id, author, timestamp, type } = data;
          const message = this.getMessage({ id, channel_id, guild_id, author, timestamp, type }, channel);
          if (message) {
            const old = message._update(data);
            return {
              old,
              updated: message
            };
          }
        }
        return {};
      }
    };
    module2.exports = MessageUpdateAction;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/actions/PresenceUpdate.js
var require_PresenceUpdate = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/actions/PresenceUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var { Events: Events2 } = require_Constants();
    var PresenceUpdateAction = class extends Action {
      handle(data) {
        var _a, _b, _c;
        let user = this.client.users.cache.get(data.user.id);
        if (!user && ((_a = data.user) == null ? void 0 : _a.username)) user = this.client.users._add(data.user);
        if (!user) return;
        if ((_b = data.user) == null ? void 0 : _b.username) {
          if (!user._equals(data.user)) this.client.actions.UserUpdate.handle(data.user);
        }
        const guild = this.client.guilds.cache.get(data.guild_id);
        if (guild) {
          let member = guild.members.cache.get(user.id);
          if (!member && data.status !== "offline") {
            member = guild.members._add({
              user,
              deaf: false,
              mute: false
            });
            this.client.emit(Events2.GUILD_MEMBER_AVAILABLE, member);
          }
        }
        const oldPresence = ((_c = (guild || this.client).presences.cache.get(user.id)) == null ? void 0 : _c._clone()) ?? null;
        const newPresence = (guild || this.client).presences._add(Object.assign(data, { guild }));
        if (this.client.listenerCount(Events2.PRESENCE_UPDATE) && !newPresence.equals(oldPresence)) {
          this.client.emit(Events2.PRESENCE_UPDATE, oldPresence, newPresence);
        }
      }
    };
    module2.exports = PresenceUpdateAction;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/actions/StageInstanceCreate.js
var require_StageInstanceCreate = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/actions/StageInstanceCreate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var { Events: Events2 } = require_Constants();
    var StageInstanceCreateAction = class extends Action {
      handle(data) {
        const client = this.client;
        const channel = this.getChannel({ id: data.channel_id, guild_id: data.guild_id });
        if (channel) {
          const stageInstance = channel.guild.stageInstances._add(data);
          client.emit(Events2.STAGE_INSTANCE_CREATE, stageInstance);
          return { stageInstance };
        }
        return {};
      }
    };
    module2.exports = StageInstanceCreateAction;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/actions/StageInstanceDelete.js
var require_StageInstanceDelete = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/actions/StageInstanceDelete.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var { deletedStageInstances } = require_StageInstance();
    var { Events: Events2 } = require_Constants();
    var StageInstanceDeleteAction = class extends Action {
      handle(data) {
        const client = this.client;
        const channel = this.getChannel({ id: data.channel_id, guild_id: data.guild_id });
        if (channel) {
          const stageInstance = channel.guild.stageInstances._add(data);
          if (stageInstance) {
            channel.guild.stageInstances.cache.delete(stageInstance.id);
            deletedStageInstances.add(stageInstance);
            client.emit(Events2.STAGE_INSTANCE_DELETE, stageInstance);
            return { stageInstance };
          }
        }
        return {};
      }
    };
    module2.exports = StageInstanceDeleteAction;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/actions/StageInstanceUpdate.js
var require_StageInstanceUpdate = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/actions/StageInstanceUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var { Events: Events2 } = require_Constants();
    var StageInstanceUpdateAction = class extends Action {
      handle(data) {
        var _a;
        const client = this.client;
        const channel = this.getChannel({ id: data.channel_id, guild_id: data.guild_id });
        if (channel) {
          const oldStageInstance = ((_a = channel.guild.stageInstances.cache.get(data.id)) == null ? void 0 : _a._clone()) ?? null;
          const newStageInstance = channel.guild.stageInstances._add(data);
          client.emit(Events2.STAGE_INSTANCE_UPDATE, oldStageInstance, newStageInstance);
          return { oldStageInstance, newStageInstance };
        }
        return {};
      }
    };
    module2.exports = StageInstanceUpdateAction;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/actions/ThreadCreate.js
var require_ThreadCreate = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/actions/ThreadCreate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var { Events: Events2 } = require_Constants();
    var ThreadCreateAction = class extends Action {
      handle(data) {
        const client = this.client;
        const existing = client.channels.cache.has(data.id);
        const thread = client.channels._add(data);
        if (!existing && thread) {
          client.emit(Events2.THREAD_CREATE, thread, data.newly_created ?? false);
        }
        return { thread };
      }
    };
    module2.exports = ThreadCreateAction;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/actions/ThreadDelete.js
var require_ThreadDelete = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/actions/ThreadDelete.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var { deletedChannels } = require_Channel();
    var { deletedMessages } = require_Message();
    var { Events: Events2 } = require_Constants();
    var ThreadDeleteAction = class extends Action {
      handle(data) {
        const client = this.client;
        const thread = client.channels.cache.get(data.id);
        if (thread) {
          client.channels._remove(thread.id);
          deletedChannels.add(thread);
          for (const message of thread.messages.cache.values()) {
            deletedMessages.add(message);
          }
          client.emit(Events2.THREAD_DELETE, thread);
        }
        return { thread };
      }
    };
    module2.exports = ThreadDeleteAction;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/actions/ThreadListSync.js
var require_ThreadListSync = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/actions/ThreadListSync.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var Action = require_Action();
    var { Events: Events2 } = require_Constants();
    var ThreadListSyncAction = class extends Action {
      handle(data) {
        const client = this.client;
        const guild = client.guilds.cache.get(data.guild_id);
        if (!guild) return {};
        if (data.channel_ids) {
          for (const id of data.channel_ids) {
            const channel = client.channels.resolve(id);
            if (channel) this.removeStale(channel);
          }
        } else {
          for (const channel of guild.channels.cache.values()) {
            this.removeStale(channel);
          }
        }
        const syncedThreads = data.threads.reduce((coll, rawThread) => {
          const thread = client.channels._add(rawThread);
          return coll.set(thread.id, thread);
        }, new Collection2());
        for (const rawMember of Object.values(data.members || {})) {
          const thread = client.channels.cache.get(rawMember.id);
          if (thread) {
            thread.members._add(rawMember);
          }
        }
        client.emit(Events2.THREAD_LIST_SYNC, syncedThreads);
        return {
          syncedThreads
        };
      }
      removeStale(channel) {
        var _a;
        (_a = channel.threads) == null ? void 0 : _a.cache.forEach((thread) => {
          if (!thread.archived) {
            this.client.channels._remove(thread.id);
          }
        });
      }
    };
    module2.exports = ThreadListSyncAction;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/actions/ThreadMemberUpdate.js
var require_ThreadMemberUpdate = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/actions/ThreadMemberUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var { Events: Events2 } = require_Constants();
    var ThreadMemberUpdateAction = class extends Action {
      handle(data) {
        const client = this.client;
        const thread = client.channels.cache.get(data.id);
        if (thread) {
          const member = thread.members.cache.get(data.user_id);
          if (!member) {
            const newMember = thread.members._add(data);
            return { newMember };
          }
          const old = member._update(data);
          client.emit(Events2.THREAD_MEMBER_UPDATE, old, member);
        }
        return {};
      }
    };
    module2.exports = ThreadMemberUpdateAction;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/actions/ThreadMembersUpdate.js
var require_ThreadMembersUpdate = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/actions/ThreadMembersUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var { Events: Events2 } = require_Constants();
    var ThreadMembersUpdateAction = class extends Action {
      handle(data) {
        var _a, _b;
        const client = this.client;
        const thread = client.channels.cache.get(data.id);
        if (thread) {
          const old = thread.members.cache.clone();
          thread.memberCount = data.member_count;
          (_a = data.added_members) == null ? void 0 : _a.forEach((rawMember) => {
            thread.members._add(rawMember);
          });
          (_b = data.removed_member_ids) == null ? void 0 : _b.forEach((memberId) => {
            thread.members.cache.delete(memberId);
          });
          client.emit(Events2.THREAD_MEMBERS_UPDATE, old, thread.members.cache);
        }
        return {};
      }
    };
    module2.exports = ThreadMembersUpdateAction;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/Typing.js
var require_Typing = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/Typing.js"(exports2, module2) {
    "use strict";
    var Base = require_Base();
    var Typing = class extends Base {
      constructor(channel, user, data) {
        super(channel.client);
        this.channel = channel;
        this.user = user;
        this._patch(data);
      }
      _patch(data) {
        if ("timestamp" in data) {
          this.startedTimestamp = data.timestamp * 1e3;
        }
      }
      /**
       * Indicates whether the status is received from a guild.
       * @returns {boolean}
       */
      inGuild() {
        return this.guild !== null;
      }
      /**
       * The time the user started typing at
       * @type {Date}
       * @readonly
       */
      get startedAt() {
        return new Date(this.startedTimestamp);
      }
      /**
       * The guild the status is from
       * @type {?Guild}
       * @readonly
       */
      get guild() {
        return this.channel.guild ?? null;
      }
      /**
       * The member who is typing
       * @type {?GuildMember}
       * @readonly
       */
      get member() {
        var _a;
        return ((_a = this.guild) == null ? void 0 : _a.members.resolve(this.user)) ?? null;
      }
    };
    module2.exports = Typing;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/actions/TypingStart.js
var require_TypingStart = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/actions/TypingStart.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Typing = require_Typing();
    var { Events: Events2 } = require_Constants();
    var TypingStart = class extends Action {
      handle(data) {
        const channel = this.getChannel({ id: data.channel_id, ..."guild_id" in data && { guild_id: data.guild_id } });
        if (!channel) return;
        if (!channel.isText()) {
          this.client.emit(Events2.WARN, `Discord sent a typing packet to a ${channel.type} channel ${channel.id}`);
          return;
        }
        const user = this.getUserFromMember(data);
        if (user) {
          this.client.emit(Events2.TYPING_START, new Typing(channel, user, data));
        }
      }
    };
    module2.exports = TypingStart;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/actions/UserUpdate.js
var require_UserUpdate = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/actions/UserUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var { Events: Events2 } = require_Constants();
    var UserUpdateAction = class extends Action {
      handle(data) {
        const client = this.client;
        const newUser = data.id === client.user.id ? client.user : client.users.cache.get(data.id);
        const oldUser = newUser._update(data);
        if (!oldUser.equals(newUser)) {
          client.emit(Events2.USER_UPDATE, oldUser, newUser);
          return {
            old: oldUser,
            updated: newUser
          };
        }
        return {
          old: null,
          updated: null
        };
      }
    };
    module2.exports = UserUpdateAction;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/actions/VoiceStateUpdate.js
var require_VoiceStateUpdate = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/actions/VoiceStateUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var VoiceState = require_VoiceState();
    var { Events: Events2 } = require_Constants();
    var VoiceStateUpdate = class extends Action {
      handle(data) {
        var _a, _b, _c;
        const client = this.client;
        const guild = client.guilds.cache.get(data.guild_id);
        if (guild) {
          const oldState = ((_a = guild.voiceStates.cache.get(data.user_id)) == null ? void 0 : _a._clone()) ?? new VoiceState(guild, { user_id: data.user_id });
          const newState = guild.voiceStates._add(data);
          let member = guild.members.cache.get(data.user_id);
          if (member && data.member) {
            member._patch(data.member);
          } else if (((_b = data.member) == null ? void 0 : _b.user) && data.member.joined_at) {
            member = guild.members._add(data.member);
          }
          if ((member == null ? void 0 : member.user.id) === client.user.id) {
            client.emit("debug", `[VOICE] received voice state update: ${JSON.stringify(data)}`);
            client.voice.onVoiceStateUpdate(data);
          }
          client.emit(Events2.VOICE_STATE_UPDATE, oldState, newState);
        } else {
          const oldState = ((_c = client.voiceStates.cache.get(data.user_id)) == null ? void 0 : _c._clone()) ?? new VoiceState({ client }, { user_id: data.user_id });
          const newState = client.voiceStates._add(data);
          if (data.user_id === client.user.id) {
            client.emit("debug", `[VOICE] received voice state update: ${JSON.stringify(data)}`);
            client.voice.onVoiceStateUpdate(data);
          }
          client.emit(Events2.VOICE_STATE_UPDATE, oldState, newState);
        }
      }
    };
    module2.exports = VoiceStateUpdate;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/actions/WebhooksUpdate.js
var require_WebhooksUpdate = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/actions/WebhooksUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var { Events: Events2 } = require_Constants();
    var WebhooksUpdate = class extends Action {
      handle(data) {
        const client = this.client;
        const channel = client.channels.cache.get(data.channel_id);
        if (channel) client.emit(Events2.WEBHOOKS_UPDATE, channel);
      }
    };
    module2.exports = WebhooksUpdate;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/actions/ActionsManager.js
var require_ActionsManager = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/actions/ActionsManager.js"(exports2, module2) {
    "use strict";
    var ActionsManager2 = class {
      constructor(client) {
        this.client = client;
        this.injectedUser = Symbol("djs.actions.injectedUser");
        this.injectedChannel = Symbol("djs.actions.injectedChannel");
        this.injectedMessage = Symbol("djs.actions.injectedMessage");
        this.register(require_ApplicationCommandPermissionsUpdate());
        this.register(require_AutoModerationActionExecution2());
        this.register(require_AutoModerationRuleCreate());
        this.register(require_AutoModerationRuleDelete());
        this.register(require_AutoModerationRuleUpdate());
        this.register(require_ChannelCreate());
        this.register(require_ChannelDelete());
        this.register(require_ChannelUpdate());
        this.register(require_GuildAuditLogEntryCreate());
        this.register(require_GuildBanAdd());
        this.register(require_GuildBanRemove());
        this.register(require_GuildChannelsPositionUpdate());
        this.register(require_GuildDelete());
        this.register(require_GuildEmojiCreate());
        this.register(require_GuildEmojiDelete());
        this.register(require_GuildEmojiUpdate());
        this.register(require_GuildEmojisUpdate());
        this.register(require_GuildIntegrationsUpdate());
        this.register(require_GuildMemberRemove());
        this.register(require_GuildMemberUpdate());
        this.register(require_GuildRoleCreate());
        this.register(require_GuildRoleDelete());
        this.register(require_GuildRoleUpdate());
        this.register(require_GuildRolesPositionUpdate());
        this.register(require_GuildScheduledEventCreate());
        this.register(require_GuildScheduledEventDelete());
        this.register(require_GuildScheduledEventUpdate());
        this.register(require_GuildScheduledEventUserAdd());
        this.register(require_GuildScheduledEventUserRemove());
        this.register(require_GuildStickerCreate());
        this.register(require_GuildStickerDelete());
        this.register(require_GuildStickerUpdate());
        this.register(require_GuildStickersUpdate());
        this.register(require_GuildUpdate());
        this.register(require_InviteCreate());
        this.register(require_InviteDelete());
        this.register(require_MessageCreate());
        this.register(require_MessageDelete());
        this.register(require_MessageDeleteBulk());
        this.register(require_MessagePollVoteAdd());
        this.register(require_MessagePollVoteRemove());
        this.register(require_MessageReactionAdd());
        this.register(require_MessageReactionRemove());
        this.register(require_MessageReactionRemoveAll());
        this.register(require_MessageReactionRemoveEmoji());
        this.register(require_MessageUpdate());
        this.register(require_PresenceUpdate());
        this.register(require_StageInstanceCreate());
        this.register(require_StageInstanceDelete());
        this.register(require_StageInstanceUpdate());
        this.register(require_ThreadCreate());
        this.register(require_ThreadDelete());
        this.register(require_ThreadListSync());
        this.register(require_ThreadMemberUpdate());
        this.register(require_ThreadMembersUpdate());
        this.register(require_TypingStart());
        this.register(require_UserUpdate());
        this.register(require_VoiceStateUpdate());
        this.register(require_WebhooksUpdate());
      }
      register(Action) {
        this[Action.name.replace(/Action$/, "")] = new Action(this.client);
      }
    };
    module2.exports = ActionsManager2;
  }
});

// browser-external:dgram
var require_dgram = __commonJS({
  "browser-external:dgram"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "dgram" has been externalized for browser compatibility. Cannot access "dgram.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:net
var require_net = __commonJS({
  "browser-external:net"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "net" has been externalized for browser compatibility. Cannot access "net.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/voice/networking/VoiceUDPClient.js
var require_VoiceUDPClient = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/voice/networking/VoiceUDPClient.js"(exports2, module2) {
    "use strict";
    var udp = require_dgram();
    var EventEmitter = require_events();
    var { isIPv4 } = require_net();
    var { Buffer: Buffer2 } = require_node_buffer();
    var { Error: Error2 } = require_errors2();
    var { VoiceOpcodes } = require_Constants();
    var Util = require_Util();
    var VoiceConnectionUDPClient = class extends EventEmitter {
      constructor(voiceConnection) {
        super();
        this.voiceConnection = voiceConnection;
        this.socket = null;
        this.discordAddress = null;
        this.localAddress = null;
        this.localPort = null;
        this.voiceConnection.on("closing", this.shutdown.bind(this));
      }
      shutdown() {
        this.emit("debug", `[UDP] shutdown requested`);
        if (this.socket) {
          this.socket.removeAllListeners("message");
          try {
            this.socket.close();
          } finally {
            this.socket = null;
          }
        }
      }
      /**
       * The port of the Discord voice server
       * @type {number}
       * @readonly
       */
      get discordPort() {
        return this.voiceConnection.authentication.port;
      }
      /**
       * Send a packet to the UDP client.
       * @param {Object} packet The packet to send
       * @returns {Promise<Object>}
       */
      send(packet) {
        return new Promise((resolve, reject) => {
          if (!this.socket) throw new Error2("UDP_SEND_FAIL");
          if (!this.discordAddress || !this.discordPort) throw new Error2("UDP_ADDRESS_MALFORMED");
          this.socket.send(packet, 0, packet.length, this.discordPort, this.discordAddress, (error2) => {
            if (error2) {
              this.emit("debug", `[UDP] >> ERROR: ${error2}`);
              reject(error2);
            } else {
              resolve(packet);
            }
          });
        });
      }
      async createUDPSocket(address) {
        this.discordAddress = address;
        const socket = this.socket = udp.createSocket("udp4");
        socket.on("error", (e) => {
          this.emit("debug", `[UDP] Error: ${e}`);
          this.emit("error", e);
        });
        socket.on("close", () => {
          this.emit("debug", "[UDP] socket closed");
        });
        this.emit("debug", `[UDP] created socket`);
        socket.once("message", (message) => {
          this.emit("debug", `[UDP] message: [${[...message]}] (${message})`);
          if (message.readUInt16BE(0) !== 2) {
            throw new Error2("UDP_WRONG_HANDSHAKE");
          }
          if (!this.voiceConnection.sockets.ws) return;
          const packet = parseLocalPacket(message);
          if (packet.error) {
            this.emit("debug", `[UDP] ERROR: ${packet.error}`);
            this.emit("error", packet.error);
            return;
          }
          this.emit("debug", `[UDP] Parse local packet: ${packet.address}:${packet.port}`);
          this.localAddress = packet.address;
          this.localPort = packet.port;
          this.voiceConnection.sockets.ws.sendPacket({
            op: VoiceOpcodes.SELECT_PROTOCOL,
            d: {
              protocol: "udp",
              codecs: Util.getAllPayloadType(),
              data: {
                address: packet.address,
                port: packet.port,
                mode: this.voiceConnection.authentication.mode
              }
            }
          });
          Object.defineProperty(this.voiceConnection, "videoCodec", {
            value: this.voiceConnection.videoCodec,
            writable: false
          });
          this.emit("debug", `[UDP] << ${JSON.stringify(packet)}`);
          socket.on("message", (buffer) => this.voiceConnection.receiver.packets.push(buffer));
        });
        const blankMessage = Buffer2.alloc(74);
        blankMessage.writeUInt16BE(1, 0);
        blankMessage.writeUInt16BE(70, 2);
        blankMessage.writeUInt32BE(this.voiceConnection.authentication.ssrc, 4);
        this.emit("debug", `Sending IP discovery packet: [${[...blankMessage]}]`);
        await this.send(blankMessage);
        this.emit("debug", `Successfully sent IP discovery packet`);
      }
    };
    function parseLocalPacket(message) {
      try {
        const packet = Buffer2.from(message);
        const address = packet.subarray(8, packet.indexOf(0, 8)).toString("utf8");
        if (!isIPv4(address)) {
          throw new Error2("UDP_ADDRESS_MALFORMED");
        }
        const port = packet.readUInt16BE(packet.length - 2);
        return { address, port };
      } catch (error2) {
        return { error: error2 };
      }
    }
    module2.exports = VoiceConnectionUDPClient;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/WebSocket.js
var require_WebSocket = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/WebSocket.js"(exports2) {
    "use strict";
    var erlpack;
    var { Buffer: Buffer2 } = require_node_buffer();
    try {
      erlpack = __require("erlpack");
      if (!erlpack.pack) erlpack = null;
    } catch {
    }
    exports2.WebSocket = require_browser();
    var ab = new TextDecoder();
    exports2.encoding = erlpack ? "etf" : "json";
    exports2.pack = erlpack ? erlpack.pack : JSON.stringify;
    exports2.unpack = (data, type) => {
      if (exports2.encoding === "json" || type === "json") {
        if (typeof data !== "string") {
          data = ab.decode(data);
        }
        return JSON.parse(data);
      }
      if (!Buffer2.isBuffer(data)) data = Buffer2.from(new Uint8Array(data));
      return erlpack.unpack(data);
    };
    exports2.create = (gateway, query = {}, ...args) => {
      const [g, q] = gateway.split("?");
      query.encoding = exports2.encoding;
      query = new URLSearchParams(query);
      if (q) new URLSearchParams(q).forEach((v, k) => query.set(k, v));
      const ws = new exports2.WebSocket(`${g}?${query}`, ...args);
      return ws;
    };
    for (const state of ["CONNECTING", "OPEN", "CLOSING", "CLOSED"]) exports2[state] = exports2.WebSocket[state];
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/voice/networking/VoiceWebSocket.js
var require_VoiceWebSocket = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/voice/networking/VoiceWebSocket.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require_events();
    var { setTimeout: setTimeout2, setInterval: setInterval2 } = require_node_timers();
    var WebSocket = require_WebSocket();
    var { Error: Error2 } = require_errors2();
    var { Opcodes, VoiceOpcodes } = require_Constants();
    var VoiceWebSocket = class extends EventEmitter {
      constructor(connection) {
        super();
        this.connection = connection;
        this.attempts = 0;
        this.dead = false;
        this.connection.on("closing", this.shutdown.bind(this));
      }
      /**
       * The client of this voice WebSocket
       * @type {Client}
       * @readonly
       */
      get client() {
        return this.connection.client;
      }
      shutdown() {
        this.emit("debug", `[WS] shutdown requested`);
        this.dead = true;
        this.reset();
      }
      /**
       * Resets the current WebSocket.
       */
      reset() {
        this.emit("debug", `[WS] reset requested`);
        if (this.ws) {
          if (this.ws.readyState !== WebSocket.CLOSED) this.ws.close();
          this.ws = null;
        }
        this.clearHeartbeat();
      }
      /**
       * Starts connecting to the Voice WebSocket Server.
       */
      connect() {
        this.emit("debug", `[WS] connect requested`);
        if (this.dead) return;
        if (this.ws) this.reset();
        if (this.attempts >= 5) {
          this.emit("debug", new Error2("VOICE_CONNECTION_ATTEMPTS_EXCEEDED", this.attempts));
          return;
        }
        this.attempts++;
        this.ws = WebSocket.create(`wss://${this.connection.authentication.endpoint}/`, { v: 7 });
        this.emit("debug", `[WS] connecting, ${this.attempts} attempts, ${this.ws.url}`);
        this.ws.onopen = this.onOpen.bind(this);
        this.ws.onmessage = this.onMessage.bind(this);
        this.ws.onclose = this.onClose.bind(this);
        this.ws.onerror = this.onError.bind(this);
      }
      /**
       * Sends data to the WebSocket if it is open.
       * @param {string} data The data to send to the WebSocket
       * @returns {Promise<string>}
       */
      send(data) {
        this.emit("debug", `[WS] >> ${data}`);
        return new Promise((resolve, reject) => {
          if (!this.ws || this.ws.readyState !== WebSocket.OPEN) throw new Error2("WS_NOT_OPEN", data);
          this.ws.send(data, null, (error2) => {
            if (error2) reject(error2);
            else resolve(data);
          });
        });
      }
      /**
       * JSON.stringify's a packet and then sends it to the WebSocket Server.
       * @param {Object} packet The packet to send
       * @returns {Promise<string>}
       */
      sendPacket(packet) {
        try {
          packet = JSON.stringify(packet);
        } catch (error2) {
          return Promise.reject(error2);
        }
        return this.send(packet);
      }
      /**
       * Called whenever the WebSocket opens.
       */
      onOpen() {
        var _a;
        this.emit("debug", `[WS] opened at gateway ${this.connection.authentication.endpoint}`);
        this.sendPacket({
          op: Opcodes.DISPATCH,
          d: {
            server_id: this.connection.serverId || ((_a = this.connection.channel.guild) == null ? void 0 : _a.id) || this.connection.channel.id,
            user_id: this.client.user.id,
            token: this.connection.authentication.token,
            session_id: this.connection.authentication.sessionId,
            streams: [{ type: "screen", rid: "100", quality: 100 }],
            video: true
          }
        }).catch(() => {
          this.emit("error", new Error2("VOICE_JOIN_SOCKET_CLOSED"));
        });
      }
      /**
       * Called whenever a message is received from the WebSocket.
       * @param {MessageEvent} event The message event that was received
       * @returns {void}
       */
      onMessage(event) {
        try {
          return this.onPacket(WebSocket.unpack(event.data, "json"));
        } catch (error2) {
          return this.onError(error2);
        }
      }
      /**
       * Called whenever the connection to the WebSocket server is lost.
       */
      onClose() {
        this.emit("debug", `[WS] closed`);
        if (!this.dead) setTimeout2(this.connect.bind(this), this.attempts * 1e3).unref();
      }
      /**
       * Called whenever an error occurs with the WebSocket.
       * @param {Error} error The error that occurred
       */
      onError(error2) {
        this.emit("debug", `[WS] Error: ${error2}`);
        this.emit("error", error2);
      }
      /**
       * Called whenever a valid packet is received from the WebSocket.
       * @param {Object} packet The received packet
       */
      onPacket(packet) {
        this.emit("debug", `[WS] << ${JSON.stringify(packet)}`);
        switch (packet.op) {
          case VoiceOpcodes.HELLO:
            this.setHeartbeat(packet.d.heartbeat_interval);
            break;
          case VoiceOpcodes.READY:
            this.emit("ready", packet.d);
            this.connection.setVideoStatus(false);
            break;
          case VoiceOpcodes.SESSION_DESCRIPTION:
            packet.d.secret_key = new Uint8Array(packet.d.secret_key);
            this.emit("sessionDescription", packet.d);
            break;
          case VoiceOpcodes.CLIENT_CONNECT:
            this.connection.ssrcMap.set(+packet.d.audio_ssrc, {
              userId: packet.d.user_id,
              speaking: 0,
              hasVideo: Boolean(packet.d.video_ssrc)
            });
            break;
          case VoiceOpcodes.CLIENT_DISCONNECT:
            const streamInfo = this.connection.receiver && this.connection.receiver.packets.streams.get(packet.d.user_id);
            if (streamInfo) {
              this.connection.receiver.packets.streams.delete(packet.d.user_id);
              streamInfo.stream.push(null);
            }
            break;
          case VoiceOpcodes.SPEAKING:
            this.emit("startSpeaking", packet.d);
            break;
          case VoiceOpcodes.SOURCES:
            this.emit("startStreaming", packet.d);
            break;
          default:
            this.emit("unknownPacket", packet);
            break;
        }
      }
      /**
       * Sets an interval at which to send a heartbeat packet to the WebSocket.
       * @param {number} interval The interval at which to send a heartbeat packet
       */
      setHeartbeat(interval) {
        if (!interval || isNaN(interval)) {
          this.onError(new Error2("VOICE_INVALID_HEARTBEAT"));
          return;
        }
        if (this.heartbeatInterval) {
          this.emit("warn", "A voice heartbeat interval is being overwritten");
          clearInterval(this.heartbeatInterval);
        }
        this.heartbeatInterval = setInterval2(this.sendHeartbeat.bind(this), interval).unref();
      }
      /**
       * Clears a heartbeat interval, if one exists.
       */
      clearHeartbeat() {
        if (!this.heartbeatInterval) {
          this.emit("warn", "Tried to clear a heartbeat interval that does not exist");
          return;
        }
        clearInterval(this.heartbeatInterval);
        this.heartbeatInterval = null;
      }
      /**
       * Sends a heartbeat packet.
       */
      sendHeartbeat() {
        this.sendPacket({ op: VoiceOpcodes.HEARTBEAT, d: Math.floor(Math.random() * 1e11) }).catch(() => {
          this.emit("warn", "Tried to send heartbeat, but connection is not open");
          this.clearHeartbeat();
        });
      }
    };
    module2.exports = VoiceWebSocket;
  }
});

// ../../../node_modules/prism-media/src/util/loader.js
var require_loader = __commonJS({
  "../../../node_modules/prism-media/src/util/loader.js"(exports2) {
    exports2.require = function loader(list) {
      const errorLog = [];
      for (const [name, fn] of list) {
        try {
          const data = fn(__require(name));
          data.name = name;
          return data;
        } catch (e) {
          errorLog.push(e);
        }
      }
      throw new Error(errorLog.join("\n"));
    };
  }
});

// ../../../node_modules/prism-media/src/opus/Opus.js
var require_Opus = __commonJS({
  "../../../node_modules/prism-media/src/opus/Opus.js"(exports2, module2) {
    var { Transform } = require_stream();
    var loader = require_loader();
    var CTL = {
      BITRATE: 4002,
      FEC: 4012,
      PLP: 4014
    };
    var Opus = {};
    function loadOpus(refresh = false) {
      if (Opus.Encoder && !refresh) return Opus;
      Opus = loader.require([
        ["@discordjs/opus", (opus) => ({ Encoder: opus.OpusEncoder })],
        ["node-opus", (opus) => ({ Encoder: opus.OpusEncoder })],
        ["opusscript", (opus) => ({ Encoder: opus })]
      ]);
      return Opus;
    }
    var charCode = (x) => x.charCodeAt(0);
    var OPUS_HEAD = Buffer.from([..."OpusHead"].map(charCode));
    var OPUS_TAGS = Buffer.from([..."OpusTags"].map(charCode));
    var OpusStream = class extends Transform {
      /**
       * Creates a new Opus transformer.
       * @private
       * @memberof opus
       * @param {Object} [options] options that you would pass to a regular Transform stream
       */
      constructor(options = {}) {
        if (!loadOpus().Encoder) {
          throw Error("Could not find an Opus module! Please install @discordjs/opus, node-opus, or opusscript.");
        }
        super(Object.assign({ readableObjectMode: true }, options));
        if (Opus.name === "opusscript") {
          options.application = Opus.Encoder.Application[options.application];
        }
        this.encoder = new Opus.Encoder(options.rate, options.channels, options.application);
        this._options = options;
        this._required = this._options.frameSize * this._options.channels * 2;
      }
      _encode(buffer) {
        return this.encoder.encode(buffer, this._options.frameSize);
      }
      _decode(buffer) {
        return this.encoder.decode(buffer, Opus.name === "opusscript" ? null : this._options.frameSize);
      }
      /**
       * Returns the Opus module being used - `opusscript`, `node-opus`, or `@discordjs/opus`.
       * @type {string}
       * @readonly
       * @example
       * console.log(`Using Opus module ${prism.opus.Encoder.type}`);
       */
      static get type() {
        return Opus.name;
      }
      /**
       * Sets the bitrate of the stream.
       * @param {number} bitrate the bitrate to use use, e.g. 48000
       * @public
       */
      setBitrate(bitrate) {
        (this.encoder.applyEncoderCTL || this.encoder.encoderCTL).apply(this.encoder, [CTL.BITRATE, Math.min(128e3, Math.max(16e3, bitrate))]);
      }
      /**
       * Enables or disables forward error correction.
       * @param {boolean} enabled whether or not to enable FEC.
       * @public
       */
      setFEC(enabled) {
        (this.encoder.applyEncoderCTL || this.encoder.encoderCTL).apply(this.encoder, [CTL.FEC, enabled ? 1 : 0]);
      }
      /**
       * Sets the expected packet loss over network transmission.
       * @param {number} [percentage] a percentage (represented between 0 and 1)
       */
      setPLP(percentage) {
        (this.encoder.applyEncoderCTL || this.encoder.encoderCTL).apply(this.encoder, [CTL.PLP, Math.min(100, Math.max(0, percentage * 100))]);
      }
      _final(cb) {
        this._cleanup();
        cb();
      }
      _destroy(err, cb) {
        this._cleanup();
        return cb ? cb(err) : void 0;
      }
      /**
       * Cleans up the Opus stream when it is no longer needed
       * @private
       */
      _cleanup() {
        if (Opus.name === "opusscript" && this.encoder) this.encoder.delete();
        this.encoder = null;
      }
    };
    var Encoder = class extends OpusStream {
      /**
       * Creates a new Opus encoder stream.
       * @memberof opus
       * @param {Object} options options that you would pass to a regular OpusStream, plus a few more:
       * @param {number} options.frameSize the frame size in bytes to use (e.g. 960 for stereo audio at 48KHz with a frame
       * duration of 20ms)
       * @param {number} options.channels the number of channels to use
       * @param {number} options.rate the sampling rate in Hz
       */
      constructor(options) {
        super(options);
        this._buffer = Buffer.alloc(0);
      }
      _transform(chunk, encoding, done) {
        this._buffer = Buffer.concat([this._buffer, chunk]);
        let n = 0;
        while (this._buffer.length >= this._required * (n + 1)) {
          const buf = this._encode(this._buffer.slice(n * this._required, (n + 1) * this._required));
          this.push(buf);
          n++;
        }
        if (n > 0) this._buffer = this._buffer.slice(n * this._required);
        return done();
      }
      _destroy(err, cb) {
        super._destroy(err, cb);
        this._buffer = null;
      }
    };
    var Decoder = class extends OpusStream {
      _transform(chunk, encoding, done) {
        const signature = chunk.slice(0, 8);
        if (chunk.length >= 8 && signature.equals(OPUS_HEAD)) {
          this.emit("format", {
            channels: this._options.channels,
            sampleRate: this._options.rate,
            bitDepth: 16,
            float: false,
            signed: true,
            version: chunk.readUInt8(8),
            preSkip: chunk.readUInt16LE(10),
            gain: chunk.readUInt16LE(16)
          });
          return done();
        }
        if (chunk.length >= 8 && signature.equals(OPUS_TAGS)) {
          this.emit("tags", chunk);
          return done();
        }
        try {
          this.push(this._decode(chunk));
        } catch (e) {
          return done(e);
        }
        return done();
      }
    };
    module2.exports = { Decoder, Encoder };
  }
});

// ../../../node_modules/prism-media/src/opus/OggDemuxer.js
var require_OggDemuxer = __commonJS({
  "../../../node_modules/prism-media/src/opus/OggDemuxer.js"(exports2, module2) {
    var { Transform } = require_stream();
    var OGG_PAGE_HEADER_SIZE = 26;
    var STREAM_STRUCTURE_VERSION = 0;
    var charCode = (x) => x.charCodeAt(0);
    var OGGS_HEADER = Buffer.from([..."OggS"].map(charCode));
    var OPUS_HEAD = Buffer.from([..."OpusHead"].map(charCode));
    var OPUS_TAGS = Buffer.from([..."OpusTags"].map(charCode));
    var OggDemuxer = class extends Transform {
      /**
       * Creates a new OggOpus demuxer.
       * @param {Object} [options] options that you would pass to a regular Transform stream.
       * @memberof opus
       */
      constructor(options = {}) {
        super(Object.assign({ readableObjectMode: true }, options));
        this._remainder = null;
        this._head = null;
        this._bitstream = null;
      }
      _transform(chunk, encoding, done) {
        if (this._remainder) {
          chunk = Buffer.concat([this._remainder, chunk]);
          this._remainder = null;
        }
        try {
          while (chunk) {
            const result = this._readPage(chunk);
            if (result) chunk = result;
            else break;
          }
        } catch (error2) {
          done(error2);
          return;
        }
        this._remainder = chunk;
        done();
      }
      /**
       * Reads a page from a buffer
       * @private
       * @param {Buffer} chunk the chunk containing the page
       * @returns {boolean|Buffer} if a buffer, it will be a slice of the excess data of the original, otherwise it will be
       * false and would indicate that there is not enough data to go ahead with reading this page.
       */
      _readPage(chunk) {
        if (chunk.length < OGG_PAGE_HEADER_SIZE) {
          return false;
        }
        if (!chunk.slice(0, 4).equals(OGGS_HEADER)) {
          throw Error(`capture_pattern is not ${OGGS_HEADER}`);
        }
        if (chunk.readUInt8(4) !== STREAM_STRUCTURE_VERSION) {
          throw Error(`stream_structure_version is not ${STREAM_STRUCTURE_VERSION}`);
        }
        if (chunk.length < 27) return false;
        const pageSegments = chunk.readUInt8(26);
        if (chunk.length < 27 + pageSegments) return false;
        const table = chunk.slice(27, 27 + pageSegments);
        const bitstream = chunk.readUInt32BE(14);
        let sizes = [], totalSize = 0;
        for (let i = 0; i < pageSegments; ) {
          let size = 0, x = 255;
          while (x === 255) {
            if (i >= table.length) return false;
            x = table.readUInt8(i);
            i++;
            size += x;
          }
          sizes.push(size);
          totalSize += size;
        }
        if (chunk.length < 27 + pageSegments + totalSize) return false;
        let start = 27 + pageSegments;
        for (const size of sizes) {
          const segment = chunk.slice(start, start + size);
          const header = segment.slice(0, 8);
          if (this._head) {
            if (header.equals(OPUS_TAGS)) this.emit("tags", segment);
            else if (this._bitstream === bitstream) this.push(segment);
          } else if (header.equals(OPUS_HEAD)) {
            this.emit("head", segment);
            this._head = segment;
            this._bitstream = bitstream;
          } else {
            this.emit("unknownSegment", segment);
          }
          start += size;
        }
        return chunk.slice(start);
      }
      _destroy(err, cb) {
        this._cleanup();
        return cb ? cb(err) : void 0;
      }
      _final(cb) {
        this._cleanup();
        cb();
      }
      /**
       * Cleans up the demuxer when it is no longer required.
       * @private
       */
      _cleanup() {
        this._remainder = null;
        this._head = null;
        this._bitstream = null;
      }
    };
    module2.exports = OggDemuxer;
  }
});

// ../../../node_modules/prism-media/src/core/WebmBase.js
var require_WebmBase = __commonJS({
  "../../../node_modules/prism-media/src/core/WebmBase.js"(exports2, module2) {
    var { Transform } = require_stream();
    var WebmBaseDemuxer = class extends Transform {
      /**
       * Creates a new Webm demuxer.
       * @private
       * @memberof core
       * @param {Object} [options] options that you would pass to a regular Transform stream.
       */
      constructor(options = {}) {
        super(Object.assign({ readableObjectMode: true }, options));
        this._remainder = null;
        this._length = 0;
        this._count = 0;
        this._skipUntil = null;
        this._track = null;
        this._incompleteTrack = {};
        this._ebmlFound = false;
      }
      _transform(chunk, encoding, done) {
        this._length += chunk.length;
        if (this._remainder) {
          chunk = Buffer.concat([this._remainder, chunk]);
          this._remainder = null;
        }
        let offset = 0;
        if (this._skipUntil && this._length > this._skipUntil) {
          offset = this._skipUntil - this._count;
          this._skipUntil = null;
        } else if (this._skipUntil) {
          this._count += chunk.length;
          done();
          return;
        }
        let result;
        while (result !== TOO_SHORT) {
          try {
            result = this._readTag(chunk, offset);
          } catch (error2) {
            done(error2);
            return;
          }
          if (result === TOO_SHORT) break;
          if (result._skipUntil) {
            this._skipUntil = result._skipUntil;
            break;
          }
          if (result.offset) offset = result.offset;
          else break;
        }
        this._count += offset;
        this._remainder = chunk.slice(offset);
        done();
        return;
      }
      /**
       * Reads an EBML ID from a buffer.
       * @private
       * @param {Buffer} chunk the buffer to read from.
       * @param {number} offset the offset in the buffer.
       * @returns {Object|Symbol} contains an `id` property (buffer) and the new `offset` (number).
       * Returns the TOO_SHORT symbol if the data wasn't big enough to facilitate the request.
       */
      _readEBMLId(chunk, offset) {
        const idLength = vintLength(chunk, offset);
        if (idLength === TOO_SHORT) return TOO_SHORT;
        return {
          id: chunk.slice(offset, offset + idLength),
          offset: offset + idLength
        };
      }
      /**
       * Reads a size variable-integer to calculate the length of the data of a tag.
       * @private
       * @param {Buffer} chunk the buffer to read from.
       * @param {number} offset the offset in the buffer.
       * @returns {Object|Symbol} contains property `offset` (number), `dataLength` (number) and `sizeLength` (number).
       * Returns the TOO_SHORT symbol if the data wasn't big enough to facilitate the request.
       */
      _readTagDataSize(chunk, offset) {
        const sizeLength = vintLength(chunk, offset);
        if (sizeLength === TOO_SHORT) return TOO_SHORT;
        const dataLength = expandVint(chunk, offset, offset + sizeLength);
        return { offset: offset + sizeLength, dataLength, sizeLength };
      }
      /**
       * Takes a buffer and attempts to read and process a tag.
       * @private
       * @param {Buffer} chunk the buffer to read from.
       * @param {number} offset the offset in the buffer.
       * @returns {Object|Symbol} contains the new `offset` (number) and optionally the `_skipUntil` property,
       * indicating that the stream should ignore any data until a certain length is reached.
       * Returns the TOO_SHORT symbol if the data wasn't big enough to facilitate the request.
       */
      _readTag(chunk, offset) {
        const idData = this._readEBMLId(chunk, offset);
        if (idData === TOO_SHORT) return TOO_SHORT;
        const ebmlID = idData.id.toString("hex");
        if (!this._ebmlFound) {
          if (ebmlID === "1a45dfa3") this._ebmlFound = true;
          else throw Error("Did not find the EBML tag at the start of the stream");
        }
        offset = idData.offset;
        const sizeData = this._readTagDataSize(chunk, offset);
        if (sizeData === TOO_SHORT) return TOO_SHORT;
        const { dataLength } = sizeData;
        offset = sizeData.offset;
        if (typeof TAGS[ebmlID] === "undefined") {
          if (chunk.length > offset + dataLength) {
            return { offset: offset + dataLength };
          }
          return { offset, _skipUntil: this._count + offset + dataLength };
        }
        const tagHasChildren = TAGS[ebmlID];
        if (tagHasChildren) {
          return { offset };
        }
        if (offset + dataLength > chunk.length) return TOO_SHORT;
        const data = chunk.slice(offset, offset + dataLength);
        if (!this._track) {
          if (ebmlID === "ae") this._incompleteTrack = {};
          if (ebmlID === "d7") this._incompleteTrack.number = data[0];
          if (ebmlID === "83") this._incompleteTrack.type = data[0];
          if (this._incompleteTrack.type === 2 && typeof this._incompleteTrack.number !== "undefined") {
            this._track = this._incompleteTrack;
          }
        }
        if (ebmlID === "63a2") {
          this._checkHead(data);
          this.emit("head", data);
        } else if (ebmlID === "a3") {
          if (!this._track) throw Error("No audio track in this webm!");
          if ((data[0] & 15) === this._track.number) {
            this.push(data.slice(4));
          }
        }
        return { offset: offset + dataLength };
      }
      _destroy(err, cb) {
        this._cleanup();
        return cb ? cb(err) : void 0;
      }
      _final(cb) {
        this._cleanup();
        cb();
      }
      /**
       * Cleans up the demuxer when it is no longer required.
       * @private
       */
      _cleanup() {
        this._remainder = null;
        this._incompleteTrack = {};
      }
    };
    var TOO_SHORT = WebmBaseDemuxer.TOO_SHORT = Symbol("TOO_SHORT");
    var TAGS = WebmBaseDemuxer.TAGS = {
      // value is true if the element has children
      "1a45dfa3": true,
      // EBML
      "18538067": true,
      // Segment
      "1f43b675": true,
      // Cluster
      "1654ae6b": true,
      // Tracks
      "ae": true,
      // TrackEntry
      "d7": false,
      // TrackNumber
      "83": false,
      // TrackType
      "a3": false,
      // SimpleBlock
      "63a2": false
    };
    module2.exports = WebmBaseDemuxer;
    function vintLength(buffer, index) {
      if (index < 0 || index > buffer.length - 1) {
        return TOO_SHORT;
      }
      let i = 0;
      for (; i < 8; i++) if (1 << 7 - i & buffer[index]) break;
      i++;
      if (index + i > buffer.length) {
        return TOO_SHORT;
      }
      return i;
    }
    function expandVint(buffer, start, end) {
      const length = vintLength(buffer, start);
      if (end > buffer.length || length === TOO_SHORT) return TOO_SHORT;
      let mask = (1 << 8 - length) - 1;
      let value = buffer[start] & mask;
      for (let i = start + 1; i < end; i++) {
        value = (value << 8) + buffer[i];
      }
      return value;
    }
  }
});

// ../../../node_modules/prism-media/src/opus/WebmDemuxer.js
var require_WebmDemuxer = __commonJS({
  "../../../node_modules/prism-media/src/opus/WebmDemuxer.js"(exports2, module2) {
    var WebmBaseDemuxer = require_WebmBase();
    var OPUS_HEAD = Buffer.from([..."OpusHead"].map((x) => x.charCodeAt(0)));
    var WebmDemuxer = class extends WebmBaseDemuxer {
      _checkHead(data) {
        if (!data.slice(0, 8).equals(OPUS_HEAD)) {
          throw Error("Audio codec is not Opus!");
        }
      }
    };
    module2.exports = WebmDemuxer;
  }
});

// ../../../node_modules/prism-media/src/opus/index.js
var require_opus = __commonJS({
  "../../../node_modules/prism-media/src/opus/index.js"(exports2, module2) {
    module2.exports = {
      // Encoder and Decoder
      ...require_Opus(),
      OggDemuxer: require_OggDemuxer(),
      WebmDemuxer: require_WebmDemuxer()
    };
  }
});

// ../../../node_modules/prism-media/src/vorbis/WebmDemuxer.js
var require_WebmDemuxer2 = __commonJS({
  "../../../node_modules/prism-media/src/vorbis/WebmDemuxer.js"(exports2, module2) {
    var WebmBaseDemuxer = require_WebmBase();
    var VORBIS_HEAD = Buffer.from([..."vorbis"].map((x) => x.charCodeAt(0)));
    var WebmDemuxer = class extends WebmBaseDemuxer {
      _checkHead(data) {
        if (data.readUInt8(0) !== 2 || !data.slice(4, 10).equals(VORBIS_HEAD)) {
          throw Error("Audio codec is not Vorbis!");
        }
        this.push(data.slice(3, 3 + data.readUInt8(1)));
        this.push(data.slice(3 + data.readUInt8(1), 3 + data.readUInt8(1) + data.readUInt8(2)));
        this.push(data.slice(3 + data.readUInt8(1) + data.readUInt8(2)));
      }
    };
    module2.exports = WebmDemuxer;
  }
});

// ../../../node_modules/prism-media/src/vorbis/index.js
var require_vorbis = __commonJS({
  "../../../node_modules/prism-media/src/vorbis/index.js"(exports2, module2) {
    module2.exports = {
      WebmDemuxer: require_WebmDemuxer2()
    };
  }
});

// browser-external:child_process
var require_child_process = __commonJS({
  "browser-external:child_process"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "child_process" has been externalized for browser compatibility. Cannot access "child_process.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// optional-peer-dep:__vite-optional-peer-dep:ffmpeg-static:prism-media
var require_vite_optional_peer_dep_ffmpeg_static_prism_media = __commonJS({
  "optional-peer-dep:__vite-optional-peer-dep:ffmpeg-static:prism-media"() {
    throw new Error(`Could not resolve "ffmpeg-static" imported by "prism-media". Is it installed?`);
  }
});

// ../../../node_modules/prism-media/src/core/FFmpeg.js
var require_FFmpeg = __commonJS({
  "../../../node_modules/prism-media/src/core/FFmpeg.js"(exports2, module2) {
    var ChildProcess = require_child_process();
    var { Duplex } = require_stream();
    var FFMPEG = {
      command: null,
      output: null
    };
    var VERSION_REGEX = /version (.+) Copyright/mi;
    Object.defineProperty(FFMPEG, "version", {
      get() {
        return VERSION_REGEX.exec(FFMPEG.output)[1];
      },
      enumerable: true
    });
    var FFmpeg = class _FFmpeg extends Duplex {
      /**
       * Creates a new FFmpeg transform stream
       * @memberof core
       * @param {Object} options Options you would pass to a regular Transform stream, plus an `args` option
       * @param {Array<string>} options.args Arguments to pass to FFmpeg
       * @param {boolean} [options.shell=false] Whether FFmpeg should be spawned inside a shell
       * @example
       * // By default, if you don't specify an input (`-i ...`) prism will assume you're piping a stream into it.
       * const transcoder = new prism.FFmpeg({
       *  args: [
       *    '-analyzeduration', '0',
       *    '-loglevel', '0',
       *    '-f', 's16le',
       *    '-ar', '48000',
       *    '-ac', '2',
       *  ]
       * });
       * const s16le = mp3File.pipe(transcoder);
       * const opus = s16le.pipe(new prism.opus.Encoder({ rate: 48000, channels: 2, frameSize: 960 }));
       */
      constructor(options = {}) {
        super();
        this.process = _FFmpeg.create({ shell: false, ...options });
        const EVENTS = {
          readable: this._reader,
          data: this._reader,
          end: this._reader,
          unpipe: this._reader,
          finish: this._writer,
          drain: this._writer
        };
        this._readableState = this._reader._readableState;
        this._writableState = this._writer._writableState;
        this._copy(["write", "end"], this._writer);
        this._copy(["read", "setEncoding", "pipe", "unpipe"], this._reader);
        for (const method of ["on", "once", "removeListener", "removeListeners", "listeners"]) {
          this[method] = (ev, fn) => EVENTS[ev] ? EVENTS[ev][method](ev, fn) : Duplex.prototype[method].call(this, ev, fn);
        }
        const processError = (error2) => this.emit("error", error2);
        this._reader.on("error", processError);
        this._writer.on("error", processError);
      }
      get _reader() {
        return this.process.stdout;
      }
      get _writer() {
        return this.process.stdin;
      }
      _copy(methods, target) {
        for (const method of methods) {
          this[method] = target[method].bind(target);
        }
      }
      _destroy(err, cb) {
        this._cleanup();
        return cb ? cb(err) : void 0;
      }
      _final(cb) {
        this._cleanup();
        cb();
      }
      _cleanup() {
        if (this.process) {
          this.once("error", () => {
          });
          this.process.kill("SIGKILL");
          this.process = null;
        }
      }
      /**
       * The available FFmpeg information
       * @typedef {Object} FFmpegInfo
       * @memberof core
       * @property {string} command The command used to launch FFmpeg
       * @property {string} output The output from running `ffmpeg -h`
       * @property {string} version The version of FFmpeg being used, determined from `output`.
       */
      /**
       * Finds a suitable FFmpeg command and obtains the debug information from it.
       * @param {boolean} [force=false] If true, will ignore any cached results and search for the command again
       * @returns {FFmpegInfo}
       * @throws Will throw an error if FFmpeg cannot be found.
       * @example
       * const ffmpeg = prism.FFmpeg.getInfo();
       *
       * console.log(`Using FFmpeg version ${ffmpeg.version}`);
       *
       * if (ffmpeg.output.includes('--enable-libopus')) {
       *   console.log('libopus is available!');
       * } else {
       *   console.log('libopus is unavailable!');
       * }
       */
      static getInfo(force = false) {
        if (FFMPEG.command && !force) return FFMPEG;
        const sources = [() => {
          const ffmpegStatic = require_vite_optional_peer_dep_ffmpeg_static_prism_media();
          return ffmpegStatic.path || ffmpegStatic;
        }, "ffmpeg", "avconv", "./ffmpeg", "./avconv"];
        for (let source of sources) {
          try {
            if (typeof source === "function") source = source();
            const result = ChildProcess.spawnSync(source, ["-h"], { windowsHide: true });
            if (result.error) throw result.error;
            Object.assign(FFMPEG, {
              command: source,
              output: Buffer.concat(result.output.filter(Boolean)).toString()
            });
            return FFMPEG;
          } catch (error2) {
          }
        }
        throw new Error("FFmpeg/avconv not found!");
      }
      /**
       * Creates a new FFmpeg instance. If you do not include `-i ...` it will be assumed that `-i -` should be prepended
       * to the options and that you'll be piping data into the process.
       * @param {String[]} [args=[]] Arguments to pass to FFmpeg
       * @returns {ChildProcess}
       * @private
       * @throws Will throw an error if FFmpeg cannot be found.
       */
      static create({ args = [], shell = false } = {}) {
        if (!args.includes("-i")) args.unshift("-i", "-");
        return ChildProcess.spawn(_FFmpeg.getInfo().command, args.concat(["pipe:1"]), { windowsHide: true, shell });
      }
    };
    module2.exports = FFmpeg;
  }
});

// ../../../node_modules/prism-media/src/core/VolumeTransformer.js
var require_VolumeTransformer = __commonJS({
  "../../../node_modules/prism-media/src/core/VolumeTransformer.js"(exports2, module2) {
    var { Transform } = require_stream();
    var VolumeTransformer = class extends Transform {
      /**
       * @memberof core
       * @param {Object} options Any optional TransformStream options plus some extra:
       * @param {string} options.type The type of transformer: s16le (signed 16-bit little-endian), s16be, s32le, s32be
       * @param {number} [options.volume=1] The output volume of the stream
       * @example
       * // Half the volume of a signed 16-bit little-endian PCM stream
       * input
       *  .pipe(new prism.VolumeTransformer({ type: 's16le', volume: 0.5 }))
       *  .pipe(writeStream);
       */
      constructor(options = {}) {
        super(options);
        switch (options.type) {
          case "s16le":
            this._readInt = (buffer, index) => buffer.readInt16LE(index);
            this._writeInt = (buffer, int, index) => buffer.writeInt16LE(int, index);
            this._bits = 16;
            break;
          case "s16be":
            this._readInt = (buffer, index) => buffer.readInt16BE(index);
            this._writeInt = (buffer, int, index) => buffer.writeInt16BE(int, index);
            this._bits = 16;
            break;
          case "s32le":
            this._readInt = (buffer, index) => buffer.readInt32LE(index);
            this._writeInt = (buffer, int, index) => buffer.writeInt32LE(int, index);
            this._bits = 32;
            break;
          case "s32be":
            this._readInt = (buffer, index) => buffer.readInt32BE(index);
            this._writeInt = (buffer, int, index) => buffer.writeInt32BE(int, index);
            this._bits = 32;
            break;
          default:
            throw new Error("VolumeTransformer type should be one of s16le, s16be, s32le, s32be");
        }
        this._bytes = this._bits / 8;
        this._extremum = Math.pow(2, this._bits - 1);
        this.volume = typeof options.volume === "undefined" ? 1 : options.volume;
        this._chunk = Buffer.alloc(0);
      }
      _readInt(buffer, index) {
        return index;
      }
      _writeInt(buffer, int, index) {
        return index;
      }
      _transform(chunk, encoding, done) {
        if (this.volume === 1) {
          this.push(chunk);
          return done();
        }
        const { _bytes, _extremum } = this;
        chunk = this._chunk = Buffer.concat([this._chunk, chunk]);
        if (chunk.length < _bytes) return done();
        const complete = Math.floor(chunk.length / _bytes) * _bytes;
        for (let i = 0; i < complete; i += _bytes) {
          const int = Math.min(_extremum - 1, Math.max(-_extremum, Math.floor(this.volume * this._readInt(chunk, i))));
          this._writeInt(chunk, int, i);
        }
        this._chunk = chunk.slice(complete);
        this.push(chunk.slice(0, complete));
        return done();
      }
      _destroy(err, cb) {
        super._destroy(err, cb);
        this._chunk = null;
      }
      /**
       * Sets the volume relative to the input stream - i.e. 1 is normal, 0.5 is half, 2 is double.
       * @param {number} volume The volume that you want to set
       */
      setVolume(volume) {
        this.volume = volume;
      }
      /**
       * Sets the volume in decibels.
       * @param {number} db The decibels
       */
      setVolumeDecibels(db) {
        this.setVolume(Math.pow(10, db / 20));
      }
      /**
       * Sets the volume so that a perceived value of 0.5 is half the perceived volume etc.
       * @param {number} value The value for the volume
       */
      setVolumeLogarithmic(value) {
        this.setVolume(Math.pow(value, 1.660964));
      }
      /**
       * The current volume of the stream in decibels
       * @readonly
       * @type {number}
       */
      get volumeDecibels() {
        return Math.log10(this.volume) * 20;
      }
      /**
       * The current volume of the stream from a logarithmic scale
       * @readonly
       * @type {number}
       */
      get volumeLogarithmic() {
        return Math.pow(this.volume, 1 / 1.660964);
      }
    };
    module2.exports = VolumeTransformer;
  }
});

// ../../../node_modules/prism-media/src/core/index.js
var require_core = __commonJS({
  "../../../node_modules/prism-media/src/core/index.js"(exports2, module2) {
    module2.exports = {
      FFmpeg: require_FFmpeg(),
      VolumeTransformer: require_VolumeTransformer()
    };
  }
});

// ../../../node_modules/prism-media/src/index.js
var require_src = __commonJS({
  "../../../node_modules/prism-media/src/index.js"(exports2, module2) {
    module2.exports = {
      opus: require_opus(),
      vorbis: require_vorbis(),
      ...require_core()
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/voice/player/processing/AnnexBNalSplitter.js
var require_AnnexBNalSplitter = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/voice/player/processing/AnnexBNalSplitter.js"(exports2, module2) {
    "use strict";
    var { Buffer: Buffer2 } = require_buffer();
    var { Transform } = require_stream();
    var H264NalUnitTypes = {
      Unspecified: 0,
      CodedSliceNonIDR: 1,
      CodedSlicePartitionA: 2,
      CodedSlicePartitionB: 3,
      CodedSlicePartitionC: 4,
      CodedSliceIdr: 5,
      SEI: 6,
      SPS: 7,
      PPS: 8,
      AccessUnitDelimiter: 9,
      EndOfSequence: 10,
      EndOfStream: 11,
      FillerData: 12,
      SEIExtenstion: 13,
      PrefixNalUnit: 14,
      SubsetSPS: 15
    };
    var H265NalUnitTypes = {
      TRAIL_N: 0,
      TRAIL_R: 1,
      TSA_N: 2,
      TSA_R: 3,
      STSA_N: 4,
      STSA_R: 5,
      RADL_N: 6,
      RADL_R: 7,
      RASL_N: 8,
      RASL_R: 9,
      RSV_VCL_N10: 10,
      RSV_VCL_R11: 11,
      RSV_VCL_N12: 12,
      RSV_VCL_R13: 13,
      RSV_VCL_N14: 14,
      RSV_VCL_R15: 15,
      BLA_W_LP: 16,
      BLA_W_RADL: 17,
      BLA_N_LP: 18,
      IDR_W_RADL: 19,
      IDR_N_LP: 20,
      CRA_NUT: 21,
      RSV_IRAP_VCL22: 22,
      RSV_IRAP_VCL23: 23,
      RSV_VCL24: 24,
      RSV_VCL25: 25,
      RSV_VCL26: 26,
      RSV_VCL27: 27,
      RSV_VCL28: 28,
      RSV_VCL29: 29,
      RSV_VCL30: 30,
      RSV_VCL31: 31,
      VPS_NUT: 32,
      SPS_NUT: 33,
      PPS_NUT: 34,
      AUD_NUT: 35,
      EOS_NUT: 36,
      EOB_NUT: 37,
      FD_NUT: 38,
      PREFIX_SEI_NUT: 39,
      SUFFIX_SEI_NUT: 40,
      RSV_NVCL41: 41,
      RSV_NVCL42: 42,
      RSV_NVCL43: 43,
      RSV_NVCL44: 44,
      RSV_NVCL45: 45,
      RSV_NVCL46: 46,
      RSV_NVCL47: 47,
      UNSPEC48: 48,
      UNSPEC49: 49,
      UNSPEC50: 50,
      UNSPEC51: 51,
      UNSPEC52: 52,
      UNSPEC53: 53,
      UNSPEC54: 54,
      UNSPEC55: 55,
      UNSPEC56: 56,
      UNSPEC57: 57,
      UNSPEC58: 58,
      UNSPEC59: 59,
      UNSPEC60: 60,
      UNSPEC61: 61,
      UNSPEC62: 62,
      UNSPEC63: 63
    };
    var H264Helpers = {
      getUnitType(frame) {
        return frame[0] & 31;
      },
      splitHeader(frame) {
        return [frame.subarray(0, 1), frame.subarray(1)];
      },
      isAUD(unitType) {
        return unitType === H264NalUnitTypes.AccessUnitDelimiter;
      }
    };
    var H265Helpers = {
      getUnitType(frame) {
        return frame[0] >> 1 & 63;
      },
      splitHeader(frame) {
        return [frame.subarray(0, 2), frame.subarray(2)];
      },
      isAUD(unitType) {
        return unitType === H265NalUnitTypes.AUD_NUT;
      }
    };
    var emptyBuffer = Buffer2.allocUnsafe(0);
    var epbPrefix = Buffer2.from([0, 0, 3]);
    var nalSuffix = Buffer2.from([0, 0, 1]);
    var AnnexBNalSplitter = class extends Transform {
      constructor(nalFunctions) {
        super();
        this._buffer = null;
        this._accessUnit = [];
        this._nalFunctions = nalFunctions;
      }
      rbsp(data) {
        const newData = Buffer2.allocUnsafe(data.length);
        let newLength = 0;
        while (true) {
          const epbsPos = data.indexOf(epbPrefix);
          if (epbsPos === -1) {
            data.copy(newData, newLength);
            newLength += data.length;
            break;
          }
          const copyRange = data[epbsPos + 3] <= 3 ? epbsPos + 2 : epbsPos + 3;
          data.copy(newData, newLength, 0, copyRange);
          newLength += copyRange;
          data = data.subarray(epbsPos + 3);
        }
        return newData.subarray(0, newLength);
      }
      findNalStart(buf) {
        const pos = buf.indexOf(nalSuffix);
        if (pos === -1) return null;
        return pos > 0 && buf[pos - 1] === 0 ? { index: pos - 1, length: 4 } : { index: pos, length: 3 };
      }
      processFrame(frame) {
        if (frame.length === 0) return;
        const unitType = this._nalFunctions.getUnitType(frame);
        if (this._nalFunctions.isAUD(unitType) && this._accessUnit.length > 0) {
          const sizeOfAccessUnit = this._accessUnit.reduce((acc, nalu) => acc + nalu.length + 4, 0);
          const accessUnitBuf = Buffer2.allocUnsafe(sizeOfAccessUnit);
          let offset = 0;
          this._accessUnit.forEach((nalu) => {
            accessUnitBuf.writeUint32BE(nalu.length, offset);
            offset += 4;
            nalu.copy(accessUnitBuf, offset);
            offset += nalu.length;
          });
          this.push(accessUnitBuf);
          this._accessUnit = [];
        } else {
          this._accessUnit.push(this.removeEpbs(frame, unitType));
        }
      }
      _transform(chunk, encoding, callback) {
        let nalStart = this.findNalStart(chunk);
        if (!this._buffer) {
          if (!nalStart) {
            callback();
            return;
          }
          chunk = chunk.subarray(nalStart.index + nalStart.length);
          this._buffer = emptyBuffer;
        }
        chunk = Buffer2.concat([this._buffer, chunk]);
        while (nalStart = this.findNalStart(chunk)) {
          const frame = chunk.subarray(0, nalStart.index);
          this.processFrame(frame);
          chunk = chunk.subarray(nalStart.index + nalStart.length);
        }
        this._buffer = chunk;
        callback();
      }
    };
    var H264NalSplitter = class extends AnnexBNalSplitter {
      constructor() {
        super(H264Helpers);
      }
      removeEpbs(frame, unitType) {
        return unitType === H264NalUnitTypes.SPS || unitType === H264NalUnitTypes.SEI ? this.rbsp(frame) : frame;
      }
    };
    var H265NalSplitter = class extends AnnexBNalSplitter {
      constructor() {
        super(H265Helpers);
      }
      removeEpbs(frame) {
        return frame;
      }
    };
    module2.exports = {
      H264NalUnitTypes,
      H265NalUnitTypes,
      H264Helpers,
      H265Helpers,
      H264NalSplitter,
      H265NalSplitter
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/voice/player/processing/IvfSplitter.js
var require_IvfSplitter = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/voice/player/processing/IvfSplitter.js"(exports2, module2) {
    "use strict";
    var { Buffer: Buffer2 } = require_buffer();
    var { Transform } = require_stream();
    var IvfTransformer = class extends Transform {
      constructor(options) {
        super(options);
        this.headerSize = 32;
        this.frameHeaderSize = 12;
        this.header = null;
        this.buf = null;
        this.retFullFrame = options && options.fullframe ? options.fullframe : false;
      }
      _parseHeader(header) {
        this.header = {
          signature: header.subarray(0, 4).toString(),
          version: header.readUIntLE(4, 2),
          headerLength: header.readUIntLE(6, 2),
          codec: header.subarray(8, 12).toString(),
          width: header.readUIntLE(12, 2),
          height: header.readUIntLE(14, 2),
          timeDenominator: header.readUIntLE(16, 4),
          timeNumerator: header.readUIntLE(20, 4),
          frameCount: header.readUIntLE(24, 4)
        };
      }
      _getFrameSize(buf) {
        return buf.readUIntLE(0, 4);
      }
      _parseFrame(frame) {
        const size = this._getFrameSize(frame);
        if (this.retFullFrame) return this.push(frame.subarray(0, 12 + size));
        const out = {
          size,
          timestamp: frame.readBigUInt64LE(4),
          data: frame.subarray(12, 12 + size)
        };
        return this.push(out.data);
      }
      _appendChunkToBuf(chunk) {
        if (this.buf) this.buf = Buffer2.concat([this.buf, chunk]);
        else this.buf = chunk;
      }
      _updateBufLen(size) {
        if (this.buf.length > size) this.buf = this.buf.subarray(size, this.buf.length);
        else this.buf = null;
      }
      _transform(chunk, encoding, callback) {
        this._appendChunkToBuf(chunk);
        if (!this.header) {
          if (this.buf.length >= this.headerSize) {
            this._parseHeader(this.buf.subarray(0, this.headerSize));
            this._updateBufLen(this.headerSize);
          } else {
            callback();
            return;
          }
        }
        while (this.buf && this.buf.length >= this.frameHeaderSize) {
          const size = this._getFrameSize(this.buf) + this.frameHeaderSize;
          if (this.buf.length >= size) {
            this._parseFrame(this.buf.subarray(0, size));
            this._updateBufLen(size);
          } else {
            break;
          }
        }
        callback();
      }
    };
    module2.exports = {
      IvfTransformer
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/voice/util/Secretbox.js
var require_Secretbox = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/voice/util/Secretbox.js"(exports2) {
    "use strict";
    var libs = {
      sodium: (sodium) => ({
        crypto_aead_xchacha20poly1305_ietf_encrypt: (plaintext, additionalData, nonce, key) => sodium.api.crypto_aead_xchacha20poly1305_ietf_encrypt(plaintext, additionalData, null, nonce, key),
        crypto_aead_xchacha20poly1305_ietf_decrypt: (plaintext, additionalData, nonce, key) => sodium.api.crypto_aead_xchacha20poly1305_ietf_decrypt(plaintext, additionalData, null, nonce, key)
      }),
      "libsodium-wrappers": (sodium) => ({
        crypto_aead_xchacha20poly1305_ietf_encrypt: (plaintext, additionalData, nonce, key) => sodium.crypto_aead_xchacha20poly1305_ietf_encrypt(plaintext, additionalData, null, nonce, key),
        crypto_aead_xchacha20poly1305_ietf_decrypt: (plaintext, additionalData, nonce, key) => sodium.crypto_aead_xchacha20poly1305_ietf_decrypt(null, plaintext, additionalData, nonce, key)
      }),
      "@stablelib/xchacha20poly1305": (stablelib) => ({
        crypto_aead_xchacha20poly1305_ietf_encrypt(cipherText, additionalData, nonce, key) {
          const crypto = new stablelib.XChaCha20Poly1305(key);
          return crypto.seal(nonce, cipherText, additionalData);
        },
        crypto_aead_xchacha20poly1305_ietf_decrypt(plaintext, additionalData, nonce, key) {
          const crypto = new stablelib.XChaCha20Poly1305(key);
          return crypto.open(nonce, plaintext, additionalData);
        }
      })
    };
    function NoLib() {
      throw new Error(
        "Cannot play audio as no valid encryption package is installed.\n- Install sodium, libsodium-wrappers, or @stablelib/xchacha20poly1305."
      );
    }
    exports2.methods = {
      crypto_aead_xchacha20poly1305_ietf_encrypt: NoLib,
      crypto_aead_xchacha20poly1305_ietf_decrypt: NoLib
    };
    async function importModule(name, usingImport = false) {
      try {
        if (usingImport) {
          return await import(name);
        } else {
          return __require(name);
        }
      } catch (e) {
        if (e.code == "ERR_REQUIRE_ESM") {
          return importModule(name, true);
        } else {
          throw e;
        }
      }
    }
    (async () => {
      for (const libName of Object.keys(libs)) {
        try {
          const lib = await importModule(libName);
          if (libName === "libsodium-wrappers" && lib.ready) await lib.ready;
          exports2.methods = libs[libName](lib);
          break;
        } catch {
        }
      }
    })();
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/voice/dispatcher/BaseDispatcher.js
var require_BaseDispatcher = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/voice/dispatcher/BaseDispatcher.js"(exports2, module2) {
    "use strict";
    var { Buffer: Buffer2 } = require_node_buffer();
    var crypto = require_node_crypto();
    var { Writable } = require_node_stream();
    var { setTimeout: setTimeout2 } = require_node_timers();
    var secretbox = require_Secretbox();
    var CHANNELS = 2;
    var MAX_UINT_16 = 2 ** 16 - 1;
    var MAX_UINT_32 = 2 ** 32 - 1;
    var extensions = [{ id: 5, len: 2, val: 0 }];
    var BaseDispatcher = class extends Writable {
      constructor(player, highWaterMark = 12, payloadType, extensionEnabled, streams = {}) {
        super({
          highWaterMark
        });
        this.streams = streams;
        this.player = player;
        this.payloadType = payloadType;
        this.extensionEnabled = extensionEnabled;
        this._nonce = 0;
        this._nonceBuffer = null;
        this.pausedSince = null;
        this._writeCallback = null;
        this._pausedTime = 0;
        this._silentPausedTime = 0;
        this.count = 0;
        this.sequence = 0;
        this.timestamp = 0;
        this.fps = 0;
        this.mtu = 1200;
        const streamError = (type, err) => {
          if (type && err) {
            err.message = `${type} stream: ${err.message}`;
            this.emit(this.player.dispatcher === this ? "error" : "debug", err);
          }
          this.destroy();
        };
        this.on("error", () => streamError());
        if (this.streams.input) this.streams.input.on("error", (err) => streamError("input", err));
        if (this.streams.ffmpeg) this.streams.ffmpeg.on("error", (err) => streamError("ffmpeg", err));
        if (this.streams.opus) this.streams.opus.on("error", (err) => streamError("opus", err));
        if (this.streams.volume) this.streams.volume.on("error", (err) => streamError("volume", err));
        this.on("finish", () => {
          this._cleanup();
          this._setSpeaking(0);
          this._setVideoStatus(false);
          this._setStreamStatus(true);
        });
      }
      resetNonceBuffer() {
        this._nonceBuffer = this.player.voiceConnection.authentication.mode === "aead_aes256_gcm_rtpsize" ? Buffer2.alloc(12) : Buffer2.alloc(24);
      }
      get TIMESTAMP_INC() {
        return this.extensionEnabled ? 9e4 / this.fps : 480 * CHANNELS;
      }
      get FRAME_LENGTH() {
        return this.extensionEnabled ? 1e3 / this.fps : 20;
      }
      partitionVideoData(data) {
        const out = [];
        const dataLength = data.length;
        for (let i = 0; i < dataLength; i += this.mtu) {
          out.push(data.slice(i, i + this.mtu));
        }
        return out;
      }
      getNewSequence() {
        const currentSeq = this.sequence;
        this.sequence++;
        if (this.sequence > MAX_UINT_16) this.sequence = 0;
        return currentSeq;
      }
      _write(chunk, enc, done) {
        if (!this.startTime) {
          this.emit("start");
          this.startTime = performance.now();
        }
        if (this.extensionEnabled) {
          this.codecCallback(chunk);
        } else {
          this._playChunk(chunk);
        }
        this._step(done);
      }
      _destroy(err, cb) {
        this._cleanup();
        super._destroy(err, cb);
      }
      _cleanup() {
        var _a;
        if (this.player.dispatcher === this) {
          this.player.dispatcher.destroy();
          this.player.dispatcher = null;
        }
        if (this.player.videoDispatcher === this) {
          this.player.videoDispatcher.destroy();
          this.player.videoDispatcher = null;
        }
        const { streams } = this;
        if (streams.opus) streams.opus.destroy();
        (_a = streams.ffmpeg) == null ? void 0 : _a.destroy();
      }
      /**
       * Pauses playback
       * @param {boolean} [silence=false] Whether to play silence while paused to prevent audio glitches
       */
      pause(silence = false) {
        if (this.paused) return;
        if (this.streams.opus) this.streams.opus.unpipe(this);
        if (this.streams.video) {
          this.streams.ffmpeg.pause();
          this.streams.video.unpipe(this);
        }
        if (!this.extensionEnabled) {
          if (silence) {
            this.streams.silence.pipe(this);
            this._silence = true;
          } else {
            this._setSpeaking(0);
          }
        }
        this.pausedSince = performance.now();
      }
      /**
       * Whether or not playback is paused
       * @type {boolean}
       * @readonly
       */
      get paused() {
        return Boolean(this.pausedSince);
      }
      /**
       * Total time that this dispatcher has been paused in milliseconds
       * @type {number}
       * @readonly
       */
      get pausedTime() {
        return this._silentPausedTime + this._pausedTime + (this.paused ? performance.now() - this.pausedSince : 0);
      }
      /**
       * Resumes playback
       */
      resume() {
        if (!this.pausedSince) return;
        if (!this.extensionEnabled) this.streams.silence.unpipe(this);
        if (this.streams.opus) this.streams.opus.pipe(this);
        if (this.streams.video) {
          this.streams.ffmpeg.resume();
          this.streams.video.pipe(this);
        }
        if (this._silence) {
          this._silentPausedTime += performance.now() - this.pausedSince;
          this._silence = false;
        } else {
          this._pausedTime += performance.now() - this.pausedSince;
        }
        this.pausedSince = null;
        if (typeof this._writeCallback === "function") this._writeCallback();
      }
      /**
       * The time (in milliseconds) that the dispatcher has been playing audio for, taking into account skips and pauses
       * @type {number}
       * @readonly
       */
      get totalStreamTime() {
        return performance.now() - this.startTime;
      }
      _step(done) {
        this._writeCallback = () => {
          this._writeCallback = null;
          done();
        };
        const next = (this.count + 1) * this.FRAME_LENGTH - (performance.now() - this.startTime - this._pausedTime);
        setTimeout2(() => {
          if ((!this.pausedSince || this._silence) && this._writeCallback) this._writeCallback();
        }, next).unref();
        this.timestamp += this.TIMESTAMP_INC;
        if (this.timestamp > MAX_UINT_32) this.timestamp = 0;
        this.count++;
        if (this.count > MAX_UINT_16) this.count = 0;
      }
      _final(callback) {
        this._writeCallback = null;
        callback();
      }
      _playChunk(chunk, isLastPacket) {
        if (this.player.dispatcher !== this && this.player.videoDispatcher !== this || !this.player.voiceConnection.authentication.secret_key) {
          return;
        }
        this[this.extensionEnabled ? "_sendVideoPacket" : "_sendPacket"](this._createPacket(chunk, isLastPacket));
      }
      /**
       * Creates a one-byte extension header
       * https://www.rfc-editor.org/rfc/rfc5285#section-4.2
       * @returns {Buffer} <Buffer be de 00 01>
       */
      createHeaderExtension() {
        const profile = Buffer2.alloc(4);
        profile[0] = 190;
        profile[1] = 222;
        profile.writeInt16BE(extensions.length, 2);
        return profile;
      }
      /**
       * Creates a single extension of type playout-delay
       * Discord seems to send this extension on every video packet
       * @see https://webrtc.googlesource.com/src/+/refs/heads/main/docs/native-code/rtp-hdrext/playout-delay
       * @returns {Buffer} playout-delay extension <Buffer 51 00 00 00>
       */
      createPayloadExtension() {
        const extensionsData = [];
        for (let ext of extensions) {
          const data = Buffer2.alloc(4);
          data[0] = (ext.id & 15) << 4;
          data[0] |= ext.len - 1 & 15;
          data.writeUIntBE(ext.val, 1, 2);
          extensionsData.push(data);
        }
        return Buffer2.concat(extensionsData);
      }
      _encrypt(buffer, additionalData) {
        const { secret_key, mode } = this.player.voiceConnection.authentication;
        this._nonce++;
        if (this._nonce > MAX_UINT_32) this._nonce = 0;
        if (!this._nonceBuffer) {
          this.resetNonceBuffer();
        }
        this._nonceBuffer.writeUInt32BE(this._nonce, 0);
        const noncePadding = this._nonceBuffer.slice(0, 4);
        let encrypted;
        switch (mode) {
          case "aead_aes256_gcm_rtpsize": {
            const cipher = crypto.createCipheriv("aes-256-gcm", secret_key, this._nonceBuffer);
            cipher.setAAD(additionalData);
            encrypted = Buffer2.concat([cipher.update(buffer), cipher.final(), cipher.getAuthTag()]);
            return [encrypted, noncePadding];
          }
          case "aead_xchacha20_poly1305_rtpsize": {
            encrypted = secretbox.methods.crypto_aead_xchacha20poly1305_ietf_encrypt(
              buffer,
              additionalData,
              this._nonceBuffer,
              secret_key
            );
            return [encrypted, noncePadding];
          }
          default: {
            throw new RangeError(`Unsupported encryption method: ${mode}`);
          }
        }
      }
      _createPacket(buffer, isLastPacket = false) {
        const rtpHeader = this.extensionEnabled ? Buffer2.concat([Buffer2.alloc(12), this.createHeaderExtension()]) : Buffer2.alloc(12);
        rtpHeader[0] = this.extensionEnabled ? 144 : 128;
        rtpHeader[1] = this.payloadType;
        if (this.extensionEnabled) {
          if (isLastPacket) {
            rtpHeader[1] |= 128;
          }
        }
        rtpHeader.writeUIntBE(this.getNewSequence(), 2, 2);
        rtpHeader.writeUIntBE(this.timestamp, 4, 4);
        rtpHeader.writeUIntBE(this.player.voiceConnection.authentication.ssrc + this.extensionEnabled, 8, 4);
        return Buffer2.concat([rtpHeader, ...this._encrypt(buffer, rtpHeader)]);
      }
      _sendPacket(packet) {
        this._setSpeaking(this.player.isScreenSharing ? 1 << 1 : 1 << 0);
        if (!this.player.voiceConnection.sockets.udp) {
          this.emit("debug", "Failed to send a packet - no UDP socket");
          return;
        }
        this.player.voiceConnection.sockets.udp.send(packet).catch((e) => {
          this._setSpeaking(0);
          this.emit("debug", `Failed to send a packet - ${e}`);
        });
      }
      _sendVideoPacket(packet) {
        this._setVideoStatus(true);
        this._setStreamStatus(false);
        if (!this.player.voiceConnection.sockets.udp) {
          this.emit("debug", "Failed to send a video packet - no UDP socket");
          return;
        }
        this.player.voiceConnection.sockets.udp.send(packet).catch((e) => {
          this._setVideoStatus(false);
          this._setStreamStatus(true);
          this.emit("debug", `Failed to send a video packet - ${e}`);
        });
      }
      _setSpeaking(value) {
        if (typeof this.player.voiceConnection !== "undefined") {
          this.player.voiceConnection.setSpeaking(value);
        }
        this.emit("speaking", value);
      }
      _setVideoStatus(value) {
        if (typeof this.player.voiceConnection !== "undefined") {
          this.player.voiceConnection.setVideoStatus(value);
        }
        this.emit("videoStatus", value);
      }
      _setStreamStatus(value) {
        var _a;
        if (typeof ((_a = this.player.voiceConnection) == null ? void 0 : _a.sendScreenshareState) !== "undefined") {
          this.player.voiceConnection.sendScreenshareState(value);
        }
        this.emit("streamStatus", value);
      }
    };
    module2.exports = BaseDispatcher;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/voice/dispatcher/VideoDispatcher.js
var require_VideoDispatcher = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/voice/dispatcher/VideoDispatcher.js"(exports2, module2) {
    "use strict";
    var BaseDispatcher = require_BaseDispatcher();
    var VideoDispatcher = class extends BaseDispatcher {
      constructor(player, highWaterMark = 12, streams, fps, payloadType) {
        super(player, highWaterMark, payloadType, true, streams);
        this.fps = fps;
      }
      /**
       * Set FPS
       * @param {number} value fps
       */
      setFPSSource(value) {
        this.fps = value;
      }
    };
    module2.exports = VideoDispatcher;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/voice/dispatcher/AnnexBDispatcher.js
var require_AnnexBDispatcher = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/voice/dispatcher/AnnexBDispatcher.js"(exports2, module2) {
    "use strict";
    var { Buffer: Buffer2 } = require_buffer();
    var VideoDispatcher = require_VideoDispatcher();
    var Util = require_Util();
    var { H264Helpers, H265Helpers } = require_AnnexBNalSplitter();
    var AnnexBDispatcher = class extends VideoDispatcher {
      constructor(player, highWaterMark = 12, streams, fps, nalFunctions, payloadType) {
        super(player, highWaterMark, streams, fps, payloadType);
        this._nalFunctions = nalFunctions;
      }
      codecCallback(frame) {
        let accessUnit = frame;
        let offset = 0;
        while (offset < accessUnit.length) {
          const naluSize = accessUnit.readUInt32BE(offset);
          offset += 4;
          const nalu = accessUnit.subarray(offset, offset + naluSize);
          const isLastNal = offset + naluSize >= accessUnit.length;
          if (nalu.length <= this.mtu) {
            this._playChunk(Buffer2.concat([this.createPayloadExtension(), nalu]), isLastNal);
          } else {
            const [naluHeader, naluData] = this._nalFunctions.splitHeader(nalu);
            const dataFragments = this.partitionVideoData(naluData);
            for (let fragmentIndex = 0; fragmentIndex < dataFragments.length; fragmentIndex++) {
              const data = dataFragments[fragmentIndex];
              const isFirstPacket = fragmentIndex === 0;
              const isFinalPacket = fragmentIndex === dataFragments.length - 1;
              this._playChunk(
                Buffer2.concat([
                  this.createPayloadExtension(),
                  this.makeFragmentationUnitHeader(isFirstPacket, isFinalPacket, naluHeader),
                  data
                ]),
                isLastNal && isFinalPacket
              );
            }
          }
          offset += naluSize;
        }
      }
    };
    var H264Dispatcher = class extends AnnexBDispatcher {
      constructor(player, highWaterMark = 12, streams, fps) {
        super(player, highWaterMark, streams, fps, H264Helpers, Util.getPayloadType("H264"));
      }
      makeFragmentationUnitHeader(isFirstPacket, isLastPacket, naluHeader) {
        const nal0 = naluHeader[0];
        const fuPayloadHeader = Buffer2.alloc(2);
        const nalType = H264Helpers.getUnitType(naluHeader);
        const fnri = nal0 & 224;
        fuPayloadHeader[0] = 28 | fnri;
        if (isFirstPacket) {
          fuPayloadHeader[1] = 128 | nalType;
        } else if (isLastPacket) {
          fuPayloadHeader[1] = 64 | nalType;
        } else {
          fuPayloadHeader[1] = nalType;
        }
        return fuPayloadHeader;
      }
    };
    var H265Dispatcher = class extends AnnexBDispatcher {
      constructor(player, highWaterMark = 12, streams, fps) {
        super(player, highWaterMark, streams, fps, H265Helpers, Util.getPayloadType("H265"));
      }
      makeFragmentationUnitHeader(isFirstPacket, isLastPacket, naluHeader) {
        const fuIndicatorHeader = Buffer2.allocUnsafe(3);
        naluHeader.copy(fuIndicatorHeader);
        const nalType = H265Helpers.getUnitType(naluHeader);
        fuIndicatorHeader[0] = fuIndicatorHeader[0] & 129 | 49 << 1;
        if (isFirstPacket) {
          fuIndicatorHeader[2] = 128 | nalType;
        } else if (isLastPacket) {
          fuIndicatorHeader[2] = 64 | nalType;
        } else {
          fuIndicatorHeader[2] = nalType;
        }
        return fuIndicatorHeader;
      }
    };
    module2.exports = {
      H264Dispatcher,
      H265Dispatcher
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/voice/util/Silence.js
var require_Silence = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/voice/util/Silence.js"(exports2, module2) {
    "use strict";
    var { Buffer: Buffer2 } = require_node_buffer();
    var { Readable } = require_stream();
    var SILENCE_FRAME = Buffer2.from([248, 255, 254]);
    var Silence = class extends Readable {
      _read() {
        this.push(SILENCE_FRAME);
      }
    };
    Silence.SILENCE_FRAME = SILENCE_FRAME;
    module2.exports = Silence;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/voice/util/VolumeInterface.js
var require_VolumeInterface = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/voice/util/VolumeInterface.js"(exports2) {
    "use strict";
    var EventEmitter = require_events();
    var { Buffer: Buffer2 } = require_node_buffer();
    var VolumeInterface = class extends EventEmitter {
      constructor({ volume = 1 } = {}) {
        super();
        this.setVolume(volume);
      }
      /**
       * Whether or not the volume of this stream is editable
       * @type {boolean}
       * @readonly
       */
      get volumeEditable() {
        return true;
      }
      /**
       * The current volume of the stream
       * @type {number}
       * @readonly
       */
      get volume() {
        return this._volume;
      }
      /**
       * The current volume of the stream in decibels
       * @type {number}
       * @readonly
       */
      get volumeDecibels() {
        return Math.log10(this.volume) * 20;
      }
      /**
       * The current volume of the stream from a logarithmic scale
       * @type {number}
       * @readonly
       */
      get volumeLogarithmic() {
        return Math.pow(this.volume, 1 / 1.660964);
      }
      applyVolume(buffer, volume) {
        volume = volume || this._volume;
        if (volume === 1) return buffer;
        const out = Buffer2.alloc(buffer.length);
        for (let i = 0; i < buffer.length; i += 2) {
          if (i >= buffer.length - 1) break;
          const uint = Math.min(32767, Math.max(-32767, Math.floor(volume * buffer.readInt16LE(i))));
          out.writeInt16LE(uint, i);
        }
        return out;
      }
      /**
       * Sets the volume relative to the input stream - i.e. 1 is normal, 0.5 is half, 2 is double.
       * @param {number} volume The volume that you want to set
       */
      setVolume(volume) {
        this.emit("volumeChange", this._volume, volume);
        this._volume = volume;
      }
      /**
       * Sets the volume in decibels.
       * @param {number} db The decibels
       */
      setVolumeDecibels(db) {
        this.setVolume(Math.pow(10, db / 20));
      }
      /**
       * Sets the volume so that a perceived value of 0.5 is half the perceived volume etc.
       * @param {number} value The value for the volume
       */
      setVolumeLogarithmic(value) {
        this.setVolume(Math.pow(value, 1.660964));
      }
    };
    var props = ["volumeDecibels", "volumeLogarithmic", "setVolumeDecibels", "setVolumeLogarithmic"];
    exports2.applyToClass = function applyToClass(structure) {
      for (const prop of props) {
        Object.defineProperty(structure.prototype, prop, Object.getOwnPropertyDescriptor(VolumeInterface.prototype, prop));
      }
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/voice/dispatcher/AudioDispatcher.js
var require_AudioDispatcher = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/voice/dispatcher/AudioDispatcher.js"(exports2, module2) {
    "use strict";
    var BaseDispatcher = require_BaseDispatcher();
    var Util = require_Util();
    var Silence = require_Silence();
    var VolumeInterface = require_VolumeInterface();
    var AudioDispatcher = class extends BaseDispatcher {
      constructor(player, { seek = 0, volume = 1, fec, plp, bitrate = 96, highWaterMark = 12 } = {}, streams) {
        const streamOptions = { seek, volume, fec, plp, bitrate, highWaterMark };
        super(player, highWaterMark, Util.getPayloadType("opus"), false, streams);
        this.streamOptions = streamOptions;
        this.streams.silence = new Silence();
        this.setVolume(volume);
        this.setBitrate(bitrate);
        if (typeof fec !== "undefined") this.setFEC(fec);
        if (typeof plp !== "undefined") this.setPLP(plp);
      }
      /**
       * Set the bitrate of the current Opus encoder if using a compatible Opus stream.
       * @param {number} value New bitrate, in kbps
       * If set to 'auto', the voice channel's bitrate will be used
       * @returns {boolean} true if the bitrate has been successfully changed.
       */
      setBitrate(value) {
        if (!value || !this.bitrateEditable) return false;
        const bitrate = value === "auto" ? this.player.voiceConnection.channel.bitrate : value;
        this.streams.opus.setBitrate(bitrate * 1e3);
        return true;
      }
      /**
       * Sets the expected packet loss percentage if using a compatible Opus stream.
       * @param {number} value between 0 and 1
       * @returns {boolean} Returns true if it was successfully set.
       */
      setPLP(value) {
        if (!this.bitrateEditable) return false;
        this.streams.opus.setPLP(value);
        return true;
      }
      /**
       * Enables or disables forward error correction if using a compatible Opus stream.
       * @param {boolean} enabled true to enable
       * @returns {boolean} Returns true if it was successfully set.
       */
      setFEC(enabled) {
        if (!this.bitrateEditable) return false;
        this.streams.opus.setFEC(enabled);
        return true;
      }
      get volumeEditable() {
        return Boolean(this.streams.volume);
      }
      /**
       * Whether or not the Opus bitrate of this stream is editable
       * @type {boolean}
       * @readonly
       */
      get bitrateEditable() {
        return this.streams.opus && this.streams.opus.setBitrate;
      }
      // Volume
      get volume() {
        return this.streams.volume ? this.streams.volume.volume : 1;
      }
      setVolume(value) {
        if (!this.streams.volume) return false;
        this.emit("volumeChange", this.volume, value);
        this.streams.volume.setVolume(value);
        return true;
      }
      // Volume stubs for docs
      /* eslint-disable no-empty-function*/
      get volumeDecibels() {
      }
      get volumeLogarithmic() {
      }
      setVolumeDecibels() {
      }
      setVolumeLogarithmic() {
      }
    };
    VolumeInterface.applyToClass(AudioDispatcher);
    module2.exports = AudioDispatcher;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/voice/dispatcher/VPxDispatcher.js
var require_VPxDispatcher = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/voice/dispatcher/VPxDispatcher.js"(exports2, module2) {
    "use strict";
    var { Buffer: Buffer2 } = require_node_buffer();
    var VideoDispatcher = require_VideoDispatcher();
    var Util = require_Util();
    var VP8Dispatcher = class extends VideoDispatcher {
      constructor(player, highWaterMark = 12, streams, fps) {
        super(player, highWaterMark, streams, fps, Util.getPayloadType("VP8"));
      }
      makeChunk(buffer, isFirstFrame) {
        const payloadDescriptorBuf = Buffer2.alloc(2);
        payloadDescriptorBuf[0] = isFirstFrame ? 144 : 128;
        payloadDescriptorBuf[1] = 128;
        const pictureIdBuf = Buffer2.alloc(2);
        pictureIdBuf.writeUintBE(this.count, 0, 2);
        pictureIdBuf[0] |= 128;
        return Buffer2.concat([payloadDescriptorBuf, pictureIdBuf, buffer]);
      }
      codecCallback(chunk) {
        const chunkSplit = this.partitionVideoData(chunk);
        for (let i = 0; i < chunkSplit.length; i++) {
          this._playChunk(
            Buffer2.concat([this.createPayloadExtension(), this.makeChunk(chunkSplit[i], i == 0)]),
            i + 1 === chunkSplit.length
          );
        }
      }
    };
    module2.exports = {
      VP8Dispatcher
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/voice/player/MediaPlayer.js
var require_MediaPlayer = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/voice/player/MediaPlayer.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require_events();
    var { Readable: ReadableStream2 } = require_stream();
    var prism = require_src();
    var { H264NalSplitter } = require_AnnexBNalSplitter();
    var { IvfTransformer } = require_IvfSplitter();
    var { H264Dispatcher } = require_AnnexBDispatcher();
    var AudioDispatcher = require_AudioDispatcher();
    var { VP8Dispatcher } = require_VPxDispatcher();
    var FFMPEG_OUTPUT_PREFIX = ["-use_wallclock_as_timestamps", "1", "-copyts", "-analyzeduration", "0"];
    var FFMPEG_INPUT_PREFIX = [
      "-reconnect",
      "1",
      "-reconnect_at_eof",
      "1",
      "-reconnect_streamed",
      "1",
      "-reconnect_delay_max",
      "4294"
    ];
    var FFMPEG_PCM_ARGUMENTS = ["-f", "s16le", "-ar", "48000", "-ac", "2"];
    var FFMPEG_VP8_ARGUMENTS = ["-f", "ivf", "-deadline", "realtime", "-c:v", "libvpx"];
    var FFMPEG_H264_ARGUMENTS = (options) => [
      "-c:v",
      "libx264",
      "-f",
      "h264",
      "-tune",
      "zerolatency",
      // '-pix_fmt',
      // 'yuv420p',
      "-preset",
      (options == null ? void 0 : options.presetH26x) || "faster",
      "-profile:v",
      "baseline",
      // '-g',
      // `${options?.fps}`,
      // '-x264-params',
      // `keyint=${options?.fps}:min-keyint=${options?.fps}`,
      "-bf",
      "0",
      "-bsf:v",
      "h264_metadata=aud=insert"
    ];
    var MediaPlayer = class extends EventEmitter {
      constructor(voiceConnection, isScreenSharing) {
        super();
        this.dispatcher = null;
        this.videoDispatcher = null;
        this.voiceConnection = voiceConnection;
        this.isScreenSharing = isScreenSharing;
      }
      destroy() {
        this.destroyDispatcher();
        this.destroyVideoDispatcher();
      }
      destroyDispatcher() {
        if (this.dispatcher) {
          this.dispatcher.destroy();
          this.dispatcher = null;
        }
      }
      destroyVideoDispatcher() {
        if (this.videoDispatcher) {
          this.videoDispatcher.destroy();
          this.videoDispatcher = null;
        }
      }
      playUnknown(input, options, streams = {}) {
        this.destroyDispatcher();
        const isStream = input instanceof ReadableStream2;
        const args = [...FFMPEG_OUTPUT_PREFIX, ...FFMPEG_PCM_ARGUMENTS];
        if (!isStream) args.unshift("-i", input);
        if (options.seek) args.unshift("-ss", String(options.seek));
        if (typeof input == "string" && input.startsWith("http")) {
          args.unshift(...FFMPEG_INPUT_PREFIX);
        }
        const ffmpeg = new prism.FFmpeg({ args });
        this.emit("debug", `[ffmpeg-audio_process] Spawn process with args:
${args.join(" ")}`);
        ffmpeg.process.stderr.on("data", (data) => {
          this.emit("debug", `[ffmpeg-audio_process]: ${data.toString()}`);
        });
        streams.ffmpeg = ffmpeg;
        if (isStream) {
          streams.input = input;
          input.pipe(ffmpeg);
        }
        return this.playPCMStream(ffmpeg, options, streams);
      }
      playPCMStream(stream, options, streams = {}) {
        this.destroyDispatcher();
        const opus = streams.opus = new prism.opus.Encoder({ channels: 2, rate: 48e3, frameSize: 960 });
        if (options && options.volume === false) {
          stream.pipe(opus);
          return this.playOpusStream(opus, options, streams);
        }
        streams.volume = new prism.VolumeTransformer({ type: "s16le", volume: options ? options.volume : 1 });
        stream.pipe(streams.volume).pipe(opus);
        return this.playOpusStream(opus, options, streams);
      }
      playOpusStream(stream, options, streams = {}) {
        this.destroyDispatcher();
        streams.opus = stream;
        if (options.volume !== false && !streams.input) {
          streams.input = stream;
          const decoder = new prism.opus.Decoder({ channels: 2, rate: 48e3, frameSize: 960 });
          streams.volume = new prism.VolumeTransformer({ type: "s16le", volume: options ? options.volume : 1 });
          streams.opus = stream.pipe(decoder).pipe(streams.volume).pipe(new prism.opus.Encoder({ channels: 2, rate: 48e3, frameSize: 960 }));
        }
        const dispatcher = this.createDispatcher(options, streams);
        streams.opus.pipe(dispatcher);
        return dispatcher;
      }
      playUnknownVideo(input, options = {}) {
        this.destroyVideoDispatcher();
        const isStream = input instanceof ReadableStream2;
        if (!(options == null ? void 0 : options.fps)) options.fps = 30;
        const args = [
          "-i",
          isStream ? "-" : input,
          ...FFMPEG_OUTPUT_PREFIX,
          "-flags",
          "low_delay",
          "-r",
          `${options == null ? void 0 : options.fps}`
        ];
        if ((options == null ? void 0 : options.bitrate) && typeof (options == null ? void 0 : options.bitrate) === "number") {
          args.push("-b:v", `${options == null ? void 0 : options.bitrate}K`);
        }
        if ((options == null ? void 0 : options.hwAccel) === true) {
          args.unshift("-hwaccel", "auto");
        }
        if (options.seek) args.unshift("-ss", String(options.seek));
        if (typeof input == "string" && input.startsWith("http")) {
          args.unshift(...FFMPEG_INPUT_PREFIX);
        }
        if (this.voiceConnection.videoCodec == "VP8") {
          args.push(...FFMPEG_VP8_ARGUMENTS);
        }
        if (this.voiceConnection.videoCodec == "H264") {
          args.push(...FFMPEG_H264_ARGUMENTS(options));
        }
        args.push("-force_key_frames", "00:02");
        if (options == null ? void 0 : options.inputFFmpegArgs) {
          args.unshift(...options.inputFFmpegArgs);
        }
        if (options == null ? void 0 : options.outputFFmpegArgs) {
          args.push(...options.outputFFmpegArgs);
        }
        const ffmpeg = new prism.FFmpeg({ args });
        const streams = { ffmpeg };
        if (isStream) {
          streams.input = input;
          input.pipe(ffmpeg);
        }
        this.emit("debug", `[ffmpeg-video_process] Spawn process with args:
${args.join(" ")}`);
        ffmpeg.process.stderr.on("data", (data) => {
          this.emit("debug", `[ffmpeg-video_process]: ${data.toString()}`);
        });
        switch (this.voiceConnection.videoCodec) {
          case "VP8": {
            return this.playIvfVideo(ffmpeg, options, streams);
          }
          case "H264": {
            return this.playAnnexBVideo(ffmpeg, options, streams, "H264");
          }
          default: {
            throw new Error("Invalid codec (Supported: VP8, H264)");
          }
        }
      }
      playIvfVideo(stream, options, streams) {
        this.destroyVideoDispatcher();
        const videoStream = new IvfTransformer();
        stream.pipe(videoStream);
        streams.video = videoStream;
        const dispatcher = this.createVideoDispatcher(options, streams);
        videoStream.pipe(dispatcher);
        return dispatcher;
      }
      // eslint-disable-next-line no-unused-vars
      playAnnexBVideo(stream, options, streams, type) {
        this.destroyVideoDispatcher();
        const videoStream = new H264NalSplitter();
        stream.pipe(videoStream);
        streams.video = videoStream;
        const dispatcher = this.createVideoDispatcher(options, streams);
        videoStream.pipe(dispatcher);
        return dispatcher;
      }
      createDispatcher(options, streams) {
        this.destroyDispatcher();
        const dispatcher = this.dispatcher = new AudioDispatcher(this, options, streams);
        return dispatcher;
      }
      /**
       * Create
       * @private
       * @param {Object} options any
       * @param {Object} streams any
       * @returns {VideoDispatcher}
       */
      createVideoDispatcher(options, streams) {
        this.destroyVideoDispatcher();
        switch (this.voiceConnection.videoCodec) {
          case "VP8": {
            const dispatcher = this.videoDispatcher = new VP8Dispatcher(
              this,
              options == null ? void 0 : options.highWaterMark,
              streams,
              options == null ? void 0 : options.fps
            );
            return dispatcher;
          }
          case "H264": {
            const dispatcher = this.videoDispatcher = new H264Dispatcher(
              this,
              options == null ? void 0 : options.highWaterMark,
              streams,
              options == null ? void 0 : options.fps
            );
            return dispatcher;
          }
          default: {
            throw new Error("Invalid codec");
          }
        }
      }
    };
    module2.exports = MediaPlayer;
  }
});

// browser-external:os
var require_os = __commonJS({
  "browser-external:os"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "os" has been externalized for browser compatibility. Cannot access "os.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:fs
var require_fs = __commonJS({
  "browser-external:fs"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "fs" has been externalized for browser compatibility. Cannot access "fs.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// ../../../node_modules/find-process/lib/utils.js
var require_utils2 = __commonJS({
  "../../../node_modules/find-process/lib/utils.js"(exports2, module2) {
    "use strict";
    var cp = require_child_process();
    var UNIT_MB = 1024 * 1024;
    var utils = {
      /**
       * exec command with maxBuffer size
       */
      exec(cmd, callback) {
        cp.exec(cmd, {
          maxBuffer: 2 * UNIT_MB,
          windowsHide: true
        }, callback);
      },
      /**
       * spawn command
       */
      spawn(cmd, args, options) {
        return cp.spawn(cmd, args, options);
      },
      /**
       * Strip top lines of text
       *
       * @param  {String} text
       * @param  {Number} num
       * @return {String}
       */
      stripLine(text, num) {
        let idx = 0;
        while (num-- > 0) {
          const nIdx = text.indexOf("\n", idx);
          if (nIdx >= 0) {
            idx = nIdx + 1;
          }
        }
        return idx > 0 ? text.substring(idx) : text;
      },
      /**
       * Split string and stop at max parts
       *
       * @param  {Number} line
       * @param  {Number} max
       * @return {Array}
       */
      split(line, max) {
        const cols = line.trim().split(/\s+/);
        if (cols.length > max) {
          cols[max - 1] = cols.slice(max - 1).join(" ");
        }
        return cols;
      },
      /**
       * Extract columns from table text
       *
       * Example:
       *
       * ```
       * extractColumns(text, [0, 2], 3)
       * ```
       *
       * From:
       * ```
       * foo       bar        bar2
       * valx      valy       valz
       * ```
       *
       * To:
       * ```
       * [ ['foo', 'bar2'], ['valx', 'valz'] ]
       * ```
       *
       * @param  {String} text  raw table text
       * @param  {Array} idxes  the column index list to extract
       * @param  {Number} max   max column number of table
       * @return {Array}
       */
      extractColumns(text, idxes, max) {
        const lines = text.split(/(\r\n|\n|\r)/);
        const columns = [];
        if (!max) {
          max = Math.max.apply(null, idxes) + 1;
        }
        lines.forEach((line) => {
          const cols = utils.split(line, max);
          const column = [];
          idxes.forEach((idx) => {
            column.push(cols[idx] || "");
          });
          columns.push(column);
        });
        return columns;
      },
      /**
       * parse table text to array
       *
       * From:
       * ```
       * Header1 : foo
       * Header2 : bar
       * Header3 : val
       *
       * Header1 : foo2
       * Header2 : bar2
       * Header3 : val2
       * ```
       *
       * To:
       * ```
       * [{ Header1: 'foo', Header2: 'bar', Header3: 'val' }, ...]
       * ```
       *
       * @param  {String} data raw table data
       * @return {Array}
       */
      parseTable(data) {
        const lines = data.split(/(\r\n\r\n|\r\n\n|\n\r\n|\n\n)/).filter((line) => {
          return line && line.trim().length > 0;
        }).map((e) => e.split(/(\r\n|\n|\r)/).filter((line) => line.trim().length > 0));
        lines.forEach((line) => {
          for (let index = 0; line[index]; ) {
            const entry = line[index];
            if (entry.startsWith(" ")) {
              line[index - 1] += entry.trimLeft();
              line.splice(index, 1);
            } else {
              index += 1;
            }
          }
        });
        return lines.map((line) => {
          const row = {};
          line.forEach((string) => {
            const splitterIndex = string.indexOf(":");
            const key = string.slice(0, splitterIndex).trim();
            row[key] = string.slice(splitterIndex + 1).trim();
          });
          return row;
        });
      }
    };
    module2.exports = utils;
  }
});

// ../../../node_modules/loglevel/lib/loglevel.js
var require_loglevel = __commonJS({
  "../../../node_modules/loglevel/lib/loglevel.js"(exports2, module2) {
    (function(root, definition) {
      "use strict";
      if (typeof define === "function" && define.amd) {
        define(definition);
      } else if (typeof module2 === "object" && module2.exports) {
        module2.exports = definition();
      } else {
        root.log = definition();
      }
    })(exports2, function() {
      "use strict";
      var noop = function() {
      };
      var undefinedType = "undefined";
      var isIE = typeof window !== undefinedType && typeof window.navigator !== undefinedType && /Trident\/|MSIE /.test(window.navigator.userAgent);
      var logMethods = [
        "trace",
        "debug",
        "info",
        "warn",
        "error"
      ];
      var _loggersByName = {};
      var defaultLogger = null;
      function bindMethod(obj, methodName) {
        var method = obj[methodName];
        if (typeof method.bind === "function") {
          return method.bind(obj);
        } else {
          try {
            return Function.prototype.bind.call(method, obj);
          } catch (e) {
            return function() {
              return Function.prototype.apply.apply(method, [obj, arguments]);
            };
          }
        }
      }
      function traceForIE() {
        if (console.log) {
          if (console.log.apply) {
            console.log.apply(console, arguments);
          } else {
            Function.prototype.apply.apply(console.log, [console, arguments]);
          }
        }
        if (console.trace) console.trace();
      }
      function realMethod(methodName) {
        if (methodName === "debug") {
          methodName = "log";
        }
        if (typeof console === undefinedType) {
          return false;
        } else if (methodName === "trace" && isIE) {
          return traceForIE;
        } else if (console[methodName] !== void 0) {
          return bindMethod(console, methodName);
        } else if (console.log !== void 0) {
          return bindMethod(console, "log");
        } else {
          return noop;
        }
      }
      function replaceLoggingMethods() {
        var level = this.getLevel();
        for (var i = 0; i < logMethods.length; i++) {
          var methodName = logMethods[i];
          this[methodName] = i < level ? noop : this.methodFactory(methodName, level, this.name);
        }
        this.log = this.debug;
        if (typeof console === undefinedType && level < this.levels.SILENT) {
          return "No console available for logging";
        }
      }
      function enableLoggingWhenConsoleArrives(methodName) {
        return function() {
          if (typeof console !== undefinedType) {
            replaceLoggingMethods.call(this);
            this[methodName].apply(this, arguments);
          }
        };
      }
      function defaultMethodFactory(methodName, _level, _loggerName) {
        return realMethod(methodName) || enableLoggingWhenConsoleArrives.apply(this, arguments);
      }
      function Logger(name, factory) {
        var self2 = this;
        var inheritedLevel;
        var defaultLevel;
        var userLevel;
        var storageKey = "loglevel";
        if (typeof name === "string") {
          storageKey += ":" + name;
        } else if (typeof name === "symbol") {
          storageKey = void 0;
        }
        function persistLevelIfPossible(levelNum) {
          var levelName = (logMethods[levelNum] || "silent").toUpperCase();
          if (typeof window === undefinedType || !storageKey) return;
          try {
            window.localStorage[storageKey] = levelName;
            return;
          } catch (ignore) {
          }
          try {
            window.document.cookie = encodeURIComponent(storageKey) + "=" + levelName + ";";
          } catch (ignore) {
          }
        }
        function getPersistedLevel() {
          var storedLevel;
          if (typeof window === undefinedType || !storageKey) return;
          try {
            storedLevel = window.localStorage[storageKey];
          } catch (ignore) {
          }
          if (typeof storedLevel === undefinedType) {
            try {
              var cookie = window.document.cookie;
              var cookieName = encodeURIComponent(storageKey);
              var location = cookie.indexOf(cookieName + "=");
              if (location !== -1) {
                storedLevel = /^([^;]+)/.exec(
                  cookie.slice(location + cookieName.length + 1)
                )[1];
              }
            } catch (ignore) {
            }
          }
          if (self2.levels[storedLevel] === void 0) {
            storedLevel = void 0;
          }
          return storedLevel;
        }
        function clearPersistedLevel() {
          if (typeof window === undefinedType || !storageKey) return;
          try {
            window.localStorage.removeItem(storageKey);
          } catch (ignore) {
          }
          try {
            window.document.cookie = encodeURIComponent(storageKey) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC";
          } catch (ignore) {
          }
        }
        function normalizeLevel(input) {
          var level = input;
          if (typeof level === "string" && self2.levels[level.toUpperCase()] !== void 0) {
            level = self2.levels[level.toUpperCase()];
          }
          if (typeof level === "number" && level >= 0 && level <= self2.levels.SILENT) {
            return level;
          } else {
            throw new TypeError("log.setLevel() called with invalid level: " + input);
          }
        }
        self2.name = name;
        self2.levels = {
          "TRACE": 0,
          "DEBUG": 1,
          "INFO": 2,
          "WARN": 3,
          "ERROR": 4,
          "SILENT": 5
        };
        self2.methodFactory = factory || defaultMethodFactory;
        self2.getLevel = function() {
          if (userLevel != null) {
            return userLevel;
          } else if (defaultLevel != null) {
            return defaultLevel;
          } else {
            return inheritedLevel;
          }
        };
        self2.setLevel = function(level, persist) {
          userLevel = normalizeLevel(level);
          if (persist !== false) {
            persistLevelIfPossible(userLevel);
          }
          return replaceLoggingMethods.call(self2);
        };
        self2.setDefaultLevel = function(level) {
          defaultLevel = normalizeLevel(level);
          if (!getPersistedLevel()) {
            self2.setLevel(level, false);
          }
        };
        self2.resetLevel = function() {
          userLevel = null;
          clearPersistedLevel();
          replaceLoggingMethods.call(self2);
        };
        self2.enableAll = function(persist) {
          self2.setLevel(self2.levels.TRACE, persist);
        };
        self2.disableAll = function(persist) {
          self2.setLevel(self2.levels.SILENT, persist);
        };
        self2.rebuild = function() {
          if (defaultLogger !== self2) {
            inheritedLevel = normalizeLevel(defaultLogger.getLevel());
          }
          replaceLoggingMethods.call(self2);
          if (defaultLogger === self2) {
            for (var childName in _loggersByName) {
              _loggersByName[childName].rebuild();
            }
          }
        };
        inheritedLevel = normalizeLevel(
          defaultLogger ? defaultLogger.getLevel() : "WARN"
        );
        var initialLevel = getPersistedLevel();
        if (initialLevel != null) {
          userLevel = normalizeLevel(initialLevel);
        }
        replaceLoggingMethods.call(self2);
      }
      defaultLogger = new Logger();
      defaultLogger.getLogger = function getLogger(name) {
        if (typeof name !== "symbol" && typeof name !== "string" || name === "") {
          throw new TypeError("You must supply a name when creating a logger.");
        }
        var logger = _loggersByName[name];
        if (!logger) {
          logger = _loggersByName[name] = new Logger(
            name,
            defaultLogger.methodFactory
          );
        }
        return logger;
      };
      var _log = typeof window !== undefinedType ? window.log : void 0;
      defaultLogger.noConflict = function() {
        if (typeof window !== undefinedType && window.log === defaultLogger) {
          window.log = _log;
        }
        return defaultLogger;
      };
      defaultLogger.getLoggers = function getLoggers() {
        return _loggersByName;
      };
      defaultLogger["default"] = defaultLogger;
      return defaultLogger;
    });
  }
});

// ../../../node_modules/find-process/lib/logger.js
var require_logger = __commonJS({
  "../../../node_modules/find-process/lib/logger.js"(exports2, module2) {
    "use strict";
    var log = require_loglevel();
    module2.exports = log;
  }
});

// ../../../node_modules/find-process/lib/find_pid.js
var require_find_pid = __commonJS({
  "../../../node_modules/find-process/lib/find_pid.js"(exports2, module2) {
    "use strict";
    var os = require_os();
    var fs = require_fs();
    var utils = require_utils2();
    var log = require_logger();
    var ensureDir = (path) => new Promise((resolve, reject) => {
      if (fs.existsSync(path)) {
        resolve();
      } else {
        fs.mkdir(path, (err) => {
          err ? reject(err) : resolve();
        });
      }
    });
    var finders = {
      darwin(port) {
        return new Promise((resolve, reject) => {
          utils.exec("netstat -anv -p TCP && netstat -anv -p UDP", function(err, stdout, stderr) {
            if (err) {
              reject(err);
            } else {
              err = stderr.toString().trim();
              if (err) {
                reject(err);
                return;
              }
              const data = utils.stripLine(stdout.toString(), 2);
              const found = utils.extractColumns(data, [0, 3, 8], 10).filter((row) => {
                return !!String(row[0]).match(/^(udp|tcp)/);
              }).find((row) => {
                const matches = String(row[1]).match(/\.(\d+)$/);
                if (matches && matches[1] === String(port)) {
                  return true;
                }
                return false;
              });
              if (found && found[2].length) {
                resolve(parseInt(found[2], 10));
              } else {
                reject(new Error(`pid of port (${port}) not found`));
              }
            }
          });
        });
      },
      freebsd: "darwin",
      sunos: "darwin",
      linux(port) {
        return new Promise((resolve, reject) => {
          const cmd = "netstat -tunlp";
          utils.exec(cmd, function(err, stdout, stderr) {
            if (err) {
              reject(err);
            } else {
              const warn = stderr.toString().trim();
              if (warn) {
                log.warn(warn);
              }
              const data = utils.stripLine(stdout.toString(), 2);
              const columns = utils.extractColumns(data, [3, 6], 7).find((column) => {
                const matches = String(column[0]).match(/:(\d+)$/);
                if (matches && matches[1] === String(port)) {
                  return true;
                }
                return false;
              });
              if (columns && columns[1]) {
                const pid = columns[1].split("/", 1)[0];
                if (pid.length) {
                  resolve(parseInt(pid, 10));
                } else {
                  reject(new Error(`pid of port (${port}) not found`));
                }
              } else {
                reject(new Error(`pid of port (${port}) not found`));
              }
            }
          });
        });
      },
      win32(port) {
        return new Promise((resolve, reject) => {
          utils.exec("netstat -ano", function(err, stdout, stderr) {
            if (err) {
              reject(err);
            } else {
              err = stderr.toString().trim();
              if (err) {
                reject(err);
                return;
              }
              const data = utils.stripLine(stdout.toString(), 4);
              const columns = utils.extractColumns(data, [1, 4], 5).find((column) => {
                const matches = String(column[0]).match(/:(\d+)$/);
                if (matches && matches[1] === String(port)) {
                  return true;
                }
                return false;
              });
              if (columns && columns[1].length && parseInt(columns[1], 10) > 0) {
                resolve(parseInt(columns[1], 10));
              } else {
                reject(new Error(`pid of port (${port}) not found`));
              }
            }
          });
        });
      },
      android(port) {
        return new Promise((resolve, reject) => {
          const dir = os.tmpdir() + "/.find-process";
          const file = dir + "/" + process.pid;
          const cmd = 'netstat -tunp >> "' + file + '"';
          ensureDir(dir).then(() => {
            utils.exec(cmd, () => {
              fs.readFile(file, "utf8", (err, data) => {
                fs.unlink(file, () => {
                });
                if (err) {
                  reject(err);
                } else {
                  data = utils.stripLine(data, 2);
                  const columns = utils.extractColumns(data, [3, 6], 7).find((column) => {
                    const matches = String(column[0]).match(/:(\d+)$/);
                    if (matches && matches[1] === String(port)) {
                      return true;
                    }
                    return false;
                  });
                  if (columns && columns[1]) {
                    const pid = columns[1].split("/", 1)[0];
                    if (pid.length) {
                      resolve(parseInt(pid, 10));
                    } else {
                      reject(new Error(`pid of port (${port}) not found`));
                    }
                  } else {
                    reject(new Error(`pid of port (${port}) not found`));
                  }
                }
              });
            });
          });
        });
      }
    };
    function findPidByPort(port) {
      const platform = process.platform;
      return new Promise((resolve, reject) => {
        if (!(platform in finders)) {
          return reject(new Error(`platform ${platform} is unsupported`));
        }
        let findPid = finders[platform];
        if (typeof findPid === "string") {
          findPid = finders[findPid];
        }
        findPid(port).then(resolve, reject);
      });
    }
    module2.exports = findPidByPort;
  }
});

// ../../../node_modules/find-process/lib/find_process.js
var require_find_process = __commonJS({
  "../../../node_modules/find-process/lib/find_process.js"(exports2, module2) {
    "use strict";
    var path = require_path();
    var utils = require_utils2();
    function matchName(text, name) {
      if (!name) {
        return true;
      }
      if (text && text.match) {
        return text.match(name);
      }
      return false;
    }
    function fetchBin(cmd) {
      const pieces = cmd.split(path.sep);
      const last = pieces[pieces.length - 1];
      if (last) {
        pieces[pieces.length - 1] = last.split(" ")[0];
      }
      const fixed = [];
      for (const part of pieces) {
        const optIdx = part.indexOf(" -");
        if (optIdx >= 0) {
          fixed.push(part.substring(0, optIdx).trim());
          break;
        } else if (part.endsWith(" ")) {
          fixed.push(part.trim());
          break;
        }
        fixed.push(part);
      }
      return fixed.join(path.sep);
    }
    function fetchName(fullpath) {
      if (process.platform === "darwin") {
        const idx = fullpath.indexOf(".app/");
        if (idx >= 0) {
          return path.basename(fullpath.substring(0, idx));
        }
      }
      return path.basename(fullpath);
    }
    var finders = {
      darwin(cond) {
        return new Promise((resolve, reject) => {
          let cmd;
          if ("pid" in cond) {
            cmd = `ps -p ${cond.pid} -ww -o pid,ppid,uid,gid,args`;
          } else {
            cmd = "ps ax -ww -o pid,ppid,uid,gid,args";
          }
          utils.exec(cmd, function(err, stdout, stderr) {
            if (err) {
              if ("pid" in cond) {
                resolve([]);
              } else {
                reject(err);
              }
            } else {
              err = stderr.toString().trim();
              if (err) {
                reject(err);
                return;
              }
              const data = utils.stripLine(stdout.toString(), 1);
              const columns = utils.extractColumns(data, [0, 1, 2, 3, 4], 5).filter((column) => {
                if (column[0] && cond.pid) {
                  return column[0] === String(cond.pid);
                } else if (column[4] && cond.name) {
                  return matchName(column[4], cond.name);
                } else {
                  return !!column[0];
                }
              });
              let list = columns.map((column) => {
                const cmd2 = String(column[4]);
                const bin = fetchBin(cmd2);
                return {
                  pid: parseInt(column[0], 10),
                  ppid: parseInt(column[1], 10),
                  uid: parseInt(column[2], 10),
                  gid: parseInt(column[3], 10),
                  name: fetchName(bin),
                  bin,
                  cmd: column[4]
                };
              });
              if (cond.config.strict && cond.name) {
                list = list.filter((item) => item.name === cond.name);
              }
              resolve(list);
            }
          });
        });
      },
      linux: "darwin",
      sunos: "darwin",
      freebsd: "darwin",
      win32(cond) {
        return new Promise((resolve, reject) => {
          const cmd = "[Console]::OutputEncoding = [System.Text.Encoding]::UTF8; Get-CimInstance -className win32_process | select Name,ProcessId,ParentProcessId,CommandLine,ExecutablePath";
          const lines = [];
          const proc = utils.spawn("powershell.exe", ["/c", cmd], { detached: false, windowsHide: true });
          proc.stdout.on("data", (data) => {
            lines.push(data.toString());
          });
          proc.on("error", (err) => {
            reject(new Error("Command '" + cmd + "' failed with reason: " + err.toString()));
          });
          proc.on("close", (code) => {
            if (code !== 0) {
              return reject(new Error("Command '" + cmd + "' terminated with code: " + code));
            }
            const list = utils.parseTable(lines.join("")).filter((row) => {
              if ("pid" in cond) {
                return row.ProcessId === String(cond.pid);
              } else if (cond.name) {
                const rowName = row.Name || "";
                if (cond.config.strict) {
                  return rowName === cond.name || rowName.endsWith(".exe") && rowName.slice(0, -4) === cond.name;
                } else {
                  return matchName(row.CommandLine || rowName, cond.name);
                }
              } else {
                return true;
              }
            }).map((row) => ({
              pid: parseInt(row.ProcessId, 10),
              ppid: parseInt(row.ParentProcessId, 10),
              // uid: void 0,
              // gid: void 0,
              bin: row.ExecutablePath,
              name: row.Name || "",
              cmd: row.CommandLine
            }));
            resolve(list);
          });
        });
      },
      android(cond) {
        return new Promise((resolve, reject) => {
          const cmd = "ps";
          utils.exec(cmd, function(err, stdout, stderr) {
            if (err) {
              if ("pid" in cond) {
                resolve([]);
              } else {
                reject(err);
              }
            } else {
              err = stderr.toString().trim();
              if (err) {
                reject(err);
                return;
              }
              const data = utils.stripLine(stdout.toString(), 1);
              const columns = utils.extractColumns(data, [0, 3], 4).filter((column) => {
                if (column[0] && cond.pid) {
                  return column[0] === String(cond.pid);
                } else if (column[1] && cond.name) {
                  return matchName(column[1], cond.name);
                } else {
                  return !!column[0];
                }
              });
              let list = columns.map((column) => {
                const cmd2 = String(column[1]);
                const bin = fetchBin(cmd2);
                return {
                  pid: parseInt(column[0], 10),
                  // ppid: void 0,
                  // uid: void 0,
                  // gid: void 0,
                  name: fetchName(bin),
                  bin,
                  cmd: cmd2
                };
              });
              if (cond.config.strict && cond.name) {
                list = list.filter((item) => item.name === cond.name);
              }
              resolve(list);
            }
          });
        });
      }
    };
    function findProcess(cond) {
      const platform = process.platform;
      return new Promise((resolve, reject) => {
        if (!(platform in finders)) {
          return reject(new Error(`platform ${platform} is unsupported`));
        }
        let find = finders[platform];
        if (typeof find === "string") {
          find = finders[find];
        }
        find(cond).then((result) => {
          if (cond.skipSelf) {
            const filteredResult = result.filter((item) => item.pid !== process.pid);
            resolve(filteredResult);
          } else {
            resolve(result);
          }
        }, reject);
      });
    }
    module2.exports = findProcess;
  }
});

// ../../../node_modules/find-process/lib/find.js
var require_find = __commonJS({
  "../../../node_modules/find-process/lib/find.js"(exports2, module2) {
    "use strict";
    var findPid = require_find_pid();
    var findProcess = require_find_process();
    var log = require_logger();
    var findBy = {
      port(port, config) {
        return findPid(port).then((pid) => {
          return findBy.pid(pid, config);
        }, () => {
          return [];
        });
      },
      pid(pid, config) {
        return findProcess({
          pid,
          config
        });
      },
      name(name, config) {
        return findProcess({
          name,
          config,
          skipSelf: true
        });
      }
    };
    function find(by, value, options) {
      const config = Object.assign({
        logLevel: "warn",
        strict: typeof options === "boolean" ? options : false
      }, options);
      log.setLevel(config.logLevel);
      return new Promise((resolve, reject) => {
        if (!(by in findBy)) {
          reject(new Error(`do not support find by "${by}"`));
        } else {
          const isNumber = /^\d+$/.test(value);
          if (by === "pid" && !isNumber) {
            reject(new Error("pid must be a number"));
          } else if (by === "port" && !isNumber) {
            reject(new Error("port must be a number"));
          } else {
            findBy[by](value, config).then(resolve, reject);
          }
        }
      });
    }
    module2.exports = find;
  }
});

// ../../../node_modules/find-process/index.js
var require_find_process2 = __commonJS({
  "../../../node_modules/find-process/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_find();
  }
});

// ../../../node_modules/tree-kill/index.js
var require_tree_kill = __commonJS({
  "../../../node_modules/tree-kill/index.js"(exports2, module2) {
    "use strict";
    var childProcess = require_child_process();
    var spawn = childProcess.spawn;
    var exec = childProcess.exec;
    module2.exports = function(pid, signal, callback) {
      if (typeof signal === "function" && callback === void 0) {
        callback = signal;
        signal = void 0;
      }
      pid = parseInt(pid);
      if (Number.isNaN(pid)) {
        if (callback) {
          return callback(new Error("pid must be a number"));
        } else {
          throw new Error("pid must be a number");
        }
      }
      var tree = {};
      var pidsToProcess = {};
      tree[pid] = [];
      pidsToProcess[pid] = 1;
      switch (process.platform) {
        case "win32":
          exec("taskkill /pid " + pid + " /T /F", callback);
          break;
        case "darwin":
          buildProcessTree(pid, tree, pidsToProcess, function(parentPid) {
            return spawn("pgrep", ["-P", parentPid]);
          }, function() {
            killAll(tree, signal, callback);
          });
          break;
        default:
          buildProcessTree(pid, tree, pidsToProcess, function(parentPid) {
            return spawn("ps", ["-o", "pid", "--no-headers", "--ppid", parentPid]);
          }, function() {
            killAll(tree, signal, callback);
          });
          break;
      }
    };
    function killAll(tree, signal, callback) {
      var killed = {};
      try {
        Object.keys(tree).forEach(function(pid) {
          tree[pid].forEach(function(pidpid) {
            if (!killed[pidpid]) {
              killPid(pidpid, signal);
              killed[pidpid] = 1;
            }
          });
          if (!killed[pid]) {
            killPid(pid, signal);
            killed[pid] = 1;
          }
        });
      } catch (err) {
        if (callback) {
          return callback(err);
        } else {
          throw err;
        }
      }
      if (callback) {
        return callback();
      }
    }
    function killPid(pid, signal) {
      try {
        process.kill(parseInt(pid, 10), signal);
      } catch (err) {
        if (err.code !== "ESRCH") throw err;
      }
    }
    function buildProcessTree(parentPid, tree, pidsToProcess, spawnChildProcessesList, cb) {
      var ps = spawnChildProcessesList(parentPid);
      var allData = "";
      ps.stdout.on("data", function(data) {
        var data = data.toString("ascii");
        allData += data;
      });
      var onClose = function(code) {
        delete pidsToProcess[parentPid];
        if (code != 0) {
          if (Object.keys(pidsToProcess).length == 0) {
            cb();
          }
          return;
        }
        allData.match(/\d+/g).forEach(function(pid) {
          pid = parseInt(pid, 10);
          tree[parentPid].push(pid);
          tree[pid] = [];
          pidsToProcess[pid] = 1;
          buildProcessTree(pid, tree, pidsToProcess, spawnChildProcessesList, cb);
        });
      };
      ps.on("close", onClose);
    }
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/voice/util/Socket.js
var require_Socket = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/voice/util/Socket.js"(exports2, module2) {
    "use strict";
    var fs = require_fs();
    var net = require_net();
    var path = require_path();
    var process2 = require_process();
    var counter = 0;
    var UnixStream = class {
      constructor(stream, onSocket) {
        if (process2.platform === "win32") {
          const pipePrefix = "\\\\.\\pipe\\";
          const pipeName = `node-webrtc.${++counter}.sock`;
          this.socketPath = path.join(pipePrefix, pipeName);
          this.url = this.socketPath;
        } else {
          this.socketPath = `./${++counter}.sock`;
          this.url = `unix:${this.socketPath}`;
        }
        try {
          fs.statSync(this.socketPath);
          fs.unlinkSync(this.socketPath);
        } catch (err) {
        }
        const server = net.createServer(onSocket);
        stream.on("finish", () => {
          server.close();
        });
        server.listen(this.socketPath);
      }
    };
    function StreamInput(stream) {
      return new UnixStream(stream, (socket) => stream.pipe(socket));
    }
    function StreamOutput(stream) {
      return new UnixStream(stream, (socket) => socket.pipe(stream));
    }
    module2.exports = { StreamOutput, StreamInput, UnixStream };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/voice/receiver/FFmpegHandler.js
var require_FFmpegHandler = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/voice/receiver/FFmpegHandler.js"(exports2, module2) {
    "use strict";
    var { spawn } = require_child_process();
    var { createSocket } = require_dgram();
    var { EventEmitter } = require_events();
    var { Buffer: Buffer2 } = require_node_buffer();
    var { Writable } = require_stream();
    var find = require_find_process2();
    var kill = require_tree_kill();
    var Util = require_Util();
    var { StreamOutput } = require_Socket();
    var FFmpegHandler = class extends EventEmitter {
      constructor(receiver, userId, codec, portUdp, output, isEnableAudio) {
        super();
        Object.defineProperty(this, "receiver", { value: receiver });
        this.userId = userId;
        this.isEnableAudio = isEnableAudio;
        this.codec = codec;
        this.portUdp = portUdp;
        const isStream = output instanceof Writable;
        if (isStream) {
          this.outputStream = StreamOutput(output);
        }
        this.output = output;
        const sdpData = Util.getSDPCodecName(portUdp, this.isEnableAudio);
        this.ready = false;
        const stream = spawn("ffmpeg", [
          "-reorder_queue_size",
          "50",
          "-err_detect",
          "ignore_err",
          "-flags2",
          "+export_mvs",
          "-fflags",
          "+genpts",
          "-fflags",
          "+discardcorrupt",
          "-use_wallclock_as_timestamps",
          "1",
          "-protocol_whitelist",
          "file,udp,rtp,pipe,fd",
          "-i",
          "-",
          // Read from stdin
          "-buffer_size",
          "1000000",
          "-max_delay",
          "500000",
          "-y",
          "-f",
          "matroska",
          isStream ? this.outputStream.url : output
        ]);
        this.stream = stream;
        this.stream.stdin.write(sdpData);
        this.stream.stdin.end();
        this.stream.stderr.once("data", (data) => {
          this.emit("debug", `stderr: ${data}`);
          this.ready = true;
          this.emit("ready");
        });
        this.socket = createSocket("udp4");
        this.socketAudio = createSocket("udp4");
      }
      /**
       * Send a payload to FFmpeg via UDP
       * @param {Buffer} payload The payload
       * @param {boolean} isAudio If the payload is audio
       * @param {*} callback Callback
       */
      sendPayloadToFFmpeg(payload, isAudio = false, callback = (e) => {
        if (e) {
          console.error("Error sending packet:", e);
        }
      }) {
        const message = Buffer2.from(payload);
        if (isAudio && !this.isEnableAudio) {
          return;
        }
        if (isAudio) {
          this.socketAudio.send(message, 0, message.length, this.portUdp + 2, "127.0.0.1", callback);
        } else {
          this.socket.send(message, 0, message.length, this.portUdp, "127.0.0.1", callback);
        }
      }
      destroy() {
        const ffmpegPid = this.stream.pid;
        const args = this.stream.spawnargs.slice(1).join(" ");
        find("name", "ffmpeg", true).then((list) => {
          let process2 = list.find((o) => o.pid === ffmpegPid || o.ppid === ffmpegPid || o.cmd.includes(args));
          if (process2) {
            kill(process2.pid);
            this.receiver.videoStreams.delete(this.userId);
            this.emit("closed");
          }
        });
      }
      /**
       * Emitted when the FFmpegHandler becomes ready to start working.
       * @event FFmpegHandler#ready
       */
      /**
       * Emitted when the FFmpegHandler is closed.
       * @event FFmpegHandler#closed
       */
    };
    module2.exports = FFmpegHandler;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/util/Speaking.js
var require_Speaking = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/util/Speaking.js"(exports2, module2) {
    "use strict";
    var BitField = require_BitField();
    var Speaking = class extends BitField {
    };
    Speaking.FLAGS = {
      SPEAKING: 1 << 0,
      SOUNDSHARE: 1 << 1,
      PRIORITY_SPEAKING: 1 << 2
    };
    module2.exports = Speaking;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/voice/receiver/PacketHandler.js
var require_PacketHandler = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/voice/receiver/PacketHandler.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require_events();
    var { Buffer: Buffer2 } = require_node_buffer();
    var crypto = require_node_crypto();
    var { setTimeout: setTimeout2 } = require_node_timers();
    var FFmpegHandler = require_FFmpegHandler();
    var Speaking = require_Speaking();
    var secretbox = require_Secretbox();
    var { SILENCE_FRAME } = require_Silence();
    var DISCORD_SPEAKING_DELAY = 250;
    var HEADER_EXTENSION_BYTE = Buffer2.from([190, 222]);
    var UNPADDED_NONCE_LENGTH = 4;
    var AUTH_TAG_LENGTH = 16;
    var Readable = class extends require_stream().Readable {
      _read() {
      }
      // eslint-disable-line no-empty-function
    };
    var PacketHandler = class extends EventEmitter {
      constructor(receiver) {
        super();
        this.receiver = receiver;
        this.streams = /* @__PURE__ */ new Map();
        this.videoStreams = /* @__PURE__ */ new Map();
        this.speakingTimeouts = /* @__PURE__ */ new Map();
      }
      getNonceBuffer() {
        return this.receiver.connection.authentication.mode === "aead_aes256_gcm_rtpsize" ? Buffer2.alloc(12) : Buffer2.alloc(24);
      }
      get connection() {
        return this.receiver.connection;
      }
      _stoppedSpeaking(userId) {
        const streamInfo = this.streams.get(userId);
        if (streamInfo && streamInfo.end === "silence") {
          this.streams.delete(userId);
          streamInfo.stream.push(null);
        }
      }
      makeStream(user, end) {
        if (this.streams.has(user)) return this.streams.get(user).stream;
        const stream = new Readable();
        stream.on("end", () => this.streams.delete(user));
        this.streams.set(user, { stream, end });
        return stream;
      }
      makeVideoStream(user, portUdp, codec, output, isEnableAudio = false) {
        if (this.videoStreams.has(user)) return this.videoStreams.get(user);
        const stream = new FFmpegHandler(this, user, codec, portUdp, output, isEnableAudio);
        stream.on("ready", () => {
          this.videoStreams.set(user, stream);
        });
        return stream;
      }
      parseBuffer(buffer, shouldReturnTuple = false) {
        const { secret_key, mode } = this.receiver.connection.authentication;
        if (!secret_key) return new Error("secret_key cannot be null or undefined");
        const nonce = this.getNonceBuffer();
        buffer.copy(nonce, 0, buffer.length - UNPADDED_NONCE_LENGTH);
        let headerSize = 12;
        const first = buffer.readUint8();
        if (first >> 4 & 1) headerSize += 4;
        const header = buffer.slice(0, headerSize);
        const encrypted = buffer.slice(headerSize, buffer.length - AUTH_TAG_LENGTH - UNPADDED_NONCE_LENGTH);
        const authTag = buffer.slice(
          buffer.length - AUTH_TAG_LENGTH - UNPADDED_NONCE_LENGTH,
          buffer.length - UNPADDED_NONCE_LENGTH
        );
        let packet;
        switch (mode) {
          case "aead_aes256_gcm_rtpsize": {
            const decipheriv = crypto.createDecipheriv("aes-256-gcm", secret_key, nonce);
            decipheriv.setAAD(header);
            decipheriv.setAuthTag(authTag);
            packet = Buffer2.concat([decipheriv.update(encrypted), decipheriv.final()]);
            break;
          }
          case "aead_xchacha20_poly1305_rtpsize": {
            packet = secretbox.methods.crypto_aead_xchacha20poly1305_ietf_decrypt(
              Buffer2.concat([encrypted, authTag]),
              header,
              nonce,
              secret_key
            );
            packet = Buffer2.from(packet);
            break;
          }
          default: {
            return new RangeError(`Unsupported decryption method: ${mode}`);
          }
        }
        if (shouldReturnTuple) {
          return [header, packet];
        }
        if (buffer.slice(12, 14).compare(HEADER_EXTENSION_BYTE) === 0) {
          const headerExtensionLength = buffer.slice(14).readUInt16BE();
          packet = packet.subarray(4 * headerExtensionLength);
        }
        return packet;
      }
      audioReceiver(buffer) {
        const ssrc = buffer.readUInt32BE(8);
        const userStat = this.connection.ssrcMap.get(ssrc);
        if (!userStat) return;
        let opusPacket;
        const streamInfo = this.streams.get(userStat.userId);
        if (userStat.hasVideo) {
          opusPacket = this.parseBuffer(buffer);
          if (opusPacket instanceof Error) {
            if (streamInfo) {
              this.emit("error", opusPacket);
            }
            return;
          }
          if (SILENCE_FRAME.equals(opusPacket)) {
            return;
          }
        }
        let speakingTimeout = this.speakingTimeouts.get(ssrc);
        if (typeof speakingTimeout === "undefined") {
          if (userStat.speaking === 0) {
            userStat.speaking = Speaking.FLAGS.SPEAKING;
          }
          this.connection.onSpeaking({ user_id: userStat.userId, ssrc, speaking: userStat.speaking });
          speakingTimeout = setTimeout2(() => {
            try {
              this.connection.onSpeaking({ user_id: userStat.userId, ssrc, speaking: 0 });
              clearTimeout(speakingTimeout);
              this.speakingTimeouts.delete(ssrc);
            } catch {
            }
          }, DISCORD_SPEAKING_DELAY).unref();
          this.speakingTimeouts.set(ssrc, speakingTimeout);
        } else {
          speakingTimeout.refresh();
        }
        if (streamInfo) {
          const { stream } = streamInfo;
          if (!opusPacket) {
            opusPacket = this.parseBuffer(buffer);
            if (opusPacket instanceof Error) {
              this.emit("error", opusPacket);
              return;
            }
          }
          stream.push(opusPacket);
        }
      }
      audioReceiverForStream(buffer) {
        const ssrc = buffer.readUInt32BE(8);
        const userStat = this.connection.ssrcMap.get(ssrc);
        if (!userStat) return;
        const streamInfo = this.videoStreams.get(userStat.userId);
        if (!streamInfo) return;
        const packet = this.parseBuffer(buffer, true);
        if (packet instanceof Error) {
          return;
        }
        if (streamInfo.isEnableAudio) {
          streamInfo.sendPayloadToFFmpeg(Buffer2.concat(packet), true);
        }
      }
      videoReceiver(buffer) {
        const ssrc = buffer.readUInt32BE(8);
        const userStat = this.connection.ssrcMap.get(ssrc - 1);
        if (!userStat) return;
        const streamInfo = this.videoStreams.get(userStat.userId);
        if (userStat.hasVideo) {
          const packet = this.parseBuffer(buffer, true);
          if (packet instanceof Error) {
            return;
          }
          let [header, videoPacket] = packet;
          if (SILENCE_FRAME.equals(videoPacket)) {
            return;
          }
          this.receiver.emit("videoData", ssrc - 1, userStat, header, videoPacket);
          if (streamInfo) {
            streamInfo.sendPayloadToFFmpeg(Buffer2.concat(packet));
          }
        }
      }
      push(buffer) {
        this.audioReceiver(buffer);
        this.videoReceiver(buffer);
        this.audioReceiverForStream(buffer);
      }
      // When udp connection is closed (STREAM_DELETE), destroy all streams (Memory leak)
      destroyAllStream() {
        for (const stream of this.streams.values()) {
          stream.stream.destroy();
        }
        this.streams.clear();
        for (const stream of this.videoStreams.values()) {
          stream.destroy();
        }
        this.videoStreams.clear();
      }
    };
    module2.exports = PacketHandler;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/voice/receiver/Receiver.js
var require_Receiver = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/voice/receiver/Receiver.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require_events();
    var prism = require_src();
    var PacketHandler = require_PacketHandler();
    var { Error: Error2 } = require_errors2();
    var VoiceReceiver = class extends EventEmitter {
      constructor(connection) {
        super();
        this.connection = connection;
        this.packets = new PacketHandler(this);
        this.packets.on("error", (err) => this.emit("debug", err));
      }
      /**
       * Options passed to `VoiceReceiver#createStream`.
       * @typedef {Object} ReceiveStreamOptions
       * @property {string} [mode='opus'] The mode for audio output. This defaults to opus, meaning discord.js won't decode
       * the packets for you. You can set this to 'pcm' so that the stream's output will be 16-bit little-endian stereo
       * audio
       * @property {string} [end='silence'] When the stream should be destroyed. If `silence`, this will be when the user
       * stops talking. Otherwise, if `manual`, this should be handled by you.
       */
      /**
       * Creates a new audio receiving stream. If a stream already exists for a user, then that stream will be returned
       * rather than generating a new one.
       * @param {UserResolvable} user The user to start listening to.
       * @param {ReceiveStreamOptions} options Options.
       * @returns {ReadableStream}
       */
      createStream(user, { mode = "opus", end = "silence" } = {}) {
        user = this.connection.client.users.resolve(user);
        if (!user) throw new Error2("VOICE_USER_MISSING");
        const stream = this.packets.makeStream(user.id, end);
        if (mode === "pcm") {
          const decoder = new prism.opus.Decoder({ channels: 2, rate: 48e3, frameSize: 960 });
          stream.pipe(decoder);
          return decoder;
        }
        return stream;
      }
      /**
       * Options passed to `VoiceReceiver#createVideoStream`.
       * @typedef {Object} ReceiveVideoStreamOptions
       * @property {number} portUdp The UDP port to use for the video stream (local stream).
       * @property {WritableStream|string} output Output stream or file path to write the video stream to.
       * @property {boolean} [isEnableAudio=false] Enable audio for the video stream.
       * <info>If you intend to record the stream with audio, make sure that `portUdp` and `portUdp + 2` are not in use.</info>
       */
      /**
       * Creates a new video receiving stream. If a stream already exists for a user, then that stream will be returned
       * rather than generating a new one.
       * <info>Proof of concept - Requires a very good internet connection</info>
       * @param {UserResolvable} user The user to start listening to.
       * @param {ReceiveVideoStreamOptions} options Options.
       * @returns {FFmpegHandler} The video stream for the specified user.
       */
      createVideoStream(user, { portUdp, output, isEnableAudio = false } = {}) {
        user = this.connection.client.users.resolve(user);
        if (!user) throw new Error2("VOICE_USER_MISSING");
        const stream = this.packets.makeVideoStream(user.id, portUdp, "H264", output, isEnableAudio);
        return stream;
      }
      /**
       * Emitted whenever there is a video data (Raw)
       * @event VoiceReceiver#videoData
       * @param {number} ssrc SSRC
       * @param {{ userId: Snowflake, hasVideo: boolean }} ssrcData SSRC Data
       * @param {Buffer} header The unencrypted RTP header contains 12 bytes, Buffer<0xbe, 0xde> and the extension size
       * @param {Buffer} packetDecrypt Decrypted contains the extension, if any, the video packet
       */
    };
    module2.exports = VoiceReceiver;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/voice/util/Function.js
var require_Function = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/voice/util/Function.js"(exports2, module2) {
    "use strict";
    function parseStreamKey(key) {
      const Arr = key.split(":");
      const type = Arr[0];
      const guildId = type == "guild" ? Arr[1] : null;
      const channelId = type == "guild" ? Arr[2] : Arr[1];
      const userId = type == "guild" ? Arr[3] : Arr[2];
      return { type, guildId, channelId, userId };
    }
    module2.exports = {
      parseStreamKey
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/voice/util/PlayInterface.js
var require_PlayInterface = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/voice/util/PlayInterface.js"(exports2, module2) {
    "use strict";
    var { Readable } = require_stream();
    var prism = require_src();
    var { Error: Error2 } = require_errors2();
    var PlayInterface = class _PlayInterface {
      constructor(player) {
        this.player = player;
      }
      /**
       * Play an audio resource.
       * @param {ReadableStream|string} resource The resource to play.
       * @param {StreamOptions} [options] The options to play.
       * @example
       * // Play a local audio file
       * connection.playAudio('/home/hydrabolt/audio.mp3', { volume: 0.5 });
       * @example
       * // Play a ReadableStream
       * connection.playAudio(ytdl('https://www.youtube.com/watch?v=ZlAU_w7-Xp8', { quality: 'highestaudio' }));
       * @example
       * // Using different protocols: https://ffmpeg.org/ffmpeg-protocols.html
       * connection.playAudio('http://www.sample-videos.com/audio/mp3/wave.mp3');
       * @returns {AudioDispatcher}
       */
      playAudio(resource, options = {}) {
        if (resource instanceof Readable || typeof resource === "string") {
          const type = options.type || "unknown";
          if (type === "unknown") {
            return this.player.playUnknown(resource, options);
          } else if (type === "converted") {
            return this.player.playPCMStream(resource, options);
          } else if (type === "opus") {
            return this.player.playOpusStream(resource, options);
          } else if (type === "ogg/opus") {
            if (!(resource instanceof Readable)) throw new Error2("VOICE_PRISM_DEMUXERS_NEED_STREAM");
            return this.player.playOpusStream(resource.pipe(new prism.opus.OggDemuxer()), options);
          } else if (type === "webm/opus") {
            if (!(resource instanceof Readable)) throw new Error2("VOICE_PRISM_DEMUXERS_NEED_STREAM");
            return this.player.playOpusStream(resource.pipe(new prism.opus.WebmDemuxer()), options);
          }
        }
        throw new Error2("VOICE_PLAY_INTERFACE_BAD_TYPE");
      }
      /**
       * Options that can be passed to stream-playing methods:
       * @typedef {Object} VideoOptions
       * @property {number} [seek=0] The time to seek to
       * @property {number} [fps] Video fps
       * @property {number} [highWaterMark=12] The maximum number of opus packets to make and store before they are
       * actually needed. See https://nodejs.org/en/docs/guides/backpressuring-in-streams/. Setting this value to
       * 1 means that changes in volume will be more instant.
       * @property {'ultrafast' | 'superfast' | 'veryfast' | 'faster' | 'fast' | 'medium' | 'slow' | 'slower' | 'veryslow'} [presetH26x='veryfast'] ffmpeg preset h264
       * @property {boolean} [hwAccel=false]  Enables hardware accelerated video decoding. Enabling this option might result in an exception
       * being thrown by Ffmpeg process if your system does not support hardware acceleration
       * @property {string[]} [inputFFmpegArgs] input ffmpeg
       * Ex: ['-config1', 'value1', '-config2', 'value2']
       * @property {string[]} [outputFFmpegArgs] output ffmpeg
       * Ex: ['-config1', 'value1', '-config2', 'value2']
       * @property {number|'auto'} [bitrate=2000] The bitrate (quality) of the video in kbps.
       * If set to 'auto', ffmpeg will automatically select
       */
      /**
       * Play a video resource.
       * @param {ReadableStream|string} resource The resource to play.
       * @param {VideoOptions} [options] The options to play.
       * @example
       * // Play a local video file
       * connection.playVideo('/home/hydrabolt/video.mp4');
       * @example
       * // Using different protocols: https://ffmpeg.org/ffmpeg-protocols.html
       * connection.playVideo('http://www.sample-videos.com/video/mp4/wave.mp4');
       * @returns {VideoDispatcher}
       */
      playVideo(resource, options = {}) {
        if (resource instanceof Readable || typeof resource === "string") {
          return this.player.playUnknownVideo(resource, options);
        }
        throw new Error2("VOICE_PLAY_INTERFACE_BAD_TYPE");
      }
      static applyToClass(structure) {
        for (const prop of ["playAudio", "playVideo"]) {
          Object.defineProperty(structure.prototype, prop, Object.getOwnPropertyDescriptor(_PlayInterface.prototype, prop));
        }
      }
    };
    module2.exports = PlayInterface;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/voice/VoiceConnection.js
var require_VoiceConnection = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/voice/VoiceConnection.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require_events();
    var { getCiphers } = require_node_crypto();
    var { setTimeout: setTimeout2 } = require_node_timers();
    var { Collection: Collection2 } = require_dist();
    var VoiceUDP = require_VoiceUDPClient();
    var VoiceWebSocket = require_VoiceWebSocket();
    var MediaPlayer = require_MediaPlayer();
    var VoiceReceiver = require_Receiver();
    var { parseStreamKey } = require_Function();
    var PlayInterface = require_PlayInterface();
    var Silence = require_Silence();
    var { Error: Error2 } = require_errors2();
    var { Opcodes, VoiceOpcodes, VoiceStatus, Events: Events2 } = require_Constants();
    var Speaking = require_Speaking();
    var Util = require_Util();
    var SingleSilence = class extends Silence {
      _read() {
        super._read();
        this.push(null);
      }
    };
    var SUPPORTED_MODES = ["aead_xchacha20_poly1305_rtpsize"];
    if (getCiphers().includes("aes-256-gcm")) {
      SUPPORTED_MODES.unshift("aead_aes256_gcm_rtpsize");
    }
    var SUPPORTED_CODECS = ["VP8", "H264"];
    var VoiceConnection = class extends EventEmitter {
      constructor(voiceManager, channel) {
        super();
        this.voiceManager = voiceManager;
        this.channel = channel;
        this.status = VoiceStatus.AUTHENTICATING;
        this.speaking = new Speaking().freeze();
        this.videoStatus = false;
        this.authentication = {};
        this.player = new MediaPlayer(this, this.constructor.name === "StreamConnection");
        this.player.on("debug", (m) => {
          this.emit("debug", `audio player - ${m}`);
        });
        this.player.on("error", (e) => {
          this.emit("warn", e);
        });
        this.once("closing", () => this.player.destroy());
        this.ssrcMap = /* @__PURE__ */ new Map();
        this._speaking = /* @__PURE__ */ new Map();
        this.sockets = {};
        this.receiver = new VoiceReceiver(this);
        this.videoCodec = "H264";
        this.streamConnection = null;
        this.streamWatchConnection = new Collection2();
      }
      /**
       * The client that instantiated this connection
       * @type {Client}
       * @readonly
       */
      get client() {
        return this.voiceManager.client;
      }
      /**
       * The current audio dispatcher (if any)
       * @type {?AudioDispatcher}
       * @readonly
       */
      get dispatcher() {
        return this.player.dispatcher;
      }
      /**
       * The current video dispatcher (if any)
       * @type {?VideoDispatcher}
       * @readonly
       */
      get videoDispatcher() {
        return this.player.videoDispatcher;
      }
      /**
       * Sets whether the voice connection should display as "speaking", "soundshare" or "none".
       * @param {BitFieldResolvable} value The new speaking state
       */
      setSpeaking(value) {
        if (this.speaking.equals(value)) return;
        if (this.status !== VoiceStatus.CONNECTED) return;
        this.speaking = new Speaking(value).freeze();
        this.sockets.ws.sendPacket({
          op: VoiceOpcodes.SPEAKING,
          d: {
            speaking: this.speaking.bitfield,
            delay: 0,
            ssrc: this.authentication.ssrc
          }
        }).catch((e) => {
          this.emit("debug", e);
        });
      }
      /**
       * Set video codec before select protocol
       * @param {VideoCodec} value Codec
       * @returns {VoiceConnection}
       */
      setVideoCodec(value) {
        if (!SUPPORTED_CODECS.includes(value)) throw new Error2("INVALID_VIDEO_CODEC", SUPPORTED_CODECS);
        this.videoCodec = value;
        return this;
      }
      /**
       * Sets video status
       * @param {boolean} value Video on or off
       */
      setVideoStatus(value) {
        if (this.status !== VoiceStatus.CONNECTED) return;
        if (value === this.videoStatus) return;
        this.videoStatus = value;
        this.sockets.ws.sendPacket({
          op: VoiceOpcodes.SOURCES,
          d: {
            audio_ssrc: this.authentication.ssrc,
            video_ssrc: value ? this.authentication.ssrc + 1 : 0,
            rtx_ssrc: value ? this.authentication.ssrc + 2 : 0,
            streams: [
              {
                type: "video",
                rid: "100",
                ssrc: value ? this.authentication.ssrc + 1 : 0,
                active: true,
                quality: 100,
                rtx_ssrc: value ? this.authentication.ssrc + 2 : 0,
                max_bitrate: 8e6,
                max_framerate: 60,
                max_resolution: {
                  type: "source",
                  width: 0,
                  height: 0
                }
              }
            ]
          }
        }).catch((e) => {
          this.emit("debug", e);
        });
      }
      /**
       * The voice state of this connection
       * @type {?VoiceState}
       */
      get voice() {
        return this.client.user.voice;
      }
      /**
       * Sends a request to the main gateway to join a voice channel.
       * @param {Object} [options] The options to provide
       * @returns {Promise<Shard>}
       * @private
       */
      sendVoiceStateUpdate(options = {}) {
        var _a;
        options = Util.mergeDefault(
          {
            guild_id: ((_a = this.channel.guild) == null ? void 0 : _a.id) || null,
            channel_id: this.channel.id,
            self_mute: this.voice ? this.voice.selfMute : false,
            self_deaf: this.voice ? this.voice.selfDeaf : false,
            self_video: this.voice ? this.voice.selfVideo : false,
            flags: 2
          },
          options
        );
        this.emit("debug", `Sending voice state update: ${JSON.stringify(options)}`);
        return this.channel.client.ws.broadcast({
          op: Opcodes.VOICE_STATE_UPDATE,
          d: options
        });
      }
      /**
       * Set the token and endpoint required to connect to the voice servers.
       * @param {string} token The voice token
       * @param {string} endpoint The voice endpoint
       * @returns {void}
       * @private
       */
      setTokenAndEndpoint(token, endpoint) {
        this.emit("debug", `Token "${token}" and endpoint "${endpoint}"`);
        if (!endpoint) {
          return;
        }
        if (!token) {
          this.authenticateFailed("VOICE_TOKEN_ABSENT");
          return;
        }
        endpoint = endpoint.match(/([^:]*)/)[0];
        this.emit("debug", `Endpoint resolved as ${endpoint}`);
        if (!endpoint) {
          this.authenticateFailed("VOICE_INVALID_ENDPOINT");
          return;
        }
        if (this.status === VoiceStatus.AUTHENTICATING) {
          this.authentication.token = token;
          this.authentication.endpoint = endpoint;
          this.checkAuthenticated();
        } else if (token !== this.authentication.token || endpoint !== this.authentication.endpoint) {
          this.reconnect(token, endpoint);
        }
      }
      /**
       * Sets the Session ID for the connection.
       * @param {string} sessionId The voice session ID
       * @private
       */
      setSessionId(sessionId) {
        this.emit("debug", `Setting sessionId ${sessionId} (stored as "${this.authentication.sessionId}")`);
        if (!sessionId) {
          this.authenticateFailed("VOICE_SESSION_ABSENT");
          return;
        }
        if (this.status === VoiceStatus.AUTHENTICATING) {
          this.authentication.sessionId = sessionId;
          this.checkAuthenticated();
        } else if (sessionId !== this.authentication.sessionId) {
          this.authentication.sessionId = sessionId;
          this.emit("newSession", sessionId);
        }
      }
      /**
       * Checks whether the voice connection is authenticated.
       * @private
       */
      checkAuthenticated() {
        const { token, endpoint, sessionId } = this.authentication;
        this.emit("debug", `Authenticated with sessionId ${sessionId}`);
        if (token && endpoint && sessionId) {
          this.status = VoiceStatus.CONNECTING;
          this.emit("authenticated");
          this.connect();
        }
      }
      /**
       * Invoked when we fail to initiate a voice connection.
       * @param {string} reason The reason for failure
       * @private
       */
      authenticateFailed(reason) {
        clearTimeout(this.connectTimeout);
        this.emit("debug", `Authenticate failed - ${reason}`);
        if (this.status === VoiceStatus.AUTHENTICATING) {
          this.emit("failed", new Error2(reason));
        } else {
          this.emit("error", new Error2(reason));
        }
        this.status = VoiceStatus.DISCONNECTED;
      }
      /**
       * Move to a different voice channel in the same guild.
       * @param {VoiceChannel} channel The channel to move to
       * @private
       */
      updateChannel(channel) {
        this.channel = channel;
        this.sendVoiceStateUpdate();
      }
      /**
       * Attempts to authenticate to the voice server.
       * @param {Object} options Join config
       * @private
       */
      authenticate(options = {}) {
        this.sendVoiceStateUpdate(options);
        this.connectTimeout = setTimeout2(() => this.authenticateFailed("VOICE_CONNECTION_TIMEOUT"), 15e3).unref();
      }
      /**
       * Attempts to reconnect to the voice server (typically after a region change).
       * @param {string} token The voice token
       * @param {string} endpoint The voice endpoint
       * @private
       */
      reconnect(token, endpoint) {
        this.authentication.token = token;
        this.authentication.endpoint = endpoint;
        this.speaking = new Speaking().freeze();
        this.status = VoiceStatus.RECONNECTING;
        this.emit("debug", `Reconnecting to ${endpoint}`);
        this.emit("reconnecting");
        this.connect();
      }
      /**
       * Disconnects the voice connection, causing a disconnect and closing event to be emitted.
       */
      disconnect() {
        this.emit("closing");
        this.emit("debug", "disconnect() triggered");
        clearTimeout(this.connectTimeout);
        const conn = this.voiceManager.connection;
        if (conn === this) this.voiceManager.connection = null;
        this.sendVoiceStateUpdate({
          channel_id: null
        });
        this._disconnect();
      }
      /**
       * Internally disconnects (doesn't send disconnect packet).
       * @private
       */
      _disconnect() {
        this.cleanup();
        this.status = VoiceStatus.DISCONNECTED;
        this.emit("disconnect");
      }
      /**
       * Cleans up after disconnect.
       * @private
       */
      cleanup() {
        this.player.destroy();
        this.speaking = new Speaking().freeze();
        const { ws, udp } = this.sockets;
        this.emit("debug", "Connection clean up");
        if (ws) {
          ws.removeAllListeners("error");
          ws.removeAllListeners("ready");
          ws.removeAllListeners("sessionDescription");
          ws.removeAllListeners("speaking");
          ws.shutdown();
        }
        if (udp) udp.removeAllListeners("error");
        this.sockets.ws = null;
        this.sockets.udp = null;
      }
      /**
       * Connect the voice connection.
       * @private
       */
      connect() {
        this.emit("debug", `Connect triggered`);
        if (this.status !== VoiceStatus.RECONNECTING) {
          if (this.sockets.ws) throw new Error2("WS_CONNECTION_EXISTS");
          if (this.sockets.udp) throw new Error2("UDP_CONNECTION_EXISTS");
        }
        if (this.sockets.ws) this.sockets.ws.shutdown();
        if (this.sockets.udp) this.sockets.udp.shutdown();
        this.sockets.ws = new VoiceWebSocket(this);
        this.sockets.udp = new VoiceUDP(this);
        const { ws, udp } = this.sockets;
        ws.on("debug", (msg) => this.emit("debug", msg));
        udp.on("debug", (msg) => this.emit("debug", msg));
        ws.on("error", (err) => this.emit("error", err));
        udp.on("error", (err) => this.emit("error", err));
        ws.on("ready", this.onReady.bind(this));
        ws.on("sessionDescription", this.onSessionDescription.bind(this));
        ws.on("startSpeaking", this.onStartSpeaking.bind(this));
        ws.on("startStreaming", this.onStartStreaming.bind(this));
        this.sockets.ws.connect();
      }
      /**
       * Invoked when the voice websocket is ready.
       * @param {Object} data The received data
       * @private
       */
      onReady(data) {
        Object.assign(this.authentication, data);
        for (let mode of data.modes) {
          if (SUPPORTED_MODES.includes(mode)) {
            this.authentication.mode = mode;
            this.emit("debug", `Selecting the ${mode} mode`);
            break;
          }
        }
        this.sockets.udp.createUDPSocket(data.ip);
      }
      /**
       * Invoked when a session description is received.
       * @param {Object} data The received data
       * @private
       */
      onSessionDescription(data) {
        Object.assign(this.authentication, data);
        this.status = VoiceStatus.CONNECTED;
        const ready = () => {
          clearTimeout(this.connectTimeout);
          this.emit("debug", `Ready with authentication details: ${JSON.stringify(this.authentication)}`);
          this.emit("ready");
        };
        if (this.dispatcher || this.videoDispatcher) {
          ready();
        } else {
          const dispatcher = this.playAudio(new SingleSilence(), { type: "opus", volume: false });
          dispatcher.once("finish", ready);
        }
      }
      onStartSpeaking({ user_id, ssrc, speaking }) {
        this.ssrcMap.set(+ssrc, {
          ...this.ssrcMap.get(+ssrc) || {},
          userId: user_id,
          speaking
        });
      }
      onStartStreaming({ video_ssrc, user_id, audio_ssrc }) {
        this.ssrcMap.set(+audio_ssrc, {
          ...this.ssrcMap.get(+audio_ssrc) || {},
          userId: user_id,
          hasVideo: Boolean(video_ssrc)
          // Maybe ?
        });
      }
      /**
       * Invoked when a speaking event is received.
       * @param {Object} data The received data
       * @private
       */
      onSpeaking({ user_id, speaking }) {
        speaking = new Speaking(speaking).freeze();
        const guild = this.channel.guild;
        const user = this.client.users.cache.get(user_id);
        const old = this._speaking.get(user_id) || new Speaking(0).freeze();
        this._speaking.set(user_id, speaking);
        if (this.status === VoiceStatus.CONNECTED) {
          this.emit("speaking", user, speaking);
          if (!speaking.has(Speaking.FLAGS.SPEAKING)) {
            this.receiver.packets._stoppedSpeaking(user_id);
          }
        }
        if (guild && user && !speaking.equals(old)) {
          const member = guild.members.cache.get(user);
          if (member) {
            this.client.emit(Events2.GUILD_MEMBER_SPEAKING, member, speaking);
          }
        }
      }
      playAudio() {
      }
      // eslint-disable-line no-empty-function
      playVideo() {
      }
      // eslint-disable-line no-empty-function
      /**
       * Create new connection to screenshare stream
       * @returns {Promise<StreamConnection>}
       */
      createStreamConnection() {
        return new Promise((resolve, reject) => {
          if (this.streamConnection) {
            return resolve(this.streamConnection);
          } else {
            const connection = this.streamConnection = new StreamConnection(this.voiceManager, this.channel, this);
            connection.setVideoCodec(this.videoCodec);
            if (!this.eventHook) {
              this.eventHook = true;
              this.channel.client.on("raw", (packet) => {
                var _a;
                if (typeof packet !== "object" || !packet.t || !packet.d || !((_a = packet.d) == null ? void 0 : _a.stream_key)) {
                  return;
                }
                const { t: event, d: data } = packet;
                const StreamKey = parseStreamKey(data.stream_key);
                if (StreamKey.userId === this.channel.client.user.id && this.channel.id == StreamKey.channelId && this.streamConnection) {
                  switch (event) {
                    case "STREAM_CREATE": {
                      this.streamConnection.setSessionId(this.authentication.sessionId);
                      this.streamConnection.serverId = data.rtc_server_id;
                      break;
                    }
                    case "STREAM_SERVER_UPDATE": {
                      this.streamConnection.setTokenAndEndpoint(data.token, data.endpoint);
                      break;
                    }
                    case "STREAM_DELETE": {
                      this.streamConnection.disconnect();
                      break;
                    }
                    case "STREAM_UPDATE": {
                      this.streamConnection.update(data);
                      break;
                    }
                  }
                }
                if (this.streamWatchConnection.has(StreamKey.userId) && this.channel.id == StreamKey.channelId) {
                  const streamConnection = this.streamWatchConnection.get(StreamKey.userId);
                  switch (event) {
                    case "STREAM_CREATE": {
                      streamConnection.setSessionId(this.authentication.sessionId);
                      streamConnection.serverId = data.rtc_server_id;
                      break;
                    }
                    case "STREAM_SERVER_UPDATE": {
                      streamConnection.setTokenAndEndpoint(data.token, data.endpoint);
                      break;
                    }
                    case "STREAM_DELETE": {
                      streamConnection.disconnect();
                      streamConnection.receiver.packets.destroyAllStream();
                      break;
                    }
                    case "STREAM_UPDATE": {
                      streamConnection.update(data);
                      break;
                    }
                  }
                }
              });
            }
            connection.sendSignalScreenshare();
            connection.sendScreenshareState(true);
            connection.on(
              "debug",
              (msg) => {
                var _a;
                return this.channel.client.emit(
                  "debug",
                  `[VOICE STREAM (${((_a = this.channel.guild) == null ? void 0 : _a.id) || this.channel.id}:${connection.status})]: ${msg}`
                );
              }
            );
            connection.once("failed", (reason) => {
              this.streamConnection = null;
              reject(reason);
            });
            connection.on("error", reject);
            connection.once("authenticated", () => {
              connection.once("ready", () => {
                resolve(connection);
                connection.removeListener("error", reject);
              });
              connection.once("disconnect", () => {
                this.streamConnection = null;
              });
            });
          }
        });
      }
      /**
       * Watch user stream
       * @param {UserResolvable} user Discord user
       * @returns {Promise<StreamConnectionReadonly>}
       */
      joinStreamConnection(user) {
        var _a;
        const userId = this.client.users.resolveId(user);
        if (!userId) {
          return Promise.reject(new Error2("VOICE_USER_MISSING"));
        }
        const voiceState = ((_a = this.channel.guild) == null ? void 0 : _a.voiceStates.cache.get(userId)) || this.client.voiceStates.cache.get(userId);
        if (!voiceState || !voiceState.streaming) {
          return Promise.reject(new Error2("VOICE_USER_NOT_STREAMING"));
        }
        return new Promise((resolve, reject) => {
          if (this.streamWatchConnection.has(userId)) {
            return resolve(this.streamWatchConnection.get(userId));
          } else {
            const connection = new StreamConnectionReadonly(this.voiceManager, this.channel, this, userId);
            this.streamWatchConnection.set(userId, connection);
            connection.setVideoCodec(this.videoCodec);
            if (!this.eventHook) {
              this.eventHook = true;
              this.channel.client.on("raw", (packet) => {
                var _a2;
                if (typeof packet !== "object" || !packet.t || !packet.d || !((_a2 = packet.d) == null ? void 0 : _a2.stream_key)) {
                  return;
                }
                const { t: event, d: data } = packet;
                const StreamKey = parseStreamKey(data.stream_key);
                if (StreamKey.userId === this.channel.client.user.id && this.channel.id == StreamKey.channelId && this.streamConnection) {
                  switch (event) {
                    case "STREAM_CREATE": {
                      this.streamConnection.setSessionId(this.authentication.sessionId);
                      this.streamConnection.serverId = data.rtc_server_id;
                      break;
                    }
                    case "STREAM_SERVER_UPDATE": {
                      this.streamConnection.setTokenAndEndpoint(data.token, data.endpoint);
                      break;
                    }
                    case "STREAM_DELETE": {
                      this.streamConnection.disconnect();
                      break;
                    }
                    case "STREAM_UPDATE": {
                      this.streamConnection.update(data);
                      break;
                    }
                  }
                }
                if (this.streamWatchConnection.has(StreamKey.userId) && this.channel.id == StreamKey.channelId) {
                  const streamConnection = this.streamWatchConnection.get(StreamKey.userId);
                  switch (event) {
                    case "STREAM_CREATE": {
                      streamConnection.setSessionId(this.authentication.sessionId);
                      streamConnection.serverId = data.rtc_server_id;
                      break;
                    }
                    case "STREAM_SERVER_UPDATE": {
                      streamConnection.setTokenAndEndpoint(data.token, data.endpoint);
                      break;
                    }
                    case "STREAM_DELETE": {
                      streamConnection.disconnect();
                      streamConnection.receiver.packets.destroyAllStream();
                      break;
                    }
                    case "STREAM_UPDATE": {
                      streamConnection.update(data);
                      break;
                    }
                  }
                }
              });
            }
            connection.sendSignalScreenshare();
            connection.on(
              "debug",
              (msg) => {
                var _a2;
                return this.channel.client.emit(
                  "debug",
                  `[VOICE STREAM WATCH (${userId}>${((_a2 = this.channel.guild) == null ? void 0 : _a2.id) || this.channel.id}:${connection.status})]: ${msg}`
                );
              }
            );
            connection.once("failed", (reason) => {
              this.streamWatchConnection.delete(userId);
              reject(reason);
            });
            connection.on("error", reject);
            connection.once("authenticated", () => {
              connection.once("ready", () => {
                resolve(connection);
                connection.removeListener("error", reject);
              });
              connection.once("disconnect", () => {
                this.streamWatchConnection.delete(userId);
              });
            });
          }
        });
      }
      /**
       * @event VoiceConnection#streamUpdate
       * @description Emitted when the StreamConnection or StreamConnectionReadonly
       * state changes, providing the previous and current stream state.
       *
       * @param {StreamState} oldData - The previous state of the stream.
       * @param {StreamState} newData - The current state of the stream.
       *
       * @typedef {Object} StreamState
       * @property {boolean} isPaused - Indicates whether the stream is currently paused.
       * @property {string|null} region - The region where the stream is hosted, or null if not specified.
       * @property {Snowflake[]} viewerIds - An array of Snowflake IDs representing the viewers connected to the stream.
       */
    };
    var _requestDisconnect;
    var StreamConnection = class extends VoiceConnection {
      /**
       * @param {ClientVoiceManager} voiceManager Voice manager
       * @param {Channel} channel any channel (joinable)
       * @param {VoiceConnection} voiceConnection parent
       */
      constructor(voiceManager, channel, voiceConnection) {
        super(voiceManager, channel);
        __privateAdd(this, _requestDisconnect, false);
        this.voiceConnection = voiceConnection;
        Object.defineProperty(this, "voiceConnection", {
          value: voiceConnection,
          writable: false
        });
        this.serverId = null;
        this.isPaused = false;
        this.viewerIds = [];
        this.region = null;
      }
      createStreamConnection() {
        return Promise.resolve(this);
      }
      joinStreamConnection() {
        throw new Error2("STREAM_CANNOT_JOIN");
      }
      get streamConnection() {
        return this;
      }
      set streamConnection(value) {
      }
      get streamWatchConnection() {
        return new Collection2();
      }
      set streamWatchConnection(value) {
      }
      disconnect() {
        if (__privateGet(this, _requestDisconnect)) return;
        this.emit("closing");
        this.emit("debug", "Stream: disconnect() triggered");
        clearTimeout(this.connectTimeout);
        if (this.voiceConnection.streamConnection === this) this.voiceConnection.streamConnection = null;
        this.sendStopScreenshare();
        this._disconnect();
      }
      /**
       * Create new stream connection (WS packet)
       * @returns {void}
       */
      sendSignalScreenshare() {
        var _a;
        const data = {
          type: ["DM", "GROUP_DM"].includes(this.channel.type) ? "call" : "guild",
          guild_id: ((_a = this.channel.guild) == null ? void 0 : _a.id) || null,
          channel_id: this.channel.id,
          preferred_region: null
        };
        this.emit("debug", `Signal Stream: ${JSON.stringify(data)}`);
        return this.channel.client.ws.broadcast({
          op: Opcodes.STREAM_CREATE,
          d: data
        });
      }
      /**
       * Send screenshare state... (WS)
       * @param {boolean} isPaused screenshare paused ?
       * @returns {void}
       */
      sendScreenshareState(isPaused = false) {
        if (isPaused == this.isPaused) return;
        this.emit(
          "streamUpdate",
          {
            isPaused: this.isPaused,
            region: this.region,
            viewerIds: this.viewerIds
          },
          {
            isPaused,
            region: this.region,
            viewerIds: this.viewerIds
          }
        );
        this.isPaused = isPaused;
        this.channel.client.ws.broadcast({
          op: Opcodes.STREAM_SET_PAUSED,
          d: {
            stream_key: this.streamKey,
            paused: isPaused
          }
        });
      }
      /**
       * Stop screenshare, delete this connection (WS)
       * @returns {void}
       * @private Using StreamConnection#disconnect()
       */
      sendStopScreenshare() {
        __privateSet(this, _requestDisconnect, true);
        this.channel.client.ws.broadcast({
          op: Opcodes.STREAM_DELETE,
          d: {
            stream_key: this.streamKey
          }
        });
      }
      update(data) {
        this.emit(
          "streamUpdate",
          {
            isPaused: this.isPaused,
            region: this.region,
            viewerIds: this.viewerIds.slice()
          },
          {
            isPaused: data.paused,
            region: data.region,
            viewerIds: data.viewer_ids
          }
        );
        this.viewerIds = data.viewer_ids;
        this.region = data.region;
      }
      /**
       * Current stream key
       * @type {string}
       */
      get streamKey() {
        return `${["DM", "GROUP_DM"].includes(this.channel.type) ? "call" : `guild:${this.channel.guild.id}`}:${this.channel.id}:${this.channel.client.user.id}`;
      }
    };
    _requestDisconnect = new WeakMap();
    var _requestDisconnect2;
    var StreamConnectionReadonly = class extends VoiceConnection {
      /**
       * @param {ClientVoiceManager} voiceManager Voice manager
       * @param {Channel} channel any channel (joinable)
       * @param {VoiceConnection} voiceConnection parent
       * @param {Snowflake} userId User ID
       */
      constructor(voiceManager, channel, voiceConnection, userId) {
        super(voiceManager, channel);
        __privateAdd(this, _requestDisconnect2, false);
        this.voiceConnection = voiceConnection;
        this.userId = userId;
        Object.defineProperty(this, "voiceConnection", {
          value: voiceConnection,
          writable: false
        });
        this.serverId = null;
        this.isPaused = false;
        this.viewerIds = [];
        this.region = null;
      }
      createStreamConnection() {
        throw new Error2("STREAM_CONNECTION_READONLY");
      }
      joinStreamConnection() {
        return Promise.resolve(this);
      }
      get streamConnection() {
        return null;
      }
      set streamConnection(value) {
      }
      get streamWatchConnection() {
        return new Collection2();
      }
      set streamWatchConnection(value) {
      }
      disconnect() {
        if (__privateGet(this, _requestDisconnect2)) return;
        this.emit("closing");
        this.emit("debug", "Stream: disconnect() triggered");
        clearTimeout(this.connectTimeout);
        this.voiceConnection.streamWatchConnection.delete(this.userId);
        this.sendStopScreenshare();
        this._disconnect();
      }
      /**
       * Create new stream connection (WS packet)
       * @returns {void}
       */
      sendSignalScreenshare() {
        this.emit("debug", `Signal Stream Watch: ${this.streamKey}`);
        return this.channel.client.ws.broadcast({
          op: Opcodes.STREAM_WATCH,
          d: {
            stream_key: this.streamKey
          }
        });
      }
      /**
       * Stop screenshare, delete this connection (WS)
       * @returns {void}
       * @private Using StreamConnection#disconnect()
       */
      sendStopScreenshare() {
        __privateSet(this, _requestDisconnect2, true);
        this.channel.client.ws.broadcast({
          op: Opcodes.STREAM_DELETE,
          d: {
            stream_key: this.streamKey
          }
        });
      }
      update(data) {
        this.emit(
          "streamUpdate",
          {
            isPaused: this.isPaused,
            region: this.region,
            viewerIds: this.viewerIds.slice()
          },
          {
            isPaused: data.paused,
            region: data.region,
            viewerIds: data.viewer_ids
          }
        );
        this.isPaused = data.paused;
        this.viewerIds = data.viewer_ids;
        this.region = data.region;
      }
      /**
       * Current stream key
       * @type {string}
       */
      get streamKey() {
        return `${["DM", "GROUP_DM"].includes(this.channel.type) ? "call" : `guild:${this.channel.guild.id}`}:${this.channel.id}:${this.userId}`;
      }
    };
    _requestDisconnect2 = new WeakMap();
    PlayInterface.applyToClass(VoiceConnection);
    PlayInterface.applyToClass(StreamConnection);
    module2.exports = VoiceConnection;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/voice/ClientVoiceManager.js
var require_ClientVoiceManager = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/voice/ClientVoiceManager.js"(exports2, module2) {
    "use strict";
    var VoiceConnection = require_VoiceConnection();
    var { Error: Error2 } = require_errors2();
    var { Events: Events2 } = require_Constants();
    var ClientVoiceManager2 = class {
      constructor(client) {
        Object.defineProperty(this, "client", { value: client });
        this.connection = null;
        this.adapters = /* @__PURE__ */ new Map();
        client.on(Events2.SHARD_DISCONNECT, (_, shardId) => {
          var _a;
          for (const [guildId, adapter] of this.adapters.entries()) {
            if (((_a = client.guilds.cache.get(guildId)) == null ? void 0 : _a.shardId) === shardId) {
            }
            adapter.destroy();
          }
        });
      }
      onVoiceServer(payload) {
        var _a, _b;
        const { guild_id, channel_id, token, endpoint } = payload;
        this.client.emit(
          "debug",
          `[VOICE] voiceServer ${channel_id ? "channel" : "guild"}: ${channel_id || guild_id} token: ${token} endpoint: ${endpoint}`
        );
        const connection = this.connection;
        if (connection) connection.setTokenAndEndpoint(token, endpoint);
        if (payload.guild_id) {
          (_a = this.adapters.get(payload.guild_id)) == null ? void 0 : _a.onVoiceServerUpdate(payload);
        } else {
          (_b = this.adapters.get(payload.channel_id)) == null ? void 0 : _b.onVoiceServerUpdate(payload);
        }
      }
      onVoiceStateUpdate(payload) {
        var _a, _b, _c, _d;
        const { guild_id, session_id, channel_id } = payload;
        const connection = this.connection;
        this.client.emit("debug", `[VOICE] connection? ${!!connection}, ${guild_id} ${session_id} ${channel_id}`);
        if (!connection) return;
        if (!channel_id) {
          connection._disconnect();
          this.connection = null;
          return;
        }
        const channel = this.client.channels.cache.get(channel_id);
        if (channel) {
          connection.channel = channel;
          connection.setSessionId(session_id);
        } else {
          this.client.emit("debug", `[VOICE] disconnecting from guild ${guild_id} as channel ${channel_id} is uncached`);
          connection.disconnect();
        }
        if (payload.guild_id && payload.session_id && payload.user_id === ((_a = this.client.user) == null ? void 0 : _a.id)) {
          (_b = this.adapters.get(payload.guild_id)) == null ? void 0 : _b.onVoiceStateUpdate(payload);
        } else if (payload.channel_id && payload.session_id && payload.user_id === ((_c = this.client.user) == null ? void 0 : _c.id)) {
          (_d = this.adapters.get(payload.channel_id)) == null ? void 0 : _d.onVoiceStateUpdate(payload);
        }
      }
      /**
       * @property {boolean} [selfMute=false]
       * @property {boolean} [selfDeaf=false]
       * @property {boolean} [selfVideo=false]
       * @property {VideoCodec} [videoCodec='H264']
       * @typedef {Object} JoinChannelConfig
       */
      /**
       * Sets up a request to join a voice channel.
       * @param {VoiceChannel | StageChannel | DMChannel | GroupDMChannel | Snowflake} channel The voice channel to join
       * @param {JoinChannelConfig} config Config to join voice channel
       * @returns {Promise<VoiceConnection>}
       */
      joinChannel(channel, config = {}) {
        return new Promise((resolve, reject) => {
          channel = this.client.channels.resolve(channel);
          if (!["DM", "GROUP_DM"].includes(channel == null ? void 0 : channel.type) && !channel.joinable) {
            throw new Error2("VOICE_JOIN_CHANNEL", channel.full);
          }
          let connection = this.connection;
          if (connection) {
            if (connection.channel.id !== channel.id) {
              this.connection.updateChannel(channel);
            }
            resolve(connection);
            return;
          } else {
            connection = new VoiceConnection(this, channel);
            if (config == null ? void 0 : config.videoCodec) connection.setVideoCodec(config.videoCodec);
            connection.on(
              "debug",
              (msg) => {
                var _a;
                return this.client.emit("debug", `[VOICE (${((_a = channel.guild) == null ? void 0 : _a.id) || channel.id}:${connection.status})]: ${msg}`);
              }
            );
            connection.authenticate({
              self_mute: Boolean(config.selfMute),
              self_deaf: Boolean(config.selfDeaf),
              self_video: Boolean(config.selfVideo)
            });
            this.connection = connection;
          }
          connection.once("failed", (reason) => {
            this.connection = null;
            reject(reason);
          });
          connection.on("error", reject);
          connection.once("authenticated", () => {
            connection.once("ready", () => {
              resolve(connection);
              connection.removeListener("error", reject);
            });
            connection.once("disconnect", () => {
              this.connection = null;
            });
          });
        });
      }
    };
    module2.exports = ClientVoiceManager2;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/gateway/common.js
var require_common = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/gateway/common.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/gateway/v9.js
var require_v9 = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/gateway/v9.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.VoiceChannelEffectSendAnimationType = exports2.GatewayDispatchEvents = exports2.GatewayIntentBits = exports2.GatewayCloseCodes = exports2.GatewayOpcodes = exports2.GatewayVersion = void 0;
    __exportStar(require_common(), exports2);
    exports2.GatewayVersion = "9";
    var GatewayOpcodes;
    (function(GatewayOpcodes2) {
      GatewayOpcodes2[GatewayOpcodes2["Dispatch"] = 0] = "Dispatch";
      GatewayOpcodes2[GatewayOpcodes2["Heartbeat"] = 1] = "Heartbeat";
      GatewayOpcodes2[GatewayOpcodes2["Identify"] = 2] = "Identify";
      GatewayOpcodes2[GatewayOpcodes2["PresenceUpdate"] = 3] = "PresenceUpdate";
      GatewayOpcodes2[GatewayOpcodes2["VoiceStateUpdate"] = 4] = "VoiceStateUpdate";
      GatewayOpcodes2[GatewayOpcodes2["Resume"] = 6] = "Resume";
      GatewayOpcodes2[GatewayOpcodes2["Reconnect"] = 7] = "Reconnect";
      GatewayOpcodes2[GatewayOpcodes2["RequestGuildMembers"] = 8] = "RequestGuildMembers";
      GatewayOpcodes2[GatewayOpcodes2["InvalidSession"] = 9] = "InvalidSession";
      GatewayOpcodes2[GatewayOpcodes2["Hello"] = 10] = "Hello";
      GatewayOpcodes2[GatewayOpcodes2["HeartbeatAck"] = 11] = "HeartbeatAck";
      GatewayOpcodes2[GatewayOpcodes2["RequestSoundboardSounds"] = 31] = "RequestSoundboardSounds";
    })(GatewayOpcodes || (exports2.GatewayOpcodes = GatewayOpcodes = {}));
    var GatewayCloseCodes;
    (function(GatewayCloseCodes2) {
      GatewayCloseCodes2[GatewayCloseCodes2["UnknownError"] = 4e3] = "UnknownError";
      GatewayCloseCodes2[GatewayCloseCodes2["UnknownOpcode"] = 4001] = "UnknownOpcode";
      GatewayCloseCodes2[GatewayCloseCodes2["DecodeError"] = 4002] = "DecodeError";
      GatewayCloseCodes2[GatewayCloseCodes2["NotAuthenticated"] = 4003] = "NotAuthenticated";
      GatewayCloseCodes2[GatewayCloseCodes2["AuthenticationFailed"] = 4004] = "AuthenticationFailed";
      GatewayCloseCodes2[GatewayCloseCodes2["AlreadyAuthenticated"] = 4005] = "AlreadyAuthenticated";
      GatewayCloseCodes2[GatewayCloseCodes2["InvalidSeq"] = 4007] = "InvalidSeq";
      GatewayCloseCodes2[GatewayCloseCodes2["RateLimited"] = 4008] = "RateLimited";
      GatewayCloseCodes2[GatewayCloseCodes2["SessionTimedOut"] = 4009] = "SessionTimedOut";
      GatewayCloseCodes2[GatewayCloseCodes2["InvalidShard"] = 4010] = "InvalidShard";
      GatewayCloseCodes2[GatewayCloseCodes2["ShardingRequired"] = 4011] = "ShardingRequired";
      GatewayCloseCodes2[GatewayCloseCodes2["InvalidAPIVersion"] = 4012] = "InvalidAPIVersion";
      GatewayCloseCodes2[GatewayCloseCodes2["InvalidIntents"] = 4013] = "InvalidIntents";
      GatewayCloseCodes2[GatewayCloseCodes2["DisallowedIntents"] = 4014] = "DisallowedIntents";
    })(GatewayCloseCodes || (exports2.GatewayCloseCodes = GatewayCloseCodes = {}));
    var GatewayIntentBits;
    (function(GatewayIntentBits2) {
      GatewayIntentBits2[GatewayIntentBits2["Guilds"] = 1] = "Guilds";
      GatewayIntentBits2[GatewayIntentBits2["GuildMembers"] = 2] = "GuildMembers";
      GatewayIntentBits2[GatewayIntentBits2["GuildModeration"] = 4] = "GuildModeration";
      GatewayIntentBits2[GatewayIntentBits2["GuildBans"] = 4] = "GuildBans";
      GatewayIntentBits2[GatewayIntentBits2["GuildExpressions"] = 8] = "GuildExpressions";
      GatewayIntentBits2[GatewayIntentBits2["GuildEmojisAndStickers"] = 8] = "GuildEmojisAndStickers";
      GatewayIntentBits2[GatewayIntentBits2["GuildIntegrations"] = 16] = "GuildIntegrations";
      GatewayIntentBits2[GatewayIntentBits2["GuildWebhooks"] = 32] = "GuildWebhooks";
      GatewayIntentBits2[GatewayIntentBits2["GuildInvites"] = 64] = "GuildInvites";
      GatewayIntentBits2[GatewayIntentBits2["GuildVoiceStates"] = 128] = "GuildVoiceStates";
      GatewayIntentBits2[GatewayIntentBits2["GuildPresences"] = 256] = "GuildPresences";
      GatewayIntentBits2[GatewayIntentBits2["GuildMessages"] = 512] = "GuildMessages";
      GatewayIntentBits2[GatewayIntentBits2["GuildMessageReactions"] = 1024] = "GuildMessageReactions";
      GatewayIntentBits2[GatewayIntentBits2["GuildMessageTyping"] = 2048] = "GuildMessageTyping";
      GatewayIntentBits2[GatewayIntentBits2["DirectMessages"] = 4096] = "DirectMessages";
      GatewayIntentBits2[GatewayIntentBits2["DirectMessageReactions"] = 8192] = "DirectMessageReactions";
      GatewayIntentBits2[GatewayIntentBits2["DirectMessageTyping"] = 16384] = "DirectMessageTyping";
      GatewayIntentBits2[GatewayIntentBits2["GuildScheduledEvents"] = 65536] = "GuildScheduledEvents";
      GatewayIntentBits2[GatewayIntentBits2["AutoModerationConfiguration"] = 1048576] = "AutoModerationConfiguration";
      GatewayIntentBits2[GatewayIntentBits2["AutoModerationExecution"] = 2097152] = "AutoModerationExecution";
      GatewayIntentBits2[GatewayIntentBits2["GuildMessagePolls"] = 16777216] = "GuildMessagePolls";
      GatewayIntentBits2[GatewayIntentBits2["DirectMessagePolls"] = 33554432] = "DirectMessagePolls";
    })(GatewayIntentBits || (exports2.GatewayIntentBits = GatewayIntentBits = {}));
    var GatewayDispatchEvents;
    (function(GatewayDispatchEvents2) {
      GatewayDispatchEvents2["ApplicationCommandPermissionsUpdate"] = "APPLICATION_COMMAND_PERMISSIONS_UPDATE";
      GatewayDispatchEvents2["AutoModerationActionExecution"] = "AUTO_MODERATION_ACTION_EXECUTION";
      GatewayDispatchEvents2["AutoModerationRuleCreate"] = "AUTO_MODERATION_RULE_CREATE";
      GatewayDispatchEvents2["AutoModerationRuleDelete"] = "AUTO_MODERATION_RULE_DELETE";
      GatewayDispatchEvents2["AutoModerationRuleUpdate"] = "AUTO_MODERATION_RULE_UPDATE";
      GatewayDispatchEvents2["ChannelCreate"] = "CHANNEL_CREATE";
      GatewayDispatchEvents2["ChannelDelete"] = "CHANNEL_DELETE";
      GatewayDispatchEvents2["ChannelPinsUpdate"] = "CHANNEL_PINS_UPDATE";
      GatewayDispatchEvents2["ChannelUpdate"] = "CHANNEL_UPDATE";
      GatewayDispatchEvents2["EntitlementCreate"] = "ENTITLEMENT_CREATE";
      GatewayDispatchEvents2["EntitlementDelete"] = "ENTITLEMENT_DELETE";
      GatewayDispatchEvents2["EntitlementUpdate"] = "ENTITLEMENT_UPDATE";
      GatewayDispatchEvents2["GuildAuditLogEntryCreate"] = "GUILD_AUDIT_LOG_ENTRY_CREATE";
      GatewayDispatchEvents2["GuildBanAdd"] = "GUILD_BAN_ADD";
      GatewayDispatchEvents2["GuildBanRemove"] = "GUILD_BAN_REMOVE";
      GatewayDispatchEvents2["GuildCreate"] = "GUILD_CREATE";
      GatewayDispatchEvents2["GuildDelete"] = "GUILD_DELETE";
      GatewayDispatchEvents2["GuildEmojisUpdate"] = "GUILD_EMOJIS_UPDATE";
      GatewayDispatchEvents2["GuildIntegrationsUpdate"] = "GUILD_INTEGRATIONS_UPDATE";
      GatewayDispatchEvents2["GuildMemberAdd"] = "GUILD_MEMBER_ADD";
      GatewayDispatchEvents2["GuildMemberRemove"] = "GUILD_MEMBER_REMOVE";
      GatewayDispatchEvents2["GuildMembersChunk"] = "GUILD_MEMBERS_CHUNK";
      GatewayDispatchEvents2["GuildMemberUpdate"] = "GUILD_MEMBER_UPDATE";
      GatewayDispatchEvents2["GuildRoleCreate"] = "GUILD_ROLE_CREATE";
      GatewayDispatchEvents2["GuildRoleDelete"] = "GUILD_ROLE_DELETE";
      GatewayDispatchEvents2["GuildRoleUpdate"] = "GUILD_ROLE_UPDATE";
      GatewayDispatchEvents2["GuildScheduledEventCreate"] = "GUILD_SCHEDULED_EVENT_CREATE";
      GatewayDispatchEvents2["GuildScheduledEventDelete"] = "GUILD_SCHEDULED_EVENT_DELETE";
      GatewayDispatchEvents2["GuildScheduledEventUpdate"] = "GUILD_SCHEDULED_EVENT_UPDATE";
      GatewayDispatchEvents2["GuildScheduledEventUserAdd"] = "GUILD_SCHEDULED_EVENT_USER_ADD";
      GatewayDispatchEvents2["GuildScheduledEventUserRemove"] = "GUILD_SCHEDULED_EVENT_USER_REMOVE";
      GatewayDispatchEvents2["GuildSoundboardSoundCreate"] = "GUILD_SOUNDBOARD_SOUND_CREATE";
      GatewayDispatchEvents2["GuildSoundboardSoundDelete"] = "GUILD_SOUNDBOARD_SOUND_DELETE";
      GatewayDispatchEvents2["GuildSoundboardSoundsUpdate"] = "GUILD_SOUNDBOARD_SOUNDS_UPDATE";
      GatewayDispatchEvents2["GuildSoundboardSoundUpdate"] = "GUILD_SOUNDBOARD_SOUND_UPDATE";
      GatewayDispatchEvents2["SoundboardSounds"] = "SOUNDBOARD_SOUNDS";
      GatewayDispatchEvents2["GuildStickersUpdate"] = "GUILD_STICKERS_UPDATE";
      GatewayDispatchEvents2["GuildUpdate"] = "GUILD_UPDATE";
      GatewayDispatchEvents2["IntegrationCreate"] = "INTEGRATION_CREATE";
      GatewayDispatchEvents2["IntegrationDelete"] = "INTEGRATION_DELETE";
      GatewayDispatchEvents2["IntegrationUpdate"] = "INTEGRATION_UPDATE";
      GatewayDispatchEvents2["InteractionCreate"] = "INTERACTION_CREATE";
      GatewayDispatchEvents2["InviteCreate"] = "INVITE_CREATE";
      GatewayDispatchEvents2["InviteDelete"] = "INVITE_DELETE";
      GatewayDispatchEvents2["MessageCreate"] = "MESSAGE_CREATE";
      GatewayDispatchEvents2["MessageDelete"] = "MESSAGE_DELETE";
      GatewayDispatchEvents2["MessageDeleteBulk"] = "MESSAGE_DELETE_BULK";
      GatewayDispatchEvents2["MessagePollVoteAdd"] = "MESSAGE_POLL_VOTE_ADD";
      GatewayDispatchEvents2["MessagePollVoteRemove"] = "MESSAGE_POLL_VOTE_REMOVE";
      GatewayDispatchEvents2["MessageReactionAdd"] = "MESSAGE_REACTION_ADD";
      GatewayDispatchEvents2["MessageReactionRemove"] = "MESSAGE_REACTION_REMOVE";
      GatewayDispatchEvents2["MessageReactionRemoveAll"] = "MESSAGE_REACTION_REMOVE_ALL";
      GatewayDispatchEvents2["MessageReactionRemoveEmoji"] = "MESSAGE_REACTION_REMOVE_EMOJI";
      GatewayDispatchEvents2["MessageUpdate"] = "MESSAGE_UPDATE";
      GatewayDispatchEvents2["PresenceUpdate"] = "PRESENCE_UPDATE";
      GatewayDispatchEvents2["Ready"] = "READY";
      GatewayDispatchEvents2["Resumed"] = "RESUMED";
      GatewayDispatchEvents2["StageInstanceCreate"] = "STAGE_INSTANCE_CREATE";
      GatewayDispatchEvents2["StageInstanceDelete"] = "STAGE_INSTANCE_DELETE";
      GatewayDispatchEvents2["StageInstanceUpdate"] = "STAGE_INSTANCE_UPDATE";
      GatewayDispatchEvents2["SubscriptionCreate"] = "SUBSCRIPTION_CREATE";
      GatewayDispatchEvents2["SubscriptionDelete"] = "SUBSCRIPTION_DELETE";
      GatewayDispatchEvents2["SubscriptionUpdate"] = "SUBSCRIPTION_UPDATE";
      GatewayDispatchEvents2["ThreadCreate"] = "THREAD_CREATE";
      GatewayDispatchEvents2["ThreadDelete"] = "THREAD_DELETE";
      GatewayDispatchEvents2["ThreadListSync"] = "THREAD_LIST_SYNC";
      GatewayDispatchEvents2["ThreadMembersUpdate"] = "THREAD_MEMBERS_UPDATE";
      GatewayDispatchEvents2["ThreadMemberUpdate"] = "THREAD_MEMBER_UPDATE";
      GatewayDispatchEvents2["ThreadUpdate"] = "THREAD_UPDATE";
      GatewayDispatchEvents2["TypingStart"] = "TYPING_START";
      GatewayDispatchEvents2["UserUpdate"] = "USER_UPDATE";
      GatewayDispatchEvents2["VoiceChannelEffectSend"] = "VOICE_CHANNEL_EFFECT_SEND";
      GatewayDispatchEvents2["VoiceServerUpdate"] = "VOICE_SERVER_UPDATE";
      GatewayDispatchEvents2["VoiceStateUpdate"] = "VOICE_STATE_UPDATE";
      GatewayDispatchEvents2["WebhooksUpdate"] = "WEBHOOKS_UPDATE";
    })(GatewayDispatchEvents || (exports2.GatewayDispatchEvents = GatewayDispatchEvents = {}));
    var VoiceChannelEffectSendAnimationType;
    (function(VoiceChannelEffectSendAnimationType2) {
      VoiceChannelEffectSendAnimationType2[VoiceChannelEffectSendAnimationType2["Premium"] = 0] = "Premium";
      VoiceChannelEffectSendAnimationType2[VoiceChannelEffectSendAnimationType2["Basic"] = 1] = "Basic";
    })(VoiceChannelEffectSendAnimationType || (exports2.VoiceChannelEffectSendAnimationType = VoiceChannelEffectSendAnimationType = {}));
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/globals.js
var require_globals = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/globals.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FormattingPatterns = void 0;
    exports2.FormattingPatterns = {
      /**
       * Regular expression for matching a user mention, strictly without a nickname
       *
       * The `id` group property is present on the `exec` result of this expression
       */
      User: /<@(?<id>\d{17,20})>/,
      /**
       * Regular expression for matching a user mention, strictly with a nickname
       *
       * The `id` group property is present on the `exec` result of this expression
       *
       * @deprecated Passing `!` in user mentions is no longer necessary / supported, and future message contents won't have it
       */
      UserWithNickname: /<@!(?<id>\d{17,20})>/,
      /**
       * Regular expression for matching a user mention, with or without a nickname
       *
       * The `id` group property is present on the `exec` result of this expression
       *
       * @deprecated Passing `!` in user mentions is no longer necessary / supported, and future message contents won't have it
       */
      UserWithOptionalNickname: /<@!?(?<id>\d{17,20})>/,
      /**
       * Regular expression for matching a channel mention
       *
       * The `id` group property is present on the `exec` result of this expression
       */
      Channel: /<#(?<id>\d{17,20})>/,
      /**
       * Regular expression for matching a role mention
       *
       * The `id` group property is present on the `exec` result of this expression
       */
      Role: /<@&(?<id>\d{17,20})>/,
      /**
       * Regular expression for matching a application command mention
       *
       * The `fullName` (possibly including `name`, `subcommandOrGroup` and `subcommand`) and `id` group properties are present on the `exec` result of this expression
       */
      SlashCommand: (
        // eslint-disable-next-line unicorn/no-unsafe-regex
        /<\/(?<fullName>(?<name>[-_\p{Letter}\p{Number}\p{sc=Deva}\p{sc=Thai}]{1,32})(?: (?<subcommandOrGroup>[-_\p{Letter}\p{Number}\p{sc=Deva}\p{sc=Thai}]{1,32}))?(?: (?<subcommand>[-_\p{Letter}\p{Number}\p{sc=Deva}\p{sc=Thai}]{1,32}))?):(?<id>\d{17,20})>/u
      ),
      /**
       * Regular expression for matching a custom emoji, either static or animated
       *
       * The `animated`, `name` and `id` group properties are present on the `exec` result of this expression
       */
      Emoji: /<(?<animated>a)?:(?<name>\w{2,32}):(?<id>\d{17,20})>/,
      /**
       * Regular expression for matching strictly an animated custom emoji
       *
       * The `animated`, `name` and `id` group properties are present on the `exec` result of this expression
       */
      AnimatedEmoji: /<(?<animated>a):(?<name>\w{2,32}):(?<id>\d{17,20})>/,
      /**
       * Regular expression for matching strictly a static custom emoji
       *
       * The `name` and `id` group properties are present on the `exec` result of this expression
       */
      StaticEmoji: /<:(?<name>\w{2,32}):(?<id>\d{17,20})>/,
      /**
       * Regular expression for matching a timestamp, either default or custom styled
       *
       * The `timestamp` and `style` group properties are present on the `exec` result of this expression
       */
      // eslint-disable-next-line prefer-named-capture-group
      Timestamp: /<t:(?<timestamp>-?\d{1,13})(:(?<style>[DFRTdft]))?>/,
      /**
       * Regular expression for matching strictly default styled timestamps
       *
       * The `timestamp` group property is present on the `exec` result of this expression
       */
      DefaultStyledTimestamp: /<t:(?<timestamp>-?\d{1,13})>/,
      /**
       * Regular expression for matching strictly custom styled timestamps
       *
       * The `timestamp` and `style` group properties are present on the `exec` result of this expression
       */
      StyledTimestamp: /<t:(?<timestamp>-?\d{1,13}):(?<style>[DFRTdft])>/,
      /**
       * Regular expression for matching a guild navigation mention
       *
       * The `type` group property is present on the `exec` result of this expression
       */
      GuildNavigation: /<id:(?<type>customize|browse|guide|linked-roles)>/,
      /**
       * Regular expression for matching a linked role mention
       *
       * The `id` group property is present on the `exec` result of this expression
       */
      LinkedRole: /<id:linked-roles:(?<id>\d{17,20})>/
    };
    Object.freeze(exports2.FormattingPatterns);
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/common.js
var require_common2 = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/common.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PermissionFlagsBits = void 0;
    exports2.PermissionFlagsBits = {
      /**
       * Allows creation of instant invites
       *
       * Applies to channel types: Text, Voice, Stage
       */
      CreateInstantInvite: 1n << 0n,
      /**
       * Allows kicking members
       */
      // eslint-disable-next-line sonarjs/no-identical-expressions
      KickMembers: 1n << 1n,
      /**
       * Allows banning members
       */
      BanMembers: 1n << 2n,
      /**
       * Allows all permissions and bypasses channel permission overwrites
       */
      Administrator: 1n << 3n,
      /**
       * Allows management and editing of channels
       *
       * Applies to channel types: Text, Voice, Stage
       */
      ManageChannels: 1n << 4n,
      /**
       * Allows management and editing of the guild
       */
      ManageGuild: 1n << 5n,
      /**
       * Allows for the addition of reactions to messages
       *
       * Applies to channel types: Text, Voice, Stage
       */
      AddReactions: 1n << 6n,
      /**
       * Allows for viewing of audit logs
       */
      ViewAuditLog: 1n << 7n,
      /**
       * Allows for using priority speaker in a voice channel
       *
       * Applies to channel types: Voice
       */
      PrioritySpeaker: 1n << 8n,
      /**
       * Allows the user to go live
       *
       * Applies to channel types: Voice, Stage
       */
      Stream: 1n << 9n,
      /**
       * Allows guild members to view a channel, which includes reading messages in text channels and joining voice channels
       *
       * Applies to channel types: Text, Voice, Stage
       */
      ViewChannel: 1n << 10n,
      /**
       * Allows for sending messages in a channel and creating threads in a forum
       * (does not allow sending messages in threads)
       *
       * Applies to channel types: Text, Voice, Stage
       */
      SendMessages: 1n << 11n,
      /**
       * Allows for sending of `/tts` messages
       *
       * Applies to channel types: Text, Voice, Stage
       */
      SendTTSMessages: 1n << 12n,
      /**
       * Allows for deletion of other users messages
       *
       * Applies to channel types: Text, Voice, Stage
       */
      ManageMessages: 1n << 13n,
      /**
       * Links sent by users with this permission will be auto-embedded
       *
       * Applies to channel types: Text, Voice, Stage
       */
      EmbedLinks: 1n << 14n,
      /**
       * Allows for uploading images and files
       *
       * Applies to channel types: Text, Voice, Stage
       */
      AttachFiles: 1n << 15n,
      /**
       * Allows for reading of message history
       *
       * Applies to channel types: Text, Voice, Stage
       */
      ReadMessageHistory: 1n << 16n,
      /**
       * Allows for using the `@everyone` tag to notify all users in a channel,
       * and the `@here` tag to notify all online users in a channel
       *
       * Applies to channel types: Text, Voice, Stage
       */
      MentionEveryone: 1n << 17n,
      /**
       * Allows the usage of custom emojis from other servers
       *
       * Applies to channel types: Text, Voice, Stage
       */
      UseExternalEmojis: 1n << 18n,
      /**
       * Allows for viewing guild insights
       */
      ViewGuildInsights: 1n << 19n,
      /**
       * Allows for joining of a voice channel
       *
       * Applies to channel types: Voice, Stage
       */
      Connect: 1n << 20n,
      /**
       * Allows for speaking in a voice channel
       *
       * Applies to channel types: Voice
       */
      Speak: 1n << 21n,
      /**
       * Allows for muting members in a voice channel
       *
       * Applies to channel types: Voice, Stage
       */
      MuteMembers: 1n << 22n,
      /**
       * Allows for deafening of members in a voice channel
       *
       * Applies to channel types: Voice
       */
      DeafenMembers: 1n << 23n,
      /**
       * Allows for moving of members between voice channels
       *
       * Applies to channel types: Voice, Stage
       */
      MoveMembers: 1n << 24n,
      /**
       * Allows for using voice-activity-detection in a voice channel
       *
       * Applies to channel types: Voice
       */
      UseVAD: 1n << 25n,
      /**
       * Allows for modification of own nickname
       */
      ChangeNickname: 1n << 26n,
      /**
       * Allows for modification of other users nicknames
       */
      ManageNicknames: 1n << 27n,
      /**
       * Allows management and editing of roles
       *
       * Applies to channel types: Text, Voice, Stage
       */
      ManageRoles: 1n << 28n,
      /**
       * Allows management and editing of webhooks
       *
       * Applies to channel types: Text, Voice, Stage
       */
      ManageWebhooks: 1n << 29n,
      /**
       * Allows management and editing of emojis, stickers, and soundboard sounds
       *
       * @deprecated This is the old name for {@apilink PermissionFlagsBits#ManageGuildExpressions}
       */
      ManageEmojisAndStickers: 1n << 30n,
      /**
       * Allows for editing and deleting emojis, stickers, and soundboard sounds created by all users
       */
      ManageGuildExpressions: 1n << 30n,
      /**
       * Allows members to use application commands, including slash commands and context menu commands
       *
       * Applies to channel types: Text, Voice, Stage
       */
      UseApplicationCommands: 1n << 31n,
      /**
       * Allows for requesting to speak in stage channels
       *
       * Applies to channel types: Stage
       */
      RequestToSpeak: 1n << 32n,
      /**
       * Allows for editing and deleting scheduled events created by all users
       *
       * Applies to channel types: Voice, Stage
       */
      ManageEvents: 1n << 33n,
      /**
       * Allows for deleting and archiving threads, and viewing all private threads
       *
       * Applies to channel types: Text
       */
      ManageThreads: 1n << 34n,
      /**
       * Allows for creating public and announcement threads
       *
       * Applies to channel types: Text
       */
      CreatePublicThreads: 1n << 35n,
      /**
       * Allows for creating private threads
       *
       * Applies to channel types: Text
       */
      CreatePrivateThreads: 1n << 36n,
      /**
       * Allows the usage of custom stickers from other servers
       *
       * Applies to channel types: Text, Voice, Stage
       */
      UseExternalStickers: 1n << 37n,
      /**
       * Allows for sending messages in threads
       *
       * Applies to channel types: Text
       */
      SendMessagesInThreads: 1n << 38n,
      /**
       * Allows for using Activities (applications with the {@apilink ApplicationFlags.Embedded} flag) in a voice channel
       *
       * Applies to channel types: Voice
       */
      UseEmbeddedActivities: 1n << 39n,
      /**
       * Allows for timing out users to prevent them from sending or reacting to messages in chat and threads,
       * and from speaking in voice and stage channels
       */
      ModerateMembers: 1n << 40n,
      /**
       * Allows for viewing role subscription insights
       */
      ViewCreatorMonetizationAnalytics: 1n << 41n,
      /**
       * Allows for using soundboard in a voice channel
       *
       * Applies to channel types: Voice
       */
      UseSoundboard: 1n << 42n,
      /**
       * Allows for creating emojis, stickers, and soundboard sounds, and editing and deleting those created by the current user
       */
      CreateGuildExpressions: 1n << 43n,
      /**
       * Allows for creating scheduled events, and editing and deleting those created by the current user
       *
       * Applies to channel types: Voice, Stage
       */
      CreateEvents: 1n << 44n,
      /**
       * Allows the usage of custom soundboard sounds from other servers
       *
       * Applies to channel types: Voice
       */
      UseExternalSounds: 1n << 45n,
      /**
       * Allows sending voice messages
       *
       * Applies to channel types: Text, Voice, Stage
       */
      SendVoiceMessages: 1n << 46n,
      /**
       * Allows sending polls
       *
       * Applies to channel types: Text, Voice, Stage
       */
      SendPolls: 1n << 49n,
      /**
       * Allows user-installed apps to send public responses. When disabled, users will still be allowed to use their apps but the responses will be ephemeral. This only applies to apps not also installed to the server
       *
       * Applies to channel types: Text, Voice, Stage
       */
      UseExternalApps: 1n << 50n
    };
    Object.freeze(exports2.PermissionFlagsBits);
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/application.js
var require_application = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/application.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApplicationWebhookEventStatus = exports2.ApplicationRoleConnectionMetadataType = exports2.ApplicationFlags = void 0;
    var ApplicationFlags;
    (function(ApplicationFlags2) {
      ApplicationFlags2[ApplicationFlags2["EmbeddedReleased"] = 2] = "EmbeddedReleased";
      ApplicationFlags2[ApplicationFlags2["ManagedEmoji"] = 4] = "ManagedEmoji";
      ApplicationFlags2[ApplicationFlags2["EmbeddedIAP"] = 8] = "EmbeddedIAP";
      ApplicationFlags2[ApplicationFlags2["GroupDMCreate"] = 16] = "GroupDMCreate";
      ApplicationFlags2[ApplicationFlags2["ApplicationAutoModerationRuleCreateBadge"] = 64] = "ApplicationAutoModerationRuleCreateBadge";
      ApplicationFlags2[ApplicationFlags2["RPCHasConnected"] = 2048] = "RPCHasConnected";
      ApplicationFlags2[ApplicationFlags2["GatewayPresence"] = 4096] = "GatewayPresence";
      ApplicationFlags2[ApplicationFlags2["GatewayPresenceLimited"] = 8192] = "GatewayPresenceLimited";
      ApplicationFlags2[ApplicationFlags2["GatewayGuildMembers"] = 16384] = "GatewayGuildMembers";
      ApplicationFlags2[ApplicationFlags2["GatewayGuildMembersLimited"] = 32768] = "GatewayGuildMembersLimited";
      ApplicationFlags2[ApplicationFlags2["VerificationPendingGuildLimit"] = 65536] = "VerificationPendingGuildLimit";
      ApplicationFlags2[ApplicationFlags2["Embedded"] = 131072] = "Embedded";
      ApplicationFlags2[ApplicationFlags2["GatewayMessageContent"] = 262144] = "GatewayMessageContent";
      ApplicationFlags2[ApplicationFlags2["GatewayMessageContentLimited"] = 524288] = "GatewayMessageContentLimited";
      ApplicationFlags2[ApplicationFlags2["EmbeddedFirstParty"] = 1048576] = "EmbeddedFirstParty";
      ApplicationFlags2[ApplicationFlags2["ApplicationCommandBadge"] = 8388608] = "ApplicationCommandBadge";
    })(ApplicationFlags || (exports2.ApplicationFlags = ApplicationFlags = {}));
    var ApplicationRoleConnectionMetadataType;
    (function(ApplicationRoleConnectionMetadataType2) {
      ApplicationRoleConnectionMetadataType2[ApplicationRoleConnectionMetadataType2["IntegerLessThanOrEqual"] = 1] = "IntegerLessThanOrEqual";
      ApplicationRoleConnectionMetadataType2[ApplicationRoleConnectionMetadataType2["IntegerGreaterThanOrEqual"] = 2] = "IntegerGreaterThanOrEqual";
      ApplicationRoleConnectionMetadataType2[ApplicationRoleConnectionMetadataType2["IntegerEqual"] = 3] = "IntegerEqual";
      ApplicationRoleConnectionMetadataType2[ApplicationRoleConnectionMetadataType2["IntegerNotEqual"] = 4] = "IntegerNotEqual";
      ApplicationRoleConnectionMetadataType2[ApplicationRoleConnectionMetadataType2["DatetimeLessThanOrEqual"] = 5] = "DatetimeLessThanOrEqual";
      ApplicationRoleConnectionMetadataType2[ApplicationRoleConnectionMetadataType2["DatetimeGreaterThanOrEqual"] = 6] = "DatetimeGreaterThanOrEqual";
      ApplicationRoleConnectionMetadataType2[ApplicationRoleConnectionMetadataType2["BooleanEqual"] = 7] = "BooleanEqual";
      ApplicationRoleConnectionMetadataType2[ApplicationRoleConnectionMetadataType2["BooleanNotEqual"] = 8] = "BooleanNotEqual";
    })(ApplicationRoleConnectionMetadataType || (exports2.ApplicationRoleConnectionMetadataType = ApplicationRoleConnectionMetadataType = {}));
    var ApplicationWebhookEventStatus;
    (function(ApplicationWebhookEventStatus2) {
      ApplicationWebhookEventStatus2[ApplicationWebhookEventStatus2["Disabled"] = 1] = "Disabled";
      ApplicationWebhookEventStatus2[ApplicationWebhookEventStatus2["Enabled"] = 2] = "Enabled";
      ApplicationWebhookEventStatus2[ApplicationWebhookEventStatus2["DisabledByDiscord"] = 3] = "DisabledByDiscord";
    })(ApplicationWebhookEventStatus || (exports2.ApplicationWebhookEventStatus = ApplicationWebhookEventStatus = {}));
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/auditLog.js
var require_auditLog = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/auditLog.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AuditLogOptionsType = exports2.AuditLogEvent = void 0;
    var AuditLogEvent;
    (function(AuditLogEvent2) {
      AuditLogEvent2[AuditLogEvent2["GuildUpdate"] = 1] = "GuildUpdate";
      AuditLogEvent2[AuditLogEvent2["ChannelCreate"] = 10] = "ChannelCreate";
      AuditLogEvent2[AuditLogEvent2["ChannelUpdate"] = 11] = "ChannelUpdate";
      AuditLogEvent2[AuditLogEvent2["ChannelDelete"] = 12] = "ChannelDelete";
      AuditLogEvent2[AuditLogEvent2["ChannelOverwriteCreate"] = 13] = "ChannelOverwriteCreate";
      AuditLogEvent2[AuditLogEvent2["ChannelOverwriteUpdate"] = 14] = "ChannelOverwriteUpdate";
      AuditLogEvent2[AuditLogEvent2["ChannelOverwriteDelete"] = 15] = "ChannelOverwriteDelete";
      AuditLogEvent2[AuditLogEvent2["MemberKick"] = 20] = "MemberKick";
      AuditLogEvent2[AuditLogEvent2["MemberPrune"] = 21] = "MemberPrune";
      AuditLogEvent2[AuditLogEvent2["MemberBanAdd"] = 22] = "MemberBanAdd";
      AuditLogEvent2[AuditLogEvent2["MemberBanRemove"] = 23] = "MemberBanRemove";
      AuditLogEvent2[AuditLogEvent2["MemberUpdate"] = 24] = "MemberUpdate";
      AuditLogEvent2[AuditLogEvent2["MemberRoleUpdate"] = 25] = "MemberRoleUpdate";
      AuditLogEvent2[AuditLogEvent2["MemberMove"] = 26] = "MemberMove";
      AuditLogEvent2[AuditLogEvent2["MemberDisconnect"] = 27] = "MemberDisconnect";
      AuditLogEvent2[AuditLogEvent2["BotAdd"] = 28] = "BotAdd";
      AuditLogEvent2[AuditLogEvent2["RoleCreate"] = 30] = "RoleCreate";
      AuditLogEvent2[AuditLogEvent2["RoleUpdate"] = 31] = "RoleUpdate";
      AuditLogEvent2[AuditLogEvent2["RoleDelete"] = 32] = "RoleDelete";
      AuditLogEvent2[AuditLogEvent2["InviteCreate"] = 40] = "InviteCreate";
      AuditLogEvent2[AuditLogEvent2["InviteUpdate"] = 41] = "InviteUpdate";
      AuditLogEvent2[AuditLogEvent2["InviteDelete"] = 42] = "InviteDelete";
      AuditLogEvent2[AuditLogEvent2["WebhookCreate"] = 50] = "WebhookCreate";
      AuditLogEvent2[AuditLogEvent2["WebhookUpdate"] = 51] = "WebhookUpdate";
      AuditLogEvent2[AuditLogEvent2["WebhookDelete"] = 52] = "WebhookDelete";
      AuditLogEvent2[AuditLogEvent2["EmojiCreate"] = 60] = "EmojiCreate";
      AuditLogEvent2[AuditLogEvent2["EmojiUpdate"] = 61] = "EmojiUpdate";
      AuditLogEvent2[AuditLogEvent2["EmojiDelete"] = 62] = "EmojiDelete";
      AuditLogEvent2[AuditLogEvent2["MessageDelete"] = 72] = "MessageDelete";
      AuditLogEvent2[AuditLogEvent2["MessageBulkDelete"] = 73] = "MessageBulkDelete";
      AuditLogEvent2[AuditLogEvent2["MessagePin"] = 74] = "MessagePin";
      AuditLogEvent2[AuditLogEvent2["MessageUnpin"] = 75] = "MessageUnpin";
      AuditLogEvent2[AuditLogEvent2["IntegrationCreate"] = 80] = "IntegrationCreate";
      AuditLogEvent2[AuditLogEvent2["IntegrationUpdate"] = 81] = "IntegrationUpdate";
      AuditLogEvent2[AuditLogEvent2["IntegrationDelete"] = 82] = "IntegrationDelete";
      AuditLogEvent2[AuditLogEvent2["StageInstanceCreate"] = 83] = "StageInstanceCreate";
      AuditLogEvent2[AuditLogEvent2["StageInstanceUpdate"] = 84] = "StageInstanceUpdate";
      AuditLogEvent2[AuditLogEvent2["StageInstanceDelete"] = 85] = "StageInstanceDelete";
      AuditLogEvent2[AuditLogEvent2["StickerCreate"] = 90] = "StickerCreate";
      AuditLogEvent2[AuditLogEvent2["StickerUpdate"] = 91] = "StickerUpdate";
      AuditLogEvent2[AuditLogEvent2["StickerDelete"] = 92] = "StickerDelete";
      AuditLogEvent2[AuditLogEvent2["GuildScheduledEventCreate"] = 100] = "GuildScheduledEventCreate";
      AuditLogEvent2[AuditLogEvent2["GuildScheduledEventUpdate"] = 101] = "GuildScheduledEventUpdate";
      AuditLogEvent2[AuditLogEvent2["GuildScheduledEventDelete"] = 102] = "GuildScheduledEventDelete";
      AuditLogEvent2[AuditLogEvent2["ThreadCreate"] = 110] = "ThreadCreate";
      AuditLogEvent2[AuditLogEvent2["ThreadUpdate"] = 111] = "ThreadUpdate";
      AuditLogEvent2[AuditLogEvent2["ThreadDelete"] = 112] = "ThreadDelete";
      AuditLogEvent2[AuditLogEvent2["ApplicationCommandPermissionUpdate"] = 121] = "ApplicationCommandPermissionUpdate";
      AuditLogEvent2[AuditLogEvent2["SoundboardSoundCreate"] = 130] = "SoundboardSoundCreate";
      AuditLogEvent2[AuditLogEvent2["SoundboardSoundUpdate"] = 131] = "SoundboardSoundUpdate";
      AuditLogEvent2[AuditLogEvent2["SoundboardSoundDelete"] = 132] = "SoundboardSoundDelete";
      AuditLogEvent2[AuditLogEvent2["AutoModerationRuleCreate"] = 140] = "AutoModerationRuleCreate";
      AuditLogEvent2[AuditLogEvent2["AutoModerationRuleUpdate"] = 141] = "AutoModerationRuleUpdate";
      AuditLogEvent2[AuditLogEvent2["AutoModerationRuleDelete"] = 142] = "AutoModerationRuleDelete";
      AuditLogEvent2[AuditLogEvent2["AutoModerationBlockMessage"] = 143] = "AutoModerationBlockMessage";
      AuditLogEvent2[AuditLogEvent2["AutoModerationFlagToChannel"] = 144] = "AutoModerationFlagToChannel";
      AuditLogEvent2[AuditLogEvent2["AutoModerationUserCommunicationDisabled"] = 145] = "AutoModerationUserCommunicationDisabled";
      AuditLogEvent2[AuditLogEvent2["CreatorMonetizationRequestCreated"] = 150] = "CreatorMonetizationRequestCreated";
      AuditLogEvent2[AuditLogEvent2["CreatorMonetizationTermsAccepted"] = 151] = "CreatorMonetizationTermsAccepted";
      AuditLogEvent2[AuditLogEvent2["OnboardingPromptCreate"] = 163] = "OnboardingPromptCreate";
      AuditLogEvent2[AuditLogEvent2["OnboardingPromptUpdate"] = 164] = "OnboardingPromptUpdate";
      AuditLogEvent2[AuditLogEvent2["OnboardingPromptDelete"] = 165] = "OnboardingPromptDelete";
      AuditLogEvent2[AuditLogEvent2["OnboardingCreate"] = 166] = "OnboardingCreate";
      AuditLogEvent2[AuditLogEvent2["OnboardingUpdate"] = 167] = "OnboardingUpdate";
      AuditLogEvent2[AuditLogEvent2["HomeSettingsCreate"] = 190] = "HomeSettingsCreate";
      AuditLogEvent2[AuditLogEvent2["HomeSettingsUpdate"] = 191] = "HomeSettingsUpdate";
    })(AuditLogEvent || (exports2.AuditLogEvent = AuditLogEvent = {}));
    var AuditLogOptionsType;
    (function(AuditLogOptionsType2) {
      AuditLogOptionsType2["Role"] = "0";
      AuditLogOptionsType2["Member"] = "1";
    })(AuditLogOptionsType || (exports2.AuditLogOptionsType = AuditLogOptionsType = {}));
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/autoModeration.js
var require_autoModeration = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/autoModeration.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AutoModerationActionType = exports2.AutoModerationRuleEventType = exports2.AutoModerationRuleKeywordPresetType = exports2.AutoModerationRuleTriggerType = void 0;
    var AutoModerationRuleTriggerType;
    (function(AutoModerationRuleTriggerType2) {
      AutoModerationRuleTriggerType2[AutoModerationRuleTriggerType2["Keyword"] = 1] = "Keyword";
      AutoModerationRuleTriggerType2[AutoModerationRuleTriggerType2["Spam"] = 3] = "Spam";
      AutoModerationRuleTriggerType2[AutoModerationRuleTriggerType2["KeywordPreset"] = 4] = "KeywordPreset";
      AutoModerationRuleTriggerType2[AutoModerationRuleTriggerType2["MentionSpam"] = 5] = "MentionSpam";
      AutoModerationRuleTriggerType2[AutoModerationRuleTriggerType2["MemberProfile"] = 6] = "MemberProfile";
    })(AutoModerationRuleTriggerType || (exports2.AutoModerationRuleTriggerType = AutoModerationRuleTriggerType = {}));
    var AutoModerationRuleKeywordPresetType;
    (function(AutoModerationRuleKeywordPresetType2) {
      AutoModerationRuleKeywordPresetType2[AutoModerationRuleKeywordPresetType2["Profanity"] = 1] = "Profanity";
      AutoModerationRuleKeywordPresetType2[AutoModerationRuleKeywordPresetType2["SexualContent"] = 2] = "SexualContent";
      AutoModerationRuleKeywordPresetType2[AutoModerationRuleKeywordPresetType2["Slurs"] = 3] = "Slurs";
    })(AutoModerationRuleKeywordPresetType || (exports2.AutoModerationRuleKeywordPresetType = AutoModerationRuleKeywordPresetType = {}));
    var AutoModerationRuleEventType;
    (function(AutoModerationRuleEventType2) {
      AutoModerationRuleEventType2[AutoModerationRuleEventType2["MessageSend"] = 1] = "MessageSend";
      AutoModerationRuleEventType2[AutoModerationRuleEventType2["MemberUpdate"] = 2] = "MemberUpdate";
    })(AutoModerationRuleEventType || (exports2.AutoModerationRuleEventType = AutoModerationRuleEventType = {}));
    var AutoModerationActionType;
    (function(AutoModerationActionType2) {
      AutoModerationActionType2[AutoModerationActionType2["BlockMessage"] = 1] = "BlockMessage";
      AutoModerationActionType2[AutoModerationActionType2["SendAlertMessage"] = 2] = "SendAlertMessage";
      AutoModerationActionType2[AutoModerationActionType2["Timeout"] = 3] = "Timeout";
      AutoModerationActionType2[AutoModerationActionType2["BlockMemberInteraction"] = 4] = "BlockMemberInteraction";
    })(AutoModerationActionType || (exports2.AutoModerationActionType = AutoModerationActionType = {}));
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/channel.js
var require_channel = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/channel.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ChannelFlags = exports2.SelectMenuDefaultValueType = exports2.TextInputStyle = exports2.ButtonStyle = exports2.ComponentType = exports2.AllowedMentionsTypes = exports2.AttachmentFlags = exports2.EmbedType = exports2.ThreadMemberFlags = exports2.ThreadAutoArchiveDuration = exports2.OverwriteType = exports2.MessageFlags = exports2.MessageReferenceType = exports2.MessageActivityType = exports2.MessageType = exports2.VideoQualityMode = exports2.ChannelType = exports2.ForumLayoutType = exports2.SortOrderType = void 0;
    var SortOrderType;
    (function(SortOrderType2) {
      SortOrderType2[SortOrderType2["LatestActivity"] = 0] = "LatestActivity";
      SortOrderType2[SortOrderType2["CreationDate"] = 1] = "CreationDate";
    })(SortOrderType || (exports2.SortOrderType = SortOrderType = {}));
    var ForumLayoutType;
    (function(ForumLayoutType2) {
      ForumLayoutType2[ForumLayoutType2["NotSet"] = 0] = "NotSet";
      ForumLayoutType2[ForumLayoutType2["ListView"] = 1] = "ListView";
      ForumLayoutType2[ForumLayoutType2["GalleryView"] = 2] = "GalleryView";
    })(ForumLayoutType || (exports2.ForumLayoutType = ForumLayoutType = {}));
    var ChannelType;
    (function(ChannelType2) {
      ChannelType2[ChannelType2["GuildText"] = 0] = "GuildText";
      ChannelType2[ChannelType2["DM"] = 1] = "DM";
      ChannelType2[ChannelType2["GuildVoice"] = 2] = "GuildVoice";
      ChannelType2[ChannelType2["GroupDM"] = 3] = "GroupDM";
      ChannelType2[ChannelType2["GuildCategory"] = 4] = "GuildCategory";
      ChannelType2[ChannelType2["GuildAnnouncement"] = 5] = "GuildAnnouncement";
      ChannelType2[ChannelType2["AnnouncementThread"] = 10] = "AnnouncementThread";
      ChannelType2[ChannelType2["PublicThread"] = 11] = "PublicThread";
      ChannelType2[ChannelType2["PrivateThread"] = 12] = "PrivateThread";
      ChannelType2[ChannelType2["GuildStageVoice"] = 13] = "GuildStageVoice";
      ChannelType2[ChannelType2["GuildDirectory"] = 14] = "GuildDirectory";
      ChannelType2[ChannelType2["GuildForum"] = 15] = "GuildForum";
      ChannelType2[ChannelType2["GuildMedia"] = 16] = "GuildMedia";
      ChannelType2[ChannelType2["GuildNews"] = 5] = "GuildNews";
      ChannelType2[ChannelType2["GuildNewsThread"] = 10] = "GuildNewsThread";
      ChannelType2[ChannelType2["GuildPublicThread"] = 11] = "GuildPublicThread";
      ChannelType2[ChannelType2["GuildPrivateThread"] = 12] = "GuildPrivateThread";
    })(ChannelType || (exports2.ChannelType = ChannelType = {}));
    var VideoQualityMode;
    (function(VideoQualityMode2) {
      VideoQualityMode2[VideoQualityMode2["Auto"] = 1] = "Auto";
      VideoQualityMode2[VideoQualityMode2["Full"] = 2] = "Full";
    })(VideoQualityMode || (exports2.VideoQualityMode = VideoQualityMode = {}));
    var MessageType;
    (function(MessageType2) {
      MessageType2[MessageType2["Default"] = 0] = "Default";
      MessageType2[MessageType2["RecipientAdd"] = 1] = "RecipientAdd";
      MessageType2[MessageType2["RecipientRemove"] = 2] = "RecipientRemove";
      MessageType2[MessageType2["Call"] = 3] = "Call";
      MessageType2[MessageType2["ChannelNameChange"] = 4] = "ChannelNameChange";
      MessageType2[MessageType2["ChannelIconChange"] = 5] = "ChannelIconChange";
      MessageType2[MessageType2["ChannelPinnedMessage"] = 6] = "ChannelPinnedMessage";
      MessageType2[MessageType2["UserJoin"] = 7] = "UserJoin";
      MessageType2[MessageType2["GuildBoost"] = 8] = "GuildBoost";
      MessageType2[MessageType2["GuildBoostTier1"] = 9] = "GuildBoostTier1";
      MessageType2[MessageType2["GuildBoostTier2"] = 10] = "GuildBoostTier2";
      MessageType2[MessageType2["GuildBoostTier3"] = 11] = "GuildBoostTier3";
      MessageType2[MessageType2["ChannelFollowAdd"] = 12] = "ChannelFollowAdd";
      MessageType2[MessageType2["GuildDiscoveryDisqualified"] = 14] = "GuildDiscoveryDisqualified";
      MessageType2[MessageType2["GuildDiscoveryRequalified"] = 15] = "GuildDiscoveryRequalified";
      MessageType2[MessageType2["GuildDiscoveryGracePeriodInitialWarning"] = 16] = "GuildDiscoveryGracePeriodInitialWarning";
      MessageType2[MessageType2["GuildDiscoveryGracePeriodFinalWarning"] = 17] = "GuildDiscoveryGracePeriodFinalWarning";
      MessageType2[MessageType2["ThreadCreated"] = 18] = "ThreadCreated";
      MessageType2[MessageType2["Reply"] = 19] = "Reply";
      MessageType2[MessageType2["ChatInputCommand"] = 20] = "ChatInputCommand";
      MessageType2[MessageType2["ThreadStarterMessage"] = 21] = "ThreadStarterMessage";
      MessageType2[MessageType2["GuildInviteReminder"] = 22] = "GuildInviteReminder";
      MessageType2[MessageType2["ContextMenuCommand"] = 23] = "ContextMenuCommand";
      MessageType2[MessageType2["AutoModerationAction"] = 24] = "AutoModerationAction";
      MessageType2[MessageType2["RoleSubscriptionPurchase"] = 25] = "RoleSubscriptionPurchase";
      MessageType2[MessageType2["InteractionPremiumUpsell"] = 26] = "InteractionPremiumUpsell";
      MessageType2[MessageType2["StageStart"] = 27] = "StageStart";
      MessageType2[MessageType2["StageEnd"] = 28] = "StageEnd";
      MessageType2[MessageType2["StageSpeaker"] = 29] = "StageSpeaker";
      MessageType2[MessageType2["StageRaiseHand"] = 30] = "StageRaiseHand";
      MessageType2[MessageType2["StageTopic"] = 31] = "StageTopic";
      MessageType2[MessageType2["GuildApplicationPremiumSubscription"] = 32] = "GuildApplicationPremiumSubscription";
      MessageType2[MessageType2["GuildIncidentAlertModeEnabled"] = 36] = "GuildIncidentAlertModeEnabled";
      MessageType2[MessageType2["GuildIncidentAlertModeDisabled"] = 37] = "GuildIncidentAlertModeDisabled";
      MessageType2[MessageType2["GuildIncidentReportRaid"] = 38] = "GuildIncidentReportRaid";
      MessageType2[MessageType2["GuildIncidentReportFalseAlarm"] = 39] = "GuildIncidentReportFalseAlarm";
      MessageType2[MessageType2["PurchaseNotification"] = 44] = "PurchaseNotification";
      MessageType2[MessageType2["PollResult"] = 46] = "PollResult";
    })(MessageType || (exports2.MessageType = MessageType = {}));
    var MessageActivityType;
    (function(MessageActivityType2) {
      MessageActivityType2[MessageActivityType2["Join"] = 1] = "Join";
      MessageActivityType2[MessageActivityType2["Spectate"] = 2] = "Spectate";
      MessageActivityType2[MessageActivityType2["Listen"] = 3] = "Listen";
      MessageActivityType2[MessageActivityType2["JoinRequest"] = 5] = "JoinRequest";
    })(MessageActivityType || (exports2.MessageActivityType = MessageActivityType = {}));
    var MessageReferenceType;
    (function(MessageReferenceType2) {
      MessageReferenceType2[MessageReferenceType2["Default"] = 0] = "Default";
      MessageReferenceType2[MessageReferenceType2["Forward"] = 1] = "Forward";
    })(MessageReferenceType || (exports2.MessageReferenceType = MessageReferenceType = {}));
    var MessageFlags;
    (function(MessageFlags2) {
      MessageFlags2[MessageFlags2["Crossposted"] = 1] = "Crossposted";
      MessageFlags2[MessageFlags2["IsCrosspost"] = 2] = "IsCrosspost";
      MessageFlags2[MessageFlags2["SuppressEmbeds"] = 4] = "SuppressEmbeds";
      MessageFlags2[MessageFlags2["SourceMessageDeleted"] = 8] = "SourceMessageDeleted";
      MessageFlags2[MessageFlags2["Urgent"] = 16] = "Urgent";
      MessageFlags2[MessageFlags2["HasThread"] = 32] = "HasThread";
      MessageFlags2[MessageFlags2["Ephemeral"] = 64] = "Ephemeral";
      MessageFlags2[MessageFlags2["Loading"] = 128] = "Loading";
      MessageFlags2[MessageFlags2["FailedToMentionSomeRolesInThread"] = 256] = "FailedToMentionSomeRolesInThread";
      MessageFlags2[MessageFlags2["ShouldShowLinkNotDiscordWarning"] = 1024] = "ShouldShowLinkNotDiscordWarning";
      MessageFlags2[MessageFlags2["SuppressNotifications"] = 4096] = "SuppressNotifications";
      MessageFlags2[MessageFlags2["IsVoiceMessage"] = 8192] = "IsVoiceMessage";
    })(MessageFlags || (exports2.MessageFlags = MessageFlags = {}));
    var OverwriteType;
    (function(OverwriteType2) {
      OverwriteType2[OverwriteType2["Role"] = 0] = "Role";
      OverwriteType2[OverwriteType2["Member"] = 1] = "Member";
    })(OverwriteType || (exports2.OverwriteType = OverwriteType = {}));
    var ThreadAutoArchiveDuration;
    (function(ThreadAutoArchiveDuration2) {
      ThreadAutoArchiveDuration2[ThreadAutoArchiveDuration2["OneHour"] = 60] = "OneHour";
      ThreadAutoArchiveDuration2[ThreadAutoArchiveDuration2["OneDay"] = 1440] = "OneDay";
      ThreadAutoArchiveDuration2[ThreadAutoArchiveDuration2["ThreeDays"] = 4320] = "ThreeDays";
      ThreadAutoArchiveDuration2[ThreadAutoArchiveDuration2["OneWeek"] = 10080] = "OneWeek";
    })(ThreadAutoArchiveDuration || (exports2.ThreadAutoArchiveDuration = ThreadAutoArchiveDuration = {}));
    var ThreadMemberFlags;
    (function(ThreadMemberFlags2) {
      ThreadMemberFlags2[ThreadMemberFlags2["HasInteracted"] = 1] = "HasInteracted";
      ThreadMemberFlags2[ThreadMemberFlags2["AllMessages"] = 2] = "AllMessages";
      ThreadMemberFlags2[ThreadMemberFlags2["OnlyMentions"] = 4] = "OnlyMentions";
      ThreadMemberFlags2[ThreadMemberFlags2["NoMessages"] = 8] = "NoMessages";
    })(ThreadMemberFlags || (exports2.ThreadMemberFlags = ThreadMemberFlags = {}));
    var EmbedType;
    (function(EmbedType2) {
      EmbedType2["Rich"] = "rich";
      EmbedType2["Image"] = "image";
      EmbedType2["Video"] = "video";
      EmbedType2["GIFV"] = "gifv";
      EmbedType2["Article"] = "article";
      EmbedType2["Link"] = "link";
      EmbedType2["AutoModerationMessage"] = "auto_moderation_message";
      EmbedType2["PollResult"] = "poll_result";
    })(EmbedType || (exports2.EmbedType = EmbedType = {}));
    var AttachmentFlags;
    (function(AttachmentFlags2) {
      AttachmentFlags2[AttachmentFlags2["IsRemix"] = 4] = "IsRemix";
    })(AttachmentFlags || (exports2.AttachmentFlags = AttachmentFlags = {}));
    var AllowedMentionsTypes;
    (function(AllowedMentionsTypes2) {
      AllowedMentionsTypes2["Everyone"] = "everyone";
      AllowedMentionsTypes2["Role"] = "roles";
      AllowedMentionsTypes2["User"] = "users";
    })(AllowedMentionsTypes || (exports2.AllowedMentionsTypes = AllowedMentionsTypes = {}));
    var ComponentType;
    (function(ComponentType2) {
      ComponentType2[ComponentType2["ActionRow"] = 1] = "ActionRow";
      ComponentType2[ComponentType2["Button"] = 2] = "Button";
      ComponentType2[ComponentType2["StringSelect"] = 3] = "StringSelect";
      ComponentType2[ComponentType2["TextInput"] = 4] = "TextInput";
      ComponentType2[ComponentType2["UserSelect"] = 5] = "UserSelect";
      ComponentType2[ComponentType2["RoleSelect"] = 6] = "RoleSelect";
      ComponentType2[ComponentType2["MentionableSelect"] = 7] = "MentionableSelect";
      ComponentType2[ComponentType2["ChannelSelect"] = 8] = "ChannelSelect";
      ComponentType2[ComponentType2["SelectMenu"] = 3] = "SelectMenu";
    })(ComponentType || (exports2.ComponentType = ComponentType = {}));
    var ButtonStyle;
    (function(ButtonStyle2) {
      ButtonStyle2[ButtonStyle2["Primary"] = 1] = "Primary";
      ButtonStyle2[ButtonStyle2["Secondary"] = 2] = "Secondary";
      ButtonStyle2[ButtonStyle2["Success"] = 3] = "Success";
      ButtonStyle2[ButtonStyle2["Danger"] = 4] = "Danger";
      ButtonStyle2[ButtonStyle2["Link"] = 5] = "Link";
      ButtonStyle2[ButtonStyle2["Premium"] = 6] = "Premium";
    })(ButtonStyle || (exports2.ButtonStyle = ButtonStyle = {}));
    var TextInputStyle;
    (function(TextInputStyle2) {
      TextInputStyle2[TextInputStyle2["Short"] = 1] = "Short";
      TextInputStyle2[TextInputStyle2["Paragraph"] = 2] = "Paragraph";
    })(TextInputStyle || (exports2.TextInputStyle = TextInputStyle = {}));
    var SelectMenuDefaultValueType;
    (function(SelectMenuDefaultValueType2) {
      SelectMenuDefaultValueType2["Channel"] = "channel";
      SelectMenuDefaultValueType2["Role"] = "role";
      SelectMenuDefaultValueType2["User"] = "user";
    })(SelectMenuDefaultValueType || (exports2.SelectMenuDefaultValueType = SelectMenuDefaultValueType = {}));
    var ChannelFlags;
    (function(ChannelFlags2) {
      ChannelFlags2[ChannelFlags2["GuildFeedRemoved"] = 1] = "GuildFeedRemoved";
      ChannelFlags2[ChannelFlags2["Pinned"] = 2] = "Pinned";
      ChannelFlags2[ChannelFlags2["ActiveChannelsRemoved"] = 4] = "ActiveChannelsRemoved";
      ChannelFlags2[ChannelFlags2["RequireTag"] = 16] = "RequireTag";
      ChannelFlags2[ChannelFlags2["IsSpam"] = 32] = "IsSpam";
      ChannelFlags2[ChannelFlags2["IsGuildResourceChannel"] = 128] = "IsGuildResourceChannel";
      ChannelFlags2[ChannelFlags2["ClydeAI"] = 256] = "ClydeAI";
      ChannelFlags2[ChannelFlags2["IsScheduledForDeletion"] = 512] = "IsScheduledForDeletion";
      ChannelFlags2[ChannelFlags2["HideMediaDownloadOptions"] = 32768] = "HideMediaDownloadOptions";
    })(ChannelFlags || (exports2.ChannelFlags = ChannelFlags = {}));
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/emoji.js
var require_emoji = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/emoji.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/gateway.js
var require_gateway = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/gateway.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ActivityFlags = exports2.ActivityType = exports2.ActivityPlatform = exports2.PresenceUpdateStatus = void 0;
    var PresenceUpdateStatus;
    (function(PresenceUpdateStatus2) {
      PresenceUpdateStatus2["Online"] = "online";
      PresenceUpdateStatus2["DoNotDisturb"] = "dnd";
      PresenceUpdateStatus2["Idle"] = "idle";
      PresenceUpdateStatus2["Invisible"] = "invisible";
      PresenceUpdateStatus2["Offline"] = "offline";
    })(PresenceUpdateStatus || (exports2.PresenceUpdateStatus = PresenceUpdateStatus = {}));
    var ActivityPlatform;
    (function(ActivityPlatform2) {
      ActivityPlatform2["Desktop"] = "desktop";
      ActivityPlatform2["Xbox"] = "xbox";
      ActivityPlatform2["Samsung"] = "samsung";
      ActivityPlatform2["IOS"] = "ios";
      ActivityPlatform2["Android"] = "android";
      ActivityPlatform2["Embedded"] = "embedded";
      ActivityPlatform2["PS4"] = "ps4";
      ActivityPlatform2["PS5"] = "ps5";
    })(ActivityPlatform || (exports2.ActivityPlatform = ActivityPlatform = {}));
    var ActivityType;
    (function(ActivityType2) {
      ActivityType2[ActivityType2["Playing"] = 0] = "Playing";
      ActivityType2[ActivityType2["Streaming"] = 1] = "Streaming";
      ActivityType2[ActivityType2["Listening"] = 2] = "Listening";
      ActivityType2[ActivityType2["Watching"] = 3] = "Watching";
      ActivityType2[ActivityType2["Custom"] = 4] = "Custom";
      ActivityType2[ActivityType2["Competing"] = 5] = "Competing";
    })(ActivityType || (exports2.ActivityType = ActivityType = {}));
    var ActivityFlags;
    (function(ActivityFlags2) {
      ActivityFlags2[ActivityFlags2["Instance"] = 1] = "Instance";
      ActivityFlags2[ActivityFlags2["Join"] = 2] = "Join";
      ActivityFlags2[ActivityFlags2["Spectate"] = 4] = "Spectate";
      ActivityFlags2[ActivityFlags2["JoinRequest"] = 8] = "JoinRequest";
      ActivityFlags2[ActivityFlags2["Sync"] = 16] = "Sync";
      ActivityFlags2[ActivityFlags2["Play"] = 32] = "Play";
      ActivityFlags2[ActivityFlags2["PartyPrivacyFriends"] = 64] = "PartyPrivacyFriends";
      ActivityFlags2[ActivityFlags2["PartyPrivacyVoiceChannel"] = 128] = "PartyPrivacyVoiceChannel";
      ActivityFlags2[ActivityFlags2["Embedded"] = 256] = "Embedded";
    })(ActivityFlags || (exports2.ActivityFlags = ActivityFlags = {}));
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/guild.js
var require_guild = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/guild.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GuildOnboardingPromptType = exports2.GuildOnboardingMode = exports2.MembershipScreeningFieldType = exports2.GuildWidgetStyle = exports2.IntegrationExpireBehavior = exports2.GuildMemberFlags = exports2.GuildFeature = exports2.GuildSystemChannelFlags = exports2.GuildHubType = exports2.GuildPremiumTier = exports2.GuildVerificationLevel = exports2.GuildNSFWLevel = exports2.GuildMFALevel = exports2.GuildExplicitContentFilter = exports2.GuildDefaultMessageNotifications = void 0;
    var GuildDefaultMessageNotifications;
    (function(GuildDefaultMessageNotifications2) {
      GuildDefaultMessageNotifications2[GuildDefaultMessageNotifications2["AllMessages"] = 0] = "AllMessages";
      GuildDefaultMessageNotifications2[GuildDefaultMessageNotifications2["OnlyMentions"] = 1] = "OnlyMentions";
    })(GuildDefaultMessageNotifications || (exports2.GuildDefaultMessageNotifications = GuildDefaultMessageNotifications = {}));
    var GuildExplicitContentFilter;
    (function(GuildExplicitContentFilter2) {
      GuildExplicitContentFilter2[GuildExplicitContentFilter2["Disabled"] = 0] = "Disabled";
      GuildExplicitContentFilter2[GuildExplicitContentFilter2["MembersWithoutRoles"] = 1] = "MembersWithoutRoles";
      GuildExplicitContentFilter2[GuildExplicitContentFilter2["AllMembers"] = 2] = "AllMembers";
    })(GuildExplicitContentFilter || (exports2.GuildExplicitContentFilter = GuildExplicitContentFilter = {}));
    var GuildMFALevel;
    (function(GuildMFALevel2) {
      GuildMFALevel2[GuildMFALevel2["None"] = 0] = "None";
      GuildMFALevel2[GuildMFALevel2["Elevated"] = 1] = "Elevated";
    })(GuildMFALevel || (exports2.GuildMFALevel = GuildMFALevel = {}));
    var GuildNSFWLevel;
    (function(GuildNSFWLevel2) {
      GuildNSFWLevel2[GuildNSFWLevel2["Default"] = 0] = "Default";
      GuildNSFWLevel2[GuildNSFWLevel2["Explicit"] = 1] = "Explicit";
      GuildNSFWLevel2[GuildNSFWLevel2["Safe"] = 2] = "Safe";
      GuildNSFWLevel2[GuildNSFWLevel2["AgeRestricted"] = 3] = "AgeRestricted";
    })(GuildNSFWLevel || (exports2.GuildNSFWLevel = GuildNSFWLevel = {}));
    var GuildVerificationLevel;
    (function(GuildVerificationLevel2) {
      GuildVerificationLevel2[GuildVerificationLevel2["None"] = 0] = "None";
      GuildVerificationLevel2[GuildVerificationLevel2["Low"] = 1] = "Low";
      GuildVerificationLevel2[GuildVerificationLevel2["Medium"] = 2] = "Medium";
      GuildVerificationLevel2[GuildVerificationLevel2["High"] = 3] = "High";
      GuildVerificationLevel2[GuildVerificationLevel2["VeryHigh"] = 4] = "VeryHigh";
    })(GuildVerificationLevel || (exports2.GuildVerificationLevel = GuildVerificationLevel = {}));
    var GuildPremiumTier;
    (function(GuildPremiumTier2) {
      GuildPremiumTier2[GuildPremiumTier2["None"] = 0] = "None";
      GuildPremiumTier2[GuildPremiumTier2["Tier1"] = 1] = "Tier1";
      GuildPremiumTier2[GuildPremiumTier2["Tier2"] = 2] = "Tier2";
      GuildPremiumTier2[GuildPremiumTier2["Tier3"] = 3] = "Tier3";
    })(GuildPremiumTier || (exports2.GuildPremiumTier = GuildPremiumTier = {}));
    var GuildHubType;
    (function(GuildHubType2) {
      GuildHubType2[GuildHubType2["Default"] = 0] = "Default";
      GuildHubType2[GuildHubType2["HighSchool"] = 1] = "HighSchool";
      GuildHubType2[GuildHubType2["College"] = 2] = "College";
    })(GuildHubType || (exports2.GuildHubType = GuildHubType = {}));
    var GuildSystemChannelFlags;
    (function(GuildSystemChannelFlags2) {
      GuildSystemChannelFlags2[GuildSystemChannelFlags2["SuppressJoinNotifications"] = 1] = "SuppressJoinNotifications";
      GuildSystemChannelFlags2[GuildSystemChannelFlags2["SuppressPremiumSubscriptions"] = 2] = "SuppressPremiumSubscriptions";
      GuildSystemChannelFlags2[GuildSystemChannelFlags2["SuppressGuildReminderNotifications"] = 4] = "SuppressGuildReminderNotifications";
      GuildSystemChannelFlags2[GuildSystemChannelFlags2["SuppressJoinNotificationReplies"] = 8] = "SuppressJoinNotificationReplies";
    })(GuildSystemChannelFlags || (exports2.GuildSystemChannelFlags = GuildSystemChannelFlags = {}));
    var GuildFeature;
    (function(GuildFeature2) {
      GuildFeature2["AnimatedBanner"] = "ANIMATED_BANNER";
      GuildFeature2["AnimatedIcon"] = "ANIMATED_ICON";
      GuildFeature2["ApplicationCommandPermissionsV2"] = "APPLICATION_COMMAND_PERMISSIONS_V2";
      GuildFeature2["AutoModeration"] = "AUTO_MODERATION";
      GuildFeature2["Banner"] = "BANNER";
      GuildFeature2["Community"] = "COMMUNITY";
      GuildFeature2["CreatorMonetizableProvisional"] = "CREATOR_MONETIZABLE_PROVISIONAL";
      GuildFeature2["CreatorStorePage"] = "CREATOR_STORE_PAGE";
      GuildFeature2["DeveloperSupportServer"] = "DEVELOPER_SUPPORT_SERVER";
      GuildFeature2["Discoverable"] = "DISCOVERABLE";
      GuildFeature2["Featurable"] = "FEATURABLE";
      GuildFeature2["HasDirectoryEntry"] = "HAS_DIRECTORY_ENTRY";
      GuildFeature2["Hub"] = "HUB";
      GuildFeature2["InvitesDisabled"] = "INVITES_DISABLED";
      GuildFeature2["InviteSplash"] = "INVITE_SPLASH";
      GuildFeature2["LinkedToHub"] = "LINKED_TO_HUB";
      GuildFeature2["MemberVerificationGateEnabled"] = "MEMBER_VERIFICATION_GATE_ENABLED";
      GuildFeature2["MoreSoundboard"] = "MORE_SOUNDBOARD";
      GuildFeature2["MonetizationEnabled"] = "MONETIZATION_ENABLED";
      GuildFeature2["MoreStickers"] = "MORE_STICKERS";
      GuildFeature2["News"] = "NEWS";
      GuildFeature2["Partnered"] = "PARTNERED";
      GuildFeature2["PreviewEnabled"] = "PREVIEW_ENABLED";
      GuildFeature2["PrivateThreads"] = "PRIVATE_THREADS";
      GuildFeature2["RaidAlertsDisabled"] = "RAID_ALERTS_DISABLED";
      GuildFeature2["RelayEnabled"] = "RELAY_ENABLED";
      GuildFeature2["RoleIcons"] = "ROLE_ICONS";
      GuildFeature2["RoleSubscriptionsAvailableForPurchase"] = "ROLE_SUBSCRIPTIONS_AVAILABLE_FOR_PURCHASE";
      GuildFeature2["RoleSubscriptionsEnabled"] = "ROLE_SUBSCRIPTIONS_ENABLED";
      GuildFeature2["Soundboard"] = "SOUNDBOARD";
      GuildFeature2["TicketedEventsEnabled"] = "TICKETED_EVENTS_ENABLED";
      GuildFeature2["VanityURL"] = "VANITY_URL";
      GuildFeature2["Verified"] = "VERIFIED";
      GuildFeature2["VIPRegions"] = "VIP_REGIONS";
      GuildFeature2["WelcomeScreenEnabled"] = "WELCOME_SCREEN_ENABLED";
    })(GuildFeature || (exports2.GuildFeature = GuildFeature = {}));
    var GuildMemberFlags;
    (function(GuildMemberFlags2) {
      GuildMemberFlags2[GuildMemberFlags2["DidRejoin"] = 1] = "DidRejoin";
      GuildMemberFlags2[GuildMemberFlags2["CompletedOnboarding"] = 2] = "CompletedOnboarding";
      GuildMemberFlags2[GuildMemberFlags2["BypassesVerification"] = 4] = "BypassesVerification";
      GuildMemberFlags2[GuildMemberFlags2["StartedOnboarding"] = 8] = "StartedOnboarding";
      GuildMemberFlags2[GuildMemberFlags2["IsGuest"] = 16] = "IsGuest";
      GuildMemberFlags2[GuildMemberFlags2["StartedHomeActions"] = 32] = "StartedHomeActions";
      GuildMemberFlags2[GuildMemberFlags2["CompletedHomeActions"] = 64] = "CompletedHomeActions";
      GuildMemberFlags2[GuildMemberFlags2["AutomodQuarantinedUsernameOrGuildNickname"] = 128] = "AutomodQuarantinedUsernameOrGuildNickname";
      GuildMemberFlags2[GuildMemberFlags2["AutomodQuarantinedBio"] = 256] = "AutomodQuarantinedBio";
      GuildMemberFlags2[GuildMemberFlags2["DmSettingsUpsellAcknowledged"] = 512] = "DmSettingsUpsellAcknowledged";
    })(GuildMemberFlags || (exports2.GuildMemberFlags = GuildMemberFlags = {}));
    var IntegrationExpireBehavior;
    (function(IntegrationExpireBehavior2) {
      IntegrationExpireBehavior2[IntegrationExpireBehavior2["RemoveRole"] = 0] = "RemoveRole";
      IntegrationExpireBehavior2[IntegrationExpireBehavior2["Kick"] = 1] = "Kick";
    })(IntegrationExpireBehavior || (exports2.IntegrationExpireBehavior = IntegrationExpireBehavior = {}));
    var GuildWidgetStyle;
    (function(GuildWidgetStyle2) {
      GuildWidgetStyle2["Shield"] = "shield";
      GuildWidgetStyle2["Banner1"] = "banner1";
      GuildWidgetStyle2["Banner2"] = "banner2";
      GuildWidgetStyle2["Banner3"] = "banner3";
      GuildWidgetStyle2["Banner4"] = "banner4";
    })(GuildWidgetStyle || (exports2.GuildWidgetStyle = GuildWidgetStyle = {}));
    var MembershipScreeningFieldType;
    (function(MembershipScreeningFieldType2) {
      MembershipScreeningFieldType2["Terms"] = "TERMS";
    })(MembershipScreeningFieldType || (exports2.MembershipScreeningFieldType = MembershipScreeningFieldType = {}));
    var GuildOnboardingMode;
    (function(GuildOnboardingMode2) {
      GuildOnboardingMode2[GuildOnboardingMode2["OnboardingDefault"] = 0] = "OnboardingDefault";
      GuildOnboardingMode2[GuildOnboardingMode2["OnboardingAdvanced"] = 1] = "OnboardingAdvanced";
    })(GuildOnboardingMode || (exports2.GuildOnboardingMode = GuildOnboardingMode = {}));
    var GuildOnboardingPromptType;
    (function(GuildOnboardingPromptType2) {
      GuildOnboardingPromptType2[GuildOnboardingPromptType2["MultipleChoice"] = 0] = "MultipleChoice";
      GuildOnboardingPromptType2[GuildOnboardingPromptType2["Dropdown"] = 1] = "Dropdown";
    })(GuildOnboardingPromptType || (exports2.GuildOnboardingPromptType = GuildOnboardingPromptType = {}));
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/guildScheduledEvent.js
var require_guildScheduledEvent = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/guildScheduledEvent.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GuildScheduledEventPrivacyLevel = exports2.GuildScheduledEventStatus = exports2.GuildScheduledEventEntityType = exports2.GuildScheduledEventRecurrenceRuleMonth = exports2.GuildScheduledEventRecurrenceRuleWeekday = exports2.GuildScheduledEventRecurrenceRuleFrequency = void 0;
    var GuildScheduledEventRecurrenceRuleFrequency;
    (function(GuildScheduledEventRecurrenceRuleFrequency2) {
      GuildScheduledEventRecurrenceRuleFrequency2[GuildScheduledEventRecurrenceRuleFrequency2["Yearly"] = 0] = "Yearly";
      GuildScheduledEventRecurrenceRuleFrequency2[GuildScheduledEventRecurrenceRuleFrequency2["Monthly"] = 1] = "Monthly";
      GuildScheduledEventRecurrenceRuleFrequency2[GuildScheduledEventRecurrenceRuleFrequency2["Weekly"] = 2] = "Weekly";
      GuildScheduledEventRecurrenceRuleFrequency2[GuildScheduledEventRecurrenceRuleFrequency2["Daily"] = 3] = "Daily";
    })(GuildScheduledEventRecurrenceRuleFrequency || (exports2.GuildScheduledEventRecurrenceRuleFrequency = GuildScheduledEventRecurrenceRuleFrequency = {}));
    var GuildScheduledEventRecurrenceRuleWeekday;
    (function(GuildScheduledEventRecurrenceRuleWeekday2) {
      GuildScheduledEventRecurrenceRuleWeekday2[GuildScheduledEventRecurrenceRuleWeekday2["Monday"] = 0] = "Monday";
      GuildScheduledEventRecurrenceRuleWeekday2[GuildScheduledEventRecurrenceRuleWeekday2["Tuesday"] = 1] = "Tuesday";
      GuildScheduledEventRecurrenceRuleWeekday2[GuildScheduledEventRecurrenceRuleWeekday2["Wednesday"] = 2] = "Wednesday";
      GuildScheduledEventRecurrenceRuleWeekday2[GuildScheduledEventRecurrenceRuleWeekday2["Thursday"] = 3] = "Thursday";
      GuildScheduledEventRecurrenceRuleWeekday2[GuildScheduledEventRecurrenceRuleWeekday2["Friday"] = 4] = "Friday";
      GuildScheduledEventRecurrenceRuleWeekday2[GuildScheduledEventRecurrenceRuleWeekday2["Saturday"] = 5] = "Saturday";
      GuildScheduledEventRecurrenceRuleWeekday2[GuildScheduledEventRecurrenceRuleWeekday2["Sunday"] = 6] = "Sunday";
    })(GuildScheduledEventRecurrenceRuleWeekday || (exports2.GuildScheduledEventRecurrenceRuleWeekday = GuildScheduledEventRecurrenceRuleWeekday = {}));
    var GuildScheduledEventRecurrenceRuleMonth;
    (function(GuildScheduledEventRecurrenceRuleMonth2) {
      GuildScheduledEventRecurrenceRuleMonth2[GuildScheduledEventRecurrenceRuleMonth2["January"] = 1] = "January";
      GuildScheduledEventRecurrenceRuleMonth2[GuildScheduledEventRecurrenceRuleMonth2["February"] = 2] = "February";
      GuildScheduledEventRecurrenceRuleMonth2[GuildScheduledEventRecurrenceRuleMonth2["March"] = 3] = "March";
      GuildScheduledEventRecurrenceRuleMonth2[GuildScheduledEventRecurrenceRuleMonth2["April"] = 4] = "April";
      GuildScheduledEventRecurrenceRuleMonth2[GuildScheduledEventRecurrenceRuleMonth2["May"] = 5] = "May";
      GuildScheduledEventRecurrenceRuleMonth2[GuildScheduledEventRecurrenceRuleMonth2["June"] = 6] = "June";
      GuildScheduledEventRecurrenceRuleMonth2[GuildScheduledEventRecurrenceRuleMonth2["July"] = 7] = "July";
      GuildScheduledEventRecurrenceRuleMonth2[GuildScheduledEventRecurrenceRuleMonth2["August"] = 8] = "August";
      GuildScheduledEventRecurrenceRuleMonth2[GuildScheduledEventRecurrenceRuleMonth2["September"] = 9] = "September";
      GuildScheduledEventRecurrenceRuleMonth2[GuildScheduledEventRecurrenceRuleMonth2["October"] = 10] = "October";
      GuildScheduledEventRecurrenceRuleMonth2[GuildScheduledEventRecurrenceRuleMonth2["November"] = 11] = "November";
      GuildScheduledEventRecurrenceRuleMonth2[GuildScheduledEventRecurrenceRuleMonth2["December"] = 12] = "December";
    })(GuildScheduledEventRecurrenceRuleMonth || (exports2.GuildScheduledEventRecurrenceRuleMonth = GuildScheduledEventRecurrenceRuleMonth = {}));
    var GuildScheduledEventEntityType;
    (function(GuildScheduledEventEntityType2) {
      GuildScheduledEventEntityType2[GuildScheduledEventEntityType2["StageInstance"] = 1] = "StageInstance";
      GuildScheduledEventEntityType2[GuildScheduledEventEntityType2["Voice"] = 2] = "Voice";
      GuildScheduledEventEntityType2[GuildScheduledEventEntityType2["External"] = 3] = "External";
    })(GuildScheduledEventEntityType || (exports2.GuildScheduledEventEntityType = GuildScheduledEventEntityType = {}));
    var GuildScheduledEventStatus;
    (function(GuildScheduledEventStatus2) {
      GuildScheduledEventStatus2[GuildScheduledEventStatus2["Scheduled"] = 1] = "Scheduled";
      GuildScheduledEventStatus2[GuildScheduledEventStatus2["Active"] = 2] = "Active";
      GuildScheduledEventStatus2[GuildScheduledEventStatus2["Completed"] = 3] = "Completed";
      GuildScheduledEventStatus2[GuildScheduledEventStatus2["Canceled"] = 4] = "Canceled";
    })(GuildScheduledEventStatus || (exports2.GuildScheduledEventStatus = GuildScheduledEventStatus = {}));
    var GuildScheduledEventPrivacyLevel;
    (function(GuildScheduledEventPrivacyLevel2) {
      GuildScheduledEventPrivacyLevel2[GuildScheduledEventPrivacyLevel2["GuildOnly"] = 2] = "GuildOnly";
    })(GuildScheduledEventPrivacyLevel || (exports2.GuildScheduledEventPrivacyLevel = GuildScheduledEventPrivacyLevel = {}));
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/_interactions/_applicationCommands/_chatInput/attachment.js
var require_attachment = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/_interactions/_applicationCommands/_chatInput/attachment.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/_interactions/_applicationCommands/_chatInput/base.js
var require_base = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/_interactions/_applicationCommands/_chatInput/base.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/_interactions/_applicationCommands/_chatInput/boolean.js
var require_boolean = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/_interactions/_applicationCommands/_chatInput/boolean.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/_interactions/_applicationCommands/_chatInput/channel.js
var require_channel2 = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/_interactions/_applicationCommands/_chatInput/channel.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/_interactions/_applicationCommands/_chatInput/integer.js
var require_integer = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/_interactions/_applicationCommands/_chatInput/integer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/_interactions/_applicationCommands/_chatInput/mentionable.js
var require_mentionable = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/_interactions/_applicationCommands/_chatInput/mentionable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/_interactions/_applicationCommands/_chatInput/number.js
var require_number = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/_interactions/_applicationCommands/_chatInput/number.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/_interactions/_applicationCommands/_chatInput/role.js
var require_role = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/_interactions/_applicationCommands/_chatInput/role.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/_interactions/_applicationCommands/_chatInput/shared.js
var require_shared = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/_interactions/_applicationCommands/_chatInput/shared.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApplicationCommandOptionType = void 0;
    var ApplicationCommandOptionType;
    (function(ApplicationCommandOptionType2) {
      ApplicationCommandOptionType2[ApplicationCommandOptionType2["Subcommand"] = 1] = "Subcommand";
      ApplicationCommandOptionType2[ApplicationCommandOptionType2["SubcommandGroup"] = 2] = "SubcommandGroup";
      ApplicationCommandOptionType2[ApplicationCommandOptionType2["String"] = 3] = "String";
      ApplicationCommandOptionType2[ApplicationCommandOptionType2["Integer"] = 4] = "Integer";
      ApplicationCommandOptionType2[ApplicationCommandOptionType2["Boolean"] = 5] = "Boolean";
      ApplicationCommandOptionType2[ApplicationCommandOptionType2["User"] = 6] = "User";
      ApplicationCommandOptionType2[ApplicationCommandOptionType2["Channel"] = 7] = "Channel";
      ApplicationCommandOptionType2[ApplicationCommandOptionType2["Role"] = 8] = "Role";
      ApplicationCommandOptionType2[ApplicationCommandOptionType2["Mentionable"] = 9] = "Mentionable";
      ApplicationCommandOptionType2[ApplicationCommandOptionType2["Number"] = 10] = "Number";
      ApplicationCommandOptionType2[ApplicationCommandOptionType2["Attachment"] = 11] = "Attachment";
    })(ApplicationCommandOptionType || (exports2.ApplicationCommandOptionType = ApplicationCommandOptionType = {}));
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/_interactions/_applicationCommands/_chatInput/string.js
var require_string = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/_interactions/_applicationCommands/_chatInput/string.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/_interactions/_applicationCommands/_chatInput/subcommand.js
var require_subcommand = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/_interactions/_applicationCommands/_chatInput/subcommand.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/_interactions/_applicationCommands/_chatInput/subcommandGroup.js
var require_subcommandGroup = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/_interactions/_applicationCommands/_chatInput/subcommandGroup.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/_interactions/_applicationCommands/_chatInput/user.js
var require_user = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/_interactions/_applicationCommands/_chatInput/user.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/_interactions/_applicationCommands/chatInput.js
var require_chatInput = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/_interactions/_applicationCommands/chatInput.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_attachment(), exports2);
    __exportStar(require_base(), exports2);
    __exportStar(require_boolean(), exports2);
    __exportStar(require_channel2(), exports2);
    __exportStar(require_integer(), exports2);
    __exportStar(require_mentionable(), exports2);
    __exportStar(require_number(), exports2);
    __exportStar(require_role(), exports2);
    __exportStar(require_shared(), exports2);
    __exportStar(require_string(), exports2);
    __exportStar(require_subcommand(), exports2);
    __exportStar(require_subcommandGroup(), exports2);
    __exportStar(require_user(), exports2);
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/_interactions/_applicationCommands/contextMenu.js
var require_contextMenu = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/_interactions/_applicationCommands/contextMenu.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/_interactions/_applicationCommands/permissions.js
var require_permissions = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/_interactions/_applicationCommands/permissions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.APIApplicationCommandPermissionsConstant = exports2.ApplicationCommandPermissionType = void 0;
    var ApplicationCommandPermissionType;
    (function(ApplicationCommandPermissionType2) {
      ApplicationCommandPermissionType2[ApplicationCommandPermissionType2["Role"] = 1] = "Role";
      ApplicationCommandPermissionType2[ApplicationCommandPermissionType2["User"] = 2] = "User";
      ApplicationCommandPermissionType2[ApplicationCommandPermissionType2["Channel"] = 3] = "Channel";
    })(ApplicationCommandPermissionType || (exports2.ApplicationCommandPermissionType = ApplicationCommandPermissionType = {}));
    exports2.APIApplicationCommandPermissionsConstant = {
      // eslint-disable-next-line unicorn/prefer-native-coercion-functions
      Everyone: (guildId) => String(guildId),
      AllChannels: (guildId) => String(BigInt(guildId) - 1n)
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/_interactions/_applicationCommands/entryPoint.js
var require_entryPoint = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/_interactions/_applicationCommands/entryPoint.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/_interactions/applicationCommands.js
var require_applicationCommands = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/_interactions/applicationCommands.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EntryPointCommandHandlerType = exports2.InteractionContextType = exports2.ApplicationIntegrationType = exports2.ApplicationCommandType = void 0;
    __exportStar(require_chatInput(), exports2);
    __exportStar(require_contextMenu(), exports2);
    __exportStar(require_permissions(), exports2);
    __exportStar(require_entryPoint(), exports2);
    var ApplicationCommandType;
    (function(ApplicationCommandType2) {
      ApplicationCommandType2[ApplicationCommandType2["ChatInput"] = 1] = "ChatInput";
      ApplicationCommandType2[ApplicationCommandType2["User"] = 2] = "User";
      ApplicationCommandType2[ApplicationCommandType2["Message"] = 3] = "Message";
      ApplicationCommandType2[ApplicationCommandType2["PrimaryEntryPoint"] = 4] = "PrimaryEntryPoint";
    })(ApplicationCommandType || (exports2.ApplicationCommandType = ApplicationCommandType = {}));
    var ApplicationIntegrationType;
    (function(ApplicationIntegrationType2) {
      ApplicationIntegrationType2[ApplicationIntegrationType2["GuildInstall"] = 0] = "GuildInstall";
      ApplicationIntegrationType2[ApplicationIntegrationType2["UserInstall"] = 1] = "UserInstall";
    })(ApplicationIntegrationType || (exports2.ApplicationIntegrationType = ApplicationIntegrationType = {}));
    var InteractionContextType;
    (function(InteractionContextType2) {
      InteractionContextType2[InteractionContextType2["Guild"] = 0] = "Guild";
      InteractionContextType2[InteractionContextType2["BotDM"] = 1] = "BotDM";
      InteractionContextType2[InteractionContextType2["PrivateChannel"] = 2] = "PrivateChannel";
    })(InteractionContextType || (exports2.InteractionContextType = InteractionContextType = {}));
    var EntryPointCommandHandlerType;
    (function(EntryPointCommandHandlerType2) {
      EntryPointCommandHandlerType2[EntryPointCommandHandlerType2["AppHandler"] = 1] = "AppHandler";
      EntryPointCommandHandlerType2[EntryPointCommandHandlerType2["DiscordLaunchActivity"] = 2] = "DiscordLaunchActivity";
    })(EntryPointCommandHandlerType || (exports2.EntryPointCommandHandlerType = EntryPointCommandHandlerType = {}));
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/_interactions/autocomplete.js
var require_autocomplete = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/_interactions/autocomplete.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/_interactions/base.js
var require_base2 = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/_interactions/base.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/_interactions/messageComponents.js
var require_messageComponents = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/_interactions/messageComponents.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/_interactions/modalSubmit.js
var require_modalSubmit = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/_interactions/modalSubmit.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/_interactions/ping.js
var require_ping = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/_interactions/ping.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/_interactions/responses.js
var require_responses = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/_interactions/responses.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InteractionResponseType = exports2.InteractionType = void 0;
    var InteractionType;
    (function(InteractionType2) {
      InteractionType2[InteractionType2["Ping"] = 1] = "Ping";
      InteractionType2[InteractionType2["ApplicationCommand"] = 2] = "ApplicationCommand";
      InteractionType2[InteractionType2["MessageComponent"] = 3] = "MessageComponent";
      InteractionType2[InteractionType2["ApplicationCommandAutocomplete"] = 4] = "ApplicationCommandAutocomplete";
      InteractionType2[InteractionType2["ModalSubmit"] = 5] = "ModalSubmit";
    })(InteractionType || (exports2.InteractionType = InteractionType = {}));
    var InteractionResponseType;
    (function(InteractionResponseType2) {
      InteractionResponseType2[InteractionResponseType2["Pong"] = 1] = "Pong";
      InteractionResponseType2[InteractionResponseType2["ChannelMessageWithSource"] = 4] = "ChannelMessageWithSource";
      InteractionResponseType2[InteractionResponseType2["DeferredChannelMessageWithSource"] = 5] = "DeferredChannelMessageWithSource";
      InteractionResponseType2[InteractionResponseType2["DeferredMessageUpdate"] = 6] = "DeferredMessageUpdate";
      InteractionResponseType2[InteractionResponseType2["UpdateMessage"] = 7] = "UpdateMessage";
      InteractionResponseType2[InteractionResponseType2["ApplicationCommandAutocompleteResult"] = 8] = "ApplicationCommandAutocompleteResult";
      InteractionResponseType2[InteractionResponseType2["Modal"] = 9] = "Modal";
      InteractionResponseType2[InteractionResponseType2["PremiumRequired"] = 10] = "PremiumRequired";
      InteractionResponseType2[InteractionResponseType2["LaunchActivity"] = 12] = "LaunchActivity";
    })(InteractionResponseType || (exports2.InteractionResponseType = InteractionResponseType = {}));
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/interactions.js
var require_interactions = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/interactions.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_applicationCommands(), exports2);
    __exportStar(require_autocomplete(), exports2);
    __exportStar(require_base2(), exports2);
    __exportStar(require_messageComponents(), exports2);
    __exportStar(require_modalSubmit(), exports2);
    __exportStar(require_ping(), exports2);
    __exportStar(require_responses(), exports2);
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/invite.js
var require_invite = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/invite.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InviteTargetType = exports2.InviteType = void 0;
    var InviteType;
    (function(InviteType2) {
      InviteType2[InviteType2["Guild"] = 0] = "Guild";
      InviteType2[InviteType2["GroupDM"] = 1] = "GroupDM";
      InviteType2[InviteType2["Friend"] = 2] = "Friend";
    })(InviteType || (exports2.InviteType = InviteType = {}));
    var InviteTargetType;
    (function(InviteTargetType2) {
      InviteTargetType2[InviteTargetType2["Stream"] = 1] = "Stream";
      InviteTargetType2[InviteTargetType2["EmbeddedApplication"] = 2] = "EmbeddedApplication";
    })(InviteTargetType || (exports2.InviteTargetType = InviteTargetType = {}));
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/monetization.js
var require_monetization = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/monetization.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SubscriptionStatus = exports2.SKUType = exports2.SKUFlags = exports2.EntitlementType = void 0;
    var EntitlementType;
    (function(EntitlementType2) {
      EntitlementType2[EntitlementType2["Purchase"] = 1] = "Purchase";
      EntitlementType2[EntitlementType2["PremiumSubscription"] = 2] = "PremiumSubscription";
      EntitlementType2[EntitlementType2["DeveloperGift"] = 3] = "DeveloperGift";
      EntitlementType2[EntitlementType2["TestModePurchase"] = 4] = "TestModePurchase";
      EntitlementType2[EntitlementType2["FreePurchase"] = 5] = "FreePurchase";
      EntitlementType2[EntitlementType2["UserGift"] = 6] = "UserGift";
      EntitlementType2[EntitlementType2["PremiumPurchase"] = 7] = "PremiumPurchase";
      EntitlementType2[EntitlementType2["ApplicationSubscription"] = 8] = "ApplicationSubscription";
    })(EntitlementType || (exports2.EntitlementType = EntitlementType = {}));
    var SKUFlags;
    (function(SKUFlags2) {
      SKUFlags2[SKUFlags2["Available"] = 4] = "Available";
      SKUFlags2[SKUFlags2["GuildSubscription"] = 128] = "GuildSubscription";
      SKUFlags2[SKUFlags2["UserSubscription"] = 256] = "UserSubscription";
    })(SKUFlags || (exports2.SKUFlags = SKUFlags = {}));
    var SKUType;
    (function(SKUType2) {
      SKUType2[SKUType2["Durable"] = 2] = "Durable";
      SKUType2[SKUType2["Consumable"] = 3] = "Consumable";
      SKUType2[SKUType2["Subscription"] = 5] = "Subscription";
      SKUType2[SKUType2["SubscriptionGroup"] = 6] = "SubscriptionGroup";
    })(SKUType || (exports2.SKUType = SKUType = {}));
    var SubscriptionStatus;
    (function(SubscriptionStatus2) {
      SubscriptionStatus2[SubscriptionStatus2["Active"] = 0] = "Active";
      SubscriptionStatus2[SubscriptionStatus2["Ending"] = 1] = "Ending";
      SubscriptionStatus2[SubscriptionStatus2["Inactive"] = 2] = "Inactive";
    })(SubscriptionStatus || (exports2.SubscriptionStatus = SubscriptionStatus = {}));
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/oauth2.js
var require_oauth2 = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/oauth2.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OAuth2Scopes = void 0;
    var OAuth2Scopes;
    (function(OAuth2Scopes2) {
      OAuth2Scopes2["Bot"] = "bot";
      OAuth2Scopes2["Connections"] = "connections";
      OAuth2Scopes2["DMChannelsRead"] = "dm_channels.read";
      OAuth2Scopes2["Email"] = "email";
      OAuth2Scopes2["Identify"] = "identify";
      OAuth2Scopes2["Guilds"] = "guilds";
      OAuth2Scopes2["GuildsJoin"] = "guilds.join";
      OAuth2Scopes2["GuildsMembersRead"] = "guilds.members.read";
      OAuth2Scopes2["GroupDMJoins"] = "gdm.join";
      OAuth2Scopes2["MessagesRead"] = "messages.read";
      OAuth2Scopes2["RoleConnectionsWrite"] = "role_connections.write";
      OAuth2Scopes2["RPC"] = "rpc";
      OAuth2Scopes2["RPCNotificationsRead"] = "rpc.notifications.read";
      OAuth2Scopes2["WebhookIncoming"] = "webhook.incoming";
      OAuth2Scopes2["Voice"] = "voice";
      OAuth2Scopes2["ApplicationsBuildsUpload"] = "applications.builds.upload";
      OAuth2Scopes2["ApplicationsBuildsRead"] = "applications.builds.read";
      OAuth2Scopes2["ApplicationsStoreUpdate"] = "applications.store.update";
      OAuth2Scopes2["ApplicationsEntitlements"] = "applications.entitlements";
      OAuth2Scopes2["RelationshipsRead"] = "relationships.read";
      OAuth2Scopes2["ActivitiesRead"] = "activities.read";
      OAuth2Scopes2["ActivitiesWrite"] = "activities.write";
      OAuth2Scopes2["ApplicationsCommands"] = "applications.commands";
      OAuth2Scopes2["ApplicationsCommandsUpdate"] = "applications.commands.update";
      OAuth2Scopes2["ApplicationCommandsPermissionsUpdate"] = "applications.commands.permissions.update";
    })(OAuth2Scopes || (exports2.OAuth2Scopes = OAuth2Scopes = {}));
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/permissions.js
var require_permissions2 = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/permissions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RoleFlags = void 0;
    var RoleFlags;
    (function(RoleFlags2) {
      RoleFlags2[RoleFlags2["InPrompt"] = 1] = "InPrompt";
    })(RoleFlags || (exports2.RoleFlags = RoleFlags = {}));
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/poll.js
var require_poll = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/poll.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PollLayoutType = void 0;
    var PollLayoutType;
    (function(PollLayoutType2) {
      PollLayoutType2[PollLayoutType2["Default"] = 1] = "Default";
    })(PollLayoutType || (exports2.PollLayoutType = PollLayoutType = {}));
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/soundboard.js
var require_soundboard = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/soundboard.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/stageInstance.js
var require_stageInstance = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/stageInstance.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.StageInstancePrivacyLevel = void 0;
    var StageInstancePrivacyLevel;
    (function(StageInstancePrivacyLevel2) {
      StageInstancePrivacyLevel2[StageInstancePrivacyLevel2["Public"] = 1] = "Public";
      StageInstancePrivacyLevel2[StageInstancePrivacyLevel2["GuildOnly"] = 2] = "GuildOnly";
    })(StageInstancePrivacyLevel || (exports2.StageInstancePrivacyLevel = StageInstancePrivacyLevel = {}));
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/sticker.js
var require_sticker = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/sticker.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.StickerFormatType = exports2.StickerType = void 0;
    var StickerType;
    (function(StickerType2) {
      StickerType2[StickerType2["Standard"] = 1] = "Standard";
      StickerType2[StickerType2["Guild"] = 2] = "Guild";
    })(StickerType || (exports2.StickerType = StickerType = {}));
    var StickerFormatType;
    (function(StickerFormatType2) {
      StickerFormatType2[StickerFormatType2["PNG"] = 1] = "PNG";
      StickerFormatType2[StickerFormatType2["APNG"] = 2] = "APNG";
      StickerFormatType2[StickerFormatType2["Lottie"] = 3] = "Lottie";
      StickerFormatType2[StickerFormatType2["GIF"] = 4] = "GIF";
    })(StickerFormatType || (exports2.StickerFormatType = StickerFormatType = {}));
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/teams.js
var require_teams = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/teams.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TeamMemberRole = exports2.TeamMemberMembershipState = void 0;
    var TeamMemberMembershipState;
    (function(TeamMemberMembershipState2) {
      TeamMemberMembershipState2[TeamMemberMembershipState2["Invited"] = 1] = "Invited";
      TeamMemberMembershipState2[TeamMemberMembershipState2["Accepted"] = 2] = "Accepted";
    })(TeamMemberMembershipState || (exports2.TeamMemberMembershipState = TeamMemberMembershipState = {}));
    var TeamMemberRole;
    (function(TeamMemberRole2) {
      TeamMemberRole2["Admin"] = "admin";
      TeamMemberRole2["Developer"] = "developer";
      TeamMemberRole2["ReadOnly"] = "read_only";
    })(TeamMemberRole || (exports2.TeamMemberRole = TeamMemberRole = {}));
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/template.js
var require_template = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/template.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/user.js
var require_user2 = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/user.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConnectionVisibility = exports2.ConnectionService = exports2.UserPremiumType = exports2.UserFlags = void 0;
    var UserFlags;
    (function(UserFlags2) {
      UserFlags2[UserFlags2["Staff"] = 1] = "Staff";
      UserFlags2[UserFlags2["Partner"] = 2] = "Partner";
      UserFlags2[UserFlags2["Hypesquad"] = 4] = "Hypesquad";
      UserFlags2[UserFlags2["BugHunterLevel1"] = 8] = "BugHunterLevel1";
      UserFlags2[UserFlags2["MFASMS"] = 16] = "MFASMS";
      UserFlags2[UserFlags2["PremiumPromoDismissed"] = 32] = "PremiumPromoDismissed";
      UserFlags2[UserFlags2["HypeSquadOnlineHouse1"] = 64] = "HypeSquadOnlineHouse1";
      UserFlags2[UserFlags2["HypeSquadOnlineHouse2"] = 128] = "HypeSquadOnlineHouse2";
      UserFlags2[UserFlags2["HypeSquadOnlineHouse3"] = 256] = "HypeSquadOnlineHouse3";
      UserFlags2[UserFlags2["PremiumEarlySupporter"] = 512] = "PremiumEarlySupporter";
      UserFlags2[UserFlags2["TeamPseudoUser"] = 1024] = "TeamPseudoUser";
      UserFlags2[UserFlags2["HasUnreadUrgentMessages"] = 8192] = "HasUnreadUrgentMessages";
      UserFlags2[UserFlags2["BugHunterLevel2"] = 16384] = "BugHunterLevel2";
      UserFlags2[UserFlags2["VerifiedBot"] = 65536] = "VerifiedBot";
      UserFlags2[UserFlags2["VerifiedDeveloper"] = 131072] = "VerifiedDeveloper";
      UserFlags2[UserFlags2["CertifiedModerator"] = 262144] = "CertifiedModerator";
      UserFlags2[UserFlags2["BotHTTPInteractions"] = 524288] = "BotHTTPInteractions";
      UserFlags2[UserFlags2["Spammer"] = 1048576] = "Spammer";
      UserFlags2[UserFlags2["DisablePremium"] = 2097152] = "DisablePremium";
      UserFlags2[UserFlags2["ActiveDeveloper"] = 4194304] = "ActiveDeveloper";
      UserFlags2[UserFlags2["Quarantined"] = 17592186044416] = "Quarantined";
      UserFlags2[UserFlags2["Collaborator"] = 1125899906842624] = "Collaborator";
      UserFlags2[UserFlags2["RestrictedCollaborator"] = 2251799813685248] = "RestrictedCollaborator";
    })(UserFlags || (exports2.UserFlags = UserFlags = {}));
    var UserPremiumType;
    (function(UserPremiumType2) {
      UserPremiumType2[UserPremiumType2["None"] = 0] = "None";
      UserPremiumType2[UserPremiumType2["NitroClassic"] = 1] = "NitroClassic";
      UserPremiumType2[UserPremiumType2["Nitro"] = 2] = "Nitro";
      UserPremiumType2[UserPremiumType2["NitroBasic"] = 3] = "NitroBasic";
    })(UserPremiumType || (exports2.UserPremiumType = UserPremiumType = {}));
    var ConnectionService;
    (function(ConnectionService2) {
      ConnectionService2["AmazonMusic"] = "amazon-music";
      ConnectionService2["BattleNet"] = "battlenet";
      ConnectionService2["Bluesky"] = "bluesky";
      ConnectionService2["BungieNet"] = "bungie";
      ConnectionService2["Crunchyroll"] = "crunchyroll";
      ConnectionService2["Domain"] = "domain";
      ConnectionService2["eBay"] = "ebay";
      ConnectionService2["EpicGames"] = "epicgames";
      ConnectionService2["Facebook"] = "facebook";
      ConnectionService2["GitHub"] = "github";
      ConnectionService2["Instagram"] = "instagram";
      ConnectionService2["LeagueOfLegends"] = "leagueoflegends";
      ConnectionService2["Mastodon"] = "mastodon";
      ConnectionService2["PayPal"] = "paypal";
      ConnectionService2["PlayStationNetwork"] = "playstation";
      ConnectionService2["Reddit"] = "reddit";
      ConnectionService2["RiotGames"] = "riotgames";
      ConnectionService2["Roblox"] = "roblox";
      ConnectionService2["Spotify"] = "spotify";
      ConnectionService2["Skype"] = "skype";
      ConnectionService2["Steam"] = "steam";
      ConnectionService2["TikTok"] = "tiktok";
      ConnectionService2["Twitch"] = "twitch";
      ConnectionService2["X"] = "twitter";
      ConnectionService2["Twitter"] = "twitter";
      ConnectionService2["Xbox"] = "xbox";
      ConnectionService2["YouTube"] = "youtube";
    })(ConnectionService || (exports2.ConnectionService = ConnectionService = {}));
    var ConnectionVisibility;
    (function(ConnectionVisibility2) {
      ConnectionVisibility2[ConnectionVisibility2["None"] = 0] = "None";
      ConnectionVisibility2[ConnectionVisibility2["Everyone"] = 1] = "Everyone";
    })(ConnectionVisibility || (exports2.ConnectionVisibility = ConnectionVisibility = {}));
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/voice.js
var require_voice = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/voice.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/webhook.js
var require_webhook = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/webhook.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WebhookType = exports2.ApplicationWebhookEventType = exports2.ApplicationWebhookType = void 0;
    var ApplicationWebhookType;
    (function(ApplicationWebhookType2) {
      ApplicationWebhookType2[ApplicationWebhookType2["Ping"] = 0] = "Ping";
      ApplicationWebhookType2[ApplicationWebhookType2["Event"] = 1] = "Event";
    })(ApplicationWebhookType || (exports2.ApplicationWebhookType = ApplicationWebhookType = {}));
    var ApplicationWebhookEventType;
    (function(ApplicationWebhookEventType2) {
      ApplicationWebhookEventType2["ApplicationAuthorized"] = "APPLICATION_AUTHORIZED";
      ApplicationWebhookEventType2["EntitlementCreate"] = "ENTITLEMENT_CREATE";
      ApplicationWebhookEventType2["QuestUserEnrollment"] = "QUEST_USER_ENROLLMENT";
    })(ApplicationWebhookEventType || (exports2.ApplicationWebhookEventType = ApplicationWebhookEventType = {}));
    var WebhookType;
    (function(WebhookType2) {
      WebhookType2[WebhookType2["Incoming"] = 1] = "Incoming";
      WebhookType2[WebhookType2["ChannelFollower"] = 2] = "ChannelFollower";
      WebhookType2[WebhookType2["Application"] = 3] = "Application";
    })(WebhookType || (exports2.WebhookType = WebhookType = {}));
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/index.js
var require_v92 = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/payloads/v9/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_common2(), exports2);
    __exportStar(require_application(), exports2);
    __exportStar(require_auditLog(), exports2);
    __exportStar(require_autoModeration(), exports2);
    __exportStar(require_channel(), exports2);
    __exportStar(require_emoji(), exports2);
    __exportStar(require_gateway(), exports2);
    __exportStar(require_guild(), exports2);
    __exportStar(require_guildScheduledEvent(), exports2);
    __exportStar(require_interactions(), exports2);
    __exportStar(require_invite(), exports2);
    __exportStar(require_monetization(), exports2);
    __exportStar(require_oauth2(), exports2);
    __exportStar(require_permissions2(), exports2);
    __exportStar(require_poll(), exports2);
    __exportStar(require_soundboard(), exports2);
    __exportStar(require_stageInstance(), exports2);
    __exportStar(require_sticker(), exports2);
    __exportStar(require_teams(), exports2);
    __exportStar(require_template(), exports2);
    __exportStar(require_user2(), exports2);
    __exportStar(require_voice(), exports2);
    __exportStar(require_webhook(), exports2);
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/utils/internals.js
var require_internals = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/utils/internals.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.urlSafeCharacters = void 0;
    var pattern = /^[\d%A-Za-z-]+$/g;
    exports2.urlSafeCharacters = {
      test(input) {
        const result = pattern.test(input);
        pattern.lastIndex = 0;
        return result;
      }
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/rest/common.js
var require_common3 = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/rest/common.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Locale = exports2.RESTJSONErrorCodes = void 0;
    var RESTJSONErrorCodes;
    (function(RESTJSONErrorCodes2) {
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["GeneralError"] = 0] = "GeneralError";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownAccount"] = 10001] = "UnknownAccount";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownApplication"] = 10002] = "UnknownApplication";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownChannel"] = 10003] = "UnknownChannel";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownGuild"] = 10004] = "UnknownGuild";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownIntegration"] = 10005] = "UnknownIntegration";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownInvite"] = 10006] = "UnknownInvite";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownMember"] = 10007] = "UnknownMember";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownMessage"] = 10008] = "UnknownMessage";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownPermissionOverwrite"] = 10009] = "UnknownPermissionOverwrite";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownProvider"] = 10010] = "UnknownProvider";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownRole"] = 10011] = "UnknownRole";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownToken"] = 10012] = "UnknownToken";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownUser"] = 10013] = "UnknownUser";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownEmoji"] = 10014] = "UnknownEmoji";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownWebhook"] = 10015] = "UnknownWebhook";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownWebhookService"] = 10016] = "UnknownWebhookService";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownSession"] = 10020] = "UnknownSession";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownAsset"] = 10021] = "UnknownAsset";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownBan"] = 10026] = "UnknownBan";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownSKU"] = 10027] = "UnknownSKU";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownStoreListing"] = 10028] = "UnknownStoreListing";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownEntitlement"] = 10029] = "UnknownEntitlement";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownBuild"] = 10030] = "UnknownBuild";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownLobby"] = 10031] = "UnknownLobby";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownBranch"] = 10032] = "UnknownBranch";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownStoreDirectoryLayout"] = 10033] = "UnknownStoreDirectoryLayout";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownRedistributable"] = 10036] = "UnknownRedistributable";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownGiftCode"] = 10038] = "UnknownGiftCode";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownStream"] = 10049] = "UnknownStream";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownPremiumServerSubscribeCooldown"] = 10050] = "UnknownPremiumServerSubscribeCooldown";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownGuildTemplate"] = 10057] = "UnknownGuildTemplate";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownDiscoverableServerCategory"] = 10059] = "UnknownDiscoverableServerCategory";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownSticker"] = 10060] = "UnknownSticker";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownStickerPack"] = 10061] = "UnknownStickerPack";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownInteraction"] = 10062] = "UnknownInteraction";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownApplicationCommand"] = 10063] = "UnknownApplicationCommand";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownVoiceState"] = 10065] = "UnknownVoiceState";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownApplicationCommandPermissions"] = 10066] = "UnknownApplicationCommandPermissions";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownStageInstance"] = 10067] = "UnknownStageInstance";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownGuildMemberVerificationForm"] = 10068] = "UnknownGuildMemberVerificationForm";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownGuildWelcomeScreen"] = 10069] = "UnknownGuildWelcomeScreen";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownGuildScheduledEvent"] = 10070] = "UnknownGuildScheduledEvent";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownGuildScheduledEventUser"] = 10071] = "UnknownGuildScheduledEventUser";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownTag"] = 10087] = "UnknownTag";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownSound"] = 10097] = "UnknownSound";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["BotsCannotUseThisEndpoint"] = 20001] = "BotsCannotUseThisEndpoint";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["OnlyBotsCanUseThisEndpoint"] = 20002] = "OnlyBotsCanUseThisEndpoint";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ExplicitContentCannotBeSentToTheDesiredRecipient"] = 20009] = "ExplicitContentCannotBeSentToTheDesiredRecipient";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["NotAuthorizedToPerformThisActionOnThisApplication"] = 20012] = "NotAuthorizedToPerformThisActionOnThisApplication";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ActionCannotBePerformedDueToSlowmodeRateLimit"] = 20016] = "ActionCannotBePerformedDueToSlowmodeRateLimit";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["TheMazeIsntMeantForYou"] = 20017] = "TheMazeIsntMeantForYou";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["OnlyTheOwnerOfThisAccountCanPerformThisAction"] = 20018] = "OnlyTheOwnerOfThisAccountCanPerformThisAction";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["AnnouncementEditLimitExceeded"] = 20022] = "AnnouncementEditLimitExceeded";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnderMinimumAge"] = 20024] = "UnderMinimumAge";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ChannelSendRateLimit"] = 20028] = "ChannelSendRateLimit";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ServerSendRateLimit"] = 20029] = "ServerSendRateLimit";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["StageTopicServerNameServerDescriptionOrChannelNamesContainDisallowedWords"] = 20031] = "StageTopicServerNameServerDescriptionOrChannelNamesContainDisallowedWords";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["GuildPremiumSubscriptionLevelTooLow"] = 20035] = "GuildPremiumSubscriptionLevelTooLow";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfGuildsReached"] = 30001] = "MaximumNumberOfGuildsReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfFriendsReached"] = 30002] = "MaximumNumberOfFriendsReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfPinsReachedForTheChannel"] = 30003] = "MaximumNumberOfPinsReachedForTheChannel";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfRecipientsReached"] = 30004] = "MaximumNumberOfRecipientsReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfGuildRolesReached"] = 30005] = "MaximumNumberOfGuildRolesReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfWebhooksReached"] = 30007] = "MaximumNumberOfWebhooksReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfEmojisReached"] = 30008] = "MaximumNumberOfEmojisReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfReactionsReached"] = 30010] = "MaximumNumberOfReactionsReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfGroupDMsReached"] = 30011] = "MaximumNumberOfGroupDMsReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfGuildChannelsReached"] = 30013] = "MaximumNumberOfGuildChannelsReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfAttachmentsInAMessageReached"] = 30015] = "MaximumNumberOfAttachmentsInAMessageReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfInvitesReached"] = 30016] = "MaximumNumberOfInvitesReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfAnimatedEmojisReached"] = 30018] = "MaximumNumberOfAnimatedEmojisReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfServerMembersReached"] = 30019] = "MaximumNumberOfServerMembersReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfServerCategoriesReached"] = 30030] = "MaximumNumberOfServerCategoriesReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["GuildAlreadyHasTemplate"] = 30031] = "GuildAlreadyHasTemplate";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfApplicationCommandsReached"] = 30032] = "MaximumNumberOfApplicationCommandsReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumThreadParticipantsReached"] = 30033] = "MaximumThreadParticipantsReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumDailyApplicationCommandCreatesReached"] = 30034] = "MaximumDailyApplicationCommandCreatesReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfNonGuildMemberBansHasBeenExceeded"] = 30035] = "MaximumNumberOfNonGuildMemberBansHasBeenExceeded";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfBanFetchesHasBeenReached"] = 30037] = "MaximumNumberOfBanFetchesHasBeenReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfUncompletedGuildScheduledEventsReached"] = 30038] = "MaximumNumberOfUncompletedGuildScheduledEventsReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfStickersReached"] = 30039] = "MaximumNumberOfStickersReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfPruneRequestsHasBeenReached"] = 30040] = "MaximumNumberOfPruneRequestsHasBeenReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfGuildWidgetSettingsUpdatesHasBeenReached"] = 30042] = "MaximumNumberOfGuildWidgetSettingsUpdatesHasBeenReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfSoundboardSoundsReached"] = 30045] = "MaximumNumberOfSoundboardSoundsReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfEditsToMessagesOlderThanOneHourReached"] = 30046] = "MaximumNumberOfEditsToMessagesOlderThanOneHourReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfPinnedThreadsInForumHasBeenReached"] = 30047] = "MaximumNumberOfPinnedThreadsInForumHasBeenReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfTagsInForumHasBeenReached"] = 30048] = "MaximumNumberOfTagsInForumHasBeenReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["BitrateIsTooHighForChannelOfThisType"] = 30052] = "BitrateIsTooHighForChannelOfThisType";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfPremiumEmojisReached"] = 30056] = "MaximumNumberOfPremiumEmojisReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfWebhooksPerGuildReached"] = 30058] = "MaximumNumberOfWebhooksPerGuildReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfChannelPermissionOverwritesReached"] = 30060] = "MaximumNumberOfChannelPermissionOverwritesReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["TheChannelsForThisGuildAreTooLarge"] = 30061] = "TheChannelsForThisGuildAreTooLarge";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["Unauthorized"] = 40001] = "Unauthorized";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["VerifyYourAccount"] = 40002] = "VerifyYourAccount";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["OpeningDirectMessagesTooFast"] = 40003] = "OpeningDirectMessagesTooFast";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["SendMessagesHasBeenTemporarilyDisabled"] = 40004] = "SendMessagesHasBeenTemporarilyDisabled";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["RequestEntityTooLarge"] = 40005] = "RequestEntityTooLarge";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["FeatureTemporarilyDisabledServerSide"] = 40006] = "FeatureTemporarilyDisabledServerSide";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UserBannedFromThisGuild"] = 40007] = "UserBannedFromThisGuild";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ConnectionHasBeenRevoked"] = 40012] = "ConnectionHasBeenRevoked";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["OnlyConsumableSKUsCanBeConsumed"] = 40018] = "OnlyConsumableSKUsCanBeConsumed";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["YouCanOnlyDeleteSandboxEntitlements"] = 40019] = "YouCanOnlyDeleteSandboxEntitlements";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["TargetUserIsNotConnectedToVoice"] = 40032] = "TargetUserIsNotConnectedToVoice";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ThisMessageWasAlreadyCrossposted"] = 40033] = "ThisMessageWasAlreadyCrossposted";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ApplicationCommandWithThatNameAlreadyExists"] = 40041] = "ApplicationCommandWithThatNameAlreadyExists";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ApplicationInteractionFailedToSend"] = 40043] = "ApplicationInteractionFailedToSend";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotSendAMessageInAForumChannel"] = 40058] = "CannotSendAMessageInAForumChannel";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InteractionHasAlreadyBeenAcknowledged"] = 40060] = "InteractionHasAlreadyBeenAcknowledged";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["TagNamesMustBeUnique"] = 40061] = "TagNamesMustBeUnique";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ServiceResourceIsBeingRateLimited"] = 40062] = "ServiceResourceIsBeingRateLimited";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ThereAreNoTagsAvailableThatCanBeSetByNonModerators"] = 40066] = "ThereAreNoTagsAvailableThatCanBeSetByNonModerators";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["TagRequiredToCreateAForumPostInThisChannel"] = 40067] = "TagRequiredToCreateAForumPostInThisChannel";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["AnEntitlementHasAlreadyBeenGrantedForThisResource"] = 40074] = "AnEntitlementHasAlreadyBeenGrantedForThisResource";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ThisInteractionHasHitTheMaximumNumberOfFollowUpMessages"] = 40094] = "ThisInteractionHasHitTheMaximumNumberOfFollowUpMessages";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["CloudflareIsBlockingYourRequest"] = 40333] = "CloudflareIsBlockingYourRequest";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MissingAccess"] = 50001] = "MissingAccess";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidAccountType"] = 50002] = "InvalidAccountType";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotExecuteActionOnDMChannel"] = 50003] = "CannotExecuteActionOnDMChannel";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["GuildWidgetDisabled"] = 50004] = "GuildWidgetDisabled";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotEditMessageAuthoredByAnotherUser"] = 50005] = "CannotEditMessageAuthoredByAnotherUser";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotSendAnEmptyMessage"] = 50006] = "CannotSendAnEmptyMessage";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotSendMessagesToThisUser"] = 50007] = "CannotSendMessagesToThisUser";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotSendMessagesInNonTextChannel"] = 50008] = "CannotSendMessagesInNonTextChannel";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ChannelVerificationLevelTooHighForYouToGainAccess"] = 50009] = "ChannelVerificationLevelTooHighForYouToGainAccess";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["OAuth2ApplicationDoesNotHaveBot"] = 50010] = "OAuth2ApplicationDoesNotHaveBot";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["OAuth2ApplicationLimitReached"] = 50011] = "OAuth2ApplicationLimitReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidOAuth2State"] = 50012] = "InvalidOAuth2State";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MissingPermissions"] = 50013] = "MissingPermissions";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidToken"] = 50014] = "InvalidToken";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["NoteWasTooLong"] = 50015] = "NoteWasTooLong";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ProvidedTooFewOrTooManyMessagesToDelete"] = 50016] = "ProvidedTooFewOrTooManyMessagesToDelete";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidMFALevel"] = 50017] = "InvalidMFALevel";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MessageCanOnlyBePinnedInTheChannelItWasSentIn"] = 50019] = "MessageCanOnlyBePinnedInTheChannelItWasSentIn";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InviteCodeInvalidOrTaken"] = 50020] = "InviteCodeInvalidOrTaken";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotExecuteActionOnSystemMessage"] = 50021] = "CannotExecuteActionOnSystemMessage";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotExecuteActionOnThisChannelType"] = 50024] = "CannotExecuteActionOnThisChannelType";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidOAuth2AccessToken"] = 50025] = "InvalidOAuth2AccessToken";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MissingRequiredOAuth2Scope"] = 50026] = "MissingRequiredOAuth2Scope";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidWebhookToken"] = 50027] = "InvalidWebhookToken";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidRole"] = 50028] = "InvalidRole";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidRecipients"] = 50033] = "InvalidRecipients";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["OneOfTheMessagesProvidedWasTooOldForBulkDelete"] = 50034] = "OneOfTheMessagesProvidedWasTooOldForBulkDelete";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidFormBodyOrContentType"] = 50035] = "InvalidFormBodyOrContentType";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InviteAcceptedToGuildWithoutTheBotBeingIn"] = 50036] = "InviteAcceptedToGuildWithoutTheBotBeingIn";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidActivityAction"] = 50039] = "InvalidActivityAction";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidAPIVersion"] = 50041] = "InvalidAPIVersion";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["FileUploadedExceedsMaximumSize"] = 50045] = "FileUploadedExceedsMaximumSize";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidFileUploaded"] = 50046] = "InvalidFileUploaded";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotSelfRedeemThisGift"] = 50054] = "CannotSelfRedeemThisGift";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidGuild"] = 50055] = "InvalidGuild";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidSKU"] = 50057] = "InvalidSKU";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidRequestOrigin"] = 50067] = "InvalidRequestOrigin";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidMessageType"] = 50068] = "InvalidMessageType";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["PaymentSourceRequiredToRedeemGift"] = 50070] = "PaymentSourceRequiredToRedeemGift";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotModifyASystemWebhook"] = 50073] = "CannotModifyASystemWebhook";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotDeleteChannelRequiredForCommunityGuilds"] = 50074] = "CannotDeleteChannelRequiredForCommunityGuilds";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotEditStickersWithinMessage"] = 50080] = "CannotEditStickersWithinMessage";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidStickerSent"] = 50081] = "InvalidStickerSent";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidActionOnArchivedThread"] = 50083] = "InvalidActionOnArchivedThread";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidThreadNotificationSettings"] = 50084] = "InvalidThreadNotificationSettings";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ParameterEarlierThanCreation"] = 50085] = "ParameterEarlierThanCreation";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["CommunityServerChannelsMustBeTextChannels"] = 50086] = "CommunityServerChannelsMustBeTextChannels";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["TheEntityTypeOfTheEventIsDifferentFromTheEntityYouAreTryingToStartTheEventFor"] = 50091] = "TheEntityTypeOfTheEventIsDifferentFromTheEntityYouAreTryingToStartTheEventFor";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ServerNotAvailableInYourLocation"] = 50095] = "ServerNotAvailableInYourLocation";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ServerNeedsMonetizationEnabledToPerformThisAction"] = 50097] = "ServerNeedsMonetizationEnabledToPerformThisAction";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ServerNeedsMoreBoostsToPerformThisAction"] = 50101] = "ServerNeedsMoreBoostsToPerformThisAction";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["RequestBodyContainsInvalidJSON"] = 50109] = "RequestBodyContainsInvalidJSON";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ProvidedFileIsInvalid"] = 50110] = "ProvidedFileIsInvalid";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ProvidedFileTypeIsInvalid"] = 50123] = "ProvidedFileTypeIsInvalid";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ProvidedFileDurationExceedsMaximumLength"] = 50124] = "ProvidedFileDurationExceedsMaximumLength";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["OwnerCannotBePendingMember"] = 50131] = "OwnerCannotBePendingMember";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["OwnershipCannotBeMovedToABotUser"] = 50132] = "OwnershipCannotBeMovedToABotUser";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["FailedToResizeAssetBelowTheMinimumSize"] = 50138] = "FailedToResizeAssetBelowTheMinimumSize";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotMixSubscriptionAndNonSubscriptionRolesForAnEmoji"] = 50144] = "CannotMixSubscriptionAndNonSubscriptionRolesForAnEmoji";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotConvertBetweenPremiumEmojiAndNormalEmoji"] = 50145] = "CannotConvertBetweenPremiumEmojiAndNormalEmoji";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UploadedFileNotFound"] = 50146] = "UploadedFileNotFound";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["SpecifiedEmojiIsInvalid"] = 50151] = "SpecifiedEmojiIsInvalid";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["VoiceMessagesDoNotSupportAdditionalContent"] = 50159] = "VoiceMessagesDoNotSupportAdditionalContent";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["VoiceMessagesMustHaveASingleAudioAttachment"] = 50160] = "VoiceMessagesMustHaveASingleAudioAttachment";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["VoiceMessagesMustHaveSupportingMetadata"] = 50161] = "VoiceMessagesMustHaveSupportingMetadata";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["VoiceMessagesCannotBeEdited"] = 50162] = "VoiceMessagesCannotBeEdited";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotDeleteGuildSubscriptionIntegration"] = 50163] = "CannotDeleteGuildSubscriptionIntegration";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["YouCannotSendVoiceMessagesInThisChannel"] = 50173] = "YouCannotSendVoiceMessagesInThisChannel";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["TheUserAccountMustFirstBeVerified"] = 50178] = "TheUserAccountMustFirstBeVerified";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ProvidedFileDoesNotHaveAValidDuration"] = 50192] = "ProvidedFileDoesNotHaveAValidDuration";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["YouDoNotHavePermissionToSendThisSticker"] = 50600] = "YouDoNotHavePermissionToSendThisSticker";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["TwoFactorAuthenticationIsRequired"] = 60003] = "TwoFactorAuthenticationIsRequired";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["NoUsersWithDiscordTagExist"] = 80004] = "NoUsersWithDiscordTagExist";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ReactionWasBlocked"] = 90001] = "ReactionWasBlocked";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UserCannotUseBurstReactions"] = 90002] = "UserCannotUseBurstReactions";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ApplicationNotYetAvailable"] = 110001] = "ApplicationNotYetAvailable";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["APIResourceOverloaded"] = 13e4] = "APIResourceOverloaded";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["TheStageIsAlreadyOpen"] = 150006] = "TheStageIsAlreadyOpen";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotReplyWithoutPermissionToReadMessageHistory"] = 160002] = "CannotReplyWithoutPermissionToReadMessageHistory";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ThreadAlreadyCreatedForMessage"] = 160004] = "ThreadAlreadyCreatedForMessage";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ThreadLocked"] = 160005] = "ThreadLocked";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumActiveThreads"] = 160006] = "MaximumActiveThreads";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumActiveAnnouncementThreads"] = 160007] = "MaximumActiveAnnouncementThreads";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidJSONForUploadedLottieFile"] = 170001] = "InvalidJSONForUploadedLottieFile";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UploadedLottiesCannotContainRasterizedImages"] = 170002] = "UploadedLottiesCannotContainRasterizedImages";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["StickerMaximumFramerateExceeded"] = 170003] = "StickerMaximumFramerateExceeded";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["StickerFrameCountExceedsMaximumOf1000Frames"] = 170004] = "StickerFrameCountExceedsMaximumOf1000Frames";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["LottieAnimationMaximumDimensionsExceeded"] = 170005] = "LottieAnimationMaximumDimensionsExceeded";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["StickerFramerateIsTooSmallOrTooLarge"] = 170006] = "StickerFramerateIsTooSmallOrTooLarge";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["StickerAnimationDurationExceedsMaximumOf5Seconds"] = 170007] = "StickerAnimationDurationExceedsMaximumOf5Seconds";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotUpdateAFinishedEvent"] = 18e4] = "CannotUpdateAFinishedEvent";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["FailedToCreateStageNeededForStageEvent"] = 180002] = "FailedToCreateStageNeededForStageEvent";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MessageWasBlockedByAutomaticModeration"] = 2e5] = "MessageWasBlockedByAutomaticModeration";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["TitleWasBlockedByAutomaticModeration"] = 200001] = "TitleWasBlockedByAutomaticModeration";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["WebhooksPostedToForumChannelsMustHaveAThreadNameOrThreadId"] = 220001] = "WebhooksPostedToForumChannelsMustHaveAThreadNameOrThreadId";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["WebhooksPostedToForumChannelsCannotHaveBothAThreadNameAndThreadId"] = 220002] = "WebhooksPostedToForumChannelsCannotHaveBothAThreadNameAndThreadId";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["WebhooksCanOnlyCreateThreadsInForumChannels"] = 220003] = "WebhooksCanOnlyCreateThreadsInForumChannels";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["WebhookServicesCannotBeUsedInForumChannels"] = 220004] = "WebhookServicesCannotBeUsedInForumChannels";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MessageBlockedByHarmfulLinksFilter"] = 24e4] = "MessageBlockedByHarmfulLinksFilter";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotEnableOnboardingRequirementsAreNotMet"] = 35e4] = "CannotEnableOnboardingRequirementsAreNotMet";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotUpdateOnboardingWhileBelowRequirements"] = 350001] = "CannotUpdateOnboardingWhileBelowRequirements";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["FailedToBanUsers"] = 5e5] = "FailedToBanUsers";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["PollVotingBlocked"] = 52e4] = "PollVotingBlocked";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["PollExpired"] = 520001] = "PollExpired";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidChannelTypeForPollCreation"] = 520002] = "InvalidChannelTypeForPollCreation";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotEditAPollMessage"] = 520003] = "CannotEditAPollMessage";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotUseAnEmojiIncludedWithThePoll"] = 520004] = "CannotUseAnEmojiIncludedWithThePoll";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotExpireANonPollMessage"] = 520006] = "CannotExpireANonPollMessage";
    })(RESTJSONErrorCodes || (exports2.RESTJSONErrorCodes = RESTJSONErrorCodes = {}));
    var Locale;
    (function(Locale2) {
      Locale2["Indonesian"] = "id";
      Locale2["EnglishUS"] = "en-US";
      Locale2["EnglishGB"] = "en-GB";
      Locale2["Bulgarian"] = "bg";
      Locale2["ChineseCN"] = "zh-CN";
      Locale2["ChineseTW"] = "zh-TW";
      Locale2["Croatian"] = "hr";
      Locale2["Czech"] = "cs";
      Locale2["Danish"] = "da";
      Locale2["Dutch"] = "nl";
      Locale2["Finnish"] = "fi";
      Locale2["French"] = "fr";
      Locale2["German"] = "de";
      Locale2["Greek"] = "el";
      Locale2["Hindi"] = "hi";
      Locale2["Hungarian"] = "hu";
      Locale2["Italian"] = "it";
      Locale2["Japanese"] = "ja";
      Locale2["Korean"] = "ko";
      Locale2["Lithuanian"] = "lt";
      Locale2["Norwegian"] = "no";
      Locale2["Polish"] = "pl";
      Locale2["PortugueseBR"] = "pt-BR";
      Locale2["Romanian"] = "ro";
      Locale2["Russian"] = "ru";
      Locale2["SpanishES"] = "es-ES";
      Locale2["SpanishLATAM"] = "es-419";
      Locale2["Swedish"] = "sv-SE";
      Locale2["Thai"] = "th";
      Locale2["Turkish"] = "tr";
      Locale2["Ukrainian"] = "uk";
      Locale2["Vietnamese"] = "vi";
    })(Locale || (exports2.Locale = Locale = {}));
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/rest/v9/application.js
var require_application2 = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/rest/v9/application.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/rest/v9/auditLog.js
var require_auditLog2 = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/rest/v9/auditLog.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/rest/v9/autoModeration.js
var require_autoModeration2 = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/rest/v9/autoModeration.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/rest/v9/channel.js
var require_channel3 = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/rest/v9/channel.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ReactionType = void 0;
    var ReactionType;
    (function(ReactionType2) {
      ReactionType2[ReactionType2["Normal"] = 0] = "Normal";
      ReactionType2[ReactionType2["Super"] = 1] = "Super";
    })(ReactionType || (exports2.ReactionType = ReactionType = {}));
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/rest/v9/emoji.js
var require_emoji2 = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/rest/v9/emoji.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/rest/v9/gateway.js
var require_gateway2 = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/rest/v9/gateway.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/rest/v9/guild.js
var require_guild2 = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/rest/v9/guild.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/rest/v9/guildScheduledEvent.js
var require_guildScheduledEvent2 = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/rest/v9/guildScheduledEvent.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/rest/v9/interactions.js
var require_interactions2 = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/rest/v9/interactions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/rest/v9/invite.js
var require_invite2 = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/rest/v9/invite.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/rest/v9/monetization.js
var require_monetization2 = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/rest/v9/monetization.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EntitlementOwnerType = void 0;
    var EntitlementOwnerType;
    (function(EntitlementOwnerType2) {
      EntitlementOwnerType2[EntitlementOwnerType2["Guild"] = 1] = "Guild";
      EntitlementOwnerType2[EntitlementOwnerType2["User"] = 2] = "User";
    })(EntitlementOwnerType || (exports2.EntitlementOwnerType = EntitlementOwnerType = {}));
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/rest/v9/oauth2.js
var require_oauth22 = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/rest/v9/oauth2.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/rest/v9/poll.js
var require_poll2 = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/rest/v9/poll.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/rest/v9/soundboard.js
var require_soundboard2 = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/rest/v9/soundboard.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/rest/v9/stageInstance.js
var require_stageInstance2 = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/rest/v9/stageInstance.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/rest/v9/sticker.js
var require_sticker2 = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/rest/v9/sticker.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/rest/v9/template.js
var require_template2 = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/rest/v9/template.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/rest/v9/user.js
var require_user3 = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/rest/v9/user.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/rest/v9/voice.js
var require_voice2 = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/rest/v9/voice.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/rest/v9/webhook.js
var require_webhook2 = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/rest/v9/webhook.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/rest/v9/index.js
var require_v93 = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/rest/v9/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OAuth2Routes = exports2.RouteBases = exports2.CDNRoutes = exports2.ImageFormat = exports2.StickerPackApplicationId = exports2.Routes = exports2.APIVersion = void 0;
    var internals_1 = require_internals();
    __exportStar(require_common3(), exports2);
    __exportStar(require_application2(), exports2);
    __exportStar(require_auditLog2(), exports2);
    __exportStar(require_autoModeration2(), exports2);
    __exportStar(require_channel3(), exports2);
    __exportStar(require_emoji2(), exports2);
    __exportStar(require_gateway2(), exports2);
    __exportStar(require_guild2(), exports2);
    __exportStar(require_guildScheduledEvent2(), exports2);
    __exportStar(require_interactions2(), exports2);
    __exportStar(require_invite2(), exports2);
    __exportStar(require_monetization2(), exports2);
    __exportStar(require_oauth22(), exports2);
    __exportStar(require_poll2(), exports2);
    __exportStar(require_soundboard2(), exports2);
    __exportStar(require_stageInstance2(), exports2);
    __exportStar(require_sticker2(), exports2);
    __exportStar(require_template2(), exports2);
    __exportStar(require_user3(), exports2);
    __exportStar(require_voice2(), exports2);
    __exportStar(require_webhook2(), exports2);
    exports2.APIVersion = "9";
    exports2.Routes = {
      /**
       * Route for:
       * - GET `/applications/{application.id}/role-connections/metadata`
       * - PUT `/applications/{application.id}/role-connections/metadata`
       */
      applicationRoleConnectionMetadata(applicationId) {
        return `/applications/${applicationId}/role-connections/metadata`;
      },
      /**
       * Route for:
       * - GET  `/guilds/{guild.id}/auto-moderation/rules`
       * - POST `/guilds/{guild.id}/auto-moderation/rules`
       */
      guildAutoModerationRules(guildId) {
        return `/guilds/${guildId}/auto-moderation/rules`;
      },
      /**
       * Routes for:
       * - GET    `/guilds/{guild.id}/auto-moderation/rules/{rule.id}`
       * - PATCH  `/guilds/{guild.id}/auto-moderation/rules/{rule.id}`
       * - DELETE `/guilds/{guild.id}/auto-moderation/rules/{rule.id}`
       */
      guildAutoModerationRule(guildId, ruleId) {
        return `/guilds/${guildId}/auto-moderation/rules/${ruleId}`;
      },
      /**
       * Route for:
       * - GET `/guilds/{guild.id}/audit-logs`
       */
      guildAuditLog(guildId) {
        return `/guilds/${guildId}/audit-logs`;
      },
      /**
       * Route for:
       * - GET    `/channels/{channel.id}`
       * - PATCH  `/channels/{channel.id}`
       * - DELETE `/channels/{channel.id}`
       */
      channel(channelId) {
        return `/channels/${channelId}`;
      },
      /**
       * Route for:
       * - GET  `/channels/{channel.id}/messages`
       * - POST `/channels/{channel.id}/messages`
       */
      channelMessages(channelId) {
        return `/channels/${channelId}/messages`;
      },
      /**
       * Route for:
       * - GET    `/channels/{channel.id}/messages/{message.id}`
       * - PATCH  `/channels/{channel.id}/messages/{message.id}`
       * - DELETE `/channels/{channel.id}/messages/{message.id}`
       */
      channelMessage(channelId, messageId) {
        return `/channels/${channelId}/messages/${messageId}`;
      },
      /**
       * Route for:
       * - POST `/channels/{channel.id}/messages/{message.id}/crosspost`
       */
      channelMessageCrosspost(channelId, messageId) {
        return `/channels/${channelId}/messages/${messageId}/crosspost`;
      },
      /**
       * Route for:
       * - PUT    `/channels/{channel.id}/messages/{message.id}/reactions/{emoji}/@me`
       * - DELETE `/channels/{channel.id}/messages/{message.id}/reactions/{emoji}/@me`
       *
       * **Note**: You need to URL encode the emoji yourself
       */
      channelMessageOwnReaction(channelId, messageId, emoji) {
        return `/channels/${channelId}/messages/${messageId}/reactions/${emoji}/@me`;
      },
      /**
       * Route for:
       * - DELETE `/channels/{channel.id}/messages/{message.id}/reactions/{emoji}/{user.id}`
       *
       * **Note**: You need to URL encode the emoji yourself
       */
      channelMessageUserReaction(channelId, messageId, emoji, userId) {
        return `/channels/${channelId}/messages/${messageId}/reactions/${emoji}/${userId}`;
      },
      /**
       * Route for:
       * - GET    `/channels/{channel.id}/messages/{message.id}/reactions/{emoji}`
       * - DELETE `/channels/{channel.id}/messages/{message.id}/reactions/{emoji}`
       *
       * **Note**: You need to URL encode the emoji yourself
       */
      channelMessageReaction(channelId, messageId, emoji) {
        return `/channels/${channelId}/messages/${messageId}/reactions/${emoji}`;
      },
      /**
       * Route for:
       * - DELETE `/channels/{channel.id}/messages/{message.id}/reactions`
       */
      channelMessageAllReactions(channelId, messageId) {
        return `/channels/${channelId}/messages/${messageId}/reactions`;
      },
      /**
       * Route for:
       * - POST `/channels/{channel.id}/messages/bulk-delete`
       */
      channelBulkDelete(channelId) {
        return `/channels/${channelId}/messages/bulk-delete`;
      },
      /**
       * Route for:
       * - PUT    `/channels/{channel.id}/permissions/{overwrite.id}`
       * - DELETE `/channels/{channel.id}/permissions/{overwrite.id}`
       */
      channelPermission(channelId, overwriteId) {
        return `/channels/${channelId}/permissions/${overwriteId}`;
      },
      /**
       * Route for:
       * - GET  `/channels/{channel.id}/invites`
       * - POST `/channels/{channel.id}/invites`
       */
      channelInvites(channelId) {
        return `/channels/${channelId}/invites`;
      },
      /**
       * Route for:
       * - POST `/channels/{channel.id}/followers`
       */
      channelFollowers(channelId) {
        return `/channels/${channelId}/followers`;
      },
      /**
       * Route for:
       * - POST `/channels/{channel.id}/typing`
       */
      channelTyping(channelId) {
        return `/channels/${channelId}/typing`;
      },
      /**
       * Route for:
       * - GET `/channels/{channel.id}/pins`
       */
      channelPins(channelId) {
        return `/channels/${channelId}/pins`;
      },
      /**
       * Route for:
       * - PUT    `/channels/{channel.id}/pins/{message.id}`
       * - DELETE `/channels/{channel.id}/pins/{message.id}`
       */
      channelPin(channelId, messageId) {
        return `/channels/${channelId}/pins/${messageId}`;
      },
      /**
       * Route for:
       * - PUT    `/channels/{channel.id}/recipients/{user.id}`
       * - DELETE `/channels/{channel.id}/recipients/{user.id}`
       */
      channelRecipient(channelId, userId) {
        return `/channels/${channelId}/recipients/${userId}`;
      },
      /**
       * Route for:
       * - GET  `/guilds/{guild.id}/emojis`
       * - POST `/guilds/{guild.id}/emojis`
       */
      guildEmojis(guildId) {
        return `/guilds/${guildId}/emojis`;
      },
      /**
       * Route for:
       * - GET    `/guilds/{guild.id}/emojis/{emoji.id}`
       * - PATCH  `/guilds/{guild.id}/emojis/{emoji.id}`
       * - DELETE `/guilds/{guild.id}/emojis/{emoji.id}`
       */
      guildEmoji(guildId, emojiId) {
        return `/guilds/${guildId}/emojis/${emojiId}`;
      },
      /**
       * Route for:
       * - POST `/guilds`
       */
      guilds() {
        return "/guilds";
      },
      /**
       * Route for:
       * - GET    `/guilds/{guild.id}`
       * - PATCH  `/guilds/{guild.id}`
       * - DELETE `/guilds/{guild.id}`
       */
      guild(guildId) {
        return `/guilds/${guildId}`;
      },
      /**
       * Route for:
       * - GET `/guilds/{guild.id}/preview`
       */
      guildPreview(guildId) {
        return `/guilds/${guildId}/preview`;
      },
      /**
       * Route for:
       * - GET   `/guilds/{guild.id}/channels`
       * - POST  `/guilds/{guild.id}/channels`
       * - PATCH `/guilds/{guild.id}/channels`
       */
      guildChannels(guildId) {
        return `/guilds/${guildId}/channels`;
      },
      /**
       * Route for:
       * - GET    `/guilds/{guild.id}/members/{user.id}`
       * - PUT    `/guilds/{guild.id}/members/{user.id}`
       * - PATCH  `/guilds/{guild.id}/members/@me`
       * - PATCH  `/guilds/{guild.id}/members/{user.id}`
       * - DELETE `/guilds/{guild.id}/members/{user.id}`
       */
      guildMember(guildId, userId = "@me") {
        return `/guilds/${guildId}/members/${userId}`;
      },
      /**
       * Route for:
       * - GET `/guilds/{guild.id}/members`
       */
      guildMembers(guildId) {
        return `/guilds/${guildId}/members`;
      },
      /**
       * Route for:
       * - GET `/guilds/{guild.id}/members/search`
       */
      guildMembersSearch(guildId) {
        return `/guilds/${guildId}/members/search`;
      },
      /**
       * Route for:
       * - PATCH `/guilds/{guild.id}/members/@me/nick`
       *
       * @deprecated Use {@link Routes.guildMember} instead.
       */
      guildCurrentMemberNickname(guildId) {
        return `/guilds/${guildId}/members/@me/nick`;
      },
      /**
       * Route for:
       * - PUT    `/guilds/{guild.id}/members/{user.id}/roles/{role.id}`
       * - DELETE `/guilds/{guild.id}/members/{user.id}/roles/{role.id}`
       */
      guildMemberRole(guildId, memberId, roleId) {
        return `/guilds/${guildId}/members/${memberId}/roles/${roleId}`;
      },
      /**
       * Route for:
       * - POST `/guilds/{guild.id}/mfa`
       */
      guildMFA(guildId) {
        return `/guilds/${guildId}/mfa`;
      },
      /**
       * Route for:
       * - GET `/guilds/{guild.id}/bans`
       */
      guildBans(guildId) {
        return `/guilds/${guildId}/bans`;
      },
      /**
       * Route for:
       * - GET    `/guilds/{guild.id}/bans/{user.id}`
       * - PUT    `/guilds/{guild.id}/bans/{user.id}`
       * - DELETE `/guilds/{guild.id}/bans/{user.id}`
       */
      guildBan(guildId, userId) {
        return `/guilds/${guildId}/bans/${userId}`;
      },
      /**
       * Route for:
       * - GET   `/guilds/{guild.id}/roles`
       * - POST  `/guilds/{guild.id}/roles`
       * - PATCH `/guilds/{guild.id}/roles`
       */
      guildRoles(guildId) {
        return `/guilds/${guildId}/roles`;
      },
      /**
       * Route for:
       * - GET    `/guilds/{guild.id}/roles/{role.id}`
       * - PATCH  `/guilds/{guild.id}/roles/{role.id}`
       * - DELETE `/guilds/{guild.id}/roles/{role.id}`
       */
      guildRole(guildId, roleId) {
        return `/guilds/${guildId}/roles/${roleId}`;
      },
      /**
       * Route for:
       * - GET  `/guilds/{guild.id}/prune`
       * - POST `/guilds/{guild.id}/prune`
       */
      guildPrune(guildId) {
        return `/guilds/${guildId}/prune`;
      },
      /**
       * Route for:
       * - GET `/guilds/{guild.id}/regions`
       */
      guildVoiceRegions(guildId) {
        return `/guilds/${guildId}/regions`;
      },
      /**
       * Route for:
       * - GET `/guilds/{guild.id}/invites`
       */
      guildInvites(guildId) {
        return `/guilds/${guildId}/invites`;
      },
      /**
       * Route for:
       * - GET  `/guilds/{guild.id}/integrations`
       */
      guildIntegrations(guildId) {
        return `/guilds/${guildId}/integrations`;
      },
      /**
       * Route for:
       * - DELETE `/guilds/{guild.id}/integrations/{integration.id}`
       */
      guildIntegration(guildId, integrationId) {
        return `/guilds/${guildId}/integrations/${integrationId}`;
      },
      /**
       * Route for:
       * - GET   `/guilds/{guild.id}/widget`
       * - PATCH `/guilds/{guild.id}/widget`
       */
      guildWidgetSettings(guildId) {
        return `/guilds/${guildId}/widget`;
      },
      /**
       * Route for:
       * - GET `/guilds/{guild.id}/widget.json`
       */
      guildWidgetJSON(guildId) {
        return `/guilds/${guildId}/widget.json`;
      },
      /**
       * Route for:
       * - GET `/guilds/{guild.id}/vanity-url`
       */
      guildVanityUrl(guildId) {
        return `/guilds/${guildId}/vanity-url`;
      },
      /**
       * Route for:
       * - GET `/guilds/{guild.id}/widget.png`
       */
      guildWidgetImage(guildId) {
        return `/guilds/${guildId}/widget.png`;
      },
      /**
       * Route for:
       * - GET    `/invites/{invite.code}`
       * - DELETE `/invites/{invite.code}`
       */
      invite(code) {
        return `/invites/${code}`;
      },
      /**
       * Route for:
       * - GET  `/guilds/templates/{template.code}`
       * - POST `/guilds/templates/{template.code}`
       */
      template(code) {
        return `/guilds/templates/${code}`;
      },
      /**
       * Route for:
       * - GET  `/guilds/{guild.id}/templates`
       * - POST `/guilds/{guild.id}/templates`
       */
      guildTemplates(guildId) {
        return `/guilds/${guildId}/templates`;
      },
      /**
       * Route for:
       * - PUT    `/guilds/{guild.id}/templates/{template.code}`
       * - PATCH  `/guilds/{guild.id}/templates/{template.code}`
       * - DELETE `/guilds/{guild.id}/templates/{template.code}`
       */
      guildTemplate(guildId, code) {
        return `/guilds/${guildId}/templates/${code}`;
      },
      /**
       * Route for:
       * - GET `/channels/{channel.id}/polls/{message.id}/answers/{answer_id}`
       */
      pollAnswerVoters(channelId, messageId, answerId) {
        return `/channels/${channelId}/polls/${messageId}/answers/${answerId}`;
      },
      /**
       * Route for:
       * - POST `/channels/{channel.id}/polls/{message.id}/expire`
       */
      expirePoll(channelId, messageId) {
        return `/channels/${channelId}/polls/${messageId}/expire`;
      },
      /**
       * Route for:
       * - POST `/channels/{channel.id}/threads`
       * - POST `/channels/{channel.id}/messages/{message.id}/threads`
       */
      threads(parentId, messageId) {
        const parts = ["", "channels", parentId];
        if (messageId)
          parts.push("messages", messageId);
        parts.push("threads");
        return parts.join("/");
      },
      /**
       * Route for:
       * - GET `/guilds/{guild.id}/threads/active`
       */
      guildActiveThreads(guildId) {
        return `/guilds/${guildId}/threads/active`;
      },
      /**
       * Route for:
       * - GET `/channels/{channel.id}/threads/active`
       * 	 (deprecated, removed in API v10, use [List Active Guild Threads](https://discord.com/developers/docs/resources/guild#list-active-threads) instead.)
       * - GET `/channels/{channel.id}/threads/archived/public`
       * - GET `/channels/{channel.id}/threads/archived/private`
       */
      channelThreads(channelId, archived) {
        const parts = ["", "channels", channelId, "threads"];
        if (archived)
          parts.push("archived", archived);
        else
          parts.push("active");
        return parts.join("/");
      },
      /**
       * Route for:
       * - GET `/channels/{channel.id}/users/@me/threads/archived/private`
       */
      channelJoinedArchivedThreads(channelId) {
        return `/channels/${channelId}/users/@me/threads/archived/private`;
      },
      /**
       * Route for:
       * - GET    `/channels/{thread.id}/thread-members`
       * - GET    `/channels/{thread.id}/thread-members/{user.id}`
       * - PUT    `/channels/{thread.id}/thread-members/@me`
       * - PUT    `/channels/{thread.id}/thread-members/{user.id}`
       * - DELETE `/channels/{thread.id}/thread-members/@me`
       * - DELETE `/channels/{thread.id}/thread-members/{user.id}`
       */
      threadMembers(threadId, userId) {
        const parts = ["", "channels", threadId, "thread-members"];
        if (userId)
          parts.push(userId);
        return parts.join("/");
      },
      /**
       * Route for:
       * - GET   `/users/@me`
       * - GET   `/users/{user.id}`
       * - PATCH `/users/@me`
       *
       * @param [userId] The user ID, defaulted to `@me`
       */
      user(userId = "@me") {
        return `/users/${userId}`;
      },
      /**
       * Route for:
       * - GET `/users/@me/applications/{application.id}/role-connection`
       * - PUT `/users/@me/applications/{application.id}/role-connection`
       */
      userApplicationRoleConnection(applicationId) {
        return `/users/@me/applications/${applicationId}/role-connection`;
      },
      /**
       * Route for:
       * - GET `/users/@me/guilds`
       */
      userGuilds() {
        return `/users/@me/guilds`;
      },
      /**
       * Route for:
       * - GET `/users/@me/guilds/{guild.id}/member`
       */
      userGuildMember(guildId) {
        return `/users/@me/guilds/${guildId}/member`;
      },
      /**
       * Route for:
       * - DELETE `/users/@me/guilds/{guild.id}`
       */
      userGuild(guildId) {
        return `/users/@me/guilds/${guildId}`;
      },
      /**
       * Route for:
       * - POST `/users/@me/channels`
       */
      userChannels() {
        return `/users/@me/channels`;
      },
      /**
       * Route for:
       * - GET `/users/@me/connections`
       */
      userConnections() {
        return `/users/@me/connections`;
      },
      /**
       * Route for:
       * - GET `/voice/regions`
       */
      voiceRegions() {
        return `/voice/regions`;
      },
      /**
       * Route for:
       * - GET  `/channels/{channel.id}/webhooks`
       * - POST `/channels/{channel.id}/webhooks`
       */
      channelWebhooks(channelId) {
        return `/channels/${channelId}/webhooks`;
      },
      /**
       * Route for:
       * - GET `/guilds/{guild.id}/webhooks`
       */
      guildWebhooks(guildId) {
        return `/guilds/${guildId}/webhooks`;
      },
      /**
       * Route for:
       * - GET    `/webhooks/{webhook.id}`
       * - GET    `/webhooks/{webhook.id}/{webhook.token}`
       * - PATCH  `/webhooks/{webhook.id}`
       * - PATCH  `/webhooks/{webhook.id}/{webhook.token}`
       * - DELETE `/webhooks/{webhook.id}`
       * - DELETE `/webhooks/{webhook.id}/{webhook.token}`
       * - POST   `/webhooks/{webhook.id}/{webhook.token}`
       *
       * - POST   `/webhooks/{application.id}/{interaction.token}`
       */
      webhook(webhookId, webhookToken) {
        const parts = ["", "webhooks", webhookId];
        if (webhookToken)
          parts.push(webhookToken);
        return parts.join("/");
      },
      /**
       * Route for:
       * - GET    `/webhooks/{webhook.id}/{webhook.token}/messages/@original`
       * - GET    `/webhooks/{webhook.id}/{webhook.token}/messages/{message.id}`
       * - PATCH  `/webhooks/{webhook.id}/{webhook.token}/messages/@original`
       * - PATCH  `/webhooks/{webhook.id}/{webhook.token}/messages/{message.id}`
       * - DELETE `/webhooks/{webhook.id}/{webhook.token}/messages/@original`
       * - DELETE `/webhooks/{webhook.id}/{webhook.token}/messages/{message.id}`
       *
       * - PATCH  `/webhooks/{application.id}/{interaction.token}/messages/@original`
       * - PATCH  `/webhooks/{application.id}/{interaction.token}/messages/{message.id}`
       * - DELETE `/webhooks/{application.id}/{interaction.token}/messages/{message.id}`
       */
      webhookMessage(webhookId, webhookToken, messageId = "@original") {
        return `/webhooks/${webhookId}/${webhookToken}/messages/${messageId}`;
      },
      /**
       * Route for:
       * - POST `/webhooks/{webhook.id}/{webhook.token}/github`
       * - POST `/webhooks/{webhook.id}/{webhook.token}/slack`
       */
      webhookPlatform(webhookId, webhookToken, platform) {
        return `/webhooks/${webhookId}/${webhookToken}/${platform}`;
      },
      /**
       * Route for:
       * - GET `/gateway`
       */
      gateway() {
        return `/gateway`;
      },
      /**
       * Route for:
       * - GET `/gateway/bot`
       */
      gatewayBot() {
        return `/gateway/bot`;
      },
      /**
       * Route for:
       * - GET `/oauth2/applications/@me`
       */
      oauth2CurrentApplication() {
        return `/oauth2/applications/@me`;
      },
      /**
       * Route for:
       * - GET `/oauth2/@me`
       */
      oauth2CurrentAuthorization() {
        return `/oauth2/@me`;
      },
      /**
       * Route for:
       * - GET `/oauth2/authorize`
       */
      oauth2Authorization() {
        return `/oauth2/authorize`;
      },
      /**
       * Route for:
       * - POST `/oauth2/token`
       */
      oauth2TokenExchange() {
        return `/oauth2/token`;
      },
      /**
       * Route for:
       * - POST `/oauth2/token/revoke`
       */
      oauth2TokenRevocation() {
        return `/oauth2/token/revoke`;
      },
      /**
       * Route for:
       * - GET  `/applications/{application.id}/commands`
       * - PUT  `/applications/{application.id}/commands`
       * - POST `/applications/{application.id}/commands`
       */
      applicationCommands(applicationId) {
        return `/applications/${applicationId}/commands`;
      },
      /**
       * Route for:
       * - GET    `/applications/{application.id}/commands/{command.id}`
       * - PATCH  `/applications/{application.id}/commands/{command.id}`
       * - DELETE `/applications/{application.id}/commands/{command.id}`
       */
      applicationCommand(applicationId, commandId) {
        return `/applications/${applicationId}/commands/${commandId}`;
      },
      /**
       * Route for:
       * - GET  `/applications/{application.id}/guilds/{guild.id}/commands`
       * - PUT  `/applications/{application.id}/guilds/{guild.id}/commands`
       * - POST `/applications/{application.id}/guilds/{guild.id}/commands`
       */
      applicationGuildCommands(applicationId, guildId) {
        return `/applications/${applicationId}/guilds/${guildId}/commands`;
      },
      /**
       * Route for:
       * - GET    `/applications/{application.id}/guilds/{guild.id}/commands/{command.id}`
       * - PATCH  `/applications/{application.id}/guilds/{guild.id}/commands/{command.id}`
       * - DELETE `/applications/{application.id}/guilds/{guild.id}/commands/{command.id}`
       */
      applicationGuildCommand(applicationId, guildId, commandId) {
        return `/applications/${applicationId}/guilds/${guildId}/commands/${commandId}`;
      },
      /**
       * Route for:
       * - POST `/interactions/{interaction.id}/{interaction.token}/callback`
       */
      interactionCallback(interactionId, interactionToken) {
        return `/interactions/${interactionId}/${interactionToken}/callback`;
      },
      /**
       * Route for:
       * - GET   `/guilds/{guild.id}/member-verification`
       * - PATCH `/guilds/{guild.id}/member-verification`
       */
      guildMemberVerification(guildId) {
        return `/guilds/${guildId}/member-verification`;
      },
      /**
       * Route for:
       * - GET `/guilds/{guild.id}/voice-states/@me`
       * - GET `/guilds/{guild.id}/voice-states/{user.id}`
       * - PATCH `/guilds/{guild.id}/voice-states/@me`
       * - PATCH `/guilds/{guild.id}/voice-states/{user.id}`
       */
      guildVoiceState(guildId, userId = "@me") {
        return `/guilds/${guildId}/voice-states/${userId}`;
      },
      /**
       * Route for:
       * - GET `/applications/{application.id}/guilds/{guild.id}/commands/permissions`
       * - PUT `/applications/{application.id}/guilds/{guild.id}/commands/permissions`
       */
      guildApplicationCommandsPermissions(applicationId, guildId) {
        return `/applications/${applicationId}/guilds/${guildId}/commands/permissions`;
      },
      /**
       * Route for:
       * - GET `/applications/{application.id}/guilds/{guild.id}/commands/{command.id}/permissions`
       * - PUT `/applications/{application.id}/guilds/{guild.id}/commands/{command.id}/permissions`
       */
      applicationCommandPermissions(applicationId, guildId, commandId) {
        return `/applications/${applicationId}/guilds/${guildId}/commands/${commandId}/permissions`;
      },
      /**
       * Route for:
       * - GET   `/guilds/{guild.id}/welcome-screen`
       * - PATCH `/guilds/{guild.id}/welcome-screen`
       */
      guildWelcomeScreen(guildId) {
        return `/guilds/${guildId}/welcome-screen`;
      },
      /**
       * Route for:
       * - POST `/stage-instances`
       */
      stageInstances() {
        return `/stage-instances`;
      },
      /**
       * Route for:
       * - GET `/stage-instances/{channel.id}`
       * - PATCH `/stage-instances/{channel.id}`
       * - DELETE `/stage-instances/{channel.id}`
       */
      stageInstance(channelId) {
        return `/stage-instances/${channelId}`;
      },
      /**
       * Route for:
       * - GET `/stickers/{sticker.id}`
       */
      sticker(stickerId) {
        return `/stickers/${stickerId}`;
      },
      /**
       * Route for:
       * - GET `/sticker-packs`
       */
      stickerPacks() {
        return "/sticker-packs";
      },
      /**
       * Route for:
       * - GET `/sticker-packs/{pack.id}`
       */
      stickerPack(packId) {
        return `/sticker-packs/${packId}`;
      },
      /**
       * Route for:
       * - GET `/sticker-packs`
       *
       * @deprecated Use {@link Routes.stickerPacks} instead.
       */
      nitroStickerPacks() {
        return "/sticker-packs";
      },
      /**
       * Route for:
       * - GET  `/guilds/{guild.id}/stickers`
       * - POST `/guilds/{guild.id}/stickers`
       */
      guildStickers(guildId) {
        return `/guilds/${guildId}/stickers`;
      },
      /**
       * Route for:
       * - GET    `/guilds/{guild.id}/stickers/{sticker.id}`
       * - PATCH  `/guilds/{guild.id}/stickers/{sticker.id}`
       * - DELETE `/guilds/{guild.id}/stickers/{sticker.id}`
       */
      guildSticker(guildId, stickerId) {
        return `/guilds/${guildId}/stickers/${stickerId}`;
      },
      /**
       * Route for:
       * - GET  `/guilds/{guild.id}/scheduled-events`
       * - POST `/guilds/{guild.id}/scheduled-events`
       */
      guildScheduledEvents(guildId) {
        return `/guilds/${guildId}/scheduled-events`;
      },
      /**
       * Route for:
       * - GET  `/guilds/{guild.id}/scheduled-events/{guildScheduledEvent.id}`
       * - PATCH `/guilds/{guild.id}/scheduled-events/{guildScheduledEvent.id}`
       * - DELETE `/guilds/{guild.id}/scheduled-events/{guildScheduledEvent.id}`
       */
      guildScheduledEvent(guildId, guildScheduledEventId) {
        return `/guilds/${guildId}/scheduled-events/${guildScheduledEventId}`;
      },
      /**
       * Route for:
       * - GET `/guilds/{guild.id}/scheduled-events/{guildScheduledEvent.id}/users`
       */
      guildScheduledEventUsers(guildId, guildScheduledEventId) {
        return `/guilds/${guildId}/scheduled-events/${guildScheduledEventId}/users`;
      },
      /**
       * Route for:
       * - GET `/guilds/{guild.id}/onboarding`
       * - PUT `/guilds/{guild.id}/onboarding`
       */
      guildOnboarding(guildId) {
        return `/guilds/${guildId}/onboarding`;
      },
      /**
       * Route for:
       * - GET `/applications/@me`
       * - PATCH `/applications/@me`
       */
      currentApplication() {
        return "/applications/@me";
      },
      /**
       * Route for:
       * - GET `/applications/{application.id}/entitlements`
       * - POST `/applications/{application.id}/entitlements`
       */
      entitlements(applicationId) {
        return `/applications/${applicationId}/entitlements`;
      },
      /**
       * Route for:
       * - GET `/applications/{application.id}/entitlements/{entitlement.id}`
       * - DELETE `/applications/{application.id}/entitlements/{entitlement.id}`
       */
      entitlement(applicationId, entitlementId) {
        return `/applications/${applicationId}/entitlements/${entitlementId}`;
      },
      /**
       * Route for:
       * - GET `/applications/{application.id}/skus`
       */
      skus(applicationId) {
        return `/applications/${applicationId}/skus`;
      },
      /**
       * Route for:
       * - POST `/guilds/{guild.id}/bulk-ban`
       */
      guildBulkBan(guildId) {
        return `/guilds/${guildId}/bulk-ban`;
      },
      /**
       * Route for:
       * - POST `/applications/{application.id}/entitlements/{entitlement.id}/consume`
       */
      consumeEntitlement(applicationId, entitlementId) {
        return `/applications/${applicationId}/entitlements/${entitlementId}/consume`;
      },
      /**
       * Route for:
       * - GET `/applications/{application.id}/emojis`
       * - POST `/applications/{application.id}/emojis`
       */
      applicationEmojis(applicationId) {
        return `/applications/${applicationId}/emojis`;
      },
      /**
       * Route for:
       * - GET `/applications/{application.id}/emojis/{emoji.id}`
       * - PATCH `/applications/{application.id}/emojis/{emoji.id}`
       * - DELETE `/applications/{application.id}/emojis/{emoji.id}`
       */
      applicationEmoji(applicationId, emojiId) {
        return `/applications/${applicationId}/emojis/${emojiId}`;
      },
      /**
       * Route for:
       * - GET `/skus/{sku.id}/subscriptions`
       */
      skuSubscriptions(skuId) {
        return `/skus/${skuId}/subscriptions`;
      },
      /**
       * Route for:
       * - GET `/skus/{sku.id}/subscriptions/{subscription.id}`
       */
      skuSubscription(skuId, subscriptionId) {
        return `/skus/${skuId}/subscriptions/${subscriptionId}`;
      },
      /**
       * Route for:
       * - POST `/channels/{channel.id}/send-soundboard-sound`
       */
      sendSoundboardSound(channelId) {
        return `/channels/${channelId}/send-soundboard-sound`;
      },
      /**
       * Route for:
       * - GET `/soundboard-default-sounds`
       */
      soundboardDefaultSounds() {
        return "/soundboard-default-sounds";
      },
      /**
       * Route for:
       * - GET `/guilds/{guild.id}/soundboard-sounds`
       * - POST `/guilds/{guild.id}/soundboard-sounds`
       */
      guildSoundboardSounds(guildId) {
        return `/guilds/${guildId}/soundboard-sounds`;
      },
      /**
       * Route for:
       * - GET `/guilds/{guild.id}/soundboard-sounds/{sound.id}`
       * - PATCH `/guilds/{guild.id}/soundboard-sounds/{sound.id}`
       * - DELETE `/guilds/{guild.id}/soundboard-sounds/{sound.id}`
       */
      guildSoundboardSound(guildId, soundId) {
        return `/guilds/${guildId}/soundboard-sounds/${soundId}`;
      }
    };
    for (const [key, fn] of Object.entries(exports2.Routes)) {
      exports2.Routes[key] = (...args) => {
        const escaped = args.map((arg) => {
          if (arg) {
            if (internals_1.urlSafeCharacters.test(String(arg))) {
              return arg;
            }
            return encodeURIComponent(arg);
          }
          return arg;
        });
        return fn.call(null, ...escaped);
      };
    }
    Object.freeze(exports2.Routes);
    exports2.StickerPackApplicationId = "710982414301790216";
    var ImageFormat;
    (function(ImageFormat2) {
      ImageFormat2["JPEG"] = "jpeg";
      ImageFormat2["PNG"] = "png";
      ImageFormat2["WebP"] = "webp";
      ImageFormat2["GIF"] = "gif";
      ImageFormat2["Lottie"] = "json";
    })(ImageFormat || (exports2.ImageFormat = ImageFormat = {}));
    exports2.CDNRoutes = {
      /**
       * Route for:
       * - GET `/emojis/{emoji.id}.{png|jpeg|webp|gif}`
       *
       * As this route supports GIFs, the hash will begin with `a_` if it is available in GIF format
       *
       * This route supports the extensions: PNG, JPEG, WebP, GIF
       */
      emoji(emojiId, format) {
        return `/emojis/${emojiId}.${format}`;
      },
      /**
       * Route for:
       * - GET `/icons/{guild.id}/{guild.icon}.{png|jpeg|webp|gif}`
       *
       * As this route supports GIFs, the hash will begin with `a_` if it is available in GIF format
       *
       * This route supports the extensions: PNG, JPEG, WebP, GIF
       */
      guildIcon(guildId, guildIcon, format) {
        return `/icons/${guildId}/${guildIcon}.${format}`;
      },
      /**
       * Route for:
       * - GET `/splashes/{guild.id}/{guild.splash}.{png|jpeg|webp}`
       *
       * This route supports the extensions: PNG, JPEG, WebP
       */
      guildSplash(guildId, guildSplash, format) {
        return `/splashes/${guildId}/${guildSplash}.${format}`;
      },
      /**
       * Route for:
       * - GET `/discovery-splashes/{guild.id}/{guild.discovery_splash}.{png|jpeg|webp}`
       *
       * This route supports the extensions: PNG, JPEG, WebP
       */
      guildDiscoverySplash(guildId, guildDiscoverySplash, format) {
        return `/discovery-splashes/${guildId}/${guildDiscoverySplash}.${format}`;
      },
      /**
       * Route for:
       * - GET `/banners/{guild.id}/{guild.banner}.{png|jpeg|webp|gif}`
       *
       * As this route supports GIFs, the hash will begin with `a_` if it is available in GIF format
       *
       * This route supports the extensions: PNG, JPEG, WebP, GIF
       */
      guildBanner(guildId, guildBanner, format) {
        return `/banners/${guildId}/${guildBanner}.${format}`;
      },
      /**
       * Route for:
       * - GET `/banners/{user.id}/{user.banner}.{png|jpeg|webp|gif}`
       *
       * As this route supports GIFs, the hash will begin with `a_` if it is available in GIF format
       *
       * This route supports the extensions: PNG, JPEG, WebP, GIF
       */
      userBanner(userId, userBanner, format) {
        return `/banners/${userId}/${userBanner}.${format}`;
      },
      /**
       * Route for:
       * - GET `/embed/avatars/{index}.png`
       *
       * The value for `index` parameter depends on whether the user is [migrated to the new username system](https://discord.com/developers/docs/change-log#unique-usernames-on-discord).
       * For users on the new username system, `index` will be `(user.id >> 22) % 6`.
       * For users on the legacy username system, `index` will be `user.discriminator % 5`.
       *
       * This route supports the extension: PNG
       */
      defaultUserAvatar(index) {
        return `/embed/avatars/${index}.png`;
      },
      /**
       * Route for:
       * - GET `/avatars/{user.id}/{user.avatar}.{png|jpeg|webp|gif}`
       *
       * As this route supports GIFs, the hash will begin with `a_` if it is available in GIF format
       *
       * This route supports the extensions: PNG, JPEG, WebP, GIF
       */
      userAvatar(userId, userAvatar, format) {
        return `/avatars/${userId}/${userAvatar}.${format}`;
      },
      /**
       * Route for:
       * - GET `/guilds/{guild.id}/users/{user.id}/avatars/{guild_member.avatar}.{png|jpeg|webp|gif}`
       *
       * As this route supports GIFs, the hash will begin with `a_` if it is available in GIF format
       *
       * This route supports the extensions: PNG, JPEG, WebP, GIF
       */
      guildMemberAvatar(guildId, userId, memberAvatar, format) {
        return `/guilds/${guildId}/users/${userId}/avatars/${memberAvatar}.${format}`;
      },
      /**
       * Route for:
       * - GET `/avatar-decorations/{user.id}/{user.avatar_decoration}.png`
       *
       * This route supports the extension: PNG
       *
       * @deprecated Use {@link CDNRoutes.avatarDecoration} instead.
       */
      userAvatarDecoration(userId, userAvatarDecoration) {
        return `/avatar-decorations/${userId}/${userAvatarDecoration}.png`;
      },
      /**
       * Route for:
       * - GET `/avatar-decoration-presets/{avatar_decoration_data_asset}.png`
       *
       * This route supports the extension: PNG
       */
      avatarDecoration(avatarDecorationDataAsset) {
        return `/avatar-decoration-presets/${avatarDecorationDataAsset}.png`;
      },
      /**
       * Route for:
       * - GET `/app-icons/{application.id}/{application.icon}.{png|jpeg|webp}`
       *
       * This route supports the extensions: PNG, JPEG, WebP
       */
      applicationIcon(applicationId, applicationIcon, format) {
        return `/app-icons/${applicationId}/${applicationIcon}.${format}`;
      },
      /**
       * Route for:
       * - GET `/app-icons/{application.id}/{application.cover_image}.{png|jpeg|webp}`
       *
       * This route supports the extensions: PNG, JPEG, WebP
       */
      applicationCover(applicationId, applicationCoverImage, format) {
        return `/app-icons/${applicationId}/${applicationCoverImage}.${format}`;
      },
      /**
       * Route for:
       * - GET `/app-assets/{application.id}/{application.asset_id}.{png|jpeg|webp}`
       *
       * This route supports the extensions: PNG, JPEG, WebP
       */
      applicationAsset(applicationId, applicationAssetId, format) {
        return `/app-assets/${applicationId}/${applicationAssetId}.${format}`;
      },
      /**
       * Route for:
       * - GET `/app-assets/{application.id}/achievements/{achievement.id}/icons/{achievement.icon}.{png|jpeg|webp}`
       *
       * This route supports the extensions: PNG, JPEG, WebP
       */
      achievementIcon(applicationId, achievementId, achievementIconHash, format) {
        return `/app-assets/${applicationId}/achievements/${achievementId}/icons/${achievementIconHash}.${format}`;
      },
      /**
       * Route for:
       * - GET `/app-assets/710982414301790216/store/{sticker_pack.banner.asset_id}.{png|jpeg|webp}`
       *
       * This route supports the extensions: PNG, JPEG, WebP
       */
      stickerPackBanner(stickerPackBannerAssetId, format) {
        return `/app-assets/${exports2.StickerPackApplicationId}/store/${stickerPackBannerAssetId}.${format}`;
      },
      /**
       * Route for:
       * - GET `/app-assets/${application.id}/store/${asset.id}.{png|jpeg|webp}}`
       *
       * This route supports the extensions: PNG, JPEG, WebP
       */
      storePageAsset(applicationId, assetId, format = ImageFormat.PNG) {
        return `/app-assets/${applicationId}/store/${assetId}.${format}`;
      },
      /**
       * Route for:
       * - GET `/team-icons/{team.id}/{team.icon}.{png|jpeg|webp}`
       *
       * This route supports the extensions: PNG, JPEG, WebP
       */
      teamIcon(teamId, teamIcon, format) {
        return `/team-icons/${teamId}/${teamIcon}.${format}`;
      },
      /**
       * Route for:
       * - GET `/stickers/{sticker.id}.{png|json}`
       *
       * This route supports the extensions: PNG, Lottie, GIF
       */
      sticker(stickerId, format) {
        return `/stickers/${stickerId}.${format}`;
      },
      /**
       * Route for:
       * - GET `/role-icons/{role.id}/{role.icon}.{png|jpeg|webp}`
       *
       * This route supports the extensions: PNG, JPEG, WebP
       */
      roleIcon(roleId, roleIcon, format) {
        return `/role-icons/${roleId}/${roleIcon}.${format}`;
      },
      /**
       * Route for:
       * - GET `/guild-events/{guild_scheduled_event.id}/{guild_scheduled_event.image}.{png|jpeg|webp}`
       *
       * This route supports the extensions: PNG, JPEG, WebP
       */
      guildScheduledEventCover(guildScheduledEventId, guildScheduledEventCoverImage, format) {
        return `/guild-events/${guildScheduledEventId}/${guildScheduledEventCoverImage}.${format}`;
      },
      /**
       * Route for:
       * - GET `/guilds/${guild.id}/users/${user.id}/banners/${guild_member.banner}.{png|jpeg|webp|gif}`
       *
       * This route supports the extensions: PNG, JPEG, WebP, GIF
       */
      guildMemberBanner(guildId, userId, guildMemberBanner, format) {
        return `/guilds/${guildId}/users/${userId}/banners/${guildMemberBanner}.${format}`;
      },
      /**
       * Route for:
       * - GET `/soundboard-sounds/${sound.id}`
       */
      soundboardSound(soundId) {
        return `/soundboard-sounds/${soundId}`;
      }
    };
    for (const [key, fn] of Object.entries(exports2.CDNRoutes)) {
      exports2.CDNRoutes[key] = (...args) => {
        const escaped = args.map((arg) => {
          if (arg) {
            if (internals_1.urlSafeCharacters.test(String(arg))) {
              return arg;
            }
            return encodeURIComponent(arg);
          }
          return arg;
        });
        return fn.call(null, ...escaped);
      };
    }
    Object.freeze(exports2.CDNRoutes);
    exports2.RouteBases = {
      api: `https://discord.com/api/v${exports2.APIVersion}`,
      cdn: "https://cdn.discordapp.com",
      media: "https://media.discordapp.net",
      invite: "https://discord.gg",
      template: "https://discord.new",
      gift: "https://discord.gift",
      scheduledEvent: "https://discord.com/events"
    };
    Object.freeze(exports2.RouteBases);
    exports2.OAuth2Routes = {
      authorizationURL: `${exports2.RouteBases.api}${exports2.Routes.oauth2Authorization()}`,
      tokenURL: `${exports2.RouteBases.api}${exports2.Routes.oauth2TokenExchange()}`,
      /**
       * See https://tools.ietf.org/html/rfc7009
       */
      tokenRevocationURL: `${exports2.RouteBases.api}${exports2.Routes.oauth2TokenRevocation()}`
    };
    Object.freeze(exports2.OAuth2Routes);
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/rpc/common.js
var require_common4 = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/rpc/common.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RPCCloseEventCodes = exports2.RPCErrorCodes = void 0;
    var RPCErrorCodes;
    (function(RPCErrorCodes2) {
      RPCErrorCodes2[RPCErrorCodes2["UnknownError"] = 1e3] = "UnknownError";
      RPCErrorCodes2[RPCErrorCodes2["InvalidPayload"] = 4e3] = "InvalidPayload";
      RPCErrorCodes2[RPCErrorCodes2["InvalidCommand"] = 4002] = "InvalidCommand";
      RPCErrorCodes2[RPCErrorCodes2["InvalidGuild"] = 4003] = "InvalidGuild";
      RPCErrorCodes2[RPCErrorCodes2["InvalidEvent"] = 4004] = "InvalidEvent";
      RPCErrorCodes2[RPCErrorCodes2["InvalidChannel"] = 4005] = "InvalidChannel";
      RPCErrorCodes2[RPCErrorCodes2["InvalidPermissions"] = 4006] = "InvalidPermissions";
      RPCErrorCodes2[RPCErrorCodes2["InvalidClientId"] = 4007] = "InvalidClientId";
      RPCErrorCodes2[RPCErrorCodes2["InvalidOrigin"] = 4008] = "InvalidOrigin";
      RPCErrorCodes2[RPCErrorCodes2["InvalidToken"] = 4009] = "InvalidToken";
      RPCErrorCodes2[RPCErrorCodes2["InvalidUser"] = 4010] = "InvalidUser";
      RPCErrorCodes2[RPCErrorCodes2["OAuth2Error"] = 5e3] = "OAuth2Error";
      RPCErrorCodes2[RPCErrorCodes2["SelectChannelTimedOut"] = 5001] = "SelectChannelTimedOut";
      RPCErrorCodes2[RPCErrorCodes2["GetGuildTimedOut"] = 5002] = "GetGuildTimedOut";
      RPCErrorCodes2[RPCErrorCodes2["SelectVoiceForceRequired"] = 5003] = "SelectVoiceForceRequired";
      RPCErrorCodes2[RPCErrorCodes2["CaptureShortcutAlreadyListening"] = 5004] = "CaptureShortcutAlreadyListening";
    })(RPCErrorCodes || (exports2.RPCErrorCodes = RPCErrorCodes = {}));
    var RPCCloseEventCodes;
    (function(RPCCloseEventCodes2) {
      RPCCloseEventCodes2[RPCCloseEventCodes2["InvalidClientId"] = 4e3] = "InvalidClientId";
      RPCCloseEventCodes2[RPCCloseEventCodes2["InvalidOrigin"] = 4001] = "InvalidOrigin";
      RPCCloseEventCodes2[RPCCloseEventCodes2["RateLimited"] = 4002] = "RateLimited";
      RPCCloseEventCodes2[RPCCloseEventCodes2["TokenRevoked"] = 4003] = "TokenRevoked";
      RPCCloseEventCodes2[RPCCloseEventCodes2["InvalidVersion"] = 4004] = "InvalidVersion";
      RPCCloseEventCodes2[RPCCloseEventCodes2["InvalidEncoding"] = 4005] = "InvalidEncoding";
    })(RPCCloseEventCodes || (exports2.RPCCloseEventCodes = RPCCloseEventCodes = {}));
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/rpc/v9.js
var require_v94 = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/rpc/v9.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_common4(), exports2);
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/utils/v9.js
var require_v95 = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/utils/v9.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isDMInteraction = isDMInteraction;
    exports2.isGuildInteraction = isGuildInteraction;
    exports2.isApplicationCommandDMInteraction = isApplicationCommandDMInteraction;
    exports2.isApplicationCommandGuildInteraction = isApplicationCommandGuildInteraction;
    exports2.isMessageComponentDMInteraction = isMessageComponentDMInteraction;
    exports2.isMessageComponentGuildInteraction = isMessageComponentGuildInteraction;
    exports2.isLinkButton = isLinkButton;
    exports2.isInteractionButton = isInteractionButton;
    exports2.isMessageComponentInteraction = isMessageComponentInteraction;
    exports2.isMessageComponentButtonInteraction = isMessageComponentButtonInteraction;
    exports2.isMessageComponentSelectMenuInteraction = isMessageComponentSelectMenuInteraction;
    exports2.isChatInputApplicationCommandInteraction = isChatInputApplicationCommandInteraction;
    exports2.isContextMenuApplicationCommandInteraction = isContextMenuApplicationCommandInteraction;
    var index_1 = require_v92();
    function isDMInteraction(interaction) {
      return Reflect.has(interaction, "user");
    }
    function isGuildInteraction(interaction) {
      return Reflect.has(interaction, "guild_id");
    }
    function isApplicationCommandDMInteraction(interaction) {
      return isDMInteraction(interaction);
    }
    function isApplicationCommandGuildInteraction(interaction) {
      return isGuildInteraction(interaction);
    }
    function isMessageComponentDMInteraction(interaction) {
      return isDMInteraction(interaction);
    }
    function isMessageComponentGuildInteraction(interaction) {
      return isGuildInteraction(interaction);
    }
    function isLinkButton(component) {
      return component.style === index_1.ButtonStyle.Link;
    }
    function isInteractionButton(component) {
      return ![index_1.ButtonStyle.Link, index_1.ButtonStyle.Premium].includes(component.style);
    }
    function isMessageComponentInteraction(interaction) {
      return interaction.type === index_1.InteractionType.MessageComponent;
    }
    function isMessageComponentButtonInteraction(interaction) {
      return interaction.data.component_type === index_1.ComponentType.Button;
    }
    function isMessageComponentSelectMenuInteraction(interaction) {
      return [
        index_1.ComponentType.StringSelect,
        index_1.ComponentType.UserSelect,
        index_1.ComponentType.RoleSelect,
        index_1.ComponentType.MentionableSelect,
        index_1.ComponentType.ChannelSelect
      ].includes(interaction.data.component_type);
    }
    function isChatInputApplicationCommandInteraction(interaction) {
      return interaction.data.type === index_1.ApplicationCommandType.ChatInput;
    }
    function isContextMenuApplicationCommandInteraction(interaction) {
      return interaction.data.type === index_1.ApplicationCommandType.Message || interaction.data.type === index_1.ApplicationCommandType.User;
    }
  }
});

// ../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/v9.js
var require_v96 = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/node_modules/discord-api-types/v9.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Utils = void 0;
    __exportStar(require_v9(), exports2);
    __exportStar(require_globals(), exports2);
    __exportStar(require_v92(), exports2);
    __exportStar(require_v93(), exports2);
    __exportStar(require_v94(), exports2);
    exports2.Utils = require_v95();
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/websocket/WebSocketShard.js
var require_WebSocketShard = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/websocket/WebSocketShard.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require_node_events();
    var { setTimeout: setTimeout2, setInterval: setInterval2, clearTimeout: clearTimeout2 } = require_node_timers();
    var WebSocket = require_WebSocket();
    var { Status: Status2, Events: Events2, ShardEvents, Opcodes, WSEvents, WSCodes } = require_Constants();
    var Intents2 = require_Intents();
    var Util = require_Util();
    var STATUS_KEYS = Object.keys(Status2);
    var CONNECTION_STATE = Object.keys(WebSocket.WebSocket);
    var zlib;
    try {
      zlib = __require("zlib-sync");
    } catch {
    }
    var WebSocketShard = class extends EventEmitter {
      constructor(manager, id) {
        super();
        this.manager = manager;
        this.id = id;
        this.resumeURL = null;
        this.status = Status2.IDLE;
        this.sequence = -1;
        this.closeSequence = 0;
        this.sessionId = null;
        this.ping = -1;
        this.lastPingTimestamp = -1;
        this.lastHeartbeatAcked = true;
        this.closeEmitted = false;
        Object.defineProperty(this, "ratelimit", {
          value: {
            queue: [],
            total: 120,
            remaining: 120,
            time: 6e4,
            timer: null
          }
        });
        Object.defineProperty(this, "connection", { value: null, writable: true });
        Object.defineProperty(this, "inflate", { value: null, writable: true });
        Object.defineProperty(this, "helloTimeout", { value: null, writable: true });
        Object.defineProperty(this, "wsCloseTimeout", { value: null, writable: true });
        Object.defineProperty(this, "eventsAttached", { value: false, writable: true });
        Object.defineProperty(this, "expectedGuilds", { value: null, writable: true });
        Object.defineProperty(this, "readyTimeout", { value: null, writable: true });
        Object.defineProperty(this, "connectedAt", { value: 0, writable: true });
      }
      /**
       * Emits a debug event.
       * @param {string} message The debug message
       * @private
       */
      debug(message) {
        this.manager.debug(message, this);
      }
      /**
       * Connects the shard to the gateway.
       * @private
       * @returns {Promise<void>} A promise that will resolve if the shard turns ready successfully,
       * or reject if we couldn't connect
       */
      connect() {
        var _a;
        const { client } = this.manager;
        if (((_a = this.connection) == null ? void 0 : _a.readyState) === WebSocket.OPEN && this.status === Status2.READY) {
          return Promise.resolve();
        }
        const gateway = this.resumeURL ?? this.manager.gateway;
        return new Promise((resolve, reject) => {
          var _a2;
          const cleanup = () => {
            this.removeListener(ShardEvents.CLOSE, onClose);
            this.removeListener(ShardEvents.READY, onReady);
            this.removeListener(ShardEvents.RESUMED, onResumed);
            this.removeListener(ShardEvents.INVALID_SESSION, onInvalidOrDestroyed);
            this.removeListener(ShardEvents.DESTROYED, onInvalidOrDestroyed);
          };
          const onReady = () => {
            cleanup();
            resolve();
          };
          const onResumed = () => {
            cleanup();
            resolve();
          };
          const onClose = (event) => {
            cleanup();
            reject(event);
          };
          const onInvalidOrDestroyed = () => {
            cleanup();
            reject();
          };
          this.once(ShardEvents.READY, onReady);
          this.once(ShardEvents.RESUMED, onResumed);
          this.once(ShardEvents.CLOSE, onClose);
          this.once(ShardEvents.INVALID_SESSION, onInvalidOrDestroyed);
          this.once(ShardEvents.DESTROYED, onInvalidOrDestroyed);
          if (((_a2 = this.connection) == null ? void 0 : _a2.readyState) === WebSocket.OPEN) {
            this.debug("An open connection was found, attempting an immediate identify.");
            this.identify();
            return;
          }
          if (this.connection) {
            this.debug(`A connection object was found. Cleaning up before continuing.
    State: ${CONNECTION_STATE[this.connection.readyState]}`);
            this.destroy({ emit: false });
          }
          const wsQuery = { v: client.options.ws.version };
          if (zlib) {
            this.inflate = new zlib.Inflate({
              chunkSize: 65535,
              flush: zlib.Z_SYNC_FLUSH,
              to: WebSocket.encoding === "json" ? "string" : ""
            });
            wsQuery.compress = "zlib-stream";
          }
          this.debug(
            `[CONNECT]
    Gateway    : ${gateway}
    Version    : ${client.options.ws.version}
    Encoding   : ${WebSocket.encoding}
    Compression: ${zlib ? "zlib-stream" : "none"}
    Agent      : ${Util.verifyProxyAgent(client.options.ws.agent)}`
          );
          this.status = this.status === Status2.DISCONNECTED ? Status2.RECONNECTING : Status2.CONNECTING;
          this.setHelloTimeout();
          this.setWsCloseTimeout(-1);
          this.connectedAt = Date.now();
          const ws = this.connection = WebSocket.create(gateway, wsQuery, {
            handshakeTimeout: 3e4,
            agent: Util.verifyProxyAgent(client.options.ws.agent) ? client.options.ws.agent : void 0
          });
          ws.onopen = this.onOpen.bind(this);
          ws.onmessage = this.onMessage.bind(this);
          ws.onerror = this.onError.bind(this);
          ws.onclose = this.onClose.bind(this);
        });
      }
      /**
       * Called whenever a connection is opened to the gateway.
       * @private
       */
      onOpen() {
        this.debug(`[CONNECTED] Took ${Date.now() - this.connectedAt}ms`);
        this.status = Status2.NEARLY;
      }
      /**
       * Called whenever a message is received.
       * @param {MessageEvent} event Event received
       * @private
       */
      onMessage({ data }) {
        let raw;
        if (data instanceof ArrayBuffer) data = new Uint8Array(data);
        if (zlib) {
          const l = data.length;
          const flush = l >= 4 && data[l - 4] === 0 && data[l - 3] === 0 && data[l - 2] === 255 && data[l - 1] === 255;
          this.inflate.push(data, flush && zlib.Z_SYNC_FLUSH);
          if (!flush) return;
          raw = this.inflate.result;
        } else {
          raw = data;
        }
        let packet;
        try {
          packet = WebSocket.unpack(raw);
        } catch (err) {
          this.manager.client.emit(Events2.SHARD_ERROR, err, this.id);
          return;
        }
        this.manager.client.emit(Events2.RAW, packet, this.id);
        if (packet.op === Opcodes.DISPATCH) this.manager.emit(packet.t, packet.d, this.id);
        this.onPacket(packet);
      }
      /**
       * Called whenever an error occurs with the WebSocket.
       * @param {ErrorEvent} event The error that occurred
       * @private
       */
      onError(event) {
        const error2 = (event == null ? void 0 : event.error) ?? event;
        if (!error2) return;
        this.manager.client.emit(Events2.SHARD_ERROR, error2, this.id);
      }
      /**
       * @external CloseEvent
       * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent}
       */
      /**
       * @external ErrorEvent
       * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/ErrorEvent}
       */
      /**
       * @external MessageEvent
       * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/MessageEvent}
       */
      /**
       * Called whenever a connection to the gateway is closed.
       * @param {CloseEvent} event Close event that was received
       * @private
       */
      onClose(event) {
        this.closeEmitted = true;
        if (this.sequence !== -1) this.closeSequence = this.sequence;
        this.sequence = -1;
        this.setHeartbeatTimer(-1);
        this.setHelloTimeout(-1);
        this.setWsCloseTimeout(-1);
        if (this.connection) {
          this._cleanupConnection();
          this.destroy({ reset: !this.sessionId, emit: false, log: false });
        }
        this.status = Status2.DISCONNECTED;
        this.emitClose(event);
      }
      /**
       * This method is responsible to emit close event for this shard.
       * This method helps the shard reconnect.
       * @param {CloseEvent} [event] Close event that was received
       */
      emitClose(event = {
        code: 1011,
        reason: WSCodes[1011],
        wasClean: false
      }) {
        this.debug(`[CLOSE]
    Event Code: ${event.code}
    Clean     : ${event.wasClean}
    Reason    : ${event.reason ?? "No reason received"}`);
        this.emit(ShardEvents.CLOSE, event);
      }
      /**
       * Called whenever a packet is received.
       * @param {Object} packet The received packet
       * @private
       */
      onPacket(packet) {
        if (!packet) {
          this.debug(`Received broken packet: '${packet}'.`);
          return;
        }
        switch (packet.t) {
          case WSEvents.READY:
            this.emit(ShardEvents.READY);
            this.resumeURL = packet.d.resume_gateway_url;
            this.sessionId = packet.d.session_id;
            this.expectedGuilds = new Set(packet.d.guilds.filter((d) => (d == null ? void 0 : d.unavailable) == true).map((d) => d.id));
            this.status = Status2.WAITING_FOR_GUILDS;
            this.debug(`[READY] Session ${this.sessionId} | Resume url ${this.resumeURL}.`);
            this.lastHeartbeatAcked = true;
            this.sendHeartbeat("ReadyHeartbeat");
            break;
          case WSEvents.RESUMED: {
            this.emit(ShardEvents.RESUMED);
            this.status = Status2.READY;
            const replayed = packet.s - this.closeSequence;
            this.debug(`[RESUMED] Session ${this.sessionId} | Replayed ${replayed} events.`);
            this.lastHeartbeatAcked = true;
            this.sendHeartbeat("ResumeHeartbeat");
            break;
          }
        }
        if (packet.s > this.sequence) this.sequence = packet.s;
        switch (packet.op) {
          case Opcodes.HELLO:
            this.setHelloTimeout(-1);
            this.setHeartbeatTimer(packet.d.heartbeat_interval);
            this.identify();
            break;
          case Opcodes.RECONNECT:
            this.debug("[RECONNECT] Discord asked us to reconnect");
            this.destroy({ closeCode: 4e3 });
            break;
          case Opcodes.INVALID_SESSION:
            this.debug(`[INVALID SESSION] Resumable: ${packet.d}.`);
            if (packet.d) {
              this.identifyResume();
              return;
            }
            this.sequence = -1;
            this.sessionId = null;
            this.status = Status2.RECONNECTING;
            this.emit(ShardEvents.INVALID_SESSION);
            break;
          case Opcodes.HEARTBEAT_ACK:
            this.ackHeartbeat();
            break;
          case Opcodes.HEARTBEAT:
            this.sendHeartbeat("HeartbeatRequest", true);
            break;
          default:
            this.manager.handlePacket(packet, this);
            if (this.status === Status2.WAITING_FOR_GUILDS && packet.t === WSEvents.GUILD_CREATE) {
              this.expectedGuilds.delete(packet.d.id);
              this.checkReady();
            }
        }
      }
      /**
       * Checks if the shard can be marked as ready
       * @private
       */
      checkReady() {
        if (this.readyTimeout) {
          clearTimeout2(this.readyTimeout);
          this.readyTimeout = null;
        }
        if (!this.expectedGuilds.size) {
          this.debug("Shard received all its guilds. Marking as fully ready.");
          this.status = Status2.READY;
          this.emit(ShardEvents.ALL_READY);
          return;
        }
        const hasGuildsIntent = new Intents2(this.manager.client.options.intents).has(Intents2.FLAGS.GUILDS);
        const { waitGuildTimeout } = this.manager.client.options;
        this.readyTimeout = setTimeout2(
          () => {
            this.debug(
              `Shard ${hasGuildsIntent ? "did" : "will"} not receive any more guild packets${hasGuildsIntent ? ` in ${waitGuildTimeout} ms` : ""}.
Unavailable guild count: ${this.expectedGuilds.size}`
            );
            this.readyTimeout = null;
            this.status = Status2.READY;
            this.emit(ShardEvents.ALL_READY, this.expectedGuilds);
          },
          hasGuildsIntent ? waitGuildTimeout : 0
        ).unref();
      }
      /**
       * Sets the HELLO packet timeout.
       * @param {number} [time] If set to -1, it will clear the hello timeout
       * @private
       */
      setHelloTimeout(time) {
        if (time === -1) {
          if (this.helloTimeout) {
            this.debug("Clearing the HELLO timeout.");
            clearTimeout2(this.helloTimeout);
            this.helloTimeout = null;
          }
          return;
        }
        this.debug("Setting a HELLO timeout for 20s.");
        this.helloTimeout = setTimeout2(() => {
          this.debug("Did not receive HELLO in time. Destroying and connecting again.");
          this.destroy({ reset: true, closeCode: 4009 });
        }, 2e4).unref();
      }
      /**
       * Sets the WebSocket Close timeout.
       * This method is responsible for detecting any zombie connections if the WebSocket fails to close properly.
       * @param {number} [time] If set to -1, it will clear the timeout
       * @private
       */
      setWsCloseTimeout(time) {
        if (this.wsCloseTimeout) {
          this.debug("[WebSocket] Clearing the close timeout.");
          clearTimeout2(this.wsCloseTimeout);
        }
        if (time === -1) {
          this.wsCloseTimeout = null;
          return;
        }
        this.wsCloseTimeout = setTimeout2(() => {
          this.setWsCloseTimeout(-1);
          if (this.closeEmitted) {
            this.debug(`[WebSocket] close was already emitted, assuming the connection was closed properly.`);
            this.closeEmitted = false;
            return;
          }
          this.debug(
            // eslint-disable-next-line max-len
            `[WebSocket] Close Emitted: ${this.closeEmitted} | did not close properly, assuming a zombie connection.
Emitting close and reconnecting again.`
          );
          if (this.connection) this._cleanupConnection();
          this.emitClose({
            code: 4009,
            reason: "Session time out.",
            wasClean: false
          });
        }, time);
      }
      /**
       * Sets the heartbeat timer for this shard.
       * @param {number} time If -1, clears the interval, any other number sets an interval
       * @private
       */
      setHeartbeatTimer(time) {
        if (time === -1) {
          if (this.heartbeatInterval) {
            this.debug("Clearing the heartbeat interval.");
            clearInterval(this.heartbeatInterval);
            this.heartbeatInterval = null;
          }
          return;
        }
        this.debug(`Setting a heartbeat interval for ${time}ms.`);
        if (this.heartbeatInterval) clearInterval(this.heartbeatInterval);
        this.heartbeatInterval = setInterval2(() => this.sendHeartbeat(), time).unref();
      }
      /**
       * Sends a heartbeat to the WebSocket.
       * If this shard didn't receive a heartbeat last time, it will destroy it and reconnect
       * @param {string} [tag='HeartbeatTimer'] What caused this heartbeat to be sent
       * @param {boolean} [ignoreHeartbeatAck] If we should send the heartbeat forcefully.
       * @private
       */
      sendHeartbeat(tag = "HeartbeatTimer", ignoreHeartbeatAck = [Status2.WAITING_FOR_GUILDS, Status2.IDENTIFYING, Status2.RESUMING].includes(this.status)) {
        if (ignoreHeartbeatAck && !this.lastHeartbeatAcked) {
          this.debug(`[${tag}] Didn't process heartbeat ack yet but we are still connected. Sending one now.`);
        } else if (!this.lastHeartbeatAcked) {
          this.debug(
            `[${tag}] Didn't receive a heartbeat ack last time, assuming zombie connection. Destroying and reconnecting.
    Status          : ${STATUS_KEYS[this.status]}
    Sequence        : ${this.sequence}
    Connection State: ${this.connection ? CONNECTION_STATE[this.connection.readyState] : "No Connection??"}`
          );
          this.destroy({ reset: true, closeCode: 4009 });
          return;
        }
        this.debug(`[${tag}] Sending a heartbeat.`);
        this.lastHeartbeatAcked = false;
        this.lastPingTimestamp = Date.now();
        this.send({ op: Opcodes.HEARTBEAT, d: this.sequence }, true);
      }
      /**
       * Acknowledges a heartbeat.
       * @private
       */
      ackHeartbeat() {
        this.lastHeartbeatAcked = true;
        const latency = Date.now() - this.lastPingTimestamp;
        this.debug(`Heartbeat acknowledged, latency of ${latency}ms.`);
        this.ping = latency;
      }
      /**
       * Identifies the client on the connection.
       * @private
       * @returns {void}
       */
      identify() {
        return this.sessionId ? this.identifyResume() : this.identifyNew();
      }
      /**
       * Identifies as a new connection on the gateway.
       * @private
       */
      identifyNew() {
        const { client } = this.manager;
        if (!client.token) {
          this.debug("[IDENTIFY] No token available to identify a new session.");
          return;
        }
        this.status = Status2.IDENTIFYING;
        Object.keys(client.options.ws.properties).filter((k) => k.startsWith("$")).forEach((k) => {
          client.options.ws.properties[k.slice(1)] = client.options.ws.properties[k];
          delete client.options.ws.properties[k];
        });
        const d = {
          ...client.options.ws,
          token: client.token
        };
        delete d.version;
        delete d.agent;
        this.debug(`[IDENTIFY] Shard ${this.id}`);
        this.send({ op: Opcodes.IDENTIFY, d }, true);
      }
      /**
       * Resumes a session on the gateway.
       * @private
       */
      identifyResume() {
        if (!this.sessionId) {
          this.debug("[RESUME] No session id was present; identifying as a new session.");
          this.identifyNew();
          return;
        }
        this.status = Status2.RESUMING;
        this.debug(`[RESUME] Session ${this.sessionId}, sequence ${this.closeSequence}`);
        const d = {
          token: this.manager.client.token,
          session_id: this.sessionId,
          seq: this.closeSequence
        };
        this.send({ op: Opcodes.RESUME, d }, true);
      }
      /**
       * Adds a packet to the queue to be sent to the gateway.
       * <warn>If you use this method, make sure you understand that you need to provide
       * a full [Payload](https://discord.com/developers/docs/topics/gateway-events#payload-structure).
       * Do not use this method if you don't know what you're doing.</warn>
       * @param {Object} data The full packet to send
       * @param {boolean} [important=false] If this packet should be added first in queue
       */
      send(data, important = false) {
        this.ratelimit.queue[important ? "unshift" : "push"](data);
        this.processQueue();
      }
      /**
       * Sends data, bypassing the queue.
       * @param {Object} data Packet to send
       * @returns {void}
       * @private
       */
      _send(data) {
        var _a;
        if (((_a = this.connection) == null ? void 0 : _a.readyState) !== WebSocket.OPEN) {
          this.debug(`Tried to send packet '${JSON.stringify(data)}' but no WebSocket is available!`);
          this.destroy({ closeCode: 4e3 });
          return;
        }
        this.connection.send(WebSocket.pack(data), (err) => {
          if (err) this.manager.client.emit(Events2.SHARD_ERROR, err, this.id);
        });
      }
      /**
       * Processes the current WebSocket queue.
       * @returns {void}
       * @private
       */
      processQueue() {
        if (this.ratelimit.remaining === 0) return;
        if (this.ratelimit.queue.length === 0) return;
        if (this.ratelimit.remaining === this.ratelimit.total) {
          this.ratelimit.timer = setTimeout2(() => {
            this.ratelimit.remaining = this.ratelimit.total;
            this.processQueue();
          }, this.ratelimit.time).unref();
        }
        while (this.ratelimit.remaining > 0) {
          const item = this.ratelimit.queue.shift();
          if (!item) return;
          this._send(item);
          this.ratelimit.remaining--;
        }
      }
      /**
       * Destroys this shard and closes its WebSocket connection.
       * @param {Object} [options={ closeCode: 1000, reset: false, emit: true, log: true }] Options for destroying the shard
       * @private
       */
      destroy({ closeCode = 1e3, reset = false, emit = true, log = true } = {}) {
        var _a;
        if (log) {
          this.debug(`[DESTROY]
    Close Code    : ${closeCode}
    Reset         : ${reset}
    Emit DESTROYED: ${emit}`);
        }
        this.setHeartbeatTimer(-1);
        this.setHelloTimeout(-1);
        this.debug(
          `[WebSocket] Destroy: Attempting to close the WebSocket. | WS State: ${CONNECTION_STATE[((_a = this.connection) == null ? void 0 : _a.readyState) ?? WebSocket.CLOSED]}`
        );
        if (this.connection) {
          if (this.connection.readyState === WebSocket.OPEN) {
            this.connection.close(closeCode);
            this.debug(`[WebSocket] Close: Tried closing. | WS State: ${CONNECTION_STATE[this.connection.readyState]}`);
          } else {
            this.debug(`WS State: ${CONNECTION_STATE[this.connection.readyState]}`);
            try {
              this.connection.close(closeCode);
            } catch (err) {
              this.debug(
                `[WebSocket] Close: Something went wrong while closing the WebSocket: ${err.message || err}. Forcefully terminating the connection | WS State: ${CONNECTION_STATE[this.connection.readyState]}`
              );
              this.connection.terminate();
            }
            if (emit) this._emitDestroyed();
          }
        } else if (emit) {
          this._emitDestroyed();
        }
        this.debug(
          `[WebSocket] Adding a WebSocket close timeout to ensure a correct WS reconnect.
        Timeout: ${this.manager.client.options.closeTimeout}ms`
        );
        this.setWsCloseTimeout(this.manager.client.options.closeTimeout);
        this.connection = null;
        this.status = Status2.DISCONNECTED;
        if (this.sequence !== -1) this.closeSequence = this.sequence;
        if (reset) {
          this.resumeURL = null;
          this.sequence = -1;
          this.sessionId = null;
        }
        this.ratelimit.remaining = this.ratelimit.total;
        this.ratelimit.queue.length = 0;
        if (this.ratelimit.timer) {
          clearTimeout2(this.ratelimit.timer);
          this.ratelimit.timer = null;
        }
      }
      /**
       * Cleans up the WebSocket connection listeners.
       * @private
       */
      _cleanupConnection() {
        this.connection.onopen = this.connection.onclose = this.connection.onmessage = null;
        this.connection.onerror = () => null;
      }
      /**
       * Emits the DESTROYED event on the shard
       * @private
       */
      _emitDestroyed() {
        this.emit(ShardEvents.DESTROYED);
      }
    };
    module2.exports = WebSocketShard;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/USER_REQUIRED_ACTION_UPDATE.js
var require_USER_REQUIRED_ACTION_UPDATE = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/USER_REQUIRED_ACTION_UPDATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, { d: data }) => {
      let msg;
      switch (data.required_action) {
        case void 0:
        case null: {
          msg = "All required actions have been completed.";
          break;
        }
        case "AGREEMENTS": {
          msg = "You need to accept the new Terms of Service and Privacy Policy.";
          client.api.users("@me").agreements.patch({
            data: {
              terms: true,
              privacy: true
            }
          }).then(() => {
            client.emit(
              "debug",
              "[USER_REQUIRED_ACTION] Successfully accepted the new Terms of Service and Privacy Policy."
            );
          }).catch((e) => {
            client.emit(
              "debug",
              `[USER_REQUIRED_ACTION] Failed to accept the new Terms of Service and Privacy Policy: ${e}`
            );
          });
          break;
        }
        case "REQUIRE_CAPTCHA": {
          msg = "You need to complete a captcha.";
          break;
        }
        case "REQUIRE_VERIFIED_EMAIL": {
          msg = "You need to verify your email.";
          break;
        }
        case "REQUIRE_REVERIFIED_EMAIL": {
          msg = "You need to reverify your email.";
          break;
        }
        case "REQUIRE_VERIFIED_PHONE": {
          msg = "You need to verify your phone number.";
          break;
        }
        case "REQUIRE_REVERIFIED_PHONE": {
          msg = "You need to reverify your phone number.";
          break;
        }
        case "REQUIRE_VERIFIED_EMAIL_OR_VERIFIED_PHONE": {
          msg = "You need to verify your email or verify your phone number.";
          break;
        }
        case "REQUIRE_REVERIFIED_EMAIL_OR_VERIFIED_PHONE": {
          msg = "You need to reverify your email or verify your phone number.";
          break;
        }
        case "REQUIRE_VERIFIED_EMAIL_OR_REVERIFIED_PHONE": {
          msg = "You need to verify your email or reverify your phone number.";
          break;
        }
        case "REQUIRE_REVERIFIED_EMAIL_OR_REVERIFIED_PHONE": {
          msg = "You need to reverify your email or reverify your phone number.";
          break;
        }
        default: {
          msg = `Unknown required action: ${data.required_action}`;
          break;
        }
      }
      client.emit("debug", `[USER_REQUIRED_ACTION] ${msg}`);
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/util/PremiumUsageFlags.js
var require_PremiumUsageFlags = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/util/PremiumUsageFlags.js"(exports2, module2) {
    "use strict";
    var BitField = require_BitField();
    var PremiumUsageFlags = class extends BitField {
    };
    PremiumUsageFlags.FLAGS = {
      PREMIUM_DISCRIMINATOR: 1 << 0,
      ANIMATED_AVATAR: 1 << 1,
      PROFILE_BANNER: 1 << 2
    };
    module2.exports = PremiumUsageFlags;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/util/PurchasedFlags.js
var require_PurchasedFlags = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/util/PurchasedFlags.js"(exports2, module2) {
    "use strict";
    var BitField = require_BitField();
    var PurchasedFlags = class extends BitField {
    };
    PurchasedFlags.FLAGS = {
      NITRO_CLASSIC: 1 << 0,
      NITRO: 1 << 1,
      GUILD_BOOST: 1 << 2,
      NITRO_BASIC: 1 << 3
    };
    module2.exports = PurchasedFlags;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/ClientUser.js
var require_ClientUser = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/ClientUser.js"(exports2, module2) {
    "use strict";
    var { setInterval: setInterval2 } = require_node_timers();
    var { Collection: Collection2 } = require_dist();
    var Invite2 = require_Invite();
    var User = require_User();
    var DataResolver2 = require_DataResolver();
    var PremiumUsageFlags = require_PremiumUsageFlags();
    var PurchasedFlags = require_PurchasedFlags();
    var Util = require_Util();
    var _packageName, _intervalSamsungPresence;
    var ClientUser = class extends User {
      constructor() {
        super(...arguments);
        __privateAdd(this, _packageName, null);
        __privateAdd(this, _intervalSamsungPresence, setInterval2(() => {
          this.client.emit("debug", `[UPDATE] Samsung Presence: ${__privateGet(this, _packageName)}`);
          if (!__privateGet(this, _packageName)) return;
          this.setSamsungActivity(__privateGet(this, _packageName), "UPDATE");
        }, 1e3 * 60 * 10).unref());
      }
      _patch(data) {
        super._patch(data);
        if ("verified" in data) {
          this.verified = data.verified;
        }
        if ("mfa_enabled" in data) {
          this.mfaEnabled = typeof data.mfa_enabled === "boolean" ? data.mfa_enabled : null;
        } else {
          this.mfaEnabled ?? (this.mfaEnabled = null);
        }
        if ("token" in data) this.client.token = data.token;
        if ("purchased_flags" in data) {
          this.purchasedFlags = new PurchasedFlags(data.purchased_flags || 0).freeze();
        } else {
          this.purchasedFlags = new PurchasedFlags().freeze();
        }
        if ("premium_usage_flags" in data) {
          this.premiumUsageFlags = new PremiumUsageFlags(data.premium_usage_flags || 0);
        } else {
          this.premiumUsageFlags = new PremiumUsageFlags().freeze();
        }
        if ("phone" in data) {
          this.phone = data.phone;
        }
        if ("nsfw_allowed" in data) {
          this.nsfwAllowed = data.nsfw_allowed;
        }
        if ("email" in data) {
          this.email = data.email;
        }
        if ("bio" in data) {
          this.bio = data.bio;
        }
        if ("pronouns" in data) {
          this.pronouns = data.pronouns;
        }
        if ("premium_type" in data) {
          this.premiumType = data.premium_type;
        }
      }
      /**
       * Represents the client user's presence
       * @type {ClientPresence}
       * @readonly
       */
      get presence() {
        return this.client.presence;
      }
      /**
       * Data used to edit the logged in client
       * @typedef {Object} ClientUserEditData
       * @property {string} [username] The new username
       * @property {?(BufferResolvable|Base64Resolvable)} [avatar] The new avatar
       * @property {?(BufferResolvable|Base64Resolvable)} [banner] The new banner
       * @property {?string} [bio] The new bio
       */
      /**
       * Edits the logged in client.
       * @param {ClientUserEditData} options The new data
       * @returns {Promise<ClientUser>}
       */
      async edit(options = {}) {
        const data = await this.client.api.users("@me").patch({ data: options });
        this.client.token = data.token;
        const { updated } = this.client.actions.UserUpdate.handle(data);
        return updated ?? this;
      }
      /**
       * Sets the username of the logged in client.
       * <info>Changing usernames in Discord is heavily rate limited, with only 2 requests
       * every hour. Use this sparingly!</info>
       * @param {string} username The new username
       * @param {string} password Current Password
       * @returns {Promise<ClientUser>}
       * @example
       * // Set username
       * client.user.setUsername('discordjs', 'passw@rd')
       *   .then(user => console.log(`My new username is ${user.username}`))
       *   .catch(console.error);
       */
      setUsername(username, password) {
        return this.edit({ username, password });
      }
      /**
       * Sets the avatar of the logged in client.
       * @param {?(BufferResolvable|Base64Resolvable)} avatar The new avatar
       * @returns {Promise<ClientUser>}
       * @example
       * // Set avatar
       * client.user.setAvatar('./avatar.png')
       *   .then(user => console.log(`New avatar set!`))
       *   .catch(console.error);
       */
      async setAvatar(avatar) {
        avatar = avatar && await DataResolver2.resolveImage(avatar);
        return this.edit({ avatar });
      }
      /**
       * Options for setting activities
       * @typedef {Object} ActivitiesOptions
       * @property {string} name Name of the activity
       * @property {string} [state] State of the activity
       * @property {ActivityType|number} [type] Type of the activity
       * @property {string} [url] Twitch / YouTube stream URL
       */
      /**
       * Data resembling a raw Discord presence.
       * @typedef {Object} PresenceData
       * @property {PresenceStatusData} [status] Status of the user
       * @property {boolean} [afk] Whether the user is AFK
       * @property {ActivitiesOptions[]|CustomStatus[]|RichPresence[]|SpotifyRPC[]} [activities] Activity the user is playing
       * @property {number|number[]} [shardId] Shard id(s) to have the activity set on
       */
      /**
       * Sets the full presence of the client user.
       * @param {PresenceData} data Data for the presence
       * @returns {ClientPresence}
       * @example
       * // Set the client user's presence
       * client.user.setPresence({ activities: [{ name: 'with discord.js' }], status: 'idle' });
       * @see {@link https://github.com/aiko-chan-ai/discord.js-selfbot-v13/blob/main/Document/RichPresence.md}
       */
      setPresence(data) {
        return this.client.presence.set(data);
      }
      /**
       * A user's status. Must be one of:
       * * `online`
       * * `idle`
       * * `invisible`
       * * `dnd` (do not disturb)
       * @typedef {string} PresenceStatusData
       */
      /**
       * Sets the status of the client user.
       * @param {PresenceStatusData} status Status to change to
       * @param {number|number[]} [shardId] Shard id(s) to have the activity set on
       * @returns {ClientPresence}
       * @example
       * // Set the client user's status
       * client.user.setStatus('idle');
       */
      setStatus(status, shardId) {
        return this.setPresence({ status, shardId });
      }
      /**
       * Options for setting an activity.
       * @typedef {Object} ActivityOptions
       * @property {string} name Name of the activity
       * @property {string} [url] Twitch / YouTube stream URL
       * @property {ActivityType|number} [type] Type of the activity
       * @property {number|number[]} [shardId] Shard Id(s) to have the activity set on
       */
      /**
       * Sets the activity the client user is playing.
       * @param {string|ActivityOptions} name Activity being played, or options for setting the activity
       * @param {ActivityOptions} [options] Options for setting the activity
       * @returns {ClientPresence}
       * @example
       * // Set the client user's activity
       * client.user.setActivity('discord.js', { type: 'WATCHING' });
       * @see {@link https://github.com/aiko-chan-ai/discord.js-selfbot-v13/blob/main/Document/RichPresence.md}
       */
      setActivity(name, options = {}) {
        if (!name) return this.setPresence({ activities: [], shardId: options.shardId });
        const activity = Object.assign({}, options, typeof name === "object" ? name : { name });
        return this.setPresence({ activities: [activity], shardId: activity.shardId });
      }
      /**
       * Sets/removes the AFK flag for the client user.
       * @param {boolean} [afk=true] Whether or not the user is AFK
       * @param {number|number[]} [shardId] Shard Id(s) to have the AFK flag set on
       * @returns {ClientPresence}
       */
      setAFK(afk = true, shardId) {
        return this.setPresence({ afk, shardId });
      }
      /**
       * Sets the banner of the logged in client.
       * @param {?(BufferResolvable|Base64Resolvable)} banner The new banner
       * @returns {Promise<ClientUser>}
       * @example
       * // Set banner
       * client.user.setBanner('./banner.png')
       *   .then(user => console.log(`New banner set!`))
       *   .catch(console.error);
       */
      async setBanner(banner) {
        banner = banner && await DataResolver2.resolveImage(banner);
        return this.edit({ banner });
      }
      /**
       * Set HyperSquad House
       * @param {string|number} type
       * * `LEAVE`: 0
       * * `HOUSE_BRAVERY`: 1
       * * `HOUSE_BRILLIANCE`: 2
       * * `HOUSE_BALANCE`: 3
       * @returns {Promise<void>}
       * @example
       * // Set HyperSquad HOUSE_BRAVERY
       * client.user.setHypeSquad(1); || client.user.setHypeSquad('HOUSE_BRAVERY');
       * // Leave
       * client.user.setHypeSquad(0);
       */
      setHypeSquad(type) {
        switch (type) {
          case "LEAVE": {
            type = 0;
            break;
          }
          case "HOUSE_BRAVERY": {
            type = 1;
            break;
          }
          case "HOUSE_BRILLIANCE": {
            type = 2;
            break;
          }
          case "HOUSE_BALANCE": {
            type = 3;
            break;
          }
        }
        if (type == 0) {
          return this.client.api.hypesquad.online.delete();
        } else {
          return this.client.api.hypesquad.online.post({
            data: { house_id: type }
          });
        }
      }
      /**
       * Set Accent color
       * @param {ColorResolvable} color Color to set
       * @returns {Promise<ClientUser>}
       */
      setAccentColor(color = null) {
        return this.edit({ accent_color: color ? Util.resolveColor(color) : null });
      }
      /**
       * Set About me
       * @param {string} [bio=null] Bio to set
       * @returns {Promise<ClientUser>}
       */
      setAboutMe(bio = null) {
        return this.edit({ bio });
      }
      /**
       * Create an invite [Friend Invites]
       * maxAge: 604800 | maxUses: 1
       * @returns {Promise<Invite>}
       * @see {@link https://github.com/13-05/hidden-disc-docs#js-snippet-for-creating-friend-invites}
       * @example
       * // Options not working
       * client.user.createFriendInvite();
       *   .then(console.log)
       *   .catch(console.error);
       */
      async createFriendInvite() {
        const data = await this.client.api.users["@me"].invites.post({
          data: {}
        });
        return new Invite2(this.client, data);
      }
      /**
       * Get all friend invites
       * @returns {Promise<Collection<string, Invite>>}
       */
      async getAllFriendInvites() {
        const data = await this.client.api.users["@me"].invites.get();
        const collection = new Collection2();
        for (const invite of data) {
          collection.set(invite.code, new Invite2(this.client, invite));
        }
        return collection;
      }
      /**
       * Revoke all friend invites
       * @returns {Promise<void>}
       */
      revokeAllFriendInvites() {
        return this.client.api.users["@me"].invites.delete();
      }
      /**
       * Sets Discord Playing status to "Playing on Samsung Galaxy". Only selected gamss from discords database works
       * @param {string} packageName Android package name
       * @param {?string} type Must be START, UPDATE, or STOP
       * @returns {Promise<ClientUser>}
       * @example
       * // Set the client user's status
       * client.user.setSamsungActivity('com.YostarJP.BlueArchive', 'START');
       * // Update
       * client.user.setSamsungActivity('com.miHoYo.bh3oversea', 'UPDATE');
       * // Stop
       * client.user.setSamsungActivity('com.miHoYo.GenshinImpact', 'STOP');
       */
      async setSamsungActivity(packageName, type = "START") {
        type = type.toUpperCase();
        if (!packageName || typeof packageName !== "string") throw new Error("Package name is required.");
        if (!["START", "UPDATE", "STOP"].includes(type)) throw new Error("Invalid type (Must be START, UPDATE, or STOP)");
        await this.client.api.presences.post({
          data: {
            package_name: packageName,
            update: type
          }
        });
        if (type !== "STOP") __privateSet(this, _packageName, packageName);
        else __privateSet(this, _packageName, null);
        return this;
      }
      /**
       * Stop ringing
       * @param {ChannelResolvable} channel DMChannel | GroupDMChannel
       * @returns {Promise<void>}
       */
      stopRinging(channel) {
        return this.client.api.channels(this.client.channels.resolveId(channel)).call["stop-ringing"].post({
          data: {}
        });
      }
      /**
       * Super Reactions
       * @returns {Promise<number>}
       */
      fetchBurstCredit() {
        return this.client.api.users["@me"]["burst-credits"].get().then((d) => d.amount);
      }
      /**
       * Set global display name
       * @param {string} globalName The new display name
       * @returns {Promise<ClientUser>}
       */
      setGlobalName(globalName = "") {
        return this.edit({ global_name: globalName });
      }
      /**
       * Set pronouns
       * @param {?string} pronouns Your pronouns
       * @returns {Promise<ClientUser>}
       */
      setPronouns(pronouns = "") {
        return this.edit({ pronouns });
      }
    };
    _packageName = new WeakMap();
    _intervalSamsungPresence = new WeakMap();
    module2.exports = ClientUser;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/READY.js
var require_READY = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/READY.js"(exports2, module2) {
    "use strict";
    var USER_REQUIRED_ACTION = require_USER_REQUIRED_ACTION_UPDATE();
    var { Opcodes } = require_Constants();
    var ClientUser;
    module2.exports = (client, { d: data }, shard) => {
      USER_REQUIRED_ACTION(client, { d: data });
      client.presence.userId = data.user.id;
      if (client.user) {
        client.user._patch(data.user);
      } else {
        ClientUser ?? (ClientUser = require_ClientUser());
        client.user = new ClientUser(client, data.user);
        client.users.cache.set(client.user.id, client.user);
      }
      for (const private_channel of data.private_channels) {
        client.channels._add(private_channel);
      }
      for (const guild of data.guilds) {
        guild.shardId = shard.id;
        client.guilds._add(guild);
      }
      client.notes._reload(data.notes);
      client.relationships._setup(data.relationships);
      client.settings._patch(data.user_settings);
      for (const gSetting of Array.isArray(data.user_guild_settings) ? data.user_guild_settings : []) {
        const guild = client.guilds.cache.get(gSetting.guild_id);
        if (guild) guild.settings._patch(gSetting);
      }
      if (data.guilds.length) {
        if (data.guilds.length > 80) {
          const data1 = data.guilds.slice(0, Math.floor(data.guilds.length / 2));
          const data2 = data.guilds.slice(Math.floor(data.guilds.length / 2));
          client.ws.broadcast({
            op: Opcodes.GUILD_SUBSCRIPTIONS_BULK,
            d: {
              subscriptions: data1.reduce((accumulator, guild) => {
                accumulator[guild.id] = {
                  typing: true,
                  threads: true,
                  activities: true,
                  member_updates: true,
                  thread_member_lists: [],
                  members: [],
                  channels: {}
                };
                return accumulator;
              }, {})
            }
          });
          client.ws.broadcast({
            op: Opcodes.GUILD_SUBSCRIPTIONS_BULK,
            d: {
              subscriptions: data2.reduce((accumulator, guild) => {
                accumulator[guild.id] = {
                  typing: true,
                  threads: true,
                  activities: true,
                  member_updates: true,
                  thread_member_lists: [],
                  members: [],
                  channels: {}
                };
                return accumulator;
              }, {})
            }
          });
        } else {
          client.ws.broadcast({
            op: Opcodes.GUILD_SUBSCRIPTIONS_BULK,
            d: {
              subscriptions: data.guilds.reduce((accumulator, guild) => {
                accumulator[guild.id] = {
                  typing: true,
                  threads: true,
                  activities: true,
                  member_updates: true,
                  thread_member_lists: [],
                  members: [],
                  channels: {}
                };
                return accumulator;
              }, {})
            }
          });
        }
      }
      Promise.all(
        data.private_channels.map(async (c, index) => {
          if (client.options.DMChannelVoiceStatusSync < 1) return;
          client.ws.broadcast({
            op: Opcodes.DM_UPDATE,
            d: {
              channel_id: c.id
            }
          });
          await client.sleep(client.options.DMChannelVoiceStatusSync * index);
        })
      ).then(() => shard.checkReady());
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/RESUMED.js
var require_RESUMED = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/RESUMED.js"(exports2, module2) {
    "use strict";
    var { Events: Events2 } = require_Constants();
    module2.exports = (client, packet, shard) => {
      const replayed = shard.sequence - shard.closeSequence;
      client.emit(Events2.SHARD_RESUME, shard.id, replayed);
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/APPLICATION_COMMAND_CREATE.js
var require_APPLICATION_COMMAND_CREATE = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/APPLICATION_COMMAND_CREATE.js"(exports2, module2) {
    "use strict";
    var { Events: Events2 } = require_Constants();
    module2.exports = (client, { d: data }) => {
      var _a;
      const commandManager = data.guild_id ? (_a = client.guilds.cache.get(data.guild_id)) == null ? void 0 : _a.commands : client.application.commands;
      if (!commandManager) return;
      const command = commandManager._add(data, data.application_id === client.application.id);
      client.emit(Events2.APPLICATION_COMMAND_CREATE, command);
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/APPLICATION_COMMAND_DELETE.js
var require_APPLICATION_COMMAND_DELETE = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/APPLICATION_COMMAND_DELETE.js"(exports2, module2) {
    "use strict";
    var { Events: Events2 } = require_Constants();
    module2.exports = (client, { d: data }) => {
      var _a;
      const commandManager = data.guild_id ? (_a = client.guilds.cache.get(data.guild_id)) == null ? void 0 : _a.commands : client.application.commands;
      if (!commandManager) return;
      const isOwn = data.application_id === client.application.id;
      const command = commandManager._add(data, isOwn);
      if (isOwn) commandManager.cache.delete(data.id);
      client.emit(Events2.APPLICATION_COMMAND_DELETE, command);
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/APPLICATION_COMMAND_UPDATE.js
var require_APPLICATION_COMMAND_UPDATE = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/APPLICATION_COMMAND_UPDATE.js"(exports2, module2) {
    "use strict";
    var { Events: Events2 } = require_Constants();
    module2.exports = (client, { d: data }) => {
      var _a, _b;
      const commandManager = data.guild_id ? (_a = client.guilds.cache.get(data.guild_id)) == null ? void 0 : _a.commands : client.application.commands;
      if (!commandManager) return;
      const oldCommand = ((_b = commandManager.cache.get(data.id)) == null ? void 0 : _b._clone()) ?? null;
      const newCommand = commandManager._add(data, data.application_id === client.application.id);
      client.emit(Events2.APPLICATION_COMMAND_UPDATE, oldCommand, newCommand);
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/APPLICATION_COMMAND_PERMISSIONS_UPDATE.js
var require_APPLICATION_COMMAND_PERMISSIONS_UPDATE = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/APPLICATION_COMMAND_PERMISSIONS_UPDATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.ApplicationCommandPermissionsUpdate.handle(packet.d);
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/AUTO_MODERATION_ACTION_EXECUTION.js
var require_AUTO_MODERATION_ACTION_EXECUTION = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/AUTO_MODERATION_ACTION_EXECUTION.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.AutoModerationActionExecution.handle(packet.d);
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/AUTO_MODERATION_RULE_CREATE.js
var require_AUTO_MODERATION_RULE_CREATE = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/AUTO_MODERATION_RULE_CREATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.AutoModerationRuleCreate.handle(packet.d);
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/AUTO_MODERATION_RULE_DELETE.js
var require_AUTO_MODERATION_RULE_DELETE = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/AUTO_MODERATION_RULE_DELETE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.AutoModerationRuleDelete.handle(packet.d);
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/AUTO_MODERATION_RULE_UPDATE.js
var require_AUTO_MODERATION_RULE_UPDATE = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/AUTO_MODERATION_RULE_UPDATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.AutoModerationRuleUpdate.handle(packet.d);
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/GUILD_CREATE.js
var require_GUILD_CREATE = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/GUILD_CREATE.js"(exports2, module2) {
    "use strict";
    var { Events: Events2, Opcodes, Status: Status2 } = require_Constants();
    var run = (client, guild) => {
      const subs = {};
      subs[guild.id] = {
        typing: true,
        threads: true,
        activities: true,
        member_updates: true,
        thread_member_lists: [],
        members: [],
        channels: {}
      };
      client.ws.broadcast({
        op: Opcodes.GUILD_SUBSCRIPTIONS_BULK,
        d: {
          subscriptions: subs
        }
      });
    };
    module2.exports = (client, { d: data }, shard) => {
      let guild = client.guilds.cache.get(data.id);
      run(client, data);
      if (guild) {
        if (!guild.available && !data.unavailable) {
          guild._patch(data);
          client.emit(Events2.GUILD_AVAILABLE, guild);
        }
      } else {
        data.shardId = shard.id;
        guild = client.guilds._add(data);
        if (client.ws.status === Status2.READY) {
          client.emit(Events2.GUILD_CREATE, guild);
          run(client, guild);
        }
      }
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/GUILD_DELETE.js
var require_GUILD_DELETE = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/GUILD_DELETE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.GuildDelete.handle(packet.d);
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/GUILD_UPDATE.js
var require_GUILD_UPDATE = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/GUILD_UPDATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.GuildUpdate.handle(packet.d);
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/INVITE_CREATE.js
var require_INVITE_CREATE = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/INVITE_CREATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.InviteCreate.handle(packet.d);
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/INVITE_DELETE.js
var require_INVITE_DELETE = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/INVITE_DELETE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.InviteDelete.handle(packet.d);
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/GUILD_MEMBER_ADD.js
var require_GUILD_MEMBER_ADD = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/GUILD_MEMBER_ADD.js"(exports2, module2) {
    "use strict";
    var { Events: Events2, Status: Status2 } = require_Constants();
    module2.exports = (client, { d: data }, shard) => {
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        guild.memberCount++;
        const member = guild.members._add(data);
        if (shard.status === Status2.READY) {
          client.emit(Events2.GUILD_MEMBER_ADD, member);
        }
      }
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/GUILD_MEMBER_REMOVE.js
var require_GUILD_MEMBER_REMOVE = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/GUILD_MEMBER_REMOVE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet, shard) => {
      client.actions.GuildMemberRemove.handle(packet.d, shard);
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/GUILD_MEMBER_UPDATE.js
var require_GUILD_MEMBER_UPDATE = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/GUILD_MEMBER_UPDATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet, shard) => {
      client.actions.GuildMemberUpdate.handle(packet.d, shard);
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/GUILD_MEMBERS_CHUNK.js
var require_GUILD_MEMBERS_CHUNK = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/GUILD_MEMBERS_CHUNK.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var { Events: Events2 } = require_Constants();
    module2.exports = (client, { d: data }) => {
      const guild = client.guilds.cache.get(data.guild_id);
      if (!guild) return;
      const members = new Collection2();
      for (const member of data.members) members.set(member.user.id, guild.members._add(member));
      if (data.presences) {
        for (const presence of data.presences) guild.presences._add(Object.assign(presence, { guild }));
      }
      client.emit(Events2.GUILD_MEMBERS_CHUNK, members, guild, {
        count: data.chunk_count,
        index: data.chunk_index,
        nonce: data.nonce,
        notFound: data.not_found
      });
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/GUILD_INTEGRATIONS_UPDATE.js
var require_GUILD_INTEGRATIONS_UPDATE = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/GUILD_INTEGRATIONS_UPDATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.GuildIntegrationsUpdate.handle(packet.d);
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/GUILD_ROLE_CREATE.js
var require_GUILD_ROLE_CREATE = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/GUILD_ROLE_CREATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.GuildRoleCreate.handle(packet.d);
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/GUILD_ROLE_DELETE.js
var require_GUILD_ROLE_DELETE = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/GUILD_ROLE_DELETE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.GuildRoleDelete.handle(packet.d);
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/GUILD_ROLE_UPDATE.js
var require_GUILD_ROLE_UPDATE = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/GUILD_ROLE_UPDATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.GuildRoleUpdate.handle(packet.d);
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/GUILD_BAN_ADD.js
var require_GUILD_BAN_ADD = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/GUILD_BAN_ADD.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.GuildBanAdd.handle(packet.d);
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/GUILD_BAN_REMOVE.js
var require_GUILD_BAN_REMOVE = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/GUILD_BAN_REMOVE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.GuildBanRemove.handle(packet.d);
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/GUILD_EMOJIS_UPDATE.js
var require_GUILD_EMOJIS_UPDATE = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/GUILD_EMOJIS_UPDATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.GuildEmojisUpdate.handle(packet.d);
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/CHANNEL_CREATE.js
var require_CHANNEL_CREATE = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/CHANNEL_CREATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.ChannelCreate.handle(packet.d);
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/CHANNEL_DELETE.js
var require_CHANNEL_DELETE = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/CHANNEL_DELETE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.ChannelDelete.handle(packet.d);
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/CHANNEL_UPDATE.js
var require_CHANNEL_UPDATE = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/CHANNEL_UPDATE.js"(exports2, module2) {
    "use strict";
    var { Events: Events2 } = require_Constants();
    module2.exports = (client, packet) => {
      const { old, updated } = client.actions.ChannelUpdate.handle(packet.d);
      if (old && updated) {
        client.emit(Events2.CHANNEL_UPDATE, old, updated);
      }
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/CHANNEL_PINS_UPDATE.js
var require_CHANNEL_PINS_UPDATE = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/CHANNEL_PINS_UPDATE.js"(exports2, module2) {
    "use strict";
    var { Events: Events2 } = require_Constants();
    module2.exports = (client, { d: data }) => {
      const channel = client.channels.cache.get(data.channel_id);
      const time = data.last_pin_timestamp ? new Date(data.last_pin_timestamp).getTime() : null;
      if (channel) {
        channel.lastPinTimestamp = time;
        client.emit(Events2.CHANNEL_PINS_UPDATE, channel, time);
      }
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/MESSAGE_CREATE.js
var require_MESSAGE_CREATE = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/MESSAGE_CREATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.MessageCreate.handle(packet.d);
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/MESSAGE_DELETE.js
var require_MESSAGE_DELETE = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/MESSAGE_DELETE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.MessageDelete.handle(packet.d);
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/MESSAGE_UPDATE.js
var require_MESSAGE_UPDATE = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/MESSAGE_UPDATE.js"(exports2, module2) {
    "use strict";
    var { Events: Events2 } = require_Constants();
    module2.exports = (client, packet) => {
      const { old, updated } = client.actions.MessageUpdate.handle(packet.d);
      if (old && updated) {
        client.emit(Events2.MESSAGE_UPDATE, old, updated);
      }
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/MESSAGE_DELETE_BULK.js
var require_MESSAGE_DELETE_BULK = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/MESSAGE_DELETE_BULK.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.MessageDeleteBulk.handle(packet.d);
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/MESSAGE_REACTION_ADD.js
var require_MESSAGE_REACTION_ADD = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/MESSAGE_REACTION_ADD.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.MessageReactionAdd.handle(packet.d);
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/MESSAGE_REACTION_REMOVE.js
var require_MESSAGE_REACTION_REMOVE = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/MESSAGE_REACTION_REMOVE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.MessageReactionRemove.handle(packet.d);
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/MESSAGE_REACTION_REMOVE_ALL.js
var require_MESSAGE_REACTION_REMOVE_ALL = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/MESSAGE_REACTION_REMOVE_ALL.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.MessageReactionRemoveAll.handle(packet.d);
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/MESSAGE_REACTION_REMOVE_EMOJI.js
var require_MESSAGE_REACTION_REMOVE_EMOJI = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/MESSAGE_REACTION_REMOVE_EMOJI.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.MessageReactionRemoveEmoji.handle(packet.d);
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/THREAD_CREATE.js
var require_THREAD_CREATE = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/THREAD_CREATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.ThreadCreate.handle(packet.d);
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/THREAD_UPDATE.js
var require_THREAD_UPDATE = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/THREAD_UPDATE.js"(exports2, module2) {
    "use strict";
    var { Events: Events2 } = require_Constants();
    module2.exports = (client, packet) => {
      const { old, updated } = client.actions.ChannelUpdate.handle(packet.d);
      if (old && updated) {
        client.emit(Events2.THREAD_UPDATE, old, updated);
      }
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/THREAD_DELETE.js
var require_THREAD_DELETE = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/THREAD_DELETE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.ThreadDelete.handle(packet.d);
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/THREAD_LIST_SYNC.js
var require_THREAD_LIST_SYNC = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/THREAD_LIST_SYNC.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.ThreadListSync.handle(packet.d);
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/THREAD_MEMBER_UPDATE.js
var require_THREAD_MEMBER_UPDATE = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/THREAD_MEMBER_UPDATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.ThreadMemberUpdate.handle(packet.d);
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/THREAD_MEMBERS_UPDATE.js
var require_THREAD_MEMBERS_UPDATE = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/THREAD_MEMBERS_UPDATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.ThreadMembersUpdate.handle(packet.d);
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/USER_UPDATE.js
var require_USER_UPDATE = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/USER_UPDATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.UserUpdate.handle(packet.d);
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/PRESENCE_UPDATE.js
var require_PRESENCE_UPDATE = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/PRESENCE_UPDATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.PresenceUpdate.handle(packet.d);
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/TYPING_START.js
var require_TYPING_START = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/TYPING_START.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.TypingStart.handle(packet.d);
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/VOICE_STATE_UPDATE.js
var require_VOICE_STATE_UPDATE = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/VOICE_STATE_UPDATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.VoiceStateUpdate.handle(packet.d);
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/VOICE_SERVER_UPDATE.js
var require_VOICE_SERVER_UPDATE = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/VOICE_SERVER_UPDATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.emit("debug", `[VOICE] received voice server: ${JSON.stringify(packet)}`);
      client.voice.onVoiceServer(packet.d);
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/WEBHOOKS_UPDATE.js
var require_WEBHOOKS_UPDATE = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/WEBHOOKS_UPDATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.WebhooksUpdate.handle(packet.d);
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/STAGE_INSTANCE_CREATE.js
var require_STAGE_INSTANCE_CREATE = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/STAGE_INSTANCE_CREATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.StageInstanceCreate.handle(packet.d);
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/STAGE_INSTANCE_UPDATE.js
var require_STAGE_INSTANCE_UPDATE = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/STAGE_INSTANCE_UPDATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.StageInstanceUpdate.handle(packet.d);
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/STAGE_INSTANCE_DELETE.js
var require_STAGE_INSTANCE_DELETE = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/STAGE_INSTANCE_DELETE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.StageInstanceDelete.handle(packet.d);
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/GUILD_STICKERS_UPDATE.js
var require_GUILD_STICKERS_UPDATE = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/GUILD_STICKERS_UPDATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.GuildStickersUpdate.handle(packet.d);
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/GUILD_SCHEDULED_EVENT_CREATE.js
var require_GUILD_SCHEDULED_EVENT_CREATE = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/GUILD_SCHEDULED_EVENT_CREATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.GuildScheduledEventCreate.handle(packet.d);
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/GUILD_SCHEDULED_EVENT_UPDATE.js
var require_GUILD_SCHEDULED_EVENT_UPDATE = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/GUILD_SCHEDULED_EVENT_UPDATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.GuildScheduledEventUpdate.handle(packet.d);
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/GUILD_SCHEDULED_EVENT_DELETE.js
var require_GUILD_SCHEDULED_EVENT_DELETE = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/GUILD_SCHEDULED_EVENT_DELETE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.GuildScheduledEventDelete.handle(packet.d);
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/GUILD_SCHEDULED_EVENT_USER_ADD.js
var require_GUILD_SCHEDULED_EVENT_USER_ADD = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/GUILD_SCHEDULED_EVENT_USER_ADD.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.GuildScheduledEventUserAdd.handle(packet.d);
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/GUILD_SCHEDULED_EVENT_USER_REMOVE.js
var require_GUILD_SCHEDULED_EVENT_USER_REMOVE = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/GUILD_SCHEDULED_EVENT_USER_REMOVE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.GuildScheduledEventUserRemove.handle(packet.d);
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/GUILD_AUDIT_LOG_ENTRY_CREATE.js
var require_GUILD_AUDIT_LOG_ENTRY_CREATE = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/GUILD_AUDIT_LOG_ENTRY_CREATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.GuildAuditLogEntryCreate.handle(packet.d);
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/RELATIONSHIP_ADD.js
var require_RELATIONSHIP_ADD = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/RELATIONSHIP_ADD.js"(exports2, module2) {
    "use strict";
    var { Events: Events2 } = require_Constants();
    module2.exports = (client, { d: data }) => {
      if (data.user) {
        client.users._add(data.user);
      }
      client.relationships.cache.set(data.id, data.type);
      client.relationships.friendNicknames.set(data.id, data.nickname);
      client.relationships.sinceCache.set(data.id, new Date(data.since || 0));
      client.emit(Events2.RELATIONSHIP_ADD, data.id, Boolean(data.should_notify));
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/RELATIONSHIP_REMOVE.js
var require_RELATIONSHIP_REMOVE = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/RELATIONSHIP_REMOVE.js"(exports2, module2) {
    "use strict";
    var { Events: Events2 } = require_Constants();
    module2.exports = (client, { d: data }) => {
      client.relationships.cache.delete(data.id);
      client.relationships.friendNicknames.delete(data.id);
      client.relationships.sinceCache.delete(data.id);
      client.emit(Events2.RELATIONSHIP_REMOVE, data.id, data.type, data.nickname);
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/RELATIONSHIP_UPDATE.js
var require_RELATIONSHIP_UPDATE = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/RELATIONSHIP_UPDATE.js"(exports2, module2) {
    "use strict";
    var { Events: Events2 } = require_Constants();
    module2.exports = (client, { d: data }) => {
      const oldType = client.relationships.cache.get(data.id);
      const oldSince = client.relationships.sinceCache.get(data.id);
      const oldNickname = client.relationships.friendNicknames.get(data.id);
      if (data.type) client.relationships.cache.set(data.id, data.type);
      if (data.nickname) client.relationships.friendNicknames.set(data.id, data.nickname);
      if (data.since) client.relationships.sinceCache.set(data.id, new Date(data.since || 0));
      client.emit(
        Events2.RELATIONSHIP_UPDATE,
        data.id,
        {
          type: oldType,
          nickname: oldNickname,
          since: oldSince
        },
        {
          type: data.type,
          nickname: data.nickname,
          since: new Date(data.since || 0)
        }
      );
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/USER_NOTE_UPDATE.js
var require_USER_NOTE_UPDATE = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/USER_NOTE_UPDATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, { d: data }) => {
      client.notes.cache.set(data.id, data.note);
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/CHANNEL_RECIPIENT_ADD.js
var require_CHANNEL_RECIPIENT_ADD = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/CHANNEL_RECIPIENT_ADD.js"(exports2, module2) {
    "use strict";
    var { Events: Events2, Status: Status2 } = require_Constants();
    module2.exports = (client, packet, shard) => {
      const channel = client.channels.cache.get(packet.d.channel_id);
      if (channel) {
        if (!channel._recipients) channel._recipients = [];
        channel._recipients.push(packet.d.user);
        const user = client.users._add(packet.d.user);
        if (shard.status == Status2.READY) {
          client.emit(Events2.CHANNEL_RECIPIENT_ADD, channel, user);
        }
      }
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/CHANNEL_RECIPIENT_REMOVE.js
var require_CHANNEL_RECIPIENT_REMOVE = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/CHANNEL_RECIPIENT_REMOVE.js"(exports2, module2) {
    "use strict";
    var { Events: Events2 } = require_Constants();
    module2.exports = (client, packet) => {
      const channel = client.channels.cache.get(packet.d.channel_id);
      if (channel) {
        if (!channel._recipients) channel._recipients = [];
        channel._recipients = channel._recipients.filter((u) => u.id !== packet.d.user.id);
        client.emit(Events2.CHANNEL_RECIPIENT_REMOVE, channel, client.users._add(packet.d.user));
      }
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/Modal.js
var require_Modal = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/Modal.js"(exports2, module2) {
    "use strict";
    var BaseMessageComponent = require_BaseMessageComponent();
    var { InteractionTypes } = require_Constants();
    var SnowflakeUtil = require_SnowflakeUtil();
    var Util = require_Util();
    var Modal = class {
      /**
       * @param {Object} data Modal to clone or raw data
       * @param {Client} client The client constructing this Modal, if provided
       */
      constructor(data = {}, client = null) {
        var _a;
        this.components = ((_a = data.components) == null ? void 0 : _a.map((c) => BaseMessageComponent.create(c, client))) ?? [];
        this.customId = data.custom_id;
        this.title = data.title;
        this.nonce = data.nonce;
        this.id = data.id;
        this.applicationId = data.application.id;
        this.channelId = data.channel_id;
        this.replied = false;
        Object.defineProperty(this, "client", {
          value: client,
          writable: false
        });
      }
      /**
       * The id of the guild the message was sent in, if any
       * @type {?Snowflake}
       * @readonly
       */
      get guildId() {
        var _a;
        return ((_a = this.client.channels.cache.get(this.channelId)) == null ? void 0 : _a.guildId) || null;
      }
      /**
       * The channel that the message was sent in
       * @type {TextBasedChannels}
       * @readonly
       */
      get channel() {
        return this.client.channels.resolve(this.channelId);
      }
      /**
       * The guild the message was sent in (if in a guild channel)
       * @type {?Guild}
       * @readonly
       */
      get guild() {
        var _a;
        return this.client.guilds.resolve(this.guildId) ?? ((_a = this.channel) == null ? void 0 : _a.guild) ?? null;
      }
      toJSON() {
        return {
          components: this.components.map((c) => c.toJSON()),
          custom_id: this.customId,
          title: this.title,
          id: this.id
        };
      }
      /**
       * Reply to this modal with data. (Event only)
       * @returns {Promise<Message|Modal>}
       * @example
       * client.on('interactionModalCreate', modal => {
       *    // Modal > ActionRow > TextInput
       *    modal.components[0].components[0].setValue('1+1');
       *    modal.components[1].components[0].setValue('hello');
       *    modal.reply();
       * })
       */
      reply() {
        if (!this.applicationId || !this.client || !this.channelId || this.replied) throw new Error("Modal cannot reply");
        const dataFinal = this.toJSON();
        dataFinal.components = dataFinal.components.map((c) => {
          c.components[0] = {
            type: c.components[0].type,
            value: c.components[0].value,
            custom_id: c.components[0].custom_id
          };
          return c;
        }).filter((c) => typeof c.components[0].value == "string");
        delete dataFinal.title;
        const nonce = SnowflakeUtil.generate();
        const postData = {
          type: InteractionTypes.MODAL_SUBMIT,
          // Modal
          application_id: this.applicationId,
          guild_id: this.guildId,
          channel_id: this.channelId,
          data: dataFinal,
          nonce,
          session_id: this.client.sessionId
        };
        this.client.api.interactions.post({
          data: postData
        });
        this.replied = true;
        return Util.createPromiseInteraction(this.client, nonce, 5e3, true, this);
      }
      // TypeScript
      /**
       * Check data
       * @type {boolean}
       * @readonly
       */
      get isMessage() {
        return false;
      }
    };
    module2.exports = Modal;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/INTERACTION_MODAL_CREATE.js
var require_INTERACTION_MODAL_CREATE = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/INTERACTION_MODAL_CREATE.js"(exports2, module2) {
    "use strict";
    var Modal = require_Modal();
    var { Events: Events2 } = require_Constants();
    module2.exports = (client, { d: data }) => {
      client.emit(Events2.INTERACTION_MODAL_CREATE, new Modal(data, client));
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/CallState.js
var require_CallState = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/CallState.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var Base = require_Base();
    var CallState = class extends Base {
      constructor(client, data) {
        super(client);
        this.channelId = data.channel_id;
        this._ringing = [];
        this._patch(data);
      }
      _patch(data) {
        if ("region" in data) {
          this.region = data.region;
        }
        if ("ringing" in data) {
          this._ringing = data.ringing;
        }
      }
      /**
       * The channel of the call
       * @type {?DMChannel|GroupDMChannel}
       */
      get channel() {
        return this.client.channels.cache.get(this.channelId);
      }
      /**
       * Sets the voice region of the call
       * @param {string} region Region of the call
       * @returns {Promise<void>}
       */
      setRTCRegion(region) {
        return this.client.api.channels(this.channelId).call.patch({ data: { region } });
      }
      /**
       * The list of user ID who is ringing
       * @type {Collection<Snowflake, User>}
       */
      get ringing() {
        return new Collection2(this._ringing.map((id) => [id, this.client.users.cache.get(id)]));
      }
    };
    module2.exports = CallState;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/CALL_CREATE.js
var require_CALL_CREATE = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/CALL_CREATE.js"(exports2, module2) {
    "use strict";
    var CallState = require_CallState();
    var { Events: Events2 } = require_Constants();
    module2.exports = (client, packet) => {
      for (const voice of packet.d.voice_states) {
        client.actions.VoiceStateUpdate.handle(voice);
      }
      client.emit(Events2.CALL_CREATE, new CallState(client, packet.d));
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/CALL_UPDATE.js
var require_CALL_UPDATE = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/CALL_UPDATE.js"(exports2, module2) {
    "use strict";
    var CallState = require_CallState();
    var { Events: Events2 } = require_Constants();
    module2.exports = (client, packet) => {
      client.emit(Events2.CALL_UPDATE, new CallState(client, packet.d));
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/CALL_DELETE.js
var require_CALL_DELETE = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/CALL_DELETE.js"(exports2, module2) {
    "use strict";
    var CallState = require_CallState();
    var { Events: Events2 } = require_Constants();
    module2.exports = (client, packet) => {
      client.emit(Events2.CALL_DELETE, new CallState(client, packet.d));
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/USER_SETTINGS_UPDATE.js
var require_USER_SETTINGS_UPDATE = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/USER_SETTINGS_UPDATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, { d: data }) => {
      client.settings._patch(data);
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/USER_GUILD_SETTINGS_UPDATE.js
var require_USER_GUILD_SETTINGS_UPDATE = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/USER_GUILD_SETTINGS_UPDATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, { d: data }) => {
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) guild == null ? void 0 : guild.settings._patch(data);
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/VOICE_CHANNEL_STATUS_UPDATE.js
var require_VOICE_CHANNEL_STATUS_UPDATE = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/VOICE_CHANNEL_STATUS_UPDATE.js"(exports2, module2) {
    "use strict";
    var { Events: Events2 } = require_Constants();
    module2.exports = (client, { d: data }) => {
      const channel = client.channels.cache.get(data.id);
      if (channel) {
        const old = channel._clone();
        channel.status = data.status;
        client.emit(Events2.CHANNEL_UPDATE, old, channel);
      }
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/MESSAGE_POLL_VOTE_ADD.js
var require_MESSAGE_POLL_VOTE_ADD = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/MESSAGE_POLL_VOTE_ADD.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.MessagePollVoteAdd.handle(packet.d);
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/MESSAGE_POLL_VOTE_REMOVE.js
var require_MESSAGE_POLL_VOTE_REMOVE = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/MESSAGE_POLL_VOTE_REMOVE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.MessagePollVoteRemove.handle(packet.d);
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/index.js
var require_handlers = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/websocket/handlers/index.js"(exports2, module2) {
    "use strict";
    var handlers = Object.fromEntries([
      ["READY", require_READY()],
      ["RESUMED", require_RESUMED()],
      ["APPLICATION_COMMAND_CREATE", require_APPLICATION_COMMAND_CREATE()],
      ["APPLICATION_COMMAND_DELETE", require_APPLICATION_COMMAND_DELETE()],
      ["APPLICATION_COMMAND_UPDATE", require_APPLICATION_COMMAND_UPDATE()],
      ["APPLICATION_COMMAND_PERMISSIONS_UPDATE", require_APPLICATION_COMMAND_PERMISSIONS_UPDATE()],
      ["AUTO_MODERATION_ACTION_EXECUTION", require_AUTO_MODERATION_ACTION_EXECUTION()],
      ["AUTO_MODERATION_RULE_CREATE", require_AUTO_MODERATION_RULE_CREATE()],
      ["AUTO_MODERATION_RULE_DELETE", require_AUTO_MODERATION_RULE_DELETE()],
      ["AUTO_MODERATION_RULE_UPDATE", require_AUTO_MODERATION_RULE_UPDATE()],
      ["GUILD_CREATE", require_GUILD_CREATE()],
      ["GUILD_DELETE", require_GUILD_DELETE()],
      ["GUILD_UPDATE", require_GUILD_UPDATE()],
      ["INVITE_CREATE", require_INVITE_CREATE()],
      ["INVITE_DELETE", require_INVITE_DELETE()],
      ["GUILD_MEMBER_ADD", require_GUILD_MEMBER_ADD()],
      ["GUILD_MEMBER_REMOVE", require_GUILD_MEMBER_REMOVE()],
      ["GUILD_MEMBER_UPDATE", require_GUILD_MEMBER_UPDATE()],
      ["GUILD_MEMBERS_CHUNK", require_GUILD_MEMBERS_CHUNK()],
      ["GUILD_INTEGRATIONS_UPDATE", require_GUILD_INTEGRATIONS_UPDATE()],
      ["GUILD_ROLE_CREATE", require_GUILD_ROLE_CREATE()],
      ["GUILD_ROLE_DELETE", require_GUILD_ROLE_DELETE()],
      ["GUILD_ROLE_UPDATE", require_GUILD_ROLE_UPDATE()],
      ["GUILD_BAN_ADD", require_GUILD_BAN_ADD()],
      ["GUILD_BAN_REMOVE", require_GUILD_BAN_REMOVE()],
      ["GUILD_EMOJIS_UPDATE", require_GUILD_EMOJIS_UPDATE()],
      ["CHANNEL_CREATE", require_CHANNEL_CREATE()],
      ["CHANNEL_DELETE", require_CHANNEL_DELETE()],
      ["CHANNEL_UPDATE", require_CHANNEL_UPDATE()],
      ["CHANNEL_PINS_UPDATE", require_CHANNEL_PINS_UPDATE()],
      ["MESSAGE_CREATE", require_MESSAGE_CREATE()],
      ["MESSAGE_DELETE", require_MESSAGE_DELETE()],
      ["MESSAGE_UPDATE", require_MESSAGE_UPDATE()],
      ["MESSAGE_DELETE_BULK", require_MESSAGE_DELETE_BULK()],
      ["MESSAGE_REACTION_ADD", require_MESSAGE_REACTION_ADD()],
      ["MESSAGE_REACTION_REMOVE", require_MESSAGE_REACTION_REMOVE()],
      ["MESSAGE_REACTION_REMOVE_ALL", require_MESSAGE_REACTION_REMOVE_ALL()],
      ["MESSAGE_REACTION_REMOVE_EMOJI", require_MESSAGE_REACTION_REMOVE_EMOJI()],
      ["THREAD_CREATE", require_THREAD_CREATE()],
      ["THREAD_UPDATE", require_THREAD_UPDATE()],
      ["THREAD_DELETE", require_THREAD_DELETE()],
      ["THREAD_LIST_SYNC", require_THREAD_LIST_SYNC()],
      ["THREAD_MEMBER_UPDATE", require_THREAD_MEMBER_UPDATE()],
      ["THREAD_MEMBERS_UPDATE", require_THREAD_MEMBERS_UPDATE()],
      ["USER_UPDATE", require_USER_UPDATE()],
      ["PRESENCE_UPDATE", require_PRESENCE_UPDATE()],
      ["TYPING_START", require_TYPING_START()],
      ["VOICE_STATE_UPDATE", require_VOICE_STATE_UPDATE()],
      ["VOICE_SERVER_UPDATE", require_VOICE_SERVER_UPDATE()],
      ["WEBHOOKS_UPDATE", require_WEBHOOKS_UPDATE()],
      ["STAGE_INSTANCE_CREATE", require_STAGE_INSTANCE_CREATE()],
      ["STAGE_INSTANCE_UPDATE", require_STAGE_INSTANCE_UPDATE()],
      ["STAGE_INSTANCE_DELETE", require_STAGE_INSTANCE_DELETE()],
      ["GUILD_STICKERS_UPDATE", require_GUILD_STICKERS_UPDATE()],
      ["GUILD_SCHEDULED_EVENT_CREATE", require_GUILD_SCHEDULED_EVENT_CREATE()],
      ["GUILD_SCHEDULED_EVENT_UPDATE", require_GUILD_SCHEDULED_EVENT_UPDATE()],
      ["GUILD_SCHEDULED_EVENT_DELETE", require_GUILD_SCHEDULED_EVENT_DELETE()],
      ["GUILD_SCHEDULED_EVENT_USER_ADD", require_GUILD_SCHEDULED_EVENT_USER_ADD()],
      ["GUILD_SCHEDULED_EVENT_USER_REMOVE", require_GUILD_SCHEDULED_EVENT_USER_REMOVE()],
      ["GUILD_AUDIT_LOG_ENTRY_CREATE", require_GUILD_AUDIT_LOG_ENTRY_CREATE()],
      // Selfbot
      ["RELATIONSHIP_ADD", require_RELATIONSHIP_ADD()],
      ["RELATIONSHIP_REMOVE", require_RELATIONSHIP_REMOVE()],
      ["RELATIONSHIP_UPDATE", require_RELATIONSHIP_UPDATE()],
      ["USER_NOTE_UPDATE", require_USER_NOTE_UPDATE()],
      ["CHANNEL_RECIPIENT_ADD", require_CHANNEL_RECIPIENT_ADD()],
      ["CHANNEL_RECIPIENT_REMOVE", require_CHANNEL_RECIPIENT_REMOVE()],
      ["INTERACTION_MODAL_CREATE", require_INTERACTION_MODAL_CREATE()],
      ["USER_REQUIRED_ACTION_UPDATE", require_USER_REQUIRED_ACTION_UPDATE()],
      ["CALL_CREATE", require_CALL_CREATE()],
      ["CALL_UPDATE", require_CALL_UPDATE()],
      ["CALL_DELETE", require_CALL_DELETE()],
      ["USER_SETTINGS_UPDATE", require_USER_SETTINGS_UPDATE()],
      ["USER_GUILD_SETTINGS_UPDATE", require_USER_GUILD_SETTINGS_UPDATE()],
      ["VOICE_CHANNEL_STATUS_UPDATE", require_VOICE_CHANNEL_STATUS_UPDATE()],
      ["MESSAGE_POLL_VOTE_ADD", require_MESSAGE_POLL_VOTE_ADD()],
      ["MESSAGE_POLL_VOTE_REMOVE", require_MESSAGE_POLL_VOTE_REMOVE()]
    ]);
    module2.exports = handlers;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/websocket/WebSocketManager.js
var require_WebSocketManager = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/websocket/WebSocketManager.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require_node_events();
    var { setImmediate: setImmediate2 } = require_node_timers();
    var { setTimeout: sleep } = require_promises();
    var { Collection: Collection2 } = require_dist();
    var { RPCErrorCodes } = require_v96();
    var WebSocketShard = require_WebSocketShard();
    var PacketHandlers = require_handlers();
    var { Error: Error2 } = require_errors2();
    var { Events: Events2, ShardEvents, Status: Status2, WSCodes, WSEvents } = require_Constants();
    var BeforeReadyWhitelist = [
      WSEvents.READY,
      WSEvents.RESUMED,
      WSEvents.GUILD_CREATE,
      WSEvents.GUILD_DELETE,
      WSEvents.GUILD_MEMBERS_CHUNK,
      WSEvents.GUILD_MEMBER_ADD,
      WSEvents.GUILD_MEMBER_REMOVE
    ];
    var UNRECOVERABLE_CLOSE_CODES = Object.keys(WSCodes).slice(2).map(Number);
    var UNRESUMABLE_CLOSE_CODES = [
      RPCErrorCodes.UnknownError,
      RPCErrorCodes.InvalidPermissions,
      RPCErrorCodes.InvalidClientId
    ];
    var WebSocketManager2 = class extends EventEmitter {
      constructor(client) {
        super();
        Object.defineProperty(this, "client", { value: client });
        this.gateway = null;
        this.totalShards = this.client.options.shards.length;
        this.shards = new Collection2();
        Object.defineProperty(this, "shardQueue", { value: /* @__PURE__ */ new Set(), writable: true });
        Object.defineProperty(this, "packetQueue", { value: [] });
        this.status = Status2.IDLE;
        this.destroyed = false;
        this.reconnecting = false;
      }
      /**
       * The average ping of all WebSocketShards
       * @type {number}
       * @readonly
       */
      get ping() {
        const sum = this.shards.reduce((a, b) => a + b.ping, 0);
        return sum / this.shards.size;
      }
      /**
       * Emits a debug message.
       * @param {string} message The debug message
       * @param {?WebSocketShard} [shard] The shard that emitted this message, if any
       * @private
       */
      debug(message, shard) {
        this.client.emit(Events2.DEBUG, `[WS => ${shard ? `Shard ${shard.id}` : "Manager"}] ${message}`);
      }
      /**
       * Connects this manager to the gateway.
       * @private
       */
      async connect() {
        let gatewayURL = "wss://gateway.discord.gg";
        await this.client.api.gateway.get({ auth: false }).then((r) => gatewayURL = r.url).catch(() => {
        });
        const total = Infinity;
        const remaining = Infinity;
        const recommendedShards = 1;
        this.debug(`Fetched Gateway Information
    URL: ${gatewayURL}
    Recommended Shards: ${recommendedShards}`);
        this.debug(`Session Limit Information
    Total: ${total}
    Remaining: ${remaining}`);
        this.gateway = `${gatewayURL}/`;
        let { shards } = this.client.options;
        if (shards === "auto") {
          this.debug(`Using the recommended shard count provided by Discord: ${recommendedShards}`);
          this.totalShards = this.client.options.shardCount = recommendedShards;
          shards = this.client.options.shards = Array.from({ length: recommendedShards }, (_, i) => i);
        }
        this.totalShards = shards.length;
        this.debug(`Spawning shards: ${shards.join(", ")}`);
        this.shardQueue = new Set(shards.map((id) => new WebSocketShard(this, id)));
        return this.createShards();
      }
      /**
       * Handles the creation of a shard.
       * @returns {Promise<boolean>}
       * @private
       */
      async createShards() {
        if (!this.shardQueue.size) return false;
        const [shard] = this.shardQueue;
        this.shardQueue.delete(shard);
        if (!shard.eventsAttached) {
          shard.on(ShardEvents.ALL_READY, (unavailableGuilds) => {
            this.client.emit(Events2.SHARD_READY, shard.id, unavailableGuilds);
            if (!this.shardQueue.size) this.reconnecting = false;
            this.checkShardsReady();
          });
          shard.on(ShardEvents.CLOSE, (event) => {
            if (event.code === 1e3 ? this.destroyed : UNRECOVERABLE_CLOSE_CODES.includes(event.code)) {
              this.client.emit(Events2.SHARD_DISCONNECT, event, shard.id);
              this.debug(WSCodes[event.code], shard);
              return;
            }
            if (UNRESUMABLE_CLOSE_CODES.includes(event.code)) {
              shard.sessionId = null;
            }
            this.client.emit(Events2.SHARD_RECONNECTING, shard.id);
            this.shardQueue.add(shard);
            if (shard.sessionId) this.debug(`Session id is present, attempting an immediate reconnect...`, shard);
            this.reconnect();
          });
          shard.on(ShardEvents.INVALID_SESSION, () => {
            this.client.emit(Events2.SHARD_RECONNECTING, shard.id);
          });
          shard.on(ShardEvents.DESTROYED, () => {
            this.debug("Shard was destroyed but no WebSocket connection was present! Reconnecting...", shard);
            this.client.emit(Events2.SHARD_RECONNECTING, shard.id);
            this.shardQueue.add(shard);
            this.reconnect();
          });
          shard.eventsAttached = true;
        }
        this.shards.set(shard.id, shard);
        try {
          await shard.connect();
        } catch (error2) {
          if ((error2 == null ? void 0 : error2.code) && UNRECOVERABLE_CLOSE_CODES.includes(error2.code)) {
            throw new Error2(WSCodes[error2.code]);
          } else if (!error2 || error2.code) {
            this.debug("Failed to connect to the gateway, requeueing...", shard);
            this.shardQueue.add(shard);
          } else {
            throw error2;
          }
        }
        if (this.shardQueue.size) {
          this.debug(`Shard Queue Size: ${this.shardQueue.size}; continuing in 5 seconds...`);
          await sleep(5e3);
          return this.createShards();
        }
        return true;
      }
      /**
       * Handles reconnects for this manager.
       * @private
       * @returns {Promise<boolean>}
       */
      async reconnect() {
        if (this.reconnecting || this.status !== Status2.READY) return false;
        this.reconnecting = true;
        try {
          await this.createShards();
        } catch (error2) {
          this.debug(`Couldn't reconnect or fetch information about the gateway. ${error2}`);
          if (error2.httpStatus !== 401) {
            this.debug(`Possible network error occurred. Retrying in 5s...`);
            await sleep(5e3);
            this.reconnecting = false;
            return this.reconnect();
          }
          if (this.client.listenerCount(Events2.INVALIDATED)) {
            this.client.emit(Events2.INVALIDATED);
            this.destroy();
          } else {
            this.client.destroy();
          }
        } finally {
          this.reconnecting = false;
        }
        return true;
      }
      /**
       * Broadcasts a packet to every shard this manager handles.
       * @param {Object} packet The packet to send
       * @private
       */
      broadcast(packet) {
        for (const shard of this.shards.values()) shard.send(packet);
      }
      /**
       * Destroys this manager and all its shards.
       * @private
       */
      destroy() {
        if (this.destroyed) return;
        this.debug(`Manager was destroyed. Called by:
${new Error2("MANAGER_DESTROYED").stack}`);
        this.destroyed = true;
        this.shardQueue.clear();
        for (const shard of this.shards.values()) shard.destroy({ closeCode: 1e3, reset: true, emit: false, log: false });
      }
      /**
       * Processes a packet and queues it if this WebSocketManager is not ready.
       * @param {Object} [packet] The packet to be handled
       * @param {WebSocketShard} [shard] The shard that will handle this packet
       * @returns {boolean}
       * @private
       */
      handlePacket(packet, shard) {
        if (packet && this.status !== Status2.READY) {
          if (!BeforeReadyWhitelist.includes(packet.t)) {
            this.packetQueue.push({ packet, shard });
            return false;
          }
        }
        if (this.packetQueue.length) {
          const item = this.packetQueue.shift();
          setImmediate2(() => {
            this.handlePacket(item.packet, item.shard);
          }).unref();
        }
        if (packet && PacketHandlers[packet.t]) {
          PacketHandlers[packet.t](this.client, packet, shard);
        } else if (packet) {
          this.client.emit(Events2.UNHANDLED_PACKET, packet, shard);
        }
        return true;
      }
      /**
       * Checks whether the client is ready to be marked as ready.
       * @private
       */
      checkShardsReady() {
        if (this.status === Status2.READY) return;
        if (this.shards.size !== this.totalShards || this.shards.some((s) => s.status !== Status2.READY)) {
          return;
        }
        this.triggerClientReady();
      }
      /**
       * Causes the client to be marked as ready and emits the ready event.
       * @private
       */
      triggerClientReady() {
        this.status = Status2.READY;
        this.client.readyAt = /* @__PURE__ */ new Date();
        this.client.emit(Events2.CLIENT_READY, this.client);
        this.handlePacket();
      }
    };
    module2.exports = WebSocketManager2;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/GuildBoost.js
var require_GuildBoost = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/GuildBoost.js"(exports2, module2) {
    "use strict";
    var Base = require_Base();
    var GuildBoost = class extends Base {
      constructor(client, data) {
        super(client);
        this._patch(data);
      }
      _patch(data) {
        if ("id" in data) {
          this.id = data.id;
        }
        if ("subscription_id" in data) {
          this.subscriptionId = data.subscription_id;
        }
        if (typeof data.premium_guild_subscription === "object" && data.premium_guild_subscription !== null) {
          this.premiumGuildSubscriptionId = data.premium_guild_subscription.id;
          this.guildId = data.premium_guild_subscription.guild_id;
          this.ended = data.premium_guild_subscription.ended;
        }
        if ("canceled" in data) {
          this.canceled = data.canceled;
        }
        if ("cooldown_ends_at" in data) {
          this.cooldownEndsAt = new Date(data.cooldown_ends_at);
        }
      }
      /**
       * The guild of the boost
       * @type {?Guild}
       * @readonly
       */
      get guilld() {
        return this.client.guilds.cache.get(this.guildId);
      }
      /**
       * Cancel the boost
       * @returns {Promise<GuildBoost>}
       */
      async unsubscribe() {
        if (!this.guildId) throw new Error("BOOST_UNUSED");
        if (!this.premiumGuildSubscriptionId) throw new Error("BOOST_UNCACHED");
        await this.client.api.guilds(this.guildId).premium.subscriptions(this.premiumGuildSubscriptionId).delete();
        this.guildId = null;
        this.premiumGuildSubscriptionId = null;
        this.ended = null;
        return this;
      }
      /**
       * Use the boost
       * @param {GuildResolvable} guild The guild to use the boost on
       * @returns {Promise<GuildBoost>}
       */
      async subscribe(guild) {
        if (this.guildId || this.premiumGuildSubscriptionId) throw new Error("BOOST_USED");
        const id = this.client.guilds.resolveId(guild);
        if (!id) throw new Error("UNKNOWN_GUILD");
        const d = await this.client.api.guilds(id).premium.subscriptions.put({
          data: {
            user_premium_guild_subscription_slot_ids: [this.id]
          }
        });
        this._patch({
          premium_guild_subscription: d
        });
        return this;
      }
    };
    module2.exports = GuildBoost;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/managers/BillingManager.js
var require_BillingManager = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/managers/BillingManager.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var BaseManager = require_BaseManager();
    var GuildBoost = require_GuildBoost();
    var BillingManager2 = class extends BaseManager {
      constructor(client) {
        super(client);
        this.paymentSources = new Collection2();
        this.guildBoosts = new Collection2();
        this.currentSubscription = new Collection2();
      }
      /**
       * Fetches all the payment sources of the client
       * @returns {Collection<Snowflake, Object>}
       */
      async fetchPaymentSources() {
        const d = await this.client.api.users("@me").billing["payment-sources"].get();
        this.paymentSources = new Collection2(d.map((s) => [s.id, s]));
        return this.paymentSources;
      }
      /**
       * Fetches all the guild boosts of the client
       * @returns {Collection<Snowflake, GuildBoost>}
       */
      async fetchGuildBoosts() {
        const d = await this.client.api.users("@me").guilds.premium["subscription-slots"].get();
        this.guildBoosts = new Collection2(d.map((s) => [s.id, new GuildBoost(this.client, s)]));
        return this.guildBoosts;
      }
      /**
       * Fetches the current subscription of the client
       * @returns {Collection<Snowflake, Object>}
       */
      async fetchCurrentSubscription() {
        const d = await this.client.api.users("@me").billing.subscriptions.get();
        this.currentSubscription = new Collection2(d.map((s) => [s.id, s]));
        return this.currentSubscription;
      }
    };
    module2.exports = BillingManager2;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/managers/ChannelManager.js
var require_ChannelManager = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/managers/ChannelManager.js"(exports2, module2) {
    "use strict";
    var process2 = require_node_process();
    var CachedManager = require_CachedManager();
    var { Channel } = require_Channel();
    var { Events: Events2, ThreadChannelTypes, RelationshipTypes } = require_Constants();
    var cacheWarningEmitted = false;
    var ChannelManager2 = class extends CachedManager {
      constructor(client, iterable) {
        super(client, Channel, iterable);
        const defaultCaching = this._cache.constructor.name === "Collection" || (this._cache.maxSize === void 0 || this._cache.maxSize === Infinity) && (this._cache.sweepFilter === void 0 || this._cache.sweepFilter.isDefault);
        if (!cacheWarningEmitted && !defaultCaching) {
          cacheWarningEmitted = true;
          process2.emitWarning(
            `Overriding the cache handling for ${this.constructor.name} is unsupported and breaks functionality.`,
            "UnsupportedCacheOverwriteWarning"
          );
        }
      }
      /**
       * The cache of Channels
       * @type {Collection<Snowflake, Channel>}
       * @name ChannelManager#cache
       */
      _add(data, guild, { cache = true, allowUnknownGuild = false } = {}) {
        var _a, _b, _c;
        const existing = this.cache.get(data.id);
        if (existing) {
          if (cache) existing._patch(data);
          (_a = guild == null ? void 0 : guild.channels) == null ? void 0 : _a._add(existing);
          if (ThreadChannelTypes.includes(existing.type)) {
            (_c = (_b = existing.parent) == null ? void 0 : _b.threads) == null ? void 0 : _c._add(existing);
          }
          return existing;
        }
        const channel = Channel.create(this.client, data, guild, { allowUnknownGuild });
        if (!channel) {
          this.client.emit(Events2.DEBUG, `Failed to find guild, or unknown type for channel ${data.id} ${data.type}`);
          return null;
        }
        if (cache && !allowUnknownGuild) this.cache.set(channel.id, channel);
        return channel;
      }
      _remove(id) {
        var _a, _b, _c;
        const channel = this.cache.get(id);
        (_a = channel == null ? void 0 : channel.guild) == null ? void 0 : _a.channels.cache.delete(id);
        (_c = (_b = channel == null ? void 0 : channel.parent) == null ? void 0 : _b.threads) == null ? void 0 : _c.cache.delete(id);
        this.cache.delete(id);
      }
      /**
       * Data that can be resolved to give a Channel object. This can be:
       * * A Channel object
       * * A Snowflake
       * @typedef {Channel|Snowflake} ChannelResolvable
       */
      /**
       * Resolves a ChannelResolvable to a Channel object.
       * @method resolve
       * @memberof ChannelManager
       * @instance
       * @param {ChannelResolvable} channel The channel resolvable to resolve
       * @returns {?Channel}
       */
      /**
       * Resolves a ChannelResolvable to a channel id string.
       * @method resolveId
       * @memberof ChannelManager
       * @instance
       * @param {ChannelResolvable} channel The channel resolvable to resolve
       * @returns {?Snowflake}
       */
      /**
       * Options for fetching a channel from Discord
       * @typedef {BaseFetchOptions} FetchChannelOptions
       * @property {boolean} [allowUnknownGuild=false] Allows the channel to be returned even if the guild is not in cache,
       * it will not be cached. <warn>Many of the properties and methods on the returned channel will throw errors</warn>
       */
      /**
       * Obtains a channel from Discord, or the channel cache if it's already available.
       * @param {Snowflake} id The channel's id
       * @param {FetchChannelOptions} [options] Additional options for this fetch
       * @returns {Promise<?Channel>}
       * @example
       * // Fetch a channel by its id
       * client.channels.fetch('222109930545610754')
       *   .then(channel => console.log(channel.name))
       *   .catch(console.error);
       */
      async fetch(id, { allowUnknownGuild = false, cache = true, force = false } = {}) {
        if (!force) {
          const existing = this.cache.get(id);
          if (existing && !existing.partial) return existing;
        }
        const data = await this.client.api.channels(id).get();
        return this._add(data, null, { cache, allowUnknownGuild });
      }
      /**
       * Create Group DM
       * @param {UserResolvable[]} [recipients=[]] Array of recipients
       * @returns {Promise<GroupDMChannel>} Channel
       * @example
       * client.channels.createGroupDM();
       */
      async createGroupDM(recipients = []) {
        if (!Array.isArray(recipients)) throw new Error(`Expected an array of recipients (got ${typeof recipients})`);
        recipients = recipients.map((r) => this.client.users.resolveId(r)).filter((r) => r && this.client.relationships.cache.get(r) == RelationshipTypes.FRIEND);
        if (recipients.length == 1 || recipients.length > 9) throw new Error("Invalid Users length (max=9)");
        const data = await this.client.api.users["@me"].channels.post({
          data: { recipients }
        });
        return this._add(data, null, { cache: true, allowUnknownGuild: true });
      }
    };
    module2.exports = ChannelManager2;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/managers/ClientUserSettingManager.js
var require_ClientUserSettingManager = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/managers/ClientUserSettingManager.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var BaseManager = require_BaseManager();
    var { TypeError: TypeError2 } = require_DJSError();
    var { CustomStatus } = require_Presence();
    var { ActivityTypes } = require_Constants();
    var _rawSetting;
    var ClientUserSettingManager2 = class extends BaseManager {
      constructor(client) {
        super(client);
        __privateAdd(this, _rawSetting, {});
        this.addFriendFrom = {
          all: null,
          mutual_friends: null,
          mutual_guilds: null
        };
      }
      /**
       * Patch data file
       * https://luna.gitlab.io/discord-unofficial-docs/docs/user_settings
       * @private
       * @param {Object} data Raw Data to patch
       */
      _patch(data = {}) {
        __privateSet(this, _rawSetting, Object.assign(__privateGet(this, _rawSetting), data));
        this.client.emit("debug", `[SETTING > ClientUser] Sync setting`);
        if ("locale" in data) {
          this.locale = data.locale;
        }
        if ("show_current_game" in data) {
          this.activityDisplay = data.show_current_game;
        }
        if ("default_guilds_restricted" in data) {
          this.allowDMsFromGuild = data.default_guilds_restricted;
        }
        if ("inline_attachment_media" in data) {
          this.displayImage = data.inline_attachment_media;
        }
        if ("inline_embed_media" in data) {
          this.linkedImageDisplay = data.inline_embed_media;
        }
        if ("gif_auto_play" in data) {
          this.autoplayGIF = data.gif_auto_play;
        }
        if ("render_embeds" in data) {
          this.previewLink = data.render_embeds;
        }
        if ("animate_emoji" in data) {
          this.animatedEmoji = data.animate_emoji;
        }
        if ("enable_tts_command" in data) {
          this.allowTTS = data.enable_tts_command;
        }
        if ("message_display_compact" in data) {
          this.compactMode = data.message_display_compact;
        }
        if ("convert_emoticons" in data) {
          this.convertEmoticons = data.convert_emoticons;
        }
        if ("explicit_content_filter" in data) {
          this.DMScanLevel = data.explicit_content_filter;
        }
        if ("theme" in data) {
          this.theme = data.theme;
        }
        if ("developer_mode" in data) {
          this.developerMode = data.developer_mode;
        }
        if ("afk_timeout" in data) {
          this.afkTimeout = data.afk_timeout;
        }
        if ("animate_stickers" in data) {
          this.stickerAnimationMode = data.animate_stickers;
        }
        if ("render_reactions" in data) {
          this.showEmojiReactions = data.render_reactions;
        }
        if ("status" in data) {
          this.client.presence.status = data.status;
          if (!("custom_status" in data)) {
            this.client.emit("debug", "[SETTING > ClientUser] Sync status");
            this.client.user.setStatus(data.status);
          }
        }
        if ("custom_status" in data) {
          this.customStatus = data.custom_status;
          const activities = this.client.presence.activities.filter(
            (a) => ![ActivityTypes.CUSTOM, "CUSTOM"].includes(a.type)
          );
          if (data.custom_status) {
            const custom = new CustomStatus(this.client);
            custom.setState(data.custom_status.text);
            let emoji;
            if (data.custom_status.emoji_id) {
              emoji = this.client.emojis.cache.get(data.custom_status.emoji_id);
            } else if (data.custom_status.emoji_name) {
              emoji = `:${data.custom_status.emoji_name}:`;
            }
            if (emoji) custom.setEmoji(emoji);
            activities.push(custom);
          }
          this.client.emit("debug", "[SETTING > ClientUser] Sync activities & status");
          this.client.user.setPresence({ activities });
        }
        if ("friend_source_flags" in data) {
        }
        if ("restricted_guilds" in data) {
          this.disableDMfromGuilds = new Collection2(
            data.restricted_guilds.map((guildId) => [guildId, this.client.guilds.cache.get(guildId)])
          );
        }
      }
      /**
       * Raw data
       * @type {Object}
       */
      get raw() {
        return __privateGet(this, _rawSetting);
      }
      async fetch() {
        const data = await this.client.api.users("@me").settings.get();
        this._patch(data);
        return this;
      }
      /**
       * Edit data
       * @param {any} data Data to edit
       */
      async edit(data) {
        const res = await this.client.api.users("@me").settings.patch({ data });
        this._patch(res);
        return this;
      }
      /**
       * Toggle compact mode
       * @returns {Promise<this>}
       */
      toggleCompactMode() {
        return this.edit({ message_display_compact: !this.compactMode });
      }
      /**
       * Discord Theme
       * @param {string} value Theme to set (dark | light)
       * @returns {Promise<this>}
       */
      setTheme(value) {
        const validValues = ["dark", "light"];
        if (!validValues.includes(value)) {
          throw new TypeError2("INVALID_TYPE", "value", "dark | light", true);
        }
        return this.edit({ theme: value });
      }
      /**
       * CustomStatus Object
       * @typedef {Object} CustomStatusOption
       * @property {string | null} text Text to set
       * @property {string | null} status The status to set: 'online', 'idle', 'dnd', 'invisible' or null.
       * @property {EmojiResolvable | null} emoji UnicodeEmoji, DiscordEmoji, or null.
       * @property {number | null} expires The number of seconds until the status expires, or null.
       */
      /**
       * Set custom status
       * @param {?CustomStatus | CustomStatusOption} options CustomStatus
       * @returns {Promise<this>}
       */
      setCustomStatus(options) {
        var _a, _b, _c, _d, _e;
        if (typeof options !== "object") {
          return this.edit({ custom_status: null });
        } else if (options instanceof CustomStatus) {
          options = options.toJSON();
          let data = {
            emoji_name: null,
            expires_at: null,
            text: null
          };
          if (typeof options.state === "string") {
            data.text = options.state;
          }
          if (options.emoji) {
            if ((_a = options.emoji) == null ? void 0 : _a.id) {
              data.emoji_name = (_b = options.emoji) == null ? void 0 : _b.name;
              data.emoji_id = (_c = options.emoji) == null ? void 0 : _c.id;
            } else {
              data.emoji_name = typeof ((_d = options.emoji) == null ? void 0 : _d.name) === "string" ? (_e = options.emoji) == null ? void 0 : _e.name : null;
            }
          }
          return this.edit({ custom_status: data });
        } else {
          let data = {
            emoji_name: null,
            expires_at: null,
            text: null
          };
          if (typeof options.text === "string") {
            if (options.text.length > 128) {
              throw new RangeError("[INVALID_VALUE] Custom status text must be less than 128 characters");
            }
            data.text = options.text;
          }
          if (options.emoji) {
            const emoji = this.client.emojis.resolve(options.emoji);
            if (emoji) {
              data.emoji_name = emoji.name;
              data.emoji_id = emoji.id;
            } else {
              data.emoji_name = typeof options.emoji === "string" ? options.emoji : null;
            }
          }
          if (typeof options.expires === "number") {
            if (options.expires < Date.now()) {
              throw new RangeError(`[INVALID_VALUE] Custom status expiration must be greater than ${Date.now()}`);
            }
            data.expires_at = new Date(options.expires).toISOString();
          }
          if (["online", "idle", "dnd", "invisible"].includes(options.status)) this.edit({ status: options.status });
          return this.edit({ custom_status: data });
        }
      }
      /**
       * Restricted guilds setting
       * @param {boolean} status Restricted status
       * @returns {Promise}
       */
      restrictedGuilds(status) {
        if (typeof status !== "boolean") {
          throw new TypeError2("INVALID_TYPE", "status", "boolean", true);
        }
        return this.edit({
          default_guilds_restricted: status,
          restricted_guilds: status ? this.client.guilds.cache.map((v) => v.id) : []
        });
      }
      /**
       * Add a guild to the list of restricted guilds.
       * @param {GuildIDResolve} guildId The guild to add
       * @returns {Promise}
       */
      addRestrictedGuild(guildId) {
        const temp = Object.assign(
          [],
          this.disableDMfromServer.map((v, k) => k)
        );
        if (temp.includes(guildId)) throw new Error("Guild is already restricted");
        temp.push(guildId);
        return this.edit({ restricted_guilds: temp });
      }
      /**
       * Remove a guild from the list of restricted guilds.
       * @param {GuildIDResolve} guildId The guild to remove
       * @returns {Promise}
       */
      removeRestrictedGuild(guildId) {
        if (!this.disableDMfromServer.delete(guildId)) throw new Error("Guild is already restricted");
        return this.edit({ restricted_guilds: this.disableDMfromServer.map((v, k) => k) });
      }
    };
    _rawSetting = new WeakMap();
    module2.exports = ClientUserSettingManager2;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/OAuth2Guild.js
var require_OAuth2Guild = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/OAuth2Guild.js"(exports2, module2) {
    "use strict";
    var BaseGuild = require_BaseGuild();
    var Permissions2 = require_Permissions();
    var OAuth2Guild = class extends BaseGuild {
      constructor(client, data) {
        super(client, data);
        this.owner = data.owner;
        this.permissions = new Permissions2(BigInt(data.permissions)).freeze();
      }
    };
    module2.exports = OAuth2Guild;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/managers/GuildManager.js
var require_GuildManager = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/managers/GuildManager.js"(exports2, module2) {
    "use strict";
    var process2 = require_node_process();
    var { setTimeout: setTimeout2 } = require_node_timers();
    var { Collection: Collection2 } = require_dist();
    var CachedManager = require_CachedManager();
    var { Guild } = require_Guild();
    var GuildChannel = require_GuildChannel();
    var GuildEmoji = require_GuildEmoji();
    var { GuildMember } = require_GuildMember();
    var Invite2 = require_Invite();
    var OAuth2Guild = require_OAuth2Guild();
    var { Role } = require_Role();
    var {
      ChannelTypes,
      Events: Events2,
      OverwriteTypes,
      VerificationLevels,
      DefaultMessageNotificationLevels,
      ExplicitContentFilterLevels,
      VideoQualityModes
    } = require_Constants();
    var DataResolver2 = require_DataResolver();
    var Permissions2 = require_Permissions();
    var SystemChannelFlags = require_SystemChannelFlags();
    var { resolveColor } = require_Util();
    var cacheWarningEmitted = false;
    var GuildManager2 = class extends CachedManager {
      constructor(client, iterable) {
        super(client, Guild, iterable);
        if (!cacheWarningEmitted && this._cache.constructor.name !== "Collection") {
          cacheWarningEmitted = true;
          process2.emitWarning(
            `Overriding the cache handling for ${this.constructor.name} is unsupported and breaks functionality.`,
            "UnsupportedCacheOverwriteWarning"
          );
        }
      }
      /**
       * The cache of this Manager
       * @type {Collection<Snowflake, Guild>}
       * @name GuildManager#cache
       */
      /**
       * Data that resolves to give a Guild object. This can be:
       * * A Guild object
       * * A GuildChannel object
       * * A GuildEmoji object
       * * A Role object
       * * A Snowflake
       * * An Invite object
       * @typedef {Guild|GuildChannel|GuildMember|GuildEmoji|Role|Snowflake|Invite} GuildResolvable
       */
      /**
       * Partial data for a Role.
       * @typedef {Object} PartialRoleData
       * @property {Snowflake|number} [id] The role's id, used to set channel overrides,
       * this is a placeholder and will be replaced by the API after consumption
       * @property {string} [name] The name of the role
       * @property {ColorResolvable} [color] The color of the role, either a hex string or a base 10 number
       * @property {boolean} [hoist] Whether or not the role should be hoisted
       * @property {number} [position] The position of the role
       * @property {PermissionResolvable} [permissions] The permissions of the role
       * @property {boolean} [mentionable] Whether or not the role should be mentionable
       */
      /**
       * Partial overwrite data.
       * @typedef {Object} PartialOverwriteData
       * @property {Snowflake|number} id The id of the {@link Role} or {@link User} this overwrite belongs to
       * @property {OverwriteType} [type] The type of this overwrite
       * @property {PermissionResolvable} [allow] The permissions to allow
       * @property {PermissionResolvable} [deny] The permissions to deny
       */
      /**
       * Partial data for a Channel.
       * @typedef {Object} PartialChannelData
       * @property {Snowflake|number} [id] The channel's id, used to set its parent,
       * this is a placeholder and will be replaced by the API after consumption
       * @property {Snowflake|number} [parentId] The parent id for this channel
       * @property {ChannelType|number} [type] The type of the channel
       * @property {string} name The name of the channel
       * @property {string} [topic] The topic of the text channel
       * @property {boolean} [nsfw] Whether the channel is NSFW
       * @property {number} [bitrate] The bitrate of the voice channel
       * @property {number} [userLimit] The user limit of the channel
       * @property {?string} [rtcRegion] The RTC region of the channel
       * @property {VideoQualityMode|number} [videoQualityMode] The camera video quality mode of the channel
       * @property {PartialOverwriteData[]} [permissionOverwrites]
       * Overwrites of the channel
       * @property {number} [rateLimitPerUser] The rate limit per user (slowmode) of the channel in seconds
       */
      /**
       * Resolves a GuildResolvable to a Guild object.
       * @method resolve
       * @memberof GuildManager
       * @instance
       * @param {GuildResolvable} guild The guild resolvable to identify
       * @returns {?Guild}
       */
      resolve(guild) {
        if (guild instanceof GuildChannel || guild instanceof GuildMember || guild instanceof GuildEmoji || guild instanceof Role || guild instanceof Invite2 && guild.guild) {
          return super.resolve(guild.guild);
        }
        return super.resolve(guild);
      }
      /**
       * Resolves a {@link GuildResolvable} to a {@link Guild} id string.
       * @method resolveId
       * @memberof GuildManager
       * @instance
       * @param {GuildResolvable} guild The guild resolvable to identify
       * @returns {?Snowflake}
       */
      resolveId(guild) {
        if (guild instanceof GuildChannel || guild instanceof GuildMember || guild instanceof GuildEmoji || guild instanceof Role || guild instanceof Invite2 && guild.guild) {
          return super.resolveId(guild.guild.id);
        }
        return super.resolveId(guild);
      }
      /**
       * Options used to create a guild.
       * @typedef {Object} GuildCreateOptions
       * @property {Snowflake|number} [afkChannelId] The AFK channel's id
       * @property {number} [afkTimeout] The AFK timeout in seconds
       * @property {PartialChannelData[]} [channels=[]] The channels for this guild
       * @property {DefaultMessageNotificationLevel|number} [defaultMessageNotifications] The default message notifications
       * for the guild
       * @property {ExplicitContentFilterLevel} [explicitContentFilter] The explicit content filter level for the guild
       * @property {?(BufferResolvable|Base64Resolvable)} [icon=null] The icon for the guild
       * @property {PartialRoleData[]} [roles=[]] The roles for this guild,
       * the first element of this array is used to change properties of the guild's everyone role.
       * @property {Snowflake|number} [systemChannelId] The system channel's id
       * @property {SystemChannelFlagsResolvable} [systemChannelFlags] The flags of the system channel
       * @property {VerificationLevel} [verificationLevel] The verification level for the guild
       */
      /**
       * Creates a guild.
       * @param {string} name The name of the guild
       * @param {GuildCreateOptions} [options] Options for creating the guild
       * @returns {Promise<Guild>} The guild that was created
       */
      async create(name, {
        afkChannelId,
        afkTimeout,
        channels = [],
        defaultMessageNotifications,
        explicitContentFilter,
        icon = null,
        roles = [],
        systemChannelId,
        systemChannelFlags,
        verificationLevel
      } = {}) {
        icon = await DataResolver2.resolveImage(icon);
        if (typeof verificationLevel === "string") {
          verificationLevel = VerificationLevels[verificationLevel];
        }
        if (typeof defaultMessageNotifications === "string") {
          defaultMessageNotifications = DefaultMessageNotificationLevels[defaultMessageNotifications];
        }
        if (typeof explicitContentFilter === "string") {
          explicitContentFilter = ExplicitContentFilterLevels[explicitContentFilter];
        }
        for (const channel of channels) {
          channel.type && (channel.type = typeof channel.type === "number" ? channel.type : ChannelTypes[channel.type]);
          channel.parent_id = channel.parentId;
          delete channel.parentId;
          channel.user_limit = channel.userLimit;
          delete channel.userLimit;
          channel.rate_limit_per_user = channel.rateLimitPerUser;
          delete channel.rateLimitPerUser;
          channel.rtc_region = channel.rtcRegion;
          delete channel.rtcRegion;
          channel.video_quality_mode = typeof channel.videoQualityMode === "string" ? VideoQualityModes[channel.videoQualityMode] : channel.videoQualityMode;
          delete channel.videoQualityMode;
          if (!channel.permissionOverwrites) continue;
          for (const overwrite of channel.permissionOverwrites) {
            if (typeof overwrite.type === "string") {
              overwrite.type = OverwriteTypes[overwrite.type];
            }
            overwrite.allow && (overwrite.allow = Permissions2.resolve(overwrite.allow).toString());
            overwrite.deny && (overwrite.deny = Permissions2.resolve(overwrite.deny).toString());
          }
          channel.permission_overwrites = channel.permissionOverwrites;
          delete channel.permissionOverwrites;
        }
        for (const role of roles) {
          role.color && (role.color = resolveColor(role.color));
          role.permissions && (role.permissions = Permissions2.resolve(role.permissions).toString());
        }
        systemChannelFlags && (systemChannelFlags = SystemChannelFlags.resolve(systemChannelFlags));
        const data = await this.client.api.guilds.post({
          data: {
            name,
            icon,
            verification_level: verificationLevel,
            default_message_notifications: defaultMessageNotifications,
            explicit_content_filter: explicitContentFilter,
            roles,
            channels,
            afk_channel_id: afkChannelId,
            afk_timeout: afkTimeout,
            system_channel_id: systemChannelId,
            system_channel_flags: systemChannelFlags,
            guild_template_code: "2TffvPucqHkN"
            // From Discord
          }
        });
        if (this.client.guilds.cache.has(data.id)) return this.client.guilds.cache.get(data.id);
        return new Promise((resolve) => {
          const handleGuild = (guild) => {
            if (guild.id === data.id) {
              clearTimeout(timeout);
              this.client.removeListener(Events2.GUILD_CREATE, handleGuild);
              this.client.decrementMaxListeners();
              resolve(guild);
            }
          };
          this.client.incrementMaxListeners();
          this.client.on(Events2.GUILD_CREATE, handleGuild);
          const timeout = setTimeout2(() => {
            this.client.removeListener(Events2.GUILD_CREATE, handleGuild);
            this.client.decrementMaxListeners();
            resolve(this.client.guilds._add(data));
          }, 1e4).unref();
        });
      }
      /**
       * Options used to fetch a single guild.
       * @typedef {BaseFetchOptions} FetchGuildOptions
       * @property {GuildResolvable} guild The guild to fetch
       * @property {boolean} [withCounts=true] Whether the approximate member and presence counts should be returned
       */
      /**
       * Options used to fetch multiple guilds.
       * @typedef {Object} FetchGuildsOptions
       * @property {Snowflake} [before] Get guilds before this guild id
       * @property {Snowflake} [after] Get guilds after this guild id
       * @property {number} [limit=200] Maximum number of guilds to request (1-200)
       */
      /**
       * Obtains one or multiple guilds from Discord, or the guild cache if it's already available.
       * @param {GuildResolvable|FetchGuildOptions|FetchGuildsOptions} [options] The guild's id or options
       * @returns {Promise<Guild|Collection<Snowflake, OAuth2Guild>>}
       */
      async fetch(options = {}) {
        const id = this.resolveId(options) ?? this.resolveId(options.guild);
        if (id) {
          if (!options.force) {
            const existing = this.cache.get(id);
            if (existing) return existing;
          }
          const data2 = await this.client.api.guilds(id).get({ query: { with_counts: options.withCounts ?? true } });
          return this._add(data2, options.cache);
        }
        const data = await this.client.api.users("@me").guilds.get({ query: options });
        return data.reduce((coll, guild) => coll.set(guild.id, new OAuth2Guild(this.client, guild)), new Collection2());
      }
    };
    module2.exports = GuildManager2;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/managers/RelationshipManager.js
var require_RelationshipManager = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/managers/RelationshipManager.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var BaseManager = require_BaseManager();
    var { GuildMember } = require_GuildMember();
    var { Message } = require_Message();
    var ThreadMember = require_ThreadMember();
    var User = require_User();
    var { RelationshipTypes } = require_Constants();
    var RelationshipManager2 = class extends BaseManager {
      constructor(client, users) {
        super(client);
        this.cache = new Collection2();
        this.friendNicknames = new Collection2();
        this.sinceCache = new Collection2();
        this._setup(users);
      }
      /**
       * Get all friends
       * @type {Collection<Snowflake, User>}
       * @readonly
       */
      get friendCache() {
        const users = this.cache.filter((value) => value === RelationshipTypes.FRIEND).map((_, key) => [key, this.client.users.cache.get(key)]);
        return new Collection2(users);
      }
      /**
       * Get all blocked users
       * @type {Collection<Snowflake, User>}
       * @readonly
       */
      get blockedCache() {
        const users = this.cache.filter((value) => value === RelationshipTypes.BLOCKED).map((_, key) => [key, this.client.users.cache.get(key)]);
        return new Collection2(users);
      }
      /**
       * Get all incoming friend requests
       * @type {Collection<Snowflake, User>}
       * @readonly
       */
      get incomingCache() {
        const users = this.cache.filter((value) => value === RelationshipTypes.PENDING_INCOMING).map((_, key) => [key, this.client.users.cache.get(key)]);
        return new Collection2(users);
      }
      /**
       * Get all outgoing friend requests
       * @type {Collection<Snowflake, User>}
       * @readonly
       */
      get outgoingCache() {
        const users = this.cache.filter((value) => value === RelationshipTypes.PENDING_OUTGOING).map((_, key) => [key, this.client.users.cache.get(key)]);
        return new Collection2(users);
      }
      /**
       * @typedef {Object} RelationshipJSONData
       * @property {Snowflake} id The ID of the target user
       * @property {RelationshipType} type The type of relationship
       * @property {string | null} nickname The nickname of the user in this relationship (1-32 characters)
       * @property {string} since When the user requested a relationship (ISO8601 timestamp)
       */
      /**
       * Return array of cache
       * @returns {RelationshipJSONData[]}
       */
      toJSON() {
        return this.cache.map((value, key) => ({
          id: key,
          type: RelationshipTypes[value],
          nickname: this.friendNicknames.get(key),
          since: this.sinceCache.get(key).toISOString()
        }));
      }
      /**
       * @private
       * @param {Array<User>} users An array of users to add to the cache
       * @returns {void}
       */
      _setup(users) {
        if (!Array.isArray(users)) return;
        for (const relationShip of users) {
          this.friendNicknames.set(relationShip.id, relationShip.nickname);
          this.cache.set(relationShip.id, relationShip.type);
          this.sinceCache.set(relationShip.id, new Date(relationShip.since || 0));
        }
      }
      /**
       * Resolves a {@link UserResolvable} to a {@link User} id.
       * @param {UserResolvable} user The UserResolvable to identify
       * @returns {?Snowflake}
       */
      resolveId(user) {
        if (user instanceof ThreadMember) return user.id;
        if (user instanceof GuildMember) return user.user.id;
        if (user instanceof Message) return user.author.id;
        if (user instanceof User) return user.id;
        return user;
      }
      /**
       * Obtains a user from Discord, or the user cache if it's already available.
       * @param {UserResolvable} [user] The user to fetch
       * @param {BaseFetchOptions} [options] Additional options for this fetch
       * @returns {Promise<RelationshipType|RelationshipManager>}
       */
      async fetch(user, { force = false } = {}) {
        if (user) {
          const id = this.resolveId(user);
          if (!force) {
            const existing = this.cache.get(id);
            if (existing && !existing.partial) return existing;
          }
          const data = await this.client.api.users["@me"].relationships.get();
          await this._setup(data);
          return this.cache.get(id);
        } else {
          const data = await this.client.api.users["@me"].relationships.get();
          await this._setup(data);
          return this;
        }
      }
      /**
       * Deletes a friend / blocked relationship with a client user or cancels a friend request.
       * @param {UserResolvable} user Target
       * @returns {Promise<boolean>}
       */
      async deleteRelationship(user) {
        const id = this.resolveId(user);
        if (![RelationshipTypes.FRIEND, RelationshipTypes.BLOCKED, RelationshipTypes.PENDING_OUTGOING].includes(
          this.cache.get(id)
        )) {
          return Promise.resolve(false);
        }
        await this.client.api.users["@me"].relationships[id].delete({
          DiscordContext: { location: "Friends" }
        });
        return true;
      }
      /**
       * @typedef {Object} FriendRequestOptions
       * @property {UserResolvable} [user] Target
       * @property {string} [username] Discord username
       * @property {number | null} [discriminator] Discord discriminator
       */
      /**
       * Sends a friend request.
       * @param {FriendRequestOptions} options Target
       * @returns {Promise<boolean>}
       */
      async sendFriendRequest(options) {
        if (options == null ? void 0 : options.user) {
          const id = this.resolveId(options.user);
          await this.client.api.users["@me"].relationships[id].put({
            data: {},
            DiscordContext: { location: "ContextMenu" }
          });
          return true;
        } else {
          await this.client.api.users["@me"].relationships.post({
            data: {
              username: options.username,
              discriminator: options.discriminator
            },
            DiscordContext: { location: "Add Friend" }
          });
          return true;
        }
      }
      /**
       * Accepts a friend request.
       * @param {UserResolvable} user The user to add as a friend
       * @returns {Promise<boolean>}
       */
      async addFriend(user) {
        const id = this.resolveId(user);
        if (this.cache.get(id) === RelationshipTypes.FRIEND) return Promise.resolve(false);
        if (this.cache.get(id) === RelationshipTypes.PENDING_OUTGOING) return Promise.resolve(false);
        await this.client.api.users["@me"].relationships[id].put({
          data: {
            type: RelationshipTypes.FRIEND
          },
          DiscordContext: { location: "Friends" }
        });
        return true;
      }
      /**
       * Changes the nickname of a friend.
       * @param {UserResolvable} user The user to change the nickname
       * @param {?string} nickname New nickname
       * @returns {Promise<boolean>}
       */
      async setNickname(user, nickname = null) {
        const id = this.resolveId(user);
        if (this.cache.get(id) !== RelationshipTypes.FRIEND) return Promise.resolve(false);
        await this.client.api.users["@me"].relationships[id].patch({
          data: {
            nickname: typeof nickname === "string" ? nickname : null
          }
        });
        if (nickname) {
          this.friendNicknames.set(id, nickname);
        } else {
          this.friendNicknames.delete(id);
        }
        return true;
      }
      /**
       * Blocks a user.
       * @param {UserResolvable} user User to block
       * @returns {Promise<boolean>}
       */
      async addBlocked(user) {
        const id = this.resolveId(user);
        if (this.cache.get(id) === RelationshipTypes.BLOCKED) return Promise.resolve(false);
        await this.client.api.users["@me"].relationships[id].put({
          data: {
            type: RelationshipTypes.BLOCKED
          },
          DiscordContext: { location: "ContextMenu" }
        });
        return true;
      }
    };
    module2.exports = RelationshipManager2;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/managers/UserManager.js
var require_UserManager = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/managers/UserManager.js"(exports2, module2) {
    "use strict";
    var CachedManager = require_CachedManager();
    var { Error: Error2 } = require_errors2();
    var { GuildMember } = require_GuildMember();
    var { Message } = require_Message();
    var ThreadMember = require_ThreadMember();
    var User = require_User();
    var UserManager2 = class extends CachedManager {
      constructor(client, iterable) {
        super(client, User, iterable);
      }
      /**
       * The cache of this manager
       * @type {Collection<Snowflake, User>}
       * @name UserManager#cache
       */
      /**
       * Data that resolves to give a User object. This can be:
       * * A User object
       * * A Snowflake
       * * A Message object (resolves to the message author)
       * * A GuildMember object
       * * A ThreadMember object
       * @typedef {User|Snowflake|Message|GuildMember|ThreadMember} UserResolvable
       */
      /**
       * The DM between the client's user and a user
       * @param {Snowflake} userId The user id
       * @returns {?DMChannel}
       * @private
       */
      dmChannel(userId) {
        return this.client.channels.cache.find((c) => c.type === "DM" && c.recipient.id === userId) ?? null;
      }
      /**
       * Creates a {@link DMChannel} between the client and a user.
       * @param {UserResolvable} user The UserResolvable to identify
       * @param {BaseFetchOptions} [options] Additional options for this fetch
       * @returns {Promise<DMChannel>}
       */
      async createDM(user, { cache = true, force = false } = {}) {
        const id = this.resolveId(user);
        if (!force) {
          const dmChannel = this.dmChannel(id);
          if (dmChannel && !dmChannel.partial) return dmChannel;
        }
        const data = await this.client.api.users["@me"].channels.post({
          data: {
            recipients: [id]
          },
          DiscordContext: {}
        });
        const dm_channel = await this.client.channels._add(data, null, { cache });
        dm_channel.sync();
        return dm_channel;
      }
      /**
       * Deletes a {@link DMChannel} (if one exists) between the client and a user. Resolves with the channel if successful.
       * @param {UserResolvable} user The UserResolvable to identify
       * @returns {Promise<DMChannel>}
       */
      async deleteDM(user) {
        const id = this.resolveId(user);
        const dmChannel = this.dmChannel(id);
        if (!dmChannel) throw new Error2("USER_NO_DM_CHANNEL");
        await this.client.api.channels(dmChannel.id).delete();
        this.client.channels._remove(dmChannel.id);
        return dmChannel;
      }
      /**
       * Obtains a user from Discord, or the user cache if it's already available.
       * @param {UserResolvable} user The user to fetch
       * @param {BaseFetchOptions} [options] Additional options for this fetch
       * @returns {Promise<User>}
       */
      async fetch(user, { cache = true, force = false } = {}) {
        const id = this.resolveId(user);
        if (!force) {
          const existing = this.cache.get(id);
          if (existing && !existing.partial) return existing;
        }
        const data = await this.client.api.users(id).get();
        return this._add(data, cache);
      }
      /**
       * Sends a message to a user.
       * @param {UserResolvable} user The UserResolvable to identify
       * @param {string|MessagePayload|MessageOptions} options The options to provide
       * @returns {Promise<Message>}
       */
      async send(user, options) {
        return (await this.createDM(user)).send(options);
      }
      /**
       * Resolves a {@link UserResolvable} to a {@link User} object.
       * @param {UserResolvable} user The UserResolvable to identify
       * @returns {?User}
       */
      resolve(user) {
        if (user instanceof GuildMember || user instanceof ThreadMember) return user.user;
        if (user instanceof Message) return user.author;
        return super.resolve(user);
      }
      /**
       * Resolves a {@link UserResolvable} to a {@link User} id.
       * @param {UserResolvable} user The UserResolvable to identify
       * @returns {?Snowflake}
       */
      resolveId(user) {
        if (user instanceof ThreadMember) return user.id;
        if (user instanceof GuildMember) return user.user.id;
        if (user instanceof Message) return user.author.id;
        return super.resolveId(user);
      }
    };
    module2.exports = UserManager2;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/managers/UserNoteManager.js
var require_UserNoteManager = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/managers/UserNoteManager.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var BaseManager = require_BaseManager();
    var UserNoteManager2 = class extends BaseManager {
      constructor(client, data = {}) {
        super(client);
        this.cache = new Collection2(Object.entries(data));
      }
      _reload(data = {}) {
        this.cache = new Collection2(Object.entries(data));
        return this;
      }
      async updateNote(id, note = null) {
        await this.client.api.users["@me"].notes(id).put({ data: { note } });
        if (!note) this.cache.delete(id, note);
        else this.cache.set(id, note);
        return this;
      }
      /**
       * Obtains a user from Discord, or the user cache if it's already available.
       * @param {UserResolvable} user The user to fetch
       * @param {BaseFetchOptions} [options] Additional options for this fetch
       * @returns {Promise<string>}
       */
      async fetch(user, { cache = true, force = false } = {}) {
        const id = this.resolveId(user);
        if (!force) {
          const existing = this.cache.get(id);
          if (existing) return existing;
        }
        const data = await this.client.api.users["@me"].notes[id].get().then((d) => d.note).catch(() => "");
        if (cache) this.cache.set(id, data);
        return data;
      }
    };
    module2.exports = UserNoteManager2;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/sharding/ShardClientUtil.js
var require_ShardClientUtil = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/sharding/ShardClientUtil.js"(exports2, module2) {
    "use strict";
    var process2 = require_node_process();
    var { Error: Error2 } = require_errors2();
    var { Events: Events2 } = require_Constants();
    var Util = require_Util();
    var ShardClientUtil2 = class {
      constructor(client, mode) {
        this.client = client;
        this.mode = mode;
        this.parentPort = null;
        if (mode === "process") {
          process2.on("message", this._handleMessage.bind(this));
          client.on("ready", () => {
            process2.send({ _ready: true });
          });
          client.on("disconnect", () => {
            process2.send({ _disconnect: true });
          });
          client.on("reconnecting", () => {
            process2.send({ _reconnecting: true });
          });
        } else if (mode === "worker") {
          this.parentPort = require_node_worker_threads().parentPort;
          this.parentPort.on("message", this._handleMessage.bind(this));
          client.on("ready", () => {
            this.parentPort.postMessage({ _ready: true });
          });
          client.on("disconnect", () => {
            this.parentPort.postMessage({ _disconnect: true });
          });
          client.on("reconnecting", () => {
            this.parentPort.postMessage({ _reconnecting: true });
          });
        }
      }
      /**
       * Array of shard ids of this client
       * @type {number[]}
       * @readonly
       */
      get ids() {
        return this.client.options.shards;
      }
      /**
       * Total number of shards
       * @type {number}
       * @readonly
       */
      get count() {
        return this.client.options.shardCount;
      }
      /**
       * Sends a message to the master process.
       * @param {*} message Message to send
       * @returns {Promise<void>}
       * @emits Shard#message
       */
      send(message) {
        return new Promise((resolve, reject) => {
          if (this.mode === "process") {
            process2.send(message, (err) => {
              if (err) reject(err);
              else resolve();
            });
          } else if (this.mode === "worker") {
            this.parentPort.postMessage(message);
            resolve();
          }
        });
      }
      /**
       * Fetches a client property value of each shard, or a given shard.
       * @param {string} prop Name of the client property to get, using periods for nesting
       * @param {number} [shard] Shard to fetch property from, all if undefined
       * @returns {Promise<*|Array<*>>}
       * @example
       * client.shard.fetchClientValues('guilds.cache.size')
       *   .then(results => console.log(`${results.reduce((prev, val) => prev + val, 0)} total guilds`))
       *   .catch(console.error);
       * @see {@link ShardingManager#fetchClientValues}
       */
      fetchClientValues(prop, shard) {
        return new Promise((resolve, reject) => {
          const parent = this.parentPort ?? process2;
          const listener = (message) => {
            if ((message == null ? void 0 : message._sFetchProp) !== prop || message._sFetchPropShard !== shard) return;
            parent.removeListener("message", listener);
            this.decrementMaxListeners(parent);
            if (!message._error) resolve(message._result);
            else reject(Util.makeError(message._error));
          };
          this.incrementMaxListeners(parent);
          parent.on("message", listener);
          this.send({ _sFetchProp: prop, _sFetchPropShard: shard }).catch((err) => {
            parent.removeListener("message", listener);
            this.decrementMaxListeners(parent);
            reject(err);
          });
        });
      }
      /**
       * Evaluates a script or function on all shards, or a given shard, in the context of the {@link Client}s.
       * @param {Function} script JavaScript to run on each shard
       * @param {BroadcastEvalOptions} [options={}] The options for the broadcast
       * @returns {Promise<*|Array<*>>} Results of the script execution
       * @example
       * client.shard.broadcastEval(client => client.guilds.cache.size)
       *   .then(results => console.log(`${results.reduce((prev, val) => prev + val, 0)} total guilds`))
       *   .catch(console.error);
       * @see {@link ShardingManager#broadcastEval}
       */
      broadcastEval(script2, options = {}) {
        return new Promise((resolve, reject) => {
          const parent = this.parentPort ?? process2;
          if (typeof script2 !== "function") {
            reject(new TypeError("SHARDING_INVALID_EVAL_BROADCAST"));
            return;
          }
          script2 = `(${script2})(this, ${JSON.stringify(options.context)})`;
          const listener = (message) => {
            if ((message == null ? void 0 : message._sEval) !== script2 || message._sEvalShard !== options.shard) return;
            parent.removeListener("message", listener);
            this.decrementMaxListeners(parent);
            if (!message._error) resolve(message._result);
            else reject(Util.makeError(message._error));
          };
          this.incrementMaxListeners(parent);
          parent.on("message", listener);
          this.send({ _sEval: script2, _sEvalShard: options.shard }).catch((err) => {
            parent.removeListener("message", listener);
            this.decrementMaxListeners(parent);
            reject(err);
          });
        });
      }
      /**
       * Requests a respawn of all shards.
       * @param {MultipleShardRespawnOptions} [options] Options for respawning shards
       * @returns {Promise<void>} Resolves upon the message being sent
       * @see {@link ShardingManager#respawnAll}
       */
      respawnAll({ shardDelay = 5e3, respawnDelay = 500, timeout = 3e4 } = {}) {
        return this.send({ _sRespawnAll: { shardDelay, respawnDelay, timeout } });
      }
      /**
       * Handles an IPC message.
       * @param {*} message Message received
       * @private
       */
      async _handleMessage(message) {
        if (!message) return;
        if (message._fetchProp) {
          try {
            const props = message._fetchProp.split(".");
            let value = this.client;
            for (const prop of props) value = value[prop];
            this._respond("fetchProp", { _fetchProp: message._fetchProp, _result: value });
          } catch (err) {
            this._respond("fetchProp", { _fetchProp: message._fetchProp, _error: Util.makePlainError(err) });
          }
        } else if (message._eval) {
          try {
            this._respond("eval", { _eval: message._eval, _result: await this.client._eval(message._eval) });
          } catch (err) {
            this._respond("eval", { _eval: message._eval, _error: Util.makePlainError(err) });
          }
        }
      }
      /**
       * Sends a message to the master process, emitting an error from the client upon failure.
       * @param {string} type Type of response to send
       * @param {*} message Message to send
       * @private
       */
      _respond(type, message) {
        this.send(message).catch((err) => {
          const error2 = new Error2(`Error when sending ${type} response to master process: ${err.message}`);
          error2.stack = err.stack;
          this.client.emit(Events2.ERROR, error2);
        });
      }
      /**
       * Creates/gets the singleton of this class.
       * @param {Client} client The client to use
       * @param {ShardingManagerMode} mode Mode the shard was spawned with
       * @returns {ShardClientUtil}
       */
      static singleton(client, mode) {
        if (!this._singleton) {
          this._singleton = new this(client, mode);
        } else {
          client.emit(
            Events2.WARN,
            "Multiple clients created in child process/worker; only the first will handle sharding helpers."
          );
        }
        return this._singleton;
      }
      /**
       * Get the shard id for a given guild id.
       * @param {Snowflake} guildId Snowflake guild id to get shard id for
       * @param {number} shardCount Number of shards
       * @returns {number}
       */
      static shardIdForGuildId(guildId, shardCount) {
        const shard = Number(BigInt(guildId) >> 22n) % shardCount;
        if (shard < 0) throw new Error2("SHARDING_SHARD_MISCALCULATION", shard, guildId, shardCount);
        return shard;
      }
      /**
       * Increments max listeners by one for a given emitter, if they are not zero.
       * @param {EventEmitter|process} emitter The emitter that emits the events.
       * @private
       */
      incrementMaxListeners(emitter) {
        const maxListeners = emitter.getMaxListeners();
        if (maxListeners !== 0) {
          emitter.setMaxListeners(maxListeners + 1);
        }
      }
      /**
       * Decrements max listeners by one for a given emitter, if they are not zero.
       * @param {EventEmitter|process} emitter The emitter that emits the events.
       * @private
       */
      decrementMaxListeners(emitter) {
        const maxListeners = emitter.getMaxListeners();
        if (maxListeners !== 0) {
          emitter.setMaxListeners(maxListeners - 1);
        }
      }
    };
    module2.exports = ShardClientUtil2;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/ClientPresence.js
var require_ClientPresence = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/ClientPresence.js"(exports2, module2) {
    "use strict";
    var { Presence } = require_Presence();
    var { TypeError: TypeError2 } = require_errors2();
    var { ActivityTypes, Opcodes } = require_Constants();
    var CustomStatusActivityTypes = [ActivityTypes.CUSTOM, ActivityTypes[ActivityTypes.CUSTOM]];
    var ClientPresence2 = class extends Presence {
      constructor(client, data = {}) {
        super(client, Object.assign(data, { status: data.status ?? "online", user: { id: null } }));
      }
      /**
       * Sets the client's presence
       * @param {PresenceData} presence The data to set the presence to
       * @returns {ClientPresence}
       */
      set(presence) {
        const packet = this._parse(presence);
        this._patch(packet);
        packet.activities = this.activities.map((a) => a.toJSON());
        this.client.ws.broadcast({ op: Opcodes.STATUS_UPDATE, d: packet });
        return this;
      }
      /**
       * Parses presence data into a packet ready to be sent to Discord
       * @param {PresenceData} presence The data to parse
       * @returns {APIPresence}
       * @private
       */
      _parse({ status, since, afk, activities }) {
        const data = {
          activities: [],
          afk: typeof afk === "boolean" ? afk : this.afk,
          since: typeof since === "number" && !Number.isNaN(since) ? this.since : 0,
          status: status ?? this.status
        };
        if (activities == null ? void 0 : activities.length) {
          for (const [i, activity] of activities.entries()) {
            if (typeof activity.name !== "string") throw new TypeError2("INVALID_TYPE", `activities[${i}].name`, "string");
            activity.type ?? (activity.type = ActivityTypes.PLAYING);
            if (typeof activity.type === "string") activity.type = ActivityTypes[activity.type];
            if (CustomStatusActivityTypes.includes(activity.type) && !activity.state) {
              activity.state = activity.name;
              activity.name = "Custom Status";
            }
            data.activities.push(activity);
          }
        } else if (!activities && (status || afk || since) && this.activities.length) {
          data.activities.push(
            ...this.activities.map((a) => {
              if (typeof a.type === "string") a.type = ActivityTypes[a.type];
              return a;
            })
          );
        }
        return data;
      }
    };
    module2.exports = ClientPresence2;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/StickerPack.js
var require_StickerPack = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/StickerPack.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var Base = require_Base();
    var { Sticker: Sticker2 } = require_Sticker();
    var SnowflakeUtil = require_SnowflakeUtil();
    var StickerPack2 = class extends Base {
      constructor(client, pack) {
        super(client);
        this.id = pack.id;
        this.stickers = new Collection2(pack.stickers.map((s) => [s.id, new Sticker2(client, s)]));
        this.name = pack.name;
        this.skuId = pack.sku_id;
        this.coverStickerId = pack.cover_sticker_id ?? null;
        this.description = pack.description;
        this.bannerId = pack.banner_asset_id ?? null;
      }
      /**
       * The timestamp the sticker was created at
       * @type {number}
       * @readonly
       */
      get createdTimestamp() {
        return SnowflakeUtil.timestampFrom(this.id);
      }
      /**
       * The time the sticker was created at
       * @type {Date}
       * @readonly
       */
      get createdAt() {
        return new Date(this.createdTimestamp);
      }
      /**
       * The sticker which is shown as the pack's icon
       * @type {?Sticker}
       * @readonly
       */
      get coverSticker() {
        return this.coverStickerId && this.stickers.get(this.coverStickerId);
      }
      /**
       * The URL to this sticker pack's banner.
       * @param {StaticImageURLOptions} [options={}] Options for the Image URL
       * @returns {?string}
       */
      bannerURL({ format, size } = {}) {
        return this.bannerId && this.client.rest.cdn.StickerPackBanner(this.bannerId, format, size);
      }
    };
    module2.exports = StickerPack2;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/VoiceRegion.js
var require_VoiceRegion = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/VoiceRegion.js"(exports2, module2) {
    "use strict";
    var Util = require_Util();
    var VoiceRegion2 = class {
      constructor(data) {
        this.id = data.id;
        this.name = data.name;
        this.vip = data.vip;
        this.deprecated = data.deprecated;
        this.optimal = data.optimal;
        this.custom = data.custom;
      }
      toJSON() {
        return Util.flatten(this);
      }
    };
    module2.exports = VoiceRegion2;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/WidgetMember.js
var require_WidgetMember = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/WidgetMember.js"(exports2, module2) {
    "use strict";
    var Base = require_Base();
    var WidgetMember = class extends Base {
      /**
       * Activity sent in a {@link WidgetMember}.
       * @typedef {Object} WidgetActivity
       * @property {string} name The name of the activity
       */
      constructor(client, data) {
        super(client);
        this.id = data.id;
        this.username = data.username;
        this.discriminator = data.discriminator;
        this.avatar = data.avatar;
        this.status = data.status;
        this.deaf = data.deaf ?? null;
        this.mute = data.mute ?? null;
        this.selfDeaf = data.self_deaf ?? null;
        this.selfMute = data.self_mute ?? null;
        this.suppress = data.suppress ?? null;
        this.channelId = data.channel_id ?? null;
        this.avatarURL = data.avatar_url;
        this.activity = data.activity ?? null;
      }
    };
    module2.exports = WidgetMember;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/Widget.js
var require_Widget = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/Widget.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var Base = require_Base();
    var WidgetMember = require_WidgetMember();
    var Widget2 = class extends Base {
      constructor(client, data) {
        super(client);
        this._patch(data);
      }
      /**
       * Represents a channel in a Widget
       * @typedef {Object} WidgetChannel
       * @property {Snowflake} id Id of the channel
       * @property {string} name Name of the channel
       * @property {number} position Position of the channel
       */
      _patch(data) {
        this.id = data.id;
        if ("name" in data) {
          this.name = data.name;
        }
        if ("instant_invite" in data) {
          this.instantInvite = data.instant_invite;
        }
        this.channels = new Collection2();
        for (const channel of data.channels) {
          this.channels.set(channel.id, channel);
        }
        this.members = new Collection2();
        for (const member of data.members) {
          this.members.set(member.id, new WidgetMember(this.client, member));
        }
        if ("presence_count" in data) {
          this.presenceCount = data.presence_count;
        }
      }
      /**
       * Update the Widget.
       * @returns {Promise<Widget>}
       */
      async fetch() {
        const data = await this.client.api.guilds(this.id, "widget.json").get();
        this._patch(data);
        return this;
      }
    };
    module2.exports = Widget2;
  }
});

// browser-external:node:string_decoder
var require_node_string_decoder = __commonJS({
  "browser-external:node:string_decoder"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "node:string_decoder" has been externalized for browser compatibility. Cannot access "node:string_decoder.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// ../../../node_modules/qrcode/lib/can-promise.js
var require_can_promise = __commonJS({
  "../../../node_modules/qrcode/lib/can-promise.js"(exports2, module2) {
    module2.exports = function() {
      return typeof Promise === "function" && Promise.prototype && Promise.prototype.then;
    };
  }
});

// ../../../node_modules/qrcode/lib/core/utils.js
var require_utils3 = __commonJS({
  "../../../node_modules/qrcode/lib/core/utils.js"(exports2) {
    var toSJISFunction;
    var CODEWORDS_COUNT = [
      0,
      // Not used
      26,
      44,
      70,
      100,
      134,
      172,
      196,
      242,
      292,
      346,
      404,
      466,
      532,
      581,
      655,
      733,
      815,
      901,
      991,
      1085,
      1156,
      1258,
      1364,
      1474,
      1588,
      1706,
      1828,
      1921,
      2051,
      2185,
      2323,
      2465,
      2611,
      2761,
      2876,
      3034,
      3196,
      3362,
      3532,
      3706
    ];
    exports2.getSymbolSize = function getSymbolSize(version) {
      if (!version) throw new Error('"version" cannot be null or undefined');
      if (version < 1 || version > 40) throw new Error('"version" should be in range from 1 to 40');
      return version * 4 + 17;
    };
    exports2.getSymbolTotalCodewords = function getSymbolTotalCodewords(version) {
      return CODEWORDS_COUNT[version];
    };
    exports2.getBCHDigit = function(data) {
      let digit = 0;
      while (data !== 0) {
        digit++;
        data >>>= 1;
      }
      return digit;
    };
    exports2.setToSJISFunction = function setToSJISFunction(f) {
      if (typeof f !== "function") {
        throw new Error('"toSJISFunc" is not a valid function.');
      }
      toSJISFunction = f;
    };
    exports2.isKanjiModeEnabled = function() {
      return typeof toSJISFunction !== "undefined";
    };
    exports2.toSJIS = function toSJIS(kanji) {
      return toSJISFunction(kanji);
    };
  }
});

// ../../../node_modules/qrcode/lib/core/error-correction-level.js
var require_error_correction_level = __commonJS({
  "../../../node_modules/qrcode/lib/core/error-correction-level.js"(exports2) {
    exports2.L = { bit: 1 };
    exports2.M = { bit: 0 };
    exports2.Q = { bit: 3 };
    exports2.H = { bit: 2 };
    function fromString(string) {
      if (typeof string !== "string") {
        throw new Error("Param is not a string");
      }
      const lcStr = string.toLowerCase();
      switch (lcStr) {
        case "l":
        case "low":
          return exports2.L;
        case "m":
        case "medium":
          return exports2.M;
        case "q":
        case "quartile":
          return exports2.Q;
        case "h":
        case "high":
          return exports2.H;
        default:
          throw new Error("Unknown EC Level: " + string);
      }
    }
    exports2.isValid = function isValid(level) {
      return level && typeof level.bit !== "undefined" && level.bit >= 0 && level.bit < 4;
    };
    exports2.from = function from(value, defaultValue) {
      if (exports2.isValid(value)) {
        return value;
      }
      try {
        return fromString(value);
      } catch (e) {
        return defaultValue;
      }
    };
  }
});

// ../../../node_modules/qrcode/lib/core/bit-buffer.js
var require_bit_buffer = __commonJS({
  "../../../node_modules/qrcode/lib/core/bit-buffer.js"(exports2, module2) {
    function BitBuffer() {
      this.buffer = [];
      this.length = 0;
    }
    BitBuffer.prototype = {
      get: function(index) {
        const bufIndex = Math.floor(index / 8);
        return (this.buffer[bufIndex] >>> 7 - index % 8 & 1) === 1;
      },
      put: function(num, length) {
        for (let i = 0; i < length; i++) {
          this.putBit((num >>> length - i - 1 & 1) === 1);
        }
      },
      getLengthInBits: function() {
        return this.length;
      },
      putBit: function(bit) {
        const bufIndex = Math.floor(this.length / 8);
        if (this.buffer.length <= bufIndex) {
          this.buffer.push(0);
        }
        if (bit) {
          this.buffer[bufIndex] |= 128 >>> this.length % 8;
        }
        this.length++;
      }
    };
    module2.exports = BitBuffer;
  }
});

// ../../../node_modules/qrcode/lib/core/bit-matrix.js
var require_bit_matrix = __commonJS({
  "../../../node_modules/qrcode/lib/core/bit-matrix.js"(exports2, module2) {
    function BitMatrix(size) {
      if (!size || size < 1) {
        throw new Error("BitMatrix size must be defined and greater than 0");
      }
      this.size = size;
      this.data = new Uint8Array(size * size);
      this.reservedBit = new Uint8Array(size * size);
    }
    BitMatrix.prototype.set = function(row, col, value, reserved) {
      const index = row * this.size + col;
      this.data[index] = value;
      if (reserved) this.reservedBit[index] = true;
    };
    BitMatrix.prototype.get = function(row, col) {
      return this.data[row * this.size + col];
    };
    BitMatrix.prototype.xor = function(row, col, value) {
      this.data[row * this.size + col] ^= value;
    };
    BitMatrix.prototype.isReserved = function(row, col) {
      return this.reservedBit[row * this.size + col];
    };
    module2.exports = BitMatrix;
  }
});

// ../../../node_modules/qrcode/lib/core/alignment-pattern.js
var require_alignment_pattern = __commonJS({
  "../../../node_modules/qrcode/lib/core/alignment-pattern.js"(exports2) {
    var getSymbolSize = require_utils3().getSymbolSize;
    exports2.getRowColCoords = function getRowColCoords(version) {
      if (version === 1) return [];
      const posCount = Math.floor(version / 7) + 2;
      const size = getSymbolSize(version);
      const intervals = size === 145 ? 26 : Math.ceil((size - 13) / (2 * posCount - 2)) * 2;
      const positions = [size - 7];
      for (let i = 1; i < posCount - 1; i++) {
        positions[i] = positions[i - 1] - intervals;
      }
      positions.push(6);
      return positions.reverse();
    };
    exports2.getPositions = function getPositions(version) {
      const coords = [];
      const pos = exports2.getRowColCoords(version);
      const posLength = pos.length;
      for (let i = 0; i < posLength; i++) {
        for (let j = 0; j < posLength; j++) {
          if (i === 0 && j === 0 || // top-left
          i === 0 && j === posLength - 1 || // bottom-left
          i === posLength - 1 && j === 0) {
            continue;
          }
          coords.push([pos[i], pos[j]]);
        }
      }
      return coords;
    };
  }
});

// ../../../node_modules/qrcode/lib/core/finder-pattern.js
var require_finder_pattern = __commonJS({
  "../../../node_modules/qrcode/lib/core/finder-pattern.js"(exports2) {
    var getSymbolSize = require_utils3().getSymbolSize;
    var FINDER_PATTERN_SIZE = 7;
    exports2.getPositions = function getPositions(version) {
      const size = getSymbolSize(version);
      return [
        // top-left
        [0, 0],
        // top-right
        [size - FINDER_PATTERN_SIZE, 0],
        // bottom-left
        [0, size - FINDER_PATTERN_SIZE]
      ];
    };
  }
});

// ../../../node_modules/qrcode/lib/core/mask-pattern.js
var require_mask_pattern = __commonJS({
  "../../../node_modules/qrcode/lib/core/mask-pattern.js"(exports2) {
    exports2.Patterns = {
      PATTERN000: 0,
      PATTERN001: 1,
      PATTERN010: 2,
      PATTERN011: 3,
      PATTERN100: 4,
      PATTERN101: 5,
      PATTERN110: 6,
      PATTERN111: 7
    };
    var PenaltyScores = {
      N1: 3,
      N2: 3,
      N3: 40,
      N4: 10
    };
    exports2.isValid = function isValid(mask) {
      return mask != null && mask !== "" && !isNaN(mask) && mask >= 0 && mask <= 7;
    };
    exports2.from = function from(value) {
      return exports2.isValid(value) ? parseInt(value, 10) : void 0;
    };
    exports2.getPenaltyN1 = function getPenaltyN1(data) {
      const size = data.size;
      let points = 0;
      let sameCountCol = 0;
      let sameCountRow = 0;
      let lastCol = null;
      let lastRow = null;
      for (let row = 0; row < size; row++) {
        sameCountCol = sameCountRow = 0;
        lastCol = lastRow = null;
        for (let col = 0; col < size; col++) {
          let module3 = data.get(row, col);
          if (module3 === lastCol) {
            sameCountCol++;
          } else {
            if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5);
            lastCol = module3;
            sameCountCol = 1;
          }
          module3 = data.get(col, row);
          if (module3 === lastRow) {
            sameCountRow++;
          } else {
            if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5);
            lastRow = module3;
            sameCountRow = 1;
          }
        }
        if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5);
        if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5);
      }
      return points;
    };
    exports2.getPenaltyN2 = function getPenaltyN2(data) {
      const size = data.size;
      let points = 0;
      for (let row = 0; row < size - 1; row++) {
        for (let col = 0; col < size - 1; col++) {
          const last = data.get(row, col) + data.get(row, col + 1) + data.get(row + 1, col) + data.get(row + 1, col + 1);
          if (last === 4 || last === 0) points++;
        }
      }
      return points * PenaltyScores.N2;
    };
    exports2.getPenaltyN3 = function getPenaltyN3(data) {
      const size = data.size;
      let points = 0;
      let bitsCol = 0;
      let bitsRow = 0;
      for (let row = 0; row < size; row++) {
        bitsCol = bitsRow = 0;
        for (let col = 0; col < size; col++) {
          bitsCol = bitsCol << 1 & 2047 | data.get(row, col);
          if (col >= 10 && (bitsCol === 1488 || bitsCol === 93)) points++;
          bitsRow = bitsRow << 1 & 2047 | data.get(col, row);
          if (col >= 10 && (bitsRow === 1488 || bitsRow === 93)) points++;
        }
      }
      return points * PenaltyScores.N3;
    };
    exports2.getPenaltyN4 = function getPenaltyN4(data) {
      let darkCount = 0;
      const modulesCount = data.data.length;
      for (let i = 0; i < modulesCount; i++) darkCount += data.data[i];
      const k = Math.abs(Math.ceil(darkCount * 100 / modulesCount / 5) - 10);
      return k * PenaltyScores.N4;
    };
    function getMaskAt(maskPattern, i, j) {
      switch (maskPattern) {
        case exports2.Patterns.PATTERN000:
          return (i + j) % 2 === 0;
        case exports2.Patterns.PATTERN001:
          return i % 2 === 0;
        case exports2.Patterns.PATTERN010:
          return j % 3 === 0;
        case exports2.Patterns.PATTERN011:
          return (i + j) % 3 === 0;
        case exports2.Patterns.PATTERN100:
          return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 === 0;
        case exports2.Patterns.PATTERN101:
          return i * j % 2 + i * j % 3 === 0;
        case exports2.Patterns.PATTERN110:
          return (i * j % 2 + i * j % 3) % 2 === 0;
        case exports2.Patterns.PATTERN111:
          return (i * j % 3 + (i + j) % 2) % 2 === 0;
        default:
          throw new Error("bad maskPattern:" + maskPattern);
      }
    }
    exports2.applyMask = function applyMask(pattern, data) {
      const size = data.size;
      for (let col = 0; col < size; col++) {
        for (let row = 0; row < size; row++) {
          if (data.isReserved(row, col)) continue;
          data.xor(row, col, getMaskAt(pattern, row, col));
        }
      }
    };
    exports2.getBestMask = function getBestMask(data, setupFormatFunc) {
      const numPatterns = Object.keys(exports2.Patterns).length;
      let bestPattern = 0;
      let lowerPenalty = Infinity;
      for (let p = 0; p < numPatterns; p++) {
        setupFormatFunc(p);
        exports2.applyMask(p, data);
        const penalty = exports2.getPenaltyN1(data) + exports2.getPenaltyN2(data) + exports2.getPenaltyN3(data) + exports2.getPenaltyN4(data);
        exports2.applyMask(p, data);
        if (penalty < lowerPenalty) {
          lowerPenalty = penalty;
          bestPattern = p;
        }
      }
      return bestPattern;
    };
  }
});

// ../../../node_modules/qrcode/lib/core/error-correction-code.js
var require_error_correction_code = __commonJS({
  "../../../node_modules/qrcode/lib/core/error-correction-code.js"(exports2) {
    var ECLevel = require_error_correction_level();
    var EC_BLOCKS_TABLE = [
      // L  M  Q  H
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      2,
      2,
      1,
      2,
      2,
      4,
      1,
      2,
      4,
      4,
      2,
      4,
      4,
      4,
      2,
      4,
      6,
      5,
      2,
      4,
      6,
      6,
      2,
      5,
      8,
      8,
      4,
      5,
      8,
      8,
      4,
      5,
      8,
      11,
      4,
      8,
      10,
      11,
      4,
      9,
      12,
      16,
      4,
      9,
      16,
      16,
      6,
      10,
      12,
      18,
      6,
      10,
      17,
      16,
      6,
      11,
      16,
      19,
      6,
      13,
      18,
      21,
      7,
      14,
      21,
      25,
      8,
      16,
      20,
      25,
      8,
      17,
      23,
      25,
      9,
      17,
      23,
      34,
      9,
      18,
      25,
      30,
      10,
      20,
      27,
      32,
      12,
      21,
      29,
      35,
      12,
      23,
      34,
      37,
      12,
      25,
      34,
      40,
      13,
      26,
      35,
      42,
      14,
      28,
      38,
      45,
      15,
      29,
      40,
      48,
      16,
      31,
      43,
      51,
      17,
      33,
      45,
      54,
      18,
      35,
      48,
      57,
      19,
      37,
      51,
      60,
      19,
      38,
      53,
      63,
      20,
      40,
      56,
      66,
      21,
      43,
      59,
      70,
      22,
      45,
      62,
      74,
      24,
      47,
      65,
      77,
      25,
      49,
      68,
      81
    ];
    var EC_CODEWORDS_TABLE = [
      // L  M  Q  H
      7,
      10,
      13,
      17,
      10,
      16,
      22,
      28,
      15,
      26,
      36,
      44,
      20,
      36,
      52,
      64,
      26,
      48,
      72,
      88,
      36,
      64,
      96,
      112,
      40,
      72,
      108,
      130,
      48,
      88,
      132,
      156,
      60,
      110,
      160,
      192,
      72,
      130,
      192,
      224,
      80,
      150,
      224,
      264,
      96,
      176,
      260,
      308,
      104,
      198,
      288,
      352,
      120,
      216,
      320,
      384,
      132,
      240,
      360,
      432,
      144,
      280,
      408,
      480,
      168,
      308,
      448,
      532,
      180,
      338,
      504,
      588,
      196,
      364,
      546,
      650,
      224,
      416,
      600,
      700,
      224,
      442,
      644,
      750,
      252,
      476,
      690,
      816,
      270,
      504,
      750,
      900,
      300,
      560,
      810,
      960,
      312,
      588,
      870,
      1050,
      336,
      644,
      952,
      1110,
      360,
      700,
      1020,
      1200,
      390,
      728,
      1050,
      1260,
      420,
      784,
      1140,
      1350,
      450,
      812,
      1200,
      1440,
      480,
      868,
      1290,
      1530,
      510,
      924,
      1350,
      1620,
      540,
      980,
      1440,
      1710,
      570,
      1036,
      1530,
      1800,
      570,
      1064,
      1590,
      1890,
      600,
      1120,
      1680,
      1980,
      630,
      1204,
      1770,
      2100,
      660,
      1260,
      1860,
      2220,
      720,
      1316,
      1950,
      2310,
      750,
      1372,
      2040,
      2430
    ];
    exports2.getBlocksCount = function getBlocksCount(version, errorCorrectionLevel) {
      switch (errorCorrectionLevel) {
        case ECLevel.L:
          return EC_BLOCKS_TABLE[(version - 1) * 4 + 0];
        case ECLevel.M:
          return EC_BLOCKS_TABLE[(version - 1) * 4 + 1];
        case ECLevel.Q:
          return EC_BLOCKS_TABLE[(version - 1) * 4 + 2];
        case ECLevel.H:
          return EC_BLOCKS_TABLE[(version - 1) * 4 + 3];
        default:
          return void 0;
      }
    };
    exports2.getTotalCodewordsCount = function getTotalCodewordsCount(version, errorCorrectionLevel) {
      switch (errorCorrectionLevel) {
        case ECLevel.L:
          return EC_CODEWORDS_TABLE[(version - 1) * 4 + 0];
        case ECLevel.M:
          return EC_CODEWORDS_TABLE[(version - 1) * 4 + 1];
        case ECLevel.Q:
          return EC_CODEWORDS_TABLE[(version - 1) * 4 + 2];
        case ECLevel.H:
          return EC_CODEWORDS_TABLE[(version - 1) * 4 + 3];
        default:
          return void 0;
      }
    };
  }
});

// ../../../node_modules/qrcode/lib/core/galois-field.js
var require_galois_field = __commonJS({
  "../../../node_modules/qrcode/lib/core/galois-field.js"(exports2) {
    var EXP_TABLE = new Uint8Array(512);
    var LOG_TABLE = new Uint8Array(256);
    (function initTables() {
      let x = 1;
      for (let i = 0; i < 255; i++) {
        EXP_TABLE[i] = x;
        LOG_TABLE[x] = i;
        x <<= 1;
        if (x & 256) {
          x ^= 285;
        }
      }
      for (let i = 255; i < 512; i++) {
        EXP_TABLE[i] = EXP_TABLE[i - 255];
      }
    })();
    exports2.log = function log(n) {
      if (n < 1) throw new Error("log(" + n + ")");
      return LOG_TABLE[n];
    };
    exports2.exp = function exp(n) {
      return EXP_TABLE[n];
    };
    exports2.mul = function mul(x, y) {
      if (x === 0 || y === 0) return 0;
      return EXP_TABLE[LOG_TABLE[x] + LOG_TABLE[y]];
    };
  }
});

// ../../../node_modules/qrcode/lib/core/polynomial.js
var require_polynomial = __commonJS({
  "../../../node_modules/qrcode/lib/core/polynomial.js"(exports2) {
    var GF = require_galois_field();
    exports2.mul = function mul(p1, p2) {
      const coeff = new Uint8Array(p1.length + p2.length - 1);
      for (let i = 0; i < p1.length; i++) {
        for (let j = 0; j < p2.length; j++) {
          coeff[i + j] ^= GF.mul(p1[i], p2[j]);
        }
      }
      return coeff;
    };
    exports2.mod = function mod(divident, divisor) {
      let result = new Uint8Array(divident);
      while (result.length - divisor.length >= 0) {
        const coeff = result[0];
        for (let i = 0; i < divisor.length; i++) {
          result[i] ^= GF.mul(divisor[i], coeff);
        }
        let offset = 0;
        while (offset < result.length && result[offset] === 0) offset++;
        result = result.slice(offset);
      }
      return result;
    };
    exports2.generateECPolynomial = function generateECPolynomial(degree) {
      let poly = new Uint8Array([1]);
      for (let i = 0; i < degree; i++) {
        poly = exports2.mul(poly, new Uint8Array([1, GF.exp(i)]));
      }
      return poly;
    };
  }
});

// ../../../node_modules/qrcode/lib/core/reed-solomon-encoder.js
var require_reed_solomon_encoder = __commonJS({
  "../../../node_modules/qrcode/lib/core/reed-solomon-encoder.js"(exports2, module2) {
    var Polynomial = require_polynomial();
    function ReedSolomonEncoder(degree) {
      this.genPoly = void 0;
      this.degree = degree;
      if (this.degree) this.initialize(this.degree);
    }
    ReedSolomonEncoder.prototype.initialize = function initialize(degree) {
      this.degree = degree;
      this.genPoly = Polynomial.generateECPolynomial(this.degree);
    };
    ReedSolomonEncoder.prototype.encode = function encode2(data) {
      if (!this.genPoly) {
        throw new Error("Encoder not initialized");
      }
      const paddedData = new Uint8Array(data.length + this.degree);
      paddedData.set(data);
      const remainder = Polynomial.mod(paddedData, this.genPoly);
      const start = this.degree - remainder.length;
      if (start > 0) {
        const buff = new Uint8Array(this.degree);
        buff.set(remainder, start);
        return buff;
      }
      return remainder;
    };
    module2.exports = ReedSolomonEncoder;
  }
});

// ../../../node_modules/qrcode/lib/core/version-check.js
var require_version_check = __commonJS({
  "../../../node_modules/qrcode/lib/core/version-check.js"(exports2) {
    exports2.isValid = function isValid(version) {
      return !isNaN(version) && version >= 1 && version <= 40;
    };
  }
});

// ../../../node_modules/qrcode/lib/core/regex.js
var require_regex = __commonJS({
  "../../../node_modules/qrcode/lib/core/regex.js"(exports2) {
    var numeric = "[0-9]+";
    var alphanumeric = "[A-Z $%*+\\-./:]+";
    var kanji = "(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+";
    kanji = kanji.replace(/u/g, "\\u");
    var byte = "(?:(?![A-Z0-9 $%*+\\-./:]|" + kanji + ")(?:.|[\r\n]))+";
    exports2.KANJI = new RegExp(kanji, "g");
    exports2.BYTE_KANJI = new RegExp("[^A-Z0-9 $%*+\\-./:]+", "g");
    exports2.BYTE = new RegExp(byte, "g");
    exports2.NUMERIC = new RegExp(numeric, "g");
    exports2.ALPHANUMERIC = new RegExp(alphanumeric, "g");
    var TEST_KANJI = new RegExp("^" + kanji + "$");
    var TEST_NUMERIC = new RegExp("^" + numeric + "$");
    var TEST_ALPHANUMERIC = new RegExp("^[A-Z0-9 $%*+\\-./:]+$");
    exports2.testKanji = function testKanji(str) {
      return TEST_KANJI.test(str);
    };
    exports2.testNumeric = function testNumeric(str) {
      return TEST_NUMERIC.test(str);
    };
    exports2.testAlphanumeric = function testAlphanumeric(str) {
      return TEST_ALPHANUMERIC.test(str);
    };
  }
});

// ../../../node_modules/qrcode/lib/core/mode.js
var require_mode = __commonJS({
  "../../../node_modules/qrcode/lib/core/mode.js"(exports2) {
    var VersionCheck = require_version_check();
    var Regex = require_regex();
    exports2.NUMERIC = {
      id: "Numeric",
      bit: 1 << 0,
      ccBits: [10, 12, 14]
    };
    exports2.ALPHANUMERIC = {
      id: "Alphanumeric",
      bit: 1 << 1,
      ccBits: [9, 11, 13]
    };
    exports2.BYTE = {
      id: "Byte",
      bit: 1 << 2,
      ccBits: [8, 16, 16]
    };
    exports2.KANJI = {
      id: "Kanji",
      bit: 1 << 3,
      ccBits: [8, 10, 12]
    };
    exports2.MIXED = {
      bit: -1
    };
    exports2.getCharCountIndicator = function getCharCountIndicator(mode, version) {
      if (!mode.ccBits) throw new Error("Invalid mode: " + mode);
      if (!VersionCheck.isValid(version)) {
        throw new Error("Invalid version: " + version);
      }
      if (version >= 1 && version < 10) return mode.ccBits[0];
      else if (version < 27) return mode.ccBits[1];
      return mode.ccBits[2];
    };
    exports2.getBestModeForData = function getBestModeForData(dataStr) {
      if (Regex.testNumeric(dataStr)) return exports2.NUMERIC;
      else if (Regex.testAlphanumeric(dataStr)) return exports2.ALPHANUMERIC;
      else if (Regex.testKanji(dataStr)) return exports2.KANJI;
      else return exports2.BYTE;
    };
    exports2.toString = function toString(mode) {
      if (mode && mode.id) return mode.id;
      throw new Error("Invalid mode");
    };
    exports2.isValid = function isValid(mode) {
      return mode && mode.bit && mode.ccBits;
    };
    function fromString(string) {
      if (typeof string !== "string") {
        throw new Error("Param is not a string");
      }
      const lcStr = string.toLowerCase();
      switch (lcStr) {
        case "numeric":
          return exports2.NUMERIC;
        case "alphanumeric":
          return exports2.ALPHANUMERIC;
        case "kanji":
          return exports2.KANJI;
        case "byte":
          return exports2.BYTE;
        default:
          throw new Error("Unknown mode: " + string);
      }
    }
    exports2.from = function from(value, defaultValue) {
      if (exports2.isValid(value)) {
        return value;
      }
      try {
        return fromString(value);
      } catch (e) {
        return defaultValue;
      }
    };
  }
});

// ../../../node_modules/qrcode/lib/core/version.js
var require_version2 = __commonJS({
  "../../../node_modules/qrcode/lib/core/version.js"(exports2) {
    var Utils = require_utils3();
    var ECCode = require_error_correction_code();
    var ECLevel = require_error_correction_level();
    var Mode = require_mode();
    var VersionCheck = require_version_check();
    var G18 = 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0;
    var G18_BCH = Utils.getBCHDigit(G18);
    function getBestVersionForDataLength(mode, length, errorCorrectionLevel) {
      for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
        if (length <= exports2.getCapacity(currentVersion, errorCorrectionLevel, mode)) {
          return currentVersion;
        }
      }
      return void 0;
    }
    function getReservedBitsCount(mode, version) {
      return Mode.getCharCountIndicator(mode, version) + 4;
    }
    function getTotalBitsFromDataArray(segments, version) {
      let totalBits = 0;
      segments.forEach(function(data) {
        const reservedBits = getReservedBitsCount(data.mode, version);
        totalBits += reservedBits + data.getBitsLength();
      });
      return totalBits;
    }
    function getBestVersionForMixedData(segments, errorCorrectionLevel) {
      for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
        const length = getTotalBitsFromDataArray(segments, currentVersion);
        if (length <= exports2.getCapacity(currentVersion, errorCorrectionLevel, Mode.MIXED)) {
          return currentVersion;
        }
      }
      return void 0;
    }
    exports2.from = function from(value, defaultValue) {
      if (VersionCheck.isValid(value)) {
        return parseInt(value, 10);
      }
      return defaultValue;
    };
    exports2.getCapacity = function getCapacity(version, errorCorrectionLevel, mode) {
      if (!VersionCheck.isValid(version)) {
        throw new Error("Invalid QR Code version");
      }
      if (typeof mode === "undefined") mode = Mode.BYTE;
      const totalCodewords = Utils.getSymbolTotalCodewords(version);
      const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel);
      const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
      if (mode === Mode.MIXED) return dataTotalCodewordsBits;
      const usableBits = dataTotalCodewordsBits - getReservedBitsCount(mode, version);
      switch (mode) {
        case Mode.NUMERIC:
          return Math.floor(usableBits / 10 * 3);
        case Mode.ALPHANUMERIC:
          return Math.floor(usableBits / 11 * 2);
        case Mode.KANJI:
          return Math.floor(usableBits / 13);
        case Mode.BYTE:
        default:
          return Math.floor(usableBits / 8);
      }
    };
    exports2.getBestVersionForData = function getBestVersionForData(data, errorCorrectionLevel) {
      let seg;
      const ecl = ECLevel.from(errorCorrectionLevel, ECLevel.M);
      if (Array.isArray(data)) {
        if (data.length > 1) {
          return getBestVersionForMixedData(data, ecl);
        }
        if (data.length === 0) {
          return 1;
        }
        seg = data[0];
      } else {
        seg = data;
      }
      return getBestVersionForDataLength(seg.mode, seg.getLength(), ecl);
    };
    exports2.getEncodedBits = function getEncodedBits(version) {
      if (!VersionCheck.isValid(version) || version < 7) {
        throw new Error("Invalid QR Code version");
      }
      let d = version << 12;
      while (Utils.getBCHDigit(d) - G18_BCH >= 0) {
        d ^= G18 << Utils.getBCHDigit(d) - G18_BCH;
      }
      return version << 12 | d;
    };
  }
});

// ../../../node_modules/qrcode/lib/core/format-info.js
var require_format_info = __commonJS({
  "../../../node_modules/qrcode/lib/core/format-info.js"(exports2) {
    var Utils = require_utils3();
    var G15 = 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0;
    var G15_MASK = 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1;
    var G15_BCH = Utils.getBCHDigit(G15);
    exports2.getEncodedBits = function getEncodedBits(errorCorrectionLevel, mask) {
      const data = errorCorrectionLevel.bit << 3 | mask;
      let d = data << 10;
      while (Utils.getBCHDigit(d) - G15_BCH >= 0) {
        d ^= G15 << Utils.getBCHDigit(d) - G15_BCH;
      }
      return (data << 10 | d) ^ G15_MASK;
    };
  }
});

// ../../../node_modules/qrcode/lib/core/numeric-data.js
var require_numeric_data = __commonJS({
  "../../../node_modules/qrcode/lib/core/numeric-data.js"(exports2, module2) {
    var Mode = require_mode();
    function NumericData(data) {
      this.mode = Mode.NUMERIC;
      this.data = data.toString();
    }
    NumericData.getBitsLength = function getBitsLength(length) {
      return 10 * Math.floor(length / 3) + (length % 3 ? length % 3 * 3 + 1 : 0);
    };
    NumericData.prototype.getLength = function getLength() {
      return this.data.length;
    };
    NumericData.prototype.getBitsLength = function getBitsLength() {
      return NumericData.getBitsLength(this.data.length);
    };
    NumericData.prototype.write = function write(bitBuffer) {
      let i, group, value;
      for (i = 0; i + 3 <= this.data.length; i += 3) {
        group = this.data.substr(i, 3);
        value = parseInt(group, 10);
        bitBuffer.put(value, 10);
      }
      const remainingNum = this.data.length - i;
      if (remainingNum > 0) {
        group = this.data.substr(i);
        value = parseInt(group, 10);
        bitBuffer.put(value, remainingNum * 3 + 1);
      }
    };
    module2.exports = NumericData;
  }
});

// ../../../node_modules/qrcode/lib/core/alphanumeric-data.js
var require_alphanumeric_data = __commonJS({
  "../../../node_modules/qrcode/lib/core/alphanumeric-data.js"(exports2, module2) {
    var Mode = require_mode();
    var ALPHA_NUM_CHARS = [
      "0",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9",
      "A",
      "B",
      "C",
      "D",
      "E",
      "F",
      "G",
      "H",
      "I",
      "J",
      "K",
      "L",
      "M",
      "N",
      "O",
      "P",
      "Q",
      "R",
      "S",
      "T",
      "U",
      "V",
      "W",
      "X",
      "Y",
      "Z",
      " ",
      "$",
      "%",
      "*",
      "+",
      "-",
      ".",
      "/",
      ":"
    ];
    function AlphanumericData(data) {
      this.mode = Mode.ALPHANUMERIC;
      this.data = data;
    }
    AlphanumericData.getBitsLength = function getBitsLength(length) {
      return 11 * Math.floor(length / 2) + 6 * (length % 2);
    };
    AlphanumericData.prototype.getLength = function getLength() {
      return this.data.length;
    };
    AlphanumericData.prototype.getBitsLength = function getBitsLength() {
      return AlphanumericData.getBitsLength(this.data.length);
    };
    AlphanumericData.prototype.write = function write(bitBuffer) {
      let i;
      for (i = 0; i + 2 <= this.data.length; i += 2) {
        let value = ALPHA_NUM_CHARS.indexOf(this.data[i]) * 45;
        value += ALPHA_NUM_CHARS.indexOf(this.data[i + 1]);
        bitBuffer.put(value, 11);
      }
      if (this.data.length % 2) {
        bitBuffer.put(ALPHA_NUM_CHARS.indexOf(this.data[i]), 6);
      }
    };
    module2.exports = AlphanumericData;
  }
});

// ../../../node_modules/qrcode/lib/core/byte-data.js
var require_byte_data = __commonJS({
  "../../../node_modules/qrcode/lib/core/byte-data.js"(exports2, module2) {
    var Mode = require_mode();
    function ByteData(data) {
      this.mode = Mode.BYTE;
      if (typeof data === "string") {
        this.data = new TextEncoder().encode(data);
      } else {
        this.data = new Uint8Array(data);
      }
    }
    ByteData.getBitsLength = function getBitsLength(length) {
      return length * 8;
    };
    ByteData.prototype.getLength = function getLength() {
      return this.data.length;
    };
    ByteData.prototype.getBitsLength = function getBitsLength() {
      return ByteData.getBitsLength(this.data.length);
    };
    ByteData.prototype.write = function(bitBuffer) {
      for (let i = 0, l = this.data.length; i < l; i++) {
        bitBuffer.put(this.data[i], 8);
      }
    };
    module2.exports = ByteData;
  }
});

// ../../../node_modules/qrcode/lib/core/kanji-data.js
var require_kanji_data = __commonJS({
  "../../../node_modules/qrcode/lib/core/kanji-data.js"(exports2, module2) {
    var Mode = require_mode();
    var Utils = require_utils3();
    function KanjiData(data) {
      this.mode = Mode.KANJI;
      this.data = data;
    }
    KanjiData.getBitsLength = function getBitsLength(length) {
      return length * 13;
    };
    KanjiData.prototype.getLength = function getLength() {
      return this.data.length;
    };
    KanjiData.prototype.getBitsLength = function getBitsLength() {
      return KanjiData.getBitsLength(this.data.length);
    };
    KanjiData.prototype.write = function(bitBuffer) {
      let i;
      for (i = 0; i < this.data.length; i++) {
        let value = Utils.toSJIS(this.data[i]);
        if (value >= 33088 && value <= 40956) {
          value -= 33088;
        } else if (value >= 57408 && value <= 60351) {
          value -= 49472;
        } else {
          throw new Error(
            "Invalid SJIS character: " + this.data[i] + "\nMake sure your charset is UTF-8"
          );
        }
        value = (value >>> 8 & 255) * 192 + (value & 255);
        bitBuffer.put(value, 13);
      }
    };
    module2.exports = KanjiData;
  }
});

// ../../../node_modules/dijkstrajs/dijkstra.js
var require_dijkstra = __commonJS({
  "../../../node_modules/dijkstrajs/dijkstra.js"(exports2, module2) {
    "use strict";
    var dijkstra = {
      single_source_shortest_paths: function(graph, s, d) {
        var predecessors = {};
        var costs = {};
        costs[s] = 0;
        var open = dijkstra.PriorityQueue.make();
        open.push(s, 0);
        var closest, u, v, cost_of_s_to_u, adjacent_nodes, cost_of_e, cost_of_s_to_u_plus_cost_of_e, cost_of_s_to_v, first_visit;
        while (!open.empty()) {
          closest = open.pop();
          u = closest.value;
          cost_of_s_to_u = closest.cost;
          adjacent_nodes = graph[u] || {};
          for (v in adjacent_nodes) {
            if (adjacent_nodes.hasOwnProperty(v)) {
              cost_of_e = adjacent_nodes[v];
              cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e;
              cost_of_s_to_v = costs[v];
              first_visit = typeof costs[v] === "undefined";
              if (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {
                costs[v] = cost_of_s_to_u_plus_cost_of_e;
                open.push(v, cost_of_s_to_u_plus_cost_of_e);
                predecessors[v] = u;
              }
            }
          }
        }
        if (typeof d !== "undefined" && typeof costs[d] === "undefined") {
          var msg = ["Could not find a path from ", s, " to ", d, "."].join("");
          throw new Error(msg);
        }
        return predecessors;
      },
      extract_shortest_path_from_predecessor_list: function(predecessors, d) {
        var nodes = [];
        var u = d;
        var predecessor;
        while (u) {
          nodes.push(u);
          predecessor = predecessors[u];
          u = predecessors[u];
        }
        nodes.reverse();
        return nodes;
      },
      find_path: function(graph, s, d) {
        var predecessors = dijkstra.single_source_shortest_paths(graph, s, d);
        return dijkstra.extract_shortest_path_from_predecessor_list(
          predecessors,
          d
        );
      },
      /**
       * A very naive priority queue implementation.
       */
      PriorityQueue: {
        make: function(opts) {
          var T = dijkstra.PriorityQueue, t = {}, key;
          opts = opts || {};
          for (key in T) {
            if (T.hasOwnProperty(key)) {
              t[key] = T[key];
            }
          }
          t.queue = [];
          t.sorter = opts.sorter || T.default_sorter;
          return t;
        },
        default_sorter: function(a, b) {
          return a.cost - b.cost;
        },
        /**
         * Add a new item to the queue and ensure the highest priority element
         * is at the front of the queue.
         */
        push: function(value, cost) {
          var item = { value, cost };
          this.queue.push(item);
          this.queue.sort(this.sorter);
        },
        /**
         * Return the highest priority element in the queue.
         */
        pop: function() {
          return this.queue.shift();
        },
        empty: function() {
          return this.queue.length === 0;
        }
      }
    };
    if (typeof module2 !== "undefined") {
      module2.exports = dijkstra;
    }
  }
});

// ../../../node_modules/qrcode/lib/core/segments.js
var require_segments = __commonJS({
  "../../../node_modules/qrcode/lib/core/segments.js"(exports2) {
    var Mode = require_mode();
    var NumericData = require_numeric_data();
    var AlphanumericData = require_alphanumeric_data();
    var ByteData = require_byte_data();
    var KanjiData = require_kanji_data();
    var Regex = require_regex();
    var Utils = require_utils3();
    var dijkstra = require_dijkstra();
    function getStringByteLength(str) {
      return unescape(encodeURIComponent(str)).length;
    }
    function getSegments(regex, mode, str) {
      const segments = [];
      let result;
      while ((result = regex.exec(str)) !== null) {
        segments.push({
          data: result[0],
          index: result.index,
          mode,
          length: result[0].length
        });
      }
      return segments;
    }
    function getSegmentsFromString(dataStr) {
      const numSegs = getSegments(Regex.NUMERIC, Mode.NUMERIC, dataStr);
      const alphaNumSegs = getSegments(Regex.ALPHANUMERIC, Mode.ALPHANUMERIC, dataStr);
      let byteSegs;
      let kanjiSegs;
      if (Utils.isKanjiModeEnabled()) {
        byteSegs = getSegments(Regex.BYTE, Mode.BYTE, dataStr);
        kanjiSegs = getSegments(Regex.KANJI, Mode.KANJI, dataStr);
      } else {
        byteSegs = getSegments(Regex.BYTE_KANJI, Mode.BYTE, dataStr);
        kanjiSegs = [];
      }
      const segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs);
      return segs.sort(function(s1, s2) {
        return s1.index - s2.index;
      }).map(function(obj) {
        return {
          data: obj.data,
          mode: obj.mode,
          length: obj.length
        };
      });
    }
    function getSegmentBitsLength(length, mode) {
      switch (mode) {
        case Mode.NUMERIC:
          return NumericData.getBitsLength(length);
        case Mode.ALPHANUMERIC:
          return AlphanumericData.getBitsLength(length);
        case Mode.KANJI:
          return KanjiData.getBitsLength(length);
        case Mode.BYTE:
          return ByteData.getBitsLength(length);
      }
    }
    function mergeSegments(segs) {
      return segs.reduce(function(acc, curr) {
        const prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null;
        if (prevSeg && prevSeg.mode === curr.mode) {
          acc[acc.length - 1].data += curr.data;
          return acc;
        }
        acc.push(curr);
        return acc;
      }, []);
    }
    function buildNodes(segs) {
      const nodes = [];
      for (let i = 0; i < segs.length; i++) {
        const seg = segs[i];
        switch (seg.mode) {
          case Mode.NUMERIC:
            nodes.push([
              seg,
              { data: seg.data, mode: Mode.ALPHANUMERIC, length: seg.length },
              { data: seg.data, mode: Mode.BYTE, length: seg.length }
            ]);
            break;
          case Mode.ALPHANUMERIC:
            nodes.push([
              seg,
              { data: seg.data, mode: Mode.BYTE, length: seg.length }
            ]);
            break;
          case Mode.KANJI:
            nodes.push([
              seg,
              { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }
            ]);
            break;
          case Mode.BYTE:
            nodes.push([
              { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }
            ]);
        }
      }
      return nodes;
    }
    function buildGraph(nodes, version) {
      const table = {};
      const graph = { start: {} };
      let prevNodeIds = ["start"];
      for (let i = 0; i < nodes.length; i++) {
        const nodeGroup = nodes[i];
        const currentNodeIds = [];
        for (let j = 0; j < nodeGroup.length; j++) {
          const node = nodeGroup[j];
          const key = "" + i + j;
          currentNodeIds.push(key);
          table[key] = { node, lastCount: 0 };
          graph[key] = {};
          for (let n = 0; n < prevNodeIds.length; n++) {
            const prevNodeId = prevNodeIds[n];
            if (table[prevNodeId] && table[prevNodeId].node.mode === node.mode) {
              graph[prevNodeId][key] = getSegmentBitsLength(table[prevNodeId].lastCount + node.length, node.mode) - getSegmentBitsLength(table[prevNodeId].lastCount, node.mode);
              table[prevNodeId].lastCount += node.length;
            } else {
              if (table[prevNodeId]) table[prevNodeId].lastCount = node.length;
              graph[prevNodeId][key] = getSegmentBitsLength(node.length, node.mode) + 4 + Mode.getCharCountIndicator(node.mode, version);
            }
          }
        }
        prevNodeIds = currentNodeIds;
      }
      for (let n = 0; n < prevNodeIds.length; n++) {
        graph[prevNodeIds[n]].end = 0;
      }
      return { map: graph, table };
    }
    function buildSingleSegment(data, modesHint) {
      let mode;
      const bestMode = Mode.getBestModeForData(data);
      mode = Mode.from(modesHint, bestMode);
      if (mode !== Mode.BYTE && mode.bit < bestMode.bit) {
        throw new Error('"' + data + '" cannot be encoded with mode ' + Mode.toString(mode) + ".\n Suggested mode is: " + Mode.toString(bestMode));
      }
      if (mode === Mode.KANJI && !Utils.isKanjiModeEnabled()) {
        mode = Mode.BYTE;
      }
      switch (mode) {
        case Mode.NUMERIC:
          return new NumericData(data);
        case Mode.ALPHANUMERIC:
          return new AlphanumericData(data);
        case Mode.KANJI:
          return new KanjiData(data);
        case Mode.BYTE:
          return new ByteData(data);
      }
    }
    exports2.fromArray = function fromArray(array) {
      return array.reduce(function(acc, seg) {
        if (typeof seg === "string") {
          acc.push(buildSingleSegment(seg, null));
        } else if (seg.data) {
          acc.push(buildSingleSegment(seg.data, seg.mode));
        }
        return acc;
      }, []);
    };
    exports2.fromString = function fromString(data, version) {
      const segs = getSegmentsFromString(data, Utils.isKanjiModeEnabled());
      const nodes = buildNodes(segs);
      const graph = buildGraph(nodes, version);
      const path = dijkstra.find_path(graph.map, "start", "end");
      const optimizedSegs = [];
      for (let i = 1; i < path.length - 1; i++) {
        optimizedSegs.push(graph.table[path[i]].node);
      }
      return exports2.fromArray(mergeSegments(optimizedSegs));
    };
    exports2.rawSplit = function rawSplit(data) {
      return exports2.fromArray(
        getSegmentsFromString(data, Utils.isKanjiModeEnabled())
      );
    };
  }
});

// ../../../node_modules/qrcode/lib/core/qrcode.js
var require_qrcode = __commonJS({
  "../../../node_modules/qrcode/lib/core/qrcode.js"(exports2) {
    var Utils = require_utils3();
    var ECLevel = require_error_correction_level();
    var BitBuffer = require_bit_buffer();
    var BitMatrix = require_bit_matrix();
    var AlignmentPattern = require_alignment_pattern();
    var FinderPattern = require_finder_pattern();
    var MaskPattern = require_mask_pattern();
    var ECCode = require_error_correction_code();
    var ReedSolomonEncoder = require_reed_solomon_encoder();
    var Version = require_version2();
    var FormatInfo = require_format_info();
    var Mode = require_mode();
    var Segments = require_segments();
    function setupFinderPattern(matrix, version) {
      const size = matrix.size;
      const pos = FinderPattern.getPositions(version);
      for (let i = 0; i < pos.length; i++) {
        const row = pos[i][0];
        const col = pos[i][1];
        for (let r = -1; r <= 7; r++) {
          if (row + r <= -1 || size <= row + r) continue;
          for (let c = -1; c <= 7; c++) {
            if (col + c <= -1 || size <= col + c) continue;
            if (r >= 0 && r <= 6 && (c === 0 || c === 6) || c >= 0 && c <= 6 && (r === 0 || r === 6) || r >= 2 && r <= 4 && c >= 2 && c <= 4) {
              matrix.set(row + r, col + c, true, true);
            } else {
              matrix.set(row + r, col + c, false, true);
            }
          }
        }
      }
    }
    function setupTimingPattern(matrix) {
      const size = matrix.size;
      for (let r = 8; r < size - 8; r++) {
        const value = r % 2 === 0;
        matrix.set(r, 6, value, true);
        matrix.set(6, r, value, true);
      }
    }
    function setupAlignmentPattern(matrix, version) {
      const pos = AlignmentPattern.getPositions(version);
      for (let i = 0; i < pos.length; i++) {
        const row = pos[i][0];
        const col = pos[i][1];
        for (let r = -2; r <= 2; r++) {
          for (let c = -2; c <= 2; c++) {
            if (r === -2 || r === 2 || c === -2 || c === 2 || r === 0 && c === 0) {
              matrix.set(row + r, col + c, true, true);
            } else {
              matrix.set(row + r, col + c, false, true);
            }
          }
        }
      }
    }
    function setupVersionInfo(matrix, version) {
      const size = matrix.size;
      const bits = Version.getEncodedBits(version);
      let row, col, mod;
      for (let i = 0; i < 18; i++) {
        row = Math.floor(i / 3);
        col = i % 3 + size - 8 - 3;
        mod = (bits >> i & 1) === 1;
        matrix.set(row, col, mod, true);
        matrix.set(col, row, mod, true);
      }
    }
    function setupFormatInfo(matrix, errorCorrectionLevel, maskPattern) {
      const size = matrix.size;
      const bits = FormatInfo.getEncodedBits(errorCorrectionLevel, maskPattern);
      let i, mod;
      for (i = 0; i < 15; i++) {
        mod = (bits >> i & 1) === 1;
        if (i < 6) {
          matrix.set(i, 8, mod, true);
        } else if (i < 8) {
          matrix.set(i + 1, 8, mod, true);
        } else {
          matrix.set(size - 15 + i, 8, mod, true);
        }
        if (i < 8) {
          matrix.set(8, size - i - 1, mod, true);
        } else if (i < 9) {
          matrix.set(8, 15 - i - 1 + 1, mod, true);
        } else {
          matrix.set(8, 15 - i - 1, mod, true);
        }
      }
      matrix.set(size - 8, 8, 1, true);
    }
    function setupData(matrix, data) {
      const size = matrix.size;
      let inc = -1;
      let row = size - 1;
      let bitIndex = 7;
      let byteIndex = 0;
      for (let col = size - 1; col > 0; col -= 2) {
        if (col === 6) col--;
        while (true) {
          for (let c = 0; c < 2; c++) {
            if (!matrix.isReserved(row, col - c)) {
              let dark = false;
              if (byteIndex < data.length) {
                dark = (data[byteIndex] >>> bitIndex & 1) === 1;
              }
              matrix.set(row, col - c, dark);
              bitIndex--;
              if (bitIndex === -1) {
                byteIndex++;
                bitIndex = 7;
              }
            }
          }
          row += inc;
          if (row < 0 || size <= row) {
            row -= inc;
            inc = -inc;
            break;
          }
        }
      }
    }
    function createData(version, errorCorrectionLevel, segments) {
      const buffer = new BitBuffer();
      segments.forEach(function(data) {
        buffer.put(data.mode.bit, 4);
        buffer.put(data.getLength(), Mode.getCharCountIndicator(data.mode, version));
        data.write(buffer);
      });
      const totalCodewords = Utils.getSymbolTotalCodewords(version);
      const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel);
      const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
      if (buffer.getLengthInBits() + 4 <= dataTotalCodewordsBits) {
        buffer.put(0, 4);
      }
      while (buffer.getLengthInBits() % 8 !== 0) {
        buffer.putBit(0);
      }
      const remainingByte = (dataTotalCodewordsBits - buffer.getLengthInBits()) / 8;
      for (let i = 0; i < remainingByte; i++) {
        buffer.put(i % 2 ? 17 : 236, 8);
      }
      return createCodewords(buffer, version, errorCorrectionLevel);
    }
    function createCodewords(bitBuffer, version, errorCorrectionLevel) {
      const totalCodewords = Utils.getSymbolTotalCodewords(version);
      const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel);
      const dataTotalCodewords = totalCodewords - ecTotalCodewords;
      const ecTotalBlocks = ECCode.getBlocksCount(version, errorCorrectionLevel);
      const blocksInGroup2 = totalCodewords % ecTotalBlocks;
      const blocksInGroup1 = ecTotalBlocks - blocksInGroup2;
      const totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks);
      const dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks);
      const dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1;
      const ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1;
      const rs = new ReedSolomonEncoder(ecCount);
      let offset = 0;
      const dcData = new Array(ecTotalBlocks);
      const ecData = new Array(ecTotalBlocks);
      let maxDataSize = 0;
      const buffer = new Uint8Array(bitBuffer.buffer);
      for (let b = 0; b < ecTotalBlocks; b++) {
        const dataSize = b < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2;
        dcData[b] = buffer.slice(offset, offset + dataSize);
        ecData[b] = rs.encode(dcData[b]);
        offset += dataSize;
        maxDataSize = Math.max(maxDataSize, dataSize);
      }
      const data = new Uint8Array(totalCodewords);
      let index = 0;
      let i, r;
      for (i = 0; i < maxDataSize; i++) {
        for (r = 0; r < ecTotalBlocks; r++) {
          if (i < dcData[r].length) {
            data[index++] = dcData[r][i];
          }
        }
      }
      for (i = 0; i < ecCount; i++) {
        for (r = 0; r < ecTotalBlocks; r++) {
          data[index++] = ecData[r][i];
        }
      }
      return data;
    }
    function createSymbol(data, version, errorCorrectionLevel, maskPattern) {
      let segments;
      if (Array.isArray(data)) {
        segments = Segments.fromArray(data);
      } else if (typeof data === "string") {
        let estimatedVersion = version;
        if (!estimatedVersion) {
          const rawSegments = Segments.rawSplit(data);
          estimatedVersion = Version.getBestVersionForData(rawSegments, errorCorrectionLevel);
        }
        segments = Segments.fromString(data, estimatedVersion || 40);
      } else {
        throw new Error("Invalid data");
      }
      const bestVersion = Version.getBestVersionForData(segments, errorCorrectionLevel);
      if (!bestVersion) {
        throw new Error("The amount of data is too big to be stored in a QR Code");
      }
      if (!version) {
        version = bestVersion;
      } else if (version < bestVersion) {
        throw new Error(
          "\nThe chosen QR Code version cannot contain this amount of data.\nMinimum version required to store current data is: " + bestVersion + ".\n"
        );
      }
      const dataBits = createData(version, errorCorrectionLevel, segments);
      const moduleCount = Utils.getSymbolSize(version);
      const modules = new BitMatrix(moduleCount);
      setupFinderPattern(modules, version);
      setupTimingPattern(modules);
      setupAlignmentPattern(modules, version);
      setupFormatInfo(modules, errorCorrectionLevel, 0);
      if (version >= 7) {
        setupVersionInfo(modules, version);
      }
      setupData(modules, dataBits);
      if (isNaN(maskPattern)) {
        maskPattern = MaskPattern.getBestMask(
          modules,
          setupFormatInfo.bind(null, modules, errorCorrectionLevel)
        );
      }
      MaskPattern.applyMask(maskPattern, modules);
      setupFormatInfo(modules, errorCorrectionLevel, maskPattern);
      return {
        modules,
        version,
        errorCorrectionLevel,
        maskPattern,
        segments
      };
    }
    exports2.create = function create(data, options) {
      if (typeof data === "undefined" || data === "") {
        throw new Error("No input text");
      }
      let errorCorrectionLevel = ECLevel.M;
      let version;
      let mask;
      if (typeof options !== "undefined") {
        errorCorrectionLevel = ECLevel.from(options.errorCorrectionLevel, ECLevel.M);
        version = Version.from(options.version);
        mask = MaskPattern.from(options.maskPattern);
        if (options.toSJISFunc) {
          Utils.setToSJISFunction(options.toSJISFunc);
        }
      }
      return createSymbol(data, version, errorCorrectionLevel, mask);
    };
  }
});

// ../../../node_modules/qrcode/lib/renderer/utils.js
var require_utils4 = __commonJS({
  "../../../node_modules/qrcode/lib/renderer/utils.js"(exports2) {
    function hex2rgba(hex) {
      if (typeof hex === "number") {
        hex = hex.toString();
      }
      if (typeof hex !== "string") {
        throw new Error("Color should be defined as hex string");
      }
      let hexCode = hex.slice().replace("#", "").split("");
      if (hexCode.length < 3 || hexCode.length === 5 || hexCode.length > 8) {
        throw new Error("Invalid hex color: " + hex);
      }
      if (hexCode.length === 3 || hexCode.length === 4) {
        hexCode = Array.prototype.concat.apply([], hexCode.map(function(c) {
          return [c, c];
        }));
      }
      if (hexCode.length === 6) hexCode.push("F", "F");
      const hexValue = parseInt(hexCode.join(""), 16);
      return {
        r: hexValue >> 24 & 255,
        g: hexValue >> 16 & 255,
        b: hexValue >> 8 & 255,
        a: hexValue & 255,
        hex: "#" + hexCode.slice(0, 6).join("")
      };
    }
    exports2.getOptions = function getOptions(options) {
      if (!options) options = {};
      if (!options.color) options.color = {};
      const margin = typeof options.margin === "undefined" || options.margin === null || options.margin < 0 ? 4 : options.margin;
      const width = options.width && options.width >= 21 ? options.width : void 0;
      const scale = options.scale || 4;
      return {
        width,
        scale: width ? 4 : scale,
        margin,
        color: {
          dark: hex2rgba(options.color.dark || "#000000ff"),
          light: hex2rgba(options.color.light || "#ffffffff")
        },
        type: options.type,
        rendererOpts: options.rendererOpts || {}
      };
    };
    exports2.getScale = function getScale(qrSize, opts) {
      return opts.width && opts.width >= qrSize + opts.margin * 2 ? opts.width / (qrSize + opts.margin * 2) : opts.scale;
    };
    exports2.getImageWidth = function getImageWidth(qrSize, opts) {
      const scale = exports2.getScale(qrSize, opts);
      return Math.floor((qrSize + opts.margin * 2) * scale);
    };
    exports2.qrToImageData = function qrToImageData(imgData, qr, opts) {
      const size = qr.modules.size;
      const data = qr.modules.data;
      const scale = exports2.getScale(size, opts);
      const symbolSize = Math.floor((size + opts.margin * 2) * scale);
      const scaledMargin = opts.margin * scale;
      const palette = [opts.color.light, opts.color.dark];
      for (let i = 0; i < symbolSize; i++) {
        for (let j = 0; j < symbolSize; j++) {
          let posDst = (i * symbolSize + j) * 4;
          let pxColor = opts.color.light;
          if (i >= scaledMargin && j >= scaledMargin && i < symbolSize - scaledMargin && j < symbolSize - scaledMargin) {
            const iSrc = Math.floor((i - scaledMargin) / scale);
            const jSrc = Math.floor((j - scaledMargin) / scale);
            pxColor = palette[data[iSrc * size + jSrc] ? 1 : 0];
          }
          imgData[posDst++] = pxColor.r;
          imgData[posDst++] = pxColor.g;
          imgData[posDst++] = pxColor.b;
          imgData[posDst] = pxColor.a;
        }
      }
    };
  }
});

// ../../../node_modules/qrcode/lib/renderer/canvas.js
var require_canvas = __commonJS({
  "../../../node_modules/qrcode/lib/renderer/canvas.js"(exports2) {
    var Utils = require_utils4();
    function clearCanvas(ctx, canvas, size) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (!canvas.style) canvas.style = {};
      canvas.height = size;
      canvas.width = size;
      canvas.style.height = size + "px";
      canvas.style.width = size + "px";
    }
    function getCanvasElement() {
      try {
        return document.createElement("canvas");
      } catch (e) {
        throw new Error("You need to specify a canvas element");
      }
    }
    exports2.render = function render(qrData, canvas, options) {
      let opts = options;
      let canvasEl = canvas;
      if (typeof opts === "undefined" && (!canvas || !canvas.getContext)) {
        opts = canvas;
        canvas = void 0;
      }
      if (!canvas) {
        canvasEl = getCanvasElement();
      }
      opts = Utils.getOptions(opts);
      const size = Utils.getImageWidth(qrData.modules.size, opts);
      const ctx = canvasEl.getContext("2d");
      const image = ctx.createImageData(size, size);
      Utils.qrToImageData(image.data, qrData, opts);
      clearCanvas(ctx, canvasEl, size);
      ctx.putImageData(image, 0, 0);
      return canvasEl;
    };
    exports2.renderToDataURL = function renderToDataURL(qrData, canvas, options) {
      let opts = options;
      if (typeof opts === "undefined" && (!canvas || !canvas.getContext)) {
        opts = canvas;
        canvas = void 0;
      }
      if (!opts) opts = {};
      const canvasEl = exports2.render(qrData, canvas, opts);
      const type = opts.type || "image/png";
      const rendererOpts = opts.rendererOpts || {};
      return canvasEl.toDataURL(type, rendererOpts.quality);
    };
  }
});

// ../../../node_modules/qrcode/lib/renderer/svg-tag.js
var require_svg_tag = __commonJS({
  "../../../node_modules/qrcode/lib/renderer/svg-tag.js"(exports2) {
    var Utils = require_utils4();
    function getColorAttrib(color, attrib) {
      const alpha = color.a / 255;
      const str = attrib + '="' + color.hex + '"';
      return alpha < 1 ? str + " " + attrib + '-opacity="' + alpha.toFixed(2).slice(1) + '"' : str;
    }
    function svgCmd(cmd, x, y) {
      let str = cmd + x;
      if (typeof y !== "undefined") str += " " + y;
      return str;
    }
    function qrToPath(data, size, margin) {
      let path = "";
      let moveBy = 0;
      let newRow = false;
      let lineLength = 0;
      for (let i = 0; i < data.length; i++) {
        const col = Math.floor(i % size);
        const row = Math.floor(i / size);
        if (!col && !newRow) newRow = true;
        if (data[i]) {
          lineLength++;
          if (!(i > 0 && col > 0 && data[i - 1])) {
            path += newRow ? svgCmd("M", col + margin, 0.5 + row + margin) : svgCmd("m", moveBy, 0);
            moveBy = 0;
            newRow = false;
          }
          if (!(col + 1 < size && data[i + 1])) {
            path += svgCmd("h", lineLength);
            lineLength = 0;
          }
        } else {
          moveBy++;
        }
      }
      return path;
    }
    exports2.render = function render(qrData, options, cb) {
      const opts = Utils.getOptions(options);
      const size = qrData.modules.size;
      const data = qrData.modules.data;
      const qrcodesize = size + opts.margin * 2;
      const bg = !opts.color.light.a ? "" : "<path " + getColorAttrib(opts.color.light, "fill") + ' d="M0 0h' + qrcodesize + "v" + qrcodesize + 'H0z"/>';
      const path = "<path " + getColorAttrib(opts.color.dark, "stroke") + ' d="' + qrToPath(data, size, opts.margin) + '"/>';
      const viewBox = 'viewBox="0 0 ' + qrcodesize + " " + qrcodesize + '"';
      const width = !opts.width ? "" : 'width="' + opts.width + '" height="' + opts.width + '" ';
      const svgTag = '<svg xmlns="http://www.w3.org/2000/svg" ' + width + viewBox + ' shape-rendering="crispEdges">' + bg + path + "</svg>\n";
      if (typeof cb === "function") {
        cb(null, svgTag);
      }
      return svgTag;
    };
  }
});

// ../../../node_modules/qrcode/lib/browser.js
var require_browser2 = __commonJS({
  "../../../node_modules/qrcode/lib/browser.js"(exports2) {
    var canPromise = require_can_promise();
    var QRCode = require_qrcode();
    var CanvasRenderer = require_canvas();
    var SvgRenderer = require_svg_tag();
    function renderCanvas(renderFunc, canvas, text, opts, cb) {
      const args = [].slice.call(arguments, 1);
      const argsNum = args.length;
      const isLastArgCb = typeof args[argsNum - 1] === "function";
      if (!isLastArgCb && !canPromise()) {
        throw new Error("Callback required as last argument");
      }
      if (isLastArgCb) {
        if (argsNum < 2) {
          throw new Error("Too few arguments provided");
        }
        if (argsNum === 2) {
          cb = text;
          text = canvas;
          canvas = opts = void 0;
        } else if (argsNum === 3) {
          if (canvas.getContext && typeof cb === "undefined") {
            cb = opts;
            opts = void 0;
          } else {
            cb = opts;
            opts = text;
            text = canvas;
            canvas = void 0;
          }
        }
      } else {
        if (argsNum < 1) {
          throw new Error("Too few arguments provided");
        }
        if (argsNum === 1) {
          text = canvas;
          canvas = opts = void 0;
        } else if (argsNum === 2 && !canvas.getContext) {
          opts = text;
          text = canvas;
          canvas = void 0;
        }
        return new Promise(function(resolve, reject) {
          try {
            const data = QRCode.create(text, opts);
            resolve(renderFunc(data, canvas, opts));
          } catch (e) {
            reject(e);
          }
        });
      }
      try {
        const data = QRCode.create(text, opts);
        cb(null, renderFunc(data, canvas, opts));
      } catch (e) {
        cb(e);
      }
    }
    exports2.create = QRCode.create;
    exports2.toCanvas = renderCanvas.bind(null, CanvasRenderer.render);
    exports2.toDataURL = renderCanvas.bind(null, CanvasRenderer.renderToDataURL);
    exports2.toString = renderCanvas.bind(null, function(data, _, opts) {
      return SvgRenderer.render(data, opts);
    });
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/util/RemoteAuth.js
var require_RemoteAuth = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/util/RemoteAuth.js"(exports2, module2) {
    "use strict";
    var { Buffer: Buffer2 } = require_node_buffer();
    var crypto = require_node_crypto();
    var EventEmitter = require_node_events();
    var { StringDecoder } = require_node_string_decoder();
    var { setTimeout: setTimeout2 } = require_node_timers();
    var { fetch } = require_undici();
    var WebSocket = require_browser();
    var { UserAgent } = require_Constants();
    var Options = require_Options();
    var defaultClientOptions = Options.createDefault();
    var baseURL = "https://discord.com/ra/";
    var wsURL = "wss://remote-auth-gateway.discord.gg/?v=2";
    var receiveEvent = {
      HELLO: "hello",
      NONCE_PROOF: "nonce_proof",
      PENDING_REMOTE_INIT: "pending_remote_init",
      HEARTBEAT_ACK: "heartbeat_ack",
      PENDING_TICKET: "pending_ticket",
      CANCEL: "cancel",
      PENDING_LOGIN: "pending_login"
    };
    var sendEvent = {
      INIT: "init",
      NONCE_PROOF: "nonce_proof",
      HEARTBEAT: "heartbeat"
    };
    var Event2 = {
      READY: "ready",
      ERROR: "error",
      CANCEL: "cancel",
      WAIT_SCAN: "pending",
      FINISH: "finish",
      CLOSED: "closed",
      DEBUG: "debug"
    };
    var _ws, _heartbeatInterval, _expire, _publicKey, _privateKey, _ticket, _fingerprint, _userDecryptString, _DiscordAuthWebsocket_instances, createWebSocket_fn, handleWebSocket_fn, handleMessage_fn, send_fn, heartbeatAck_fn, ready_fn, createKey_fn, encodePublicKey_fn, init_fn, receiveNonceProof_fn, decryptPayload_fn, pendingLogin_fn, awaitLogin_fn, findRealToken_fn;
    var _DiscordAuthWebsocket = class _DiscordAuthWebsocket extends EventEmitter {
      /**
       * Creates a new DiscordAuthWebsocket instance.
       */
      constructor() {
        super();
        __privateAdd(this, _DiscordAuthWebsocket_instances);
        __privateAdd(this, _ws, null);
        __privateAdd(this, _heartbeatInterval, null);
        __privateAdd(this, _expire, null);
        __privateAdd(this, _publicKey, null);
        __privateAdd(this, _privateKey, null);
        __privateAdd(this, _ticket, null);
        __privateAdd(this, _fingerprint, "");
        __privateAdd(this, _userDecryptString, "");
        this.token = "";
      }
      /**
       * @type {string}
       */
      get AuthURL() {
        return baseURL + __privateGet(this, _fingerprint);
      }
      /**
       * @type {Date}
       */
      get exprire() {
        return __privateGet(this, _expire);
      }
      /**
       * @type {UserRaw}
       */
      get user() {
        return _DiscordAuthWebsocket.decryptUser(__privateGet(this, _userDecryptString));
      }
      /**
       * Connect WS
       * @param {Client} [client] DiscordJS Client
       * @returns {Promise<void>}
       */
      connect(client) {
        __privateMethod(this, _DiscordAuthWebsocket_instances, createWebSocket_fn).call(this, wsURL);
        if (client) {
          return __privateMethod(this, _DiscordAuthWebsocket_instances, awaitLogin_fn).call(this, client);
        } else {
          return Promise.resolve();
        }
      }
      /**
       * Destroy client
       * @returns {void}
       */
      destroy() {
        if (!this.ws) return;
        this.ws.close();
        this.emit(Event2.DEBUG, "WebSocket closed.");
        this.emit(Event2.CLOSED);
      }
      /**
       * Generate QR code for user to scan (Terminal)
       * @returns {void}
       */
      generateQR() {
        if (!__privateGet(this, _fingerprint)) return;
        require_browser2().toString(this.AuthURL, { type: "utf8", errorCorrectionLevel: "L" }, (err, url) => {
          if (err) {
          }
          console.log(url);
        });
      }
      static decryptUser(payload) {
        const values = payload.split(":");
        const id = values[0];
        const username = values[3];
        const discriminator = values[1];
        const avatar = values[2];
        return {
          id,
          username,
          discriminator,
          avatar
        };
      }
    };
    _ws = new WeakMap();
    _heartbeatInterval = new WeakMap();
    _expire = new WeakMap();
    _publicKey = new WeakMap();
    _privateKey = new WeakMap();
    _ticket = new WeakMap();
    _fingerprint = new WeakMap();
    _userDecryptString = new WeakMap();
    _DiscordAuthWebsocket_instances = new WeakSet();
    createWebSocket_fn = function(url) {
      __privateSet(this, _ws, new WebSocket(url, {
        headers: {
          Origin: "https://discord.com",
          "User-Agent": UserAgent
        }
      }));
      __privateMethod(this, _DiscordAuthWebsocket_instances, handleWebSocket_fn).call(this);
    };
    handleWebSocket_fn = function() {
      __privateGet(this, _ws).on("error", (error2) => {
        this.emit(Event2.ERROR, error2);
      });
      __privateGet(this, _ws).on("open", () => {
        this.emit(Event2.DEBUG, "[WS] Client Connected");
      });
      __privateGet(this, _ws).on("close", () => {
        this.emit(Event2.DEBUG, "[WS] Connection closed");
      });
      __privateGet(this, _ws).on("message", __privateMethod(this, _DiscordAuthWebsocket_instances, handleMessage_fn).bind(this));
    };
    handleMessage_fn = function(message) {
      message = JSON.parse(message);
      switch (message.op) {
        case receiveEvent.HELLO: {
          __privateMethod(this, _DiscordAuthWebsocket_instances, ready_fn).call(this, message);
          break;
        }
        case receiveEvent.NONCE_PROOF: {
          __privateMethod(this, _DiscordAuthWebsocket_instances, receiveNonceProof_fn).call(this, message);
          break;
        }
        case receiveEvent.PENDING_REMOTE_INIT: {
          __privateSet(this, _fingerprint, message.fingerprint);
          this.emit(Event2.READY, this);
          break;
        }
        case receiveEvent.HEARTBEAT_ACK: {
          this.emit(Event2.DEBUG, `Heartbeat acknowledged.`);
          __privateMethod(this, _DiscordAuthWebsocket_instances, heartbeatAck_fn).call(this);
          break;
        }
        case receiveEvent.PENDING_TICKET: {
          __privateMethod(this, _DiscordAuthWebsocket_instances, pendingLogin_fn).call(this, message);
          break;
        }
        case receiveEvent.CANCEL: {
          this.emit(Event2.CANCEL, this);
          this.destroy();
          break;
        }
        case receiveEvent.PENDING_LOGIN: {
          __privateSet(this, _ticket, message.ticket);
          __privateMethod(this, _DiscordAuthWebsocket_instances, findRealToken_fn).call(this);
          break;
        }
      }
    };
    send_fn = function(op, data) {
      if (!__privateGet(this, _ws)) return;
      let payload = { op };
      if (data !== null) payload = { ...payload, ...data };
      __privateGet(this, _ws).send(JSON.stringify(payload));
    };
    heartbeatAck_fn = function() {
      setTimeout2(() => {
        __privateMethod(this, _DiscordAuthWebsocket_instances, send_fn).call(this, sendEvent.HEARTBEAT);
      }, __privateGet(this, _heartbeatInterval)).unref();
    };
    ready_fn = function(data) {
      this.emit(Event2.DEBUG, "Attempting server handshake...");
      __privateSet(this, _expire, new Date(Date.now() + data.timeout_ms));
      __privateSet(this, _heartbeatInterval, data.heartbeat_interval);
      __privateMethod(this, _DiscordAuthWebsocket_instances, createKey_fn).call(this);
      __privateMethod(this, _DiscordAuthWebsocket_instances, heartbeatAck_fn).call(this);
      __privateMethod(this, _DiscordAuthWebsocket_instances, init_fn).call(this);
    };
    createKey_fn = function() {
      const key = crypto.generateKeyPairSync("rsa", {
        modulusLength: 2048,
        publicKeyEncoding: {
          type: "spki",
          format: "pem"
        },
        privateKeyEncoding: {
          type: "pkcs1",
          format: "pem"
        }
      });
      __privateSet(this, _privateKey, key.privateKey);
      __privateSet(this, _publicKey, key.publicKey);
    };
    encodePublicKey_fn = function() {
      const decoder = new StringDecoder("utf-8");
      let pub_key = decoder.write(__privateGet(this, _publicKey));
      pub_key = pub_key.split("\n").slice(1, -2).join("");
      return pub_key;
    };
    init_fn = function() {
      const public_key = __privateMethod(this, _DiscordAuthWebsocket_instances, encodePublicKey_fn).call(this);
      __privateMethod(this, _DiscordAuthWebsocket_instances, send_fn).call(this, sendEvent.INIT, { encoded_public_key: public_key });
    };
    receiveNonceProof_fn = function(data) {
      const nonce = data.encrypted_nonce;
      const decrypted_nonce = __privateMethod(this, _DiscordAuthWebsocket_instances, decryptPayload_fn).call(this, nonce);
      const proof = crypto.createHash("sha256").update(decrypted_nonce).digest().toString("base64").replace(/\+/g, "-").replace(/\//g, "_").replace(/=+/, "").replace(/\s+$/, "");
      __privateMethod(this, _DiscordAuthWebsocket_instances, send_fn).call(this, sendEvent.NONCE_PROOF, { proof });
    };
    decryptPayload_fn = function(encrypted_payload) {
      const payload = Buffer2.from(encrypted_payload, "base64");
      const decoder = new StringDecoder("utf-8");
      const private_key = decoder.write(__privateGet(this, _privateKey));
      const data = crypto.privateDecrypt(
        {
          key: private_key,
          padding: crypto.constants.RSA_PKCS1_OAEP_PADDING,
          oaepHash: "sha256"
        },
        payload
      );
      return data;
    };
    pendingLogin_fn = function(data) {
      const user_data = __privateMethod(this, _DiscordAuthWebsocket_instances, decryptPayload_fn).call(this, data.encrypted_user_payload);
      __privateSet(this, _userDecryptString, user_data.toString());
      this.emit(Event2.WAIT_SCAN, this.user);
    };
    awaitLogin_fn = function(client) {
      return new Promise((r) => {
        this.once(Event2.FINISH, (token) => {
          r(client.login(token));
        });
      });
    };
    findRealToken_fn = function() {
      return fetch(`https://discord.com/api/v9/users/@me/remote-auth/login`, {
        method: "POST",
        headers: {
          Accept: "*/*",
          "Accept-Language": "en-US",
          "Content-Type": "application/json",
          "Sec-Fetch-Dest": "empty",
          "Sec-Fetch-Mode": "cors",
          "Sec-Fetch-Site": "same-origin",
          "X-Debug-Options": "bugReporterEnabled",
          "X-Super-Properties": `${Buffer2.from(JSON.stringify(defaultClientOptions.ws.properties), "ascii").toString(
            "base64"
          )}`,
          "X-Discord-Locale": "en-US",
          "User-Agent": UserAgent,
          Referer: "https://discord.com/channels/@me",
          Connection: "keep-alive",
          Origin: "https://discord.com"
        },
        body: JSON.stringify({
          ticket: __privateGet(this, _ticket)
        })
      }).then((r) => r.json()).then((res) => {
        if (res.encrypted_token) {
          this.token = __privateMethod(this, _DiscordAuthWebsocket_instances, decryptPayload_fn).call(this, res.encrypted_token).toString();
        }
        this.emit(Event2.FINISH, this.token);
        this.destroy();
      }).catch(() => false);
    };
    var DiscordAuthWebsocket2 = _DiscordAuthWebsocket;
    module2.exports = DiscordAuthWebsocket2;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/client/Client.js
var require_Client = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/client/Client.js"(exports, module) {
    "use strict";
    var process = require_node_process();
    var { setInterval } = require_node_timers();
    var { setTimeout } = require_node_timers();
    var { Collection } = require_dist();
    var BaseClient = require_BaseClient();
    var ActionsManager = require_ActionsManager();
    var ClientVoiceManager = require_ClientVoiceManager();
    var WebSocketManager = require_WebSocketManager();
    var { Error, TypeError } = require_errors2();
    var BaseGuildEmojiManager = require_BaseGuildEmojiManager();
    var BillingManager = require_BillingManager();
    var ChannelManager = require_ChannelManager();
    var ClientUserSettingManager = require_ClientUserSettingManager();
    var GuildManager = require_GuildManager();
    var PresenceManager = require_PresenceManager();
    var RelationshipManager = require_RelationshipManager();
    var UserManager = require_UserManager();
    var UserNoteManager = require_UserNoteManager();
    var VoiceStateManager = require_VoiceStateManager();
    var ShardClientUtil = require_ShardClientUtil();
    var ClientPresence = require_ClientPresence();
    var GuildPreview = require_GuildPreview();
    var GuildTemplate = require_GuildTemplate();
    var Invite = require_Invite();
    var { Sticker } = require_Sticker();
    var StickerPack = require_StickerPack();
    var VoiceRegion = require_VoiceRegion();
    var Webhook = require_Webhook();
    var Widget = require_Widget();
    var { Events, Status } = require_Constants();
    var DataResolver = require_DataResolver();
    var Intents = require_Intents();
    var Permissions = require_Permissions();
    var DiscordAuthWebsocket = require_RemoteAuth();
    var Sweepers = require_Sweepers();
    var Client = class extends BaseClient {
      /**
       * @param {ClientOptions} [options] Options for the client
       */
      constructor(options) {
        super(options);
        this._validateOptions();
        this._cleanups = /* @__PURE__ */ new Set();
        this._finalizers = new FinalizationRegistry(this._finalize.bind(this));
        this.ws = new WebSocketManager(this);
        this.actions = new ActionsManager(this);
        this.voice = new ClientVoiceManager(this);
        this.voiceStates = new VoiceStateManager({ client: this });
        this.shard = process.env.SHARDING_MANAGER ? ShardClientUtil.singleton(this, process.env.SHARDING_MANAGER_MODE) : null;
        this.users = new UserManager(this);
        this.guilds = new GuildManager(this);
        this.channels = new ChannelManager(this);
        this.sweepers = new Sweepers(this, this.options.sweepers);
        this.presence = new ClientPresence(this, this.options.presence);
        this.presences = new PresenceManager(this);
        this.notes = new UserNoteManager(this);
        this.relationships = new RelationshipManager(this);
        this.billing = new BillingManager(this);
        this.settings = new ClientUserSettingManager(this);
        Object.defineProperty(this, "token", { writable: true });
        if (!this.token && "DISCORD_TOKEN" in process.env) {
          this.token = process.env.DISCORD_TOKEN;
        } else {
          this.token = null;
        }
        this.user = null;
        this.readyAt = null;
        if (this.options.messageSweepInterval > 0) {
          process.emitWarning(
            "The message sweeping client options are deprecated, use the global sweepers instead.",
            "DeprecationWarning"
          );
          this.sweepMessageInterval = setInterval(
            this.sweepMessages.bind(this),
            this.options.messageSweepInterval * 1e3
          ).unref();
        }
      }
      /**
       * All custom emojis that the client has access to, mapped by their ids
       * @type {BaseGuildEmojiManager}
       * @readonly
       */
      get emojis() {
        const emojis = new BaseGuildEmojiManager(this);
        for (const guild of this.guilds.cache.values()) {
          if (guild.available) for (const emoji of guild.emojis.cache.values()) emojis.cache.set(emoji.id, emoji);
        }
        return emojis;
      }
      /**
       * Timestamp of the time the client was last `READY` at
       * @type {?number}
       * @readonly
       */
      get readyTimestamp() {
        var _a;
        return ((_a = this.readyAt) == null ? void 0 : _a.getTime()) ?? null;
      }
      /**
       * How long it has been since the client last entered the `READY` state in milliseconds
       * @type {?number}
       * @readonly
       */
      get uptime() {
        return this.readyAt ? Date.now() - this.readyAt : null;
      }
      /**
       * Logs the client in, establishing a WebSocket connection to Discord.
       * @param {string} [token=this.token] Token of the account to log in with
       * @returns {Promise<string>} Token of the account used
       * @example
       * client.login('my token');
       */
      async login(token = this.token) {
        if (!token || typeof token !== "string") throw new Error("TOKEN_INVALID");
        this.token = token = token.replace(/^(Bot|Bearer)\s*/i, "");
        this.emit(
          Events.DEBUG,
          `
      Logging on with a user token is unfortunately against the Discord
      \`Terms of Service\` <https://support.discord.com/hc/en-us/articles/115002192352>
      and doing so might potentially get your account banned.
      Use this at your own risk.`
        );
        this.emit(
          Events.DEBUG,
          `Provided token: ${token.split(".").map((val, i) => i > 1 ? val.replace(/./g, "*") : val).join(".")}`
        );
        if (this.options.presence) {
          this.options.ws.presence = this.presence._parse(this.options.presence);
        }
        this.emit(Events.DEBUG, "Preparing to connect to the gateway...");
        try {
          await this.ws.connect();
          return this.token;
        } catch (error2) {
          this.destroy();
          throw error2;
        }
      }
      QRLogin() {
        const ws = new DiscordAuthWebsocket();
        ws.once("ready", () => ws.generateQR());
        return ws.connect(this);
      }
      /**
       * Logs the client in, establishing a WebSocket connection to Discord.
       * @param {string} email The email associated with the account
       * @param {string} password The password assicated with the account
       * @param {string|number} [mfaCode = null] The mfa code if you have it enabled
       * @returns {string | null} Token of the account used
       *
       * @example
       * client.passLogin("test@gmail.com", "SuperSecretPa$$word", 1234)
       * @deprecated This method will not be updated until I find the most convenient way to implement MFA.
       */
      async passLogin(email, password, mfaCode = null) {
        const initial = await this.api.auth.login.post({
          auth: false,
          versioned: true,
          data: { gift_code_sku_id: null, login_source: null, undelete: false, login: email, password }
        });
        if ("token" in initial) {
          return this.login(initial.token);
        } else if ("ticket" in initial) {
          const totp = await this.api.auth.mfa.totp.post({
            auth: false,
            versioned: true,
            data: { gift_code_sku_id: null, login_source: null, code: mfaCode, ticket: initial.ticket }
          });
          if ("token" in totp) {
            return this.login(totp.token);
          }
        }
        return null;
      }
      /**
       * Returns whether the client has logged in, indicative of being able to access
       * properties such as `user` and `application`.
       * @returns {boolean}
       */
      isReady() {
        return !this.ws.destroyed && this.ws.status === Status.READY;
      }
      /**
       * Logs out, terminates the connection to Discord, and destroys the client.
       * @returns {void}
       */
      destroy() {
        super.destroy();
        for (const fn of this._cleanups) fn();
        this._cleanups.clear();
        if (this.sweepMessageInterval) clearInterval(this.sweepMessageInterval);
        this.sweepers.destroy();
        this.ws.destroy();
        this.token = null;
      }
      /**
       * Logs out, terminates the connection to Discord, destroys the client and destroys the token.
       * @returns {Promise<void>}
       */
      async logout() {
        await this.api.auth.logout.post({
          data: {
            provider: null,
            voip_provider: null
          }
        });
        return this.destroy();
      }
      /**
       * Options used when fetching an invite from Discord.
       * @typedef {Object} ClientFetchInviteOptions
       * @property {Snowflake} [guildScheduledEventId] The id of the guild scheduled event to include with
       * the invite
       */
      /**
       * Obtains an invite from Discord.
       * @param {InviteResolvable} invite Invite code or URL
       * @param {ClientFetchInviteOptions} [options] Options for fetching the invite
       * @returns {Promise<Invite>}
       * @example
       * client.fetchInvite('https://discord.gg/djs')
       *   .then(invite => console.log(`Obtained invite with code: ${invite.code}`))
       *   .catch(console.error);
       */
      async fetchInvite(invite, options) {
        const code = DataResolver.resolveInviteCode(invite);
        const data = await this.api.invites(code).get({
          query: { with_counts: true, with_expiration: true, guild_scheduled_event_id: options == null ? void 0 : options.guildScheduledEventId }
        });
        return new Invite(this, data);
      }
      /**
       * Obtains a template from Discord.
       * @param {GuildTemplateResolvable} template Template code or URL
       * @returns {Promise<GuildTemplate>}
       * @example
       * client.fetchGuildTemplate('https://discord.new/FKvmczH2HyUf')
       *   .then(template => console.log(`Obtained template with code: ${template.code}`))
       *   .catch(console.error);
       */
      async fetchGuildTemplate(template) {
        const code = DataResolver.resolveGuildTemplateCode(template);
        const data = await this.api.guilds.templates(code).get();
        return new GuildTemplate(this, data);
      }
      /**
       * Obtains a webhook from Discord.
       * @param {Snowflake} id The webhook's id
       * @param {string} [token] Token for the webhook
       * @returns {Promise<Webhook>}
       * @example
       * client.fetchWebhook('id', 'token')
       *   .then(webhook => console.log(`Obtained webhook with name: ${webhook.name}`))
       *   .catch(console.error);
       */
      async fetchWebhook(id, token) {
        const data = await this.api.webhooks(id, token).get();
        return new Webhook(this, { token, ...data });
      }
      /**
       * Obtains the available voice regions from Discord.
       * @returns {Promise<Collection<string, VoiceRegion>>}
       * @example
       * client.fetchVoiceRegions()
       *   .then(regions => console.log(`Available regions are: ${regions.map(region => region.name).join(', ')}`))
       *   .catch(console.error);
       */
      async fetchVoiceRegions() {
        const apiRegions = await this.api.voice.regions.get();
        const regions = new Collection();
        for (const region of apiRegions) regions.set(region.id, new VoiceRegion(region));
        return regions;
      }
      /**
       * Obtains a sticker from Discord.
       * @param {Snowflake} id The sticker's id
       * @returns {Promise<Sticker>}
       * @example
       * client.fetchSticker('id')
       *   .then(sticker => console.log(`Obtained sticker with name: ${sticker.name}`))
       *   .catch(console.error);
       */
      async fetchSticker(id) {
        const data = await this.api.stickers(id).get();
        return new Sticker(this, data);
      }
      /**
       * Obtains the list of sticker packs available to Nitro subscribers from Discord.
       * @returns {Promise<Collection<Snowflake, StickerPack>>}
       * @example
       * client.fetchPremiumStickerPacks()
       *   .then(packs => console.log(`Available sticker packs are: ${packs.map(pack => pack.name).join(', ')}`))
       *   .catch(console.error);
       */
      async fetchPremiumStickerPacks() {
        const data = await this.api("sticker-packs").get();
        return new Collection(data.sticker_packs.map((p) => [p.id, new StickerPack(this, p)]));
      }
      /**
       * A last ditch cleanup function for garbage collection.
       * @param {Function} options.cleanup The function called to GC
       * @param {string} [options.message] The message to send after a successful GC
       * @param {string} [options.name] The name of the item being GCed
       * @private
       */
      _finalize({ cleanup, message, name }) {
        try {
          cleanup();
          this._cleanups.delete(cleanup);
          if (message) {
            this.emit(Events.DEBUG, message);
          }
        } catch {
          this.emit(Events.DEBUG, `Garbage collection failed on ${name ?? "an unknown item"}.`);
        }
      }
      /**
       * Sweeps all text-based channels' messages and removes the ones older than the max message lifetime.
       * If the message has been edited, the time of the edit is used rather than the time of the original message.
       * @param {number} [lifetime=this.options.messageCacheLifetime] Messages that are older than this (in seconds)
       * will be removed from the caches. The default is based on {@link ClientOptions#messageCacheLifetime}
       * @returns {number} Amount of messages that were removed from the caches,
       * or -1 if the message cache lifetime is unlimited
       * @example
       * // Remove all messages older than 1800 seconds from the messages cache
       * const amount = client.sweepMessages(1800);
       * console.log(`Successfully removed ${amount} messages from the cache.`);
       */
      sweepMessages(lifetime = this.options.messageCacheLifetime) {
        if (typeof lifetime !== "number" || isNaN(lifetime)) {
          throw new TypeError("INVALID_TYPE", "lifetime", "number");
        }
        if (lifetime <= 0) {
          this.emit(Events.DEBUG, "Didn't sweep messages - lifetime is unlimited");
          return -1;
        }
        const messages = this.sweepers.sweepMessages(Sweepers.outdatedMessageSweepFilter(lifetime)());
        this.emit(Events.DEBUG, `Swept ${messages} messages older than ${lifetime} seconds`);
        return messages;
      }
      /**
       * Obtains a guild preview from Discord, available for all guilds the bot is in and all Discoverable guilds.
       * @param {GuildResolvable} guild The guild to fetch the preview for
       * @returns {Promise<GuildPreview>}
       */
      async fetchGuildPreview(guild) {
        const id = this.guilds.resolveId(guild);
        if (!id) throw new TypeError("INVALID_TYPE", "guild", "GuildResolvable");
        const data = await this.api.guilds(id).preview.get();
        return new GuildPreview(this, data);
      }
      /**
       * Obtains the widget data of a guild from Discord, available for guilds with the widget enabled.
       * @param {GuildResolvable} guild The guild to fetch the widget data for
       * @returns {Promise<Widget>}
       */
      async fetchGuildWidget(guild) {
        const id = this.guilds.resolveId(guild);
        if (!id) throw new TypeError("INVALID_TYPE", "guild", "GuildResolvable");
        const data = await this.api.guilds(id, "widget.json").get();
        return new Widget(this, data);
      }
      /**
       * Refresh the Discord CDN links with hashes so they can be usable.
       * @param {...string} urls Discord CDN URLs
       * @returns {Promise<Array<{ original: string, refreshed: string }>>}
       */
      async refreshAttachmentURL(...urls) {
        urls = urls.map((url) => {
          const urlObject = new URL(url);
          urlObject.search = "";
          return urlObject.toString();
        });
        const data = await this.api.attachments("refresh-urls").post({
          data: { attachment_urls: urls }
        });
        return data.refreshed_urls;
      }
      /**
       * Options for {@link Client#generateInvite}.
       * @typedef {Object} InviteGenerationOptions
       * @property {InviteScope[]} scopes Scopes that should be requested
       * @property {PermissionResolvable} [permissions] Permissions to request
       * @property {GuildResolvable} [guild] Guild to preselect
       * @property {boolean} [disableGuildSelect] Whether to disable the guild selection
       */
      /**
       * The sleep function in JavaScript returns a promise that resolves after a specified timeout.
       * @param {number} timeout - The timeout parameter is the amount of time, in milliseconds, that the sleep
       * function will wait before resolving the promise and continuing execution.
       * @returns {void} The `sleep` function is returning a Promise.
       */
      sleep(timeout) {
        return new Promise((r) => setTimeout(r, timeout));
      }
      toJSON() {
        return super.toJSON({
          readyAt: false
        });
      }
      /**
       * The current session id of the shard
       * @type {?string}
       */
      get sessionId() {
        var _a;
        return (_a = this.ws.shards.first()) == null ? void 0 : _a.sessionId;
      }
      /**
       * Options for {@link Client#acceptInvite}.
       * @typedef {Object} AcceptInviteOptions
       * @property {boolean} [bypassOnboarding=true] Whether to bypass onboarding
       * @property {boolean} [bypassVerify=true] Whether to bypass rule screening
       */
      /**
       * Join this Guild / GroupDMChannel using this invite
       * @param {InviteResolvable} invite Invite code or URL
       * @param {AcceptInviteOptions} [options] Options
       * @returns {Promise<Guild|DMChannel|GroupDMChannel>}
       * @example
       * await client.acceptInvite('https://discord.gg/genshinimpact', { bypassOnboarding: true, bypassVerify: true })
       */
      async acceptInvite(invite, options = { bypassOnboarding: true, bypassVerify: true }) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r;
        const code = DataResolver.resolveInviteCode(invite);
        if (!code) throw new Error("INVITE_RESOLVE_CODE");
        const i = await this.fetchInvite(code);
        if (((_a = i.guild) == null ? void 0 : _a.id) && this.guilds.cache.has((_b = i.guild) == null ? void 0 : _b.id)) return this.guilds.cache.get((_c = i.guild) == null ? void 0 : _c.id);
        if (this.channels.cache.has(i.channelId)) return this.channels.cache.get(i.channelId);
        const data = await this.api.invites(code).post({
          DiscordContext: { location: "Markdown Link" },
          data: {
            session_id: this.sessionId
          }
        });
        this.emit(Events.DEBUG, `[Invite > Guild ${(_d = i.guild) == null ? void 0 : _d.id}] Joined`);
        if ((_e = i.guild) == null ? void 0 : _e.id) {
          const guild = this.guilds.cache.get((_f = i.guild) == null ? void 0 : _f.id);
          if (i.flags.has("GUEST")) {
            this.emit(Events.DEBUG, `[Invite > Guild ${(_g = i.guild) == null ? void 0 : _g.id}] Guest invite`);
            return guild;
          }
          if (options.bypassOnboarding) {
            const onboardingData = await this.api.guilds[(_h = i.guild) == null ? void 0 : _h.id].onboarding.get();
            if (onboardingData.enabled) {
              const prompts = onboardingData.prompts.filter((o) => o.in_onboarding);
              if (prompts.length) {
                const onboarding_prompts_seen = {};
                const onboarding_responses = [];
                const onboarding_responses_seen = {};
                const currentDate = Date.now();
                prompts.forEach((prompt) => {
                  onboarding_prompts_seen[prompt.id] = currentDate;
                  if (prompt.required) onboarding_responses.push(prompt.options[0].id);
                  prompt.options.forEach((option) => {
                    onboarding_responses_seen[option.id] = currentDate;
                  });
                });
                await this.api.guilds[(_i = i.guild) == null ? void 0 : _i.id]["onboarding-responses"].post({
                  data: {
                    onboarding_prompts_seen,
                    onboarding_responses,
                    onboarding_responses_seen
                  }
                });
                this.emit(Events.DEBUG, `[Invite > Guild ${(_j = i.guild) == null ? void 0 : _j.id}] Bypassed onboarding`);
              }
            }
          }
          if (data.show_verification_form && options.bypassVerify) {
            if (i.guild.verificationLevel == "VERY_HIGH" && !this.user.phone) {
              this.emit(Events.DEBUG, `[Invite > Guild ${(_k = i.guild) == null ? void 0 : _k.id}] Cannot bypass verify (Phone required)`);
              return this.guilds.cache.get((_l = i.guild) == null ? void 0 : _l.id);
            }
            if (i.guild.verificationLevel !== "NONE" && !this.user.email) {
              this.emit(Events.DEBUG, `[Invite > Guild ${(_m = i.guild) == null ? void 0 : _m.id}] Cannot bypass verify (Email required)`);
              return this.guilds.cache.get((_n = i.guild) == null ? void 0 : _n.id);
            }
            const getForm = await this.api.guilds((_o = i.guild) == null ? void 0 : _o.id)["member-verification"].get({ query: { with_guild: false, invite_code: this.code } }).catch(() => {
            });
            if (getForm && getForm.form_fields[0]) {
              const form = Object.assign(getForm.form_fields[0], { response: true });
              await this.api.guilds((_p = i.guild) == null ? void 0 : _p.id).requests["@me"].put({ data: { form_fields: [form], version: getForm.version } });
              this.emit(Events.DEBUG, `[Invite > Guild ${(_q = i.guild) == null ? void 0 : _q.id}] Bypassed verify`);
            }
          }
          return guild;
        } else {
          return this.channels.cache.has(i.channelId || ((_r = data.channel) == null ? void 0 : _r.id));
        }
      }
      /**
       * Redeem nitro from code or url.
       * @param {string} nitro Nitro url or code
       * @param {TextChannelResolvable} [channel] Channel that the code was sent in
       * @param {Snowflake} [paymentSourceId] Payment source id
       * @returns {Promise<any>}
       */
      redeemNitro(nitro, channel, paymentSourceId) {
        if (typeof nitro !== "string") throw new Error("INVALID_NITRO");
        const nitroCode = nitro.match(/(discord.gift|discord.com|discordapp.com\/gifts)\/(\w{16,25})/) || nitro.match(/(discord\.gift\/|discord\.com\/gifts\/|discordapp\.com\/gifts\/)(\w+)/);
        if (!nitroCode) return false;
        const code = nitroCode[2];
        channel = this.channels.resolveId(channel);
        return this.api.entitlements["gift-codes"](code).redeem.post({
          auth: true,
          data: { channel_id: channel || null, payment_source_id: paymentSourceId || null }
        });
      }
      /**
       * @typedef {Object} OAuth2AuthorizeOptions
       * @property {string} [guild_id] Guild ID
       * @property {PermissionResolvable} [permissions] Permissions
       * @property {boolean} [authorize] Whether to authorize or not
       * @property {string} [code] 2FA Code
       * @property {string} [webhook_channel_id] Webhook Channel ID
       */
      /**
       * Authorize an application.
       * @param {string} url Discord Auth URL
       * @param {OAuth2AuthorizeOptions} options Oauth2 options
       * @returns {Promise<any>}
       * @example
       * client.authorizeURL(`https://discord.com/api/oauth2/authorize?client_id=botID&permissions=8&scope=applications.commands%20bot`, {
          guild_id: "guildID",
          permissions: "62221393", // your permissions
          authorize: true
        })
       */
      authorizeURL(url, options = { authorize: true }) {
        const pathnameAPI = /\/api\/(v\d{1,2}\/)?oauth2\/authorize/;
        const pathnameURL = /\/oauth2\/authorize/;
        const url_ = new URL(url);
        if (!["discord.com", "canary.discord.com", "ptb.discord.com"].includes(url_.hostname) || !pathnameAPI.test(url_.pathname) && !pathnameURL.test(url_.pathname)) {
          throw new Error("INVALID_URL", url);
        }
        const searchParams = Object.fromEntries(url_.searchParams);
        options.permissions ?? (options.permissions = `${Permissions.resolve(searchParams.permissions || 0)}`);
        options.integration_type ?? (options.integration_type = searchParams.integration_type || 0);
        options.location_context = {
          guild_id: "10000",
          channel_id: "10000",
          channel_type: 1e4
        };
        options.guild_id ?? (options.guild_id = searchParams.guild_id);
        options.authorize ?? (options.authorize = true);
        delete searchParams.permissions;
        delete searchParams.integration_type;
        delete searchParams.guild_id;
        if (!options.permissions || !options.guild_id) throw new Error("INVALID_OAUTH_OPTIONS");
        return this.api.oauth2.authorize.post({
          query: searchParams,
          data: options
        });
      }
      /**
       * Install User Apps
       * @param {Snowflake} applicationId  Discord Application id
       * @returns {Promise<void>}
       */
      installUserApps(applicationId) {
        return this.api.applications(applicationId).public.get({
          query: {
            with_guild: false
          }
        }).then((rawData) => {
          const installTypes = rawData.integration_types_config["1"];
          if (installTypes) {
            return this.api.oauth2.authorize.post({
              query: {
                client_id: applicationId,
                scope: installTypes.oauth2_install_params.scopes.join(" ")
              },
              data: {
                permissions: "0",
                authorize: true,
                integration_type: 1
              }
            });
          } else {
            return false;
          }
        });
      }
      /**
       * Deauthorize an application.
       * @param {Snowflake} applicationId Discord Application id
       * @returns {Promise<void>}
       */
      deauthorize(applicationId) {
        return this.api.oauth2.tokens.get().then((data) => data.find((o) => o.application.id == applicationId)).then((o) => this.api.oauth2.tokens(o.id).delete());
      }
      /**
       * Calls {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval} on a script
       * with the client as `this`.
       * @param {string} script Script to eval
       * @returns {*}
       * @private
       */
      _eval(script) {
        return eval(script);
      }
      /**
       * Validates the client options.
       * @param {ClientOptions} [options=this.options] Options to validate
       * @private
       */
      _validateOptions(options = this.options) {
        if (typeof options.makeCache !== "function") {
          throw new TypeError("CLIENT_INVALID_OPTION", "makeCache", "a function");
        }
        if (typeof options.messageCacheLifetime !== "number" || isNaN(options.messageCacheLifetime)) {
          throw new TypeError("CLIENT_INVALID_OPTION", "The messageCacheLifetime", "a number");
        }
        if (typeof options.messageSweepInterval !== "number" || isNaN(options.messageSweepInterval)) {
          throw new TypeError("CLIENT_INVALID_OPTION", "messageSweepInterval", "a number");
        }
        if (typeof options.sweepers !== "object" || options.sweepers === null) {
          throw new TypeError("CLIENT_INVALID_OPTION", "sweepers", "an object");
        }
        if (typeof options.invalidRequestWarningInterval !== "number" || isNaN(options.invalidRequestWarningInterval)) {
          throw new TypeError("CLIENT_INVALID_OPTION", "invalidRequestWarningInterval", "a number");
        }
        if (!Array.isArray(options.partials)) {
          throw new TypeError("CLIENT_INVALID_OPTION", "partials", "an Array");
        }
        if (typeof options.DMChannelVoiceStatusSync !== "number" || isNaN(options.DMChannelVoiceStatusSync)) {
          throw new TypeError("CLIENT_INVALID_OPTION", "DMChannelVoiceStatusSync", "a number");
        }
        if (typeof options.waitGuildTimeout !== "number" || isNaN(options.waitGuildTimeout)) {
          throw new TypeError("CLIENT_INVALID_OPTION", "waitGuildTimeout", "a number");
        }
        if (typeof options.restWsBridgeTimeout !== "number" || isNaN(options.restWsBridgeTimeout)) {
          throw new TypeError("CLIENT_INVALID_OPTION", "restWsBridgeTimeout", "a number");
        }
        if (typeof options.restRequestTimeout !== "number" || isNaN(options.restRequestTimeout)) {
          throw new TypeError("CLIENT_INVALID_OPTION", "restRequestTimeout", "a number");
        }
        if (typeof options.restGlobalRateLimit !== "number" || isNaN(options.restGlobalRateLimit)) {
          throw new TypeError("CLIENT_INVALID_OPTION", "restGlobalRateLimit", "a number");
        }
        if (typeof options.restSweepInterval !== "number" || isNaN(options.restSweepInterval)) {
          throw new TypeError("CLIENT_INVALID_OPTION", "restSweepInterval", "a number");
        }
        if (typeof options.retryLimit !== "number" || isNaN(options.retryLimit)) {
          throw new TypeError("CLIENT_INVALID_OPTION", "retryLimit", "a number");
        }
        if (typeof options.failIfNotExists !== "boolean") {
          throw new TypeError("CLIENT_INVALID_OPTION", "failIfNotExists", "a boolean");
        }
        if (typeof options.rejectOnRateLimit !== "undefined" && !(typeof options.rejectOnRateLimit === "function" || Array.isArray(options.rejectOnRateLimit))) {
          throw new TypeError("CLIENT_INVALID_OPTION", "rejectOnRateLimit", "an array or a function");
        }
        this.options.shardCount = 1;
        this.options.shards = [0];
        this.options.intents = Intents.ALL;
      }
    };
    module.exports = Client;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/sharding/Shard.js
var require_Shard = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/sharding/Shard.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require_node_events();
    var path = require_node_path();
    var process2 = require_node_process();
    var { setTimeout: setTimeout2 } = require_node_timers();
    var { setTimeout: sleep } = require_promises();
    var { Error: Error2 } = require_errors2();
    var Util = require_Util();
    var childProcess = null;
    var Worker = null;
    var Shard = class extends EventEmitter {
      constructor(manager, id) {
        super();
        if (manager.mode === "process") childProcess = require_node_child_process();
        else if (manager.mode === "worker") Worker = require_node_worker_threads().Worker;
        this.manager = manager;
        this.id = id;
        this.args = manager.shardArgs ?? [];
        this.execArgv = manager.execArgv;
        this.env = Object.assign({}, process2.env, {
          SHARDING_MANAGER: true,
          SHARDS: this.id,
          SHARD_COUNT: this.manager.totalShards,
          DISCORD_TOKEN: this.manager.token
        });
        this.ready = false;
        this.process = null;
        this.worker = null;
        this._evals = /* @__PURE__ */ new Map();
        this._fetches = /* @__PURE__ */ new Map();
        this._exitListener = null;
      }
      /**
       * Forks a child process or creates a worker thread for the shard.
       * <warn>You should not need to call this manually.</warn>
       * @param {number} [timeout=30000] The amount in milliseconds to wait until the {@link Client} has become ready
       * before resolving (`-1` or `Infinity` for no wait)
       * @returns {Promise<ChildProcess>}
       */
      spawn(timeout = 3e4) {
        if (this.process) throw new Error2("SHARDING_PROCESS_EXISTS", this.id);
        if (this.worker) throw new Error2("SHARDING_WORKER_EXISTS", this.id);
        this._exitListener = this._handleExit.bind(this, void 0, timeout);
        if (this.manager.mode === "process") {
          this.process = childProcess.fork(path.resolve(this.manager.file), this.args, {
            env: this.env,
            execArgv: this.execArgv
          }).on("message", this._handleMessage.bind(this)).on("exit", this._exitListener);
        } else if (this.manager.mode === "worker") {
          this.worker = new Worker(path.resolve(this.manager.file), { workerData: this.env }).on("message", this._handleMessage.bind(this)).on("exit", this._exitListener);
        }
        this._evals.clear();
        this._fetches.clear();
        const child = this.process ?? this.worker;
        this.emit("spawn", child);
        if (timeout === -1 || timeout === Infinity) return Promise.resolve(child);
        return new Promise((resolve, reject) => {
          const cleanup = () => {
            clearTimeout(spawnTimeoutTimer);
            this.off("ready", onReady);
            this.off("disconnect", onDisconnect);
            this.off("death", onDeath);
          };
          const onReady = () => {
            cleanup();
            resolve(child);
          };
          const onDisconnect = () => {
            cleanup();
            reject(new Error2("SHARDING_READY_DISCONNECTED", this.id));
          };
          const onDeath = () => {
            cleanup();
            reject(new Error2("SHARDING_READY_DIED", this.id));
          };
          const onTimeout = () => {
            cleanup();
            reject(new Error2("SHARDING_READY_TIMEOUT", this.id));
          };
          const spawnTimeoutTimer = setTimeout2(onTimeout, timeout);
          this.once("ready", onReady);
          this.once("disconnect", onDisconnect);
          this.once("death", onDeath);
        });
      }
      /**
       * Immediately kills the shard's process/worker and does not restart it.
       */
      kill() {
        if (this.process) {
          this.process.removeListener("exit", this._exitListener);
          this.process.kill();
        } else {
          this.worker.removeListener("exit", this._exitListener);
          this.worker.terminate();
        }
        this._handleExit(false);
      }
      /**
       * Options used to respawn a shard.
       * @typedef {Object} ShardRespawnOptions
       * @property {number} [delay=500] How long to wait between killing the process/worker and
       * restarting it (in milliseconds)
       * @property {number} [timeout=30000] The amount in milliseconds to wait until the {@link Client}
       * has become ready before resolving (`-1` or `Infinity` for no wait)
       */
      /**
       * Kills and restarts the shard's process/worker.
       * @param {ShardRespawnOptions} [options] Options for respawning the shard
       * @returns {Promise<ChildProcess>}
       */
      async respawn({ delay = 500, timeout = 3e4 } = {}) {
        this.kill();
        if (delay > 0) await sleep(delay);
        return this.spawn(timeout);
      }
      /**
       * Sends a message to the shard's process/worker.
       * @param {*} message Message to send to the shard
       * @returns {Promise<Shard>}
       */
      send(message) {
        return new Promise((resolve, reject) => {
          if (this.process) {
            this.process.send(message, (err) => {
              if (err) reject(err);
              else resolve(this);
            });
          } else {
            this.worker.postMessage(message);
            resolve(this);
          }
        });
      }
      /**
       * Fetches a client property value of the shard.
       * @param {string} prop Name of the client property to get, using periods for nesting
       * @returns {Promise<*>}
       * @example
       * shard.fetchClientValue('guilds.cache.size')
       *   .then(count => console.log(`${count} guilds in shard ${shard.id}`))
       *   .catch(console.error);
       */
      fetchClientValue(prop) {
        if (!this.process && !this.worker) return Promise.reject(new Error2("SHARDING_NO_CHILD_EXISTS", this.id));
        if (this._fetches.has(prop)) return this._fetches.get(prop);
        const promise = new Promise((resolve, reject) => {
          const child = this.process ?? this.worker;
          const listener = (message) => {
            if ((message == null ? void 0 : message._fetchProp) !== prop) return;
            child.removeListener("message", listener);
            this.decrementMaxListeners(child);
            this._fetches.delete(prop);
            if (!message._error) resolve(message._result);
            else reject(Util.makeError(message._error));
          };
          this.incrementMaxListeners(child);
          child.on("message", listener);
          this.send({ _fetchProp: prop }).catch((err) => {
            child.removeListener("message", listener);
            this.decrementMaxListeners(child);
            this._fetches.delete(prop);
            reject(err);
          });
        });
        this._fetches.set(prop, promise);
        return promise;
      }
      /**
       * Evaluates a script or function on the shard, in the context of the {@link Client}.
       * @param {string|Function} script JavaScript to run on the shard
       * @param {*} [context] The context for the eval
       * @returns {Promise<*>} Result of the script execution
       */
      eval(script2, context) {
        const _eval = typeof script2 === "function" ? `(${script2})(this, ${JSON.stringify(context)})` : script2;
        if (!this.process && !this.worker) return Promise.reject(new Error2("SHARDING_NO_CHILD_EXISTS", this.id));
        if (this._evals.has(_eval)) return this._evals.get(_eval);
        const promise = new Promise((resolve, reject) => {
          const child = this.process ?? this.worker;
          const listener = (message) => {
            if ((message == null ? void 0 : message._eval) !== _eval) return;
            child.removeListener("message", listener);
            this.decrementMaxListeners(child);
            this._evals.delete(_eval);
            if (!message._error) resolve(message._result);
            else reject(Util.makeError(message._error));
          };
          this.incrementMaxListeners(child);
          child.on("message", listener);
          this.send({ _eval }).catch((err) => {
            child.removeListener("message", listener);
            this.decrementMaxListeners(child);
            this._evals.delete(_eval);
            reject(err);
          });
        });
        this._evals.set(_eval, promise);
        return promise;
      }
      /**
       * Handles a message received from the child process/worker.
       * @param {*} message Message received
       * @private
       */
      _handleMessage(message) {
        if (message) {
          if (message._ready) {
            this.ready = true;
            this.emit("ready");
            return;
          }
          if (message._disconnect) {
            this.ready = false;
            this.emit("disconnect");
            return;
          }
          if (message._reconnecting) {
            this.ready = false;
            this.emit("reconnecting");
            return;
          }
          if (message._sFetchProp) {
            const resp = { _sFetchProp: message._sFetchProp, _sFetchPropShard: message._sFetchPropShard };
            this.manager.fetchClientValues(message._sFetchProp, message._sFetchPropShard).then(
              (results) => this.send({ ...resp, _result: results }),
              (err) => this.send({ ...resp, _error: Util.makePlainError(err) })
            );
            return;
          }
          if (message._sEval) {
            const resp = { _sEval: message._sEval, _sEvalShard: message._sEvalShard };
            this.manager._performOnShards("eval", [message._sEval], message._sEvalShard).then(
              (results) => this.send({ ...resp, _result: results }),
              (err) => this.send({ ...resp, _error: Util.makePlainError(err) })
            );
            return;
          }
          if (message._sRespawnAll) {
            const { shardDelay, respawnDelay, timeout } = message._sRespawnAll;
            this.manager.respawnAll({ shardDelay, respawnDelay, timeout }).catch(() => {
            });
            return;
          }
        }
        this.emit("message", message);
      }
      /**
       * Handles the shard's process/worker exiting.
       * @param {boolean} [respawn=this.manager.respawn] Whether to spawn the shard again
       * @param {number} [timeout] The amount in milliseconds to wait until the {@link Client}
       * has become ready (`-1` or `Infinity` for no wait)
       * @private
       */
      _handleExit(respawn = this.manager.respawn, timeout) {
        this.emit("death", this.process ?? this.worker);
        this.ready = false;
        this.process = null;
        this.worker = null;
        this._evals.clear();
        this._fetches.clear();
        if (respawn) this.spawn(timeout).catch((err) => this.emit("error", err));
      }
      /**
       * Increments max listeners by one for a given emitter, if they are not zero.
       * @param {EventEmitter|process} emitter The emitter that emits the events.
       * @private
       */
      incrementMaxListeners(emitter) {
        const maxListeners = emitter.getMaxListeners();
        if (maxListeners !== 0) {
          emitter.setMaxListeners(maxListeners + 1);
        }
      }
      /**
       * Decrements max listeners by one for a given emitter, if they are not zero.
       * @param {EventEmitter|process} emitter The emitter that emits the events.
       * @private
       */
      decrementMaxListeners(emitter) {
        const maxListeners = emitter.getMaxListeners();
        if (maxListeners !== 0) {
          emitter.setMaxListeners(maxListeners - 1);
        }
      }
    };
    module2.exports = Shard;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/sharding/ShardingManager.js
var require_ShardingManager = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/sharding/ShardingManager.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require_node_events();
    var fs = require_node_fs();
    var path = require_node_path();
    var process2 = require_node_process();
    var { setTimeout: sleep } = require_promises();
    var { Collection: Collection2 } = require_dist();
    var Shard = require_Shard();
    var { Error: Error2, TypeError: TypeError2, RangeError: RangeError2 } = require_errors2();
    var Util = require_Util();
    var ShardingManager = class extends EventEmitter {
      /**
       * The mode to spawn shards with for a {@link ShardingManager}. Can be either one of:
       * * 'process' to use child processes
       * * 'worker' to use [Worker threads](https://nodejs.org/api/worker_threads.html)
       * @typedef {string} ShardingManagerMode
       */
      /**
       * The options to spawn shards with for a {@link ShardingManager}.
       * @typedef {Object} ShardingManagerOptions
       * @property {string|number} [totalShards='auto'] Number of total shards of all shard managers or "auto"
       * @property {string|number[]} [shardList='auto'] List of shards to spawn or "auto"
       * @property {ShardingManagerMode} [mode='process'] Which mode to use for shards
       * @property {boolean} [respawn=true] Whether shards should automatically respawn upon exiting
       * @property {string[]} [shardArgs=[]] Arguments to pass to the shard script when spawning
       * (only available when mode is set to 'process')
       * @property {string[]} [execArgv=[]] Arguments to pass to the shard script executable when spawning
       * (only available when mode is set to 'process')
       * @property {string} [token] Token to use for automatic shard count and passing to shards
       */
      /**
       * @param {string} file Path to your shard script file
       * @param {ShardingManagerOptions} [options] Options for the sharding manager
       */
      constructor(file, options = {}) {
        var _a;
        super();
        options = Util.mergeDefault(
          {
            totalShards: "auto",
            mode: "process",
            respawn: true,
            shardArgs: [],
            execArgv: [],
            token: process2.env.DISCORD_TOKEN
          },
          options
        );
        this.file = file;
        if (!file) throw new Error2("CLIENT_INVALID_OPTION", "File", "specified.");
        if (!path.isAbsolute(file)) this.file = path.resolve(process2.cwd(), file);
        const stats = fs.statSync(this.file);
        if (!stats.isFile()) throw new Error2("CLIENT_INVALID_OPTION", "File", "a file");
        this.shardList = options.shardList ?? "auto";
        if (this.shardList !== "auto") {
          if (!Array.isArray(this.shardList)) {
            throw new TypeError2("CLIENT_INVALID_OPTION", "shardList", "an array.");
          }
          this.shardList = [...new Set(this.shardList)];
          if (this.shardList.length < 1) throw new RangeError2("CLIENT_INVALID_OPTION", "shardList", "at least 1 id.");
          if (this.shardList.some(
            (shardId) => typeof shardId !== "number" || isNaN(shardId) || !Number.isInteger(shardId) || shardId < 0
          )) {
            throw new TypeError2("CLIENT_INVALID_OPTION", "shardList", "an array of positive integers.");
          }
        }
        this.totalShards = options.totalShards || "auto";
        if (this.totalShards !== "auto") {
          if (typeof this.totalShards !== "number" || isNaN(this.totalShards)) {
            throw new TypeError2("CLIENT_INVALID_OPTION", "Amount of shards", "a number.");
          }
          if (this.totalShards < 1) throw new RangeError2("CLIENT_INVALID_OPTION", "Amount of shards", "at least 1.");
          if (!Number.isInteger(this.totalShards)) {
            throw new RangeError2("CLIENT_INVALID_OPTION", "Amount of shards", "an integer.");
          }
        }
        this.mode = options.mode;
        if (this.mode !== "process" && this.mode !== "worker") {
          throw new RangeError2("CLIENT_INVALID_OPTION", "Sharding mode", '"process" or "worker"');
        }
        this.respawn = options.respawn;
        this.shardArgs = options.shardArgs;
        this.execArgv = options.execArgv;
        this.token = ((_a = options.token) == null ? void 0 : _a.replace(/^Bot\s*/i, "")) ?? null;
        this.shards = new Collection2();
        process2.env.SHARDING_MANAGER = true;
        process2.env.SHARDING_MANAGER_MODE = this.mode;
        process2.env.DISCORD_TOKEN = this.token;
      }
      /**
       * Creates a single shard.
       * <warn>Using this method is usually not necessary if you use the spawn method.</warn>
       * @param {number} [id=this.shards.size] Id of the shard to create
       * <info>This is usually not necessary to manually specify.</info>
       * @returns {Shard} Note that the created shard needs to be explicitly spawned using its spawn method.
       */
      createShard(id = this.shards.size) {
        const shard = new Shard(this, id);
        this.shards.set(id, shard);
        this.emit("shardCreate", shard);
        return shard;
      }
      /**
       * Options used to spawn multiple shards.
       * @typedef {Object} MultipleShardSpawnOptions
       * @property {number|string} [amount=this.totalShards] Number of shards to spawn
       * @property {number} [delay=5500] How long to wait in between spawning each shard (in milliseconds)
       * @property {number} [timeout=30000] The amount in milliseconds to wait until the {@link Client} has become ready
       */
      /**
       * Spawns multiple shards.
       * @param {MultipleShardSpawnOptions} [options] Options for spawning shards
       * @returns {Promise<Collection<number, Shard>>}
       */
      async spawn({ amount = this.totalShards, delay = 5500, timeout = 3e4 } = {}) {
        if (amount === "auto") {
          amount = 1;
        } else {
          if (typeof amount !== "number" || isNaN(amount)) {
            throw new TypeError2("CLIENT_INVALID_OPTION", "Amount of shards", "a number.");
          }
          if (amount < 1) throw new RangeError2("CLIENT_INVALID_OPTION", "Amount of shards", "at least 1.");
          if (!Number.isInteger(amount)) {
            throw new TypeError2("CLIENT_INVALID_OPTION", "Amount of shards", "an integer.");
          }
        }
        if (this.shards.size >= amount) throw new Error2("SHARDING_ALREADY_SPAWNED", this.shards.size);
        if (this.shardList === "auto" || this.totalShards === "auto" || this.totalShards !== amount) {
          this.shardList = [...Array(amount).keys()];
        }
        if (this.totalShards === "auto" || this.totalShards !== amount) {
          this.totalShards = amount;
        }
        if (this.shardList.some((shardId) => shardId >= amount)) {
          throw new RangeError2(
            "CLIENT_INVALID_OPTION",
            "Amount of shards",
            "bigger than the highest shardId in the shardList option."
          );
        }
        for (const shardId of this.shardList) {
          const promises = [];
          const shard = this.createShard(shardId);
          promises.push(shard.spawn(timeout));
          if (delay > 0 && this.shards.size !== this.shardList.length) promises.push(sleep(delay));
          await Promise.all(promises);
        }
        return this.shards;
      }
      /**
       * Sends a message to all shards.
       * @param {*} message Message to be sent to the shards
       * @returns {Promise<Shard[]>}
       */
      broadcast(message) {
        const promises = [];
        for (const shard of this.shards.values()) promises.push(shard.send(message));
        return Promise.all(promises);
      }
      /**
       * Options for {@link ShardingManager#broadcastEval} and {@link ShardClientUtil#broadcastEval}.
       * @typedef {Object} BroadcastEvalOptions
       * @property {number} [shard] Shard to run script on, all if undefined
       * @property {*} [context] The JSON-serializable values to call the script with
       */
      /**
       * Evaluates a script on all shards, or a given shard, in the context of the {@link Client}s.
       * @param {Function} script JavaScript to run on each shard
       * @param {BroadcastEvalOptions} [options={}] The options for the broadcast
       * @returns {Promise<*|Array<*>>} Results of the script execution
       */
      broadcastEval(script2, options = {}) {
        if (typeof script2 !== "function") return Promise.reject(new TypeError2("SHARDING_INVALID_EVAL_BROADCAST"));
        return this._performOnShards("eval", [`(${script2})(this, ${JSON.stringify(options.context)})`], options.shard);
      }
      /**
       * Fetches a client property value of each shard, or a given shard.
       * @param {string} prop Name of the client property to get, using periods for nesting
       * @param {number} [shard] Shard to fetch property from, all if undefined
       * @returns {Promise<*|Array<*>>}
       * @example
       * manager.fetchClientValues('guilds.cache.size')
       *   .then(results => console.log(`${results.reduce((prev, val) => prev + val, 0)} total guilds`))
       *   .catch(console.error);
       */
      fetchClientValues(prop, shard) {
        return this._performOnShards("fetchClientValue", [prop], shard);
      }
      /**
       * Runs a method with given arguments on all shards, or a given shard.
       * @param {string} method Method name to run on each shard
       * @param {Array<*>} args Arguments to pass through to the method call
       * @param {number} [shard] Shard to run on, all if undefined
       * @returns {Promise<*|Array<*>>} Results of the method execution
       * @private
       */
      _performOnShards(method, args, shard) {
        if (this.shards.size === 0) return Promise.reject(new Error2("SHARDING_NO_SHARDS"));
        if (typeof shard === "number") {
          if (this.shards.has(shard)) return this.shards.get(shard)[method](...args);
          return Promise.reject(new Error2("SHARDING_SHARD_NOT_FOUND", shard));
        }
        if (this.shards.size !== this.shardList.length) return Promise.reject(new Error2("SHARDING_IN_PROCESS"));
        const promises = [];
        for (const sh of this.shards.values()) promises.push(sh[method](...args));
        return Promise.all(promises);
      }
      /**
       * Options used to respawn all shards.
       * @typedef {Object} MultipleShardRespawnOptions
       * @property {number} [shardDelay=5000] How long to wait between shards (in milliseconds)
       * @property {number} [respawnDelay=500] How long to wait between killing a shard's process and restarting it
       * (in milliseconds)
       * @property {number} [timeout=30000] The amount in milliseconds to wait for a shard to become ready before
       * continuing to another (`-1` or `Infinity` for no wait)
       */
      /**
       * Kills all running shards and respawns them.
       * @param {MultipleShardRespawnOptions} [options] Options for respawning shards
       * @returns {Promise<Collection<number, Shard>>}
       */
      async respawnAll({ shardDelay = 5e3, respawnDelay = 500, timeout = 3e4 } = {}) {
        let s = 0;
        for (const shard of this.shards.values()) {
          const promises = [shard.respawn({ delay: respawnDelay, timeout })];
          if (++s < this.shards.size && shardDelay > 0) promises.push(sleep(shardDelay));
          await Promise.all(promises);
        }
        return this.shards;
      }
    };
    module2.exports = ShardingManager;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/util/Formatters.js
var require_Formatters = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/util/Formatters.js"(exports2, module2) {
    "use strict";
    var {
      blockQuote,
      bold,
      channelMention,
      codeBlock,
      formatEmoji,
      hideLinkEmbed,
      hyperlink,
      inlineCode,
      italic,
      quote,
      roleMention,
      spoiler,
      strikethrough,
      time,
      TimestampStyles,
      underscore,
      userMention
    } = require_dist2();
    var Formatters = class extends null {
    };
    Formatters.blockQuote = blockQuote;
    Formatters.bold = bold;
    Formatters.channelMention = channelMention;
    Formatters.chatInputApplicationCommandMention = function chatInputApplicationCommandMention(commandName, subcommandGroupOrSubOrId, subcommandNameOrId, commandId) {
      if (typeof commandId !== "undefined") {
        return `</${commandName} ${subcommandGroupOrSubOrId} ${subcommandNameOrId}:${commandId}>`;
      }
      if (typeof subcommandNameOrId !== "undefined") {
        return `</${commandName} ${subcommandGroupOrSubOrId}:${subcommandNameOrId}>`;
      }
      return `</${commandName}:${subcommandGroupOrSubOrId}>`;
    };
    Formatters.codeBlock = codeBlock;
    Formatters.formatEmoji = formatEmoji;
    Formatters.hideLinkEmbed = hideLinkEmbed;
    Formatters.hyperlink = hyperlink;
    Formatters.inlineCode = inlineCode;
    Formatters.italic = italic;
    Formatters.quote = quote;
    Formatters.roleMention = roleMention;
    Formatters.spoiler = spoiler;
    Formatters.strikethrough = strikethrough;
    Formatters.time = time;
    Formatters.TimestampStyles = TimestampStyles;
    Formatters.underscore = underscore;
    Formatters.userMention = userMention;
    module2.exports = Formatters;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/package.json
var require_package = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/package.json"(exports2, module2) {
    module2.exports = {
      name: "discord.js-selfbot-v13",
      version: "3.4.6",
      description: "A unofficial discord.js fork for creating selfbots [Based on discord.js v13]",
      main: "./src/index.js",
      types: "./typings/index.d.ts",
      scripts: {
        all: "npm run build && npm publish",
        test: "npm run lint:all && npm run docs:test && npm run test:typescript",
        "fix:all": "npm run lint:fix && npm run lint:typings:fix && npm run format",
        "test:typescript": "tsc --noEmit && tsd",
        lint: "eslint .",
        "lint:fix": "eslint . --fix",
        "lint:typings": "tslint typings/index.d.ts",
        "lint:typings:fix": "tslint typings/index.d.ts --fix",
        format: "prettier --write src/**/*.js typings/**/*.ts",
        "lint:all": "npm run lint &&  npm run lint:typings",
        docs: "docgen --source src --custom docs/index.yml --output docs/main.json",
        "docs:test": "docgen --source src --custom docs/index.yml",
        build: "npm run lint:fix && npm run lint:typings:fix && npm run format && npm run docs"
      },
      files: [
        "src",
        "typings"
      ],
      directories: {
        lib: "src",
        test: "test"
      },
      repository: {
        type: "git",
        url: "git+https://github.com/aiko-chan-ai/discord.js-selfbot-v13.git"
      },
      keywords: [
        "discord.js",
        "discord.js v13",
        "selfbot",
        "selfbot v13",
        "djs",
        "api",
        "bot",
        "node",
        "discord",
        "client",
        "discordapp"
      ],
      author: "aiko-chan-ai",
      license: "GNU General Public License v3.0",
      bugs: {
        url: "https://github.com/aiko-chan-ai/discord.js-selfbot-v13/issues"
      },
      homepage: "https://github.com/aiko-chan-ai/discord.js-selfbot-v13#readme",
      dependencies: {
        "@discordjs/builders": "^1.6.3",
        "@discordjs/collection": "^1.5.3",
        "@sapphire/async-queue": "^1.5.3",
        "@sapphire/shapeshift": "^3.9.5",
        "discord-api-types": "^0.37.103",
        "fetch-cookie": "^2.1.0",
        "find-process": "^1.4.7",
        "prism-media": "^1.3.5",
        qrcode: "^1.5.4",
        "tough-cookie": "^4.1.4",
        "tree-kill": "^1.2.2",
        undici: "^6.21.0",
        ws: "^8.16.0"
      },
      engines: {
        node: ">=16.6.0",
        npm: ">=7.0.0"
      },
      devDependencies: {
        "@commitlint/cli": "^16.0.1",
        "@commitlint/config-angular": "^16.0.0",
        "@discordjs/docgen": "^0.11.1",
        "@favware/npm-deprecate": "^1.0.7",
        "@types/node": "^20.14.12",
        "@types/ws": "^8.5.10",
        "conventional-changelog-cli": "^2.2.2",
        dtslint: "^4.2.1",
        eslint: "^8.39.0",
        "eslint-config-prettier": "^8.8.0",
        "eslint-plugin-import": "^2.27.5",
        "eslint-plugin-prettier": "^4.2.1",
        husky: "^7.0.4",
        "is-ci": "^3.0.1",
        jest: "^28.1.3",
        "lint-staged": "^12.1.4",
        prettier: "^2.8.8",
        tsd: "^0.28.1",
        tslint: "^6.1.3",
        typescript: "^5.5.4"
      }
    };
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/managers/ApplicationCommandManager.js
var require_ApplicationCommandManager = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/managers/ApplicationCommandManager.js"(exports2, module2) {
    "use strict";
    var { isJSONEncodable } = require_dist2();
    var { Collection: Collection2 } = require_dist();
    var ApplicationCommandPermissionsManager = require_ApplicationCommandPermissionsManager();
    var CachedManager = require_CachedManager();
    var { TypeError: TypeError2 } = require_errors2();
    var ApplicationCommand = require_ApplicationCommand();
    var { ApplicationCommandTypes } = require_Constants();
    var Permissions2 = require_Permissions();
    var ApplicationCommandManager = class extends CachedManager {
      constructor(client, iterable) {
        super(client, ApplicationCommand, iterable);
        this.permissions = new ApplicationCommandPermissionsManager(this);
      }
      /**
       * The cache of this manager
       * @type {Collection<Snowflake, ApplicationCommand>}
       * @name ApplicationCommandManager#cache
       */
      _add(data, cache, guildId) {
        return super._add(data, cache, { extras: [this.guild, guildId] });
      }
      /**
       * The APIRouter path to the commands
       * @param {Snowflake} [options.id] The application command's id
       * @param {Snowflake} [options.guildId] The guild's id to use in the path,
       * ignored when using a {@link GuildApplicationCommandManager}
       * @returns {Object}
       * @private
       */
      commandPath({ id, guildId } = {}) {
        var _a;
        let path = this.client.api.applications(this.client.application.id);
        if (this.guild ?? guildId) path = path.guilds(((_a = this.guild) == null ? void 0 : _a.id) ?? guildId);
        return id ? path.commands(id) : path.commands;
      }
      /**
       * Data that resolves to give an ApplicationCommand object. This can be:
       * * An ApplicationCommand object
       * * A Snowflake
       * @typedef {ApplicationCommand|Snowflake} ApplicationCommandResolvable
       */
      /* eslint-disable max-len */
      /**
       * Data that resolves to the data of an ApplicationCommand
       * @typedef {ApplicationCommandData|APIApplicationCommand|SlashCommandBuilder|ContextMenuCommandBuilder} ApplicationCommandDataResolvable
       */
      /* eslint-enable max-len */
      /**
       * Options used to fetch data from Discord
       * @typedef {Object} BaseFetchOptions
       * @property {boolean} [cache=true] Whether to cache the fetched data if it wasn't already
       * @property {boolean} [force=false] Whether to skip the cache check and request the API
       */
      /**
       * Options used to fetch Application Commands from Discord
       * @typedef {BaseFetchOptions} FetchApplicationCommandOptions
       * @property {Snowflake} [guildId] The guild's id to fetch commands for, for when the guild is not cached
       * @property {LocaleString} [locale] The locale to use when fetching this command
       * @property {boolean} [withLocalizations] Whether to fetch all localization data
       */
      /**
       * Obtains one or multiple application commands from Discord, or the cache if it's already available.
       * @param {Snowflake} [id] The application command's id
       * @param {FetchApplicationCommandOptions} [options] Additional options for this fetch
       * @returns {Promise<ApplicationCommand|Collection<Snowflake, ApplicationCommand>>}
       * @example
       * // Fetch a single command
       * client.application.commands.fetch('123456789012345678')
       *   .then(command => console.log(`Fetched command ${command.name}`))
       *   .catch(console.error);
       * @example
       * // Fetch all commands
       * guild.commands.fetch()
       *   .then(commands => console.log(`Fetched ${commands.size} commands`))
       *   .catch(console.error);
       */
      async fetch(id, { guildId, cache = true, force = false, locale, withLocalizations } = {}) {
        if (typeof id === "object") {
          ({ guildId, cache = true, locale, withLocalizations } = id);
        } else if (id) {
          if (!force) {
            const existing = this.cache.get(id);
            if (existing) return existing;
          }
          const command = await this.commandPath({ id, guildId }).get();
          return this._add(command, cache);
        }
        const data = await this.commandPath({ guildId }).get({
          headers: {
            "X-Discord-Locale": locale
          },
          query: typeof withLocalizations === "boolean" ? { with_localizations: withLocalizations } : void 0
        });
        return data.reduce((coll, command) => coll.set(command.id, this._add(command, cache, guildId)), new Collection2());
      }
      /**
       * Creates an application command.
       * @param {ApplicationCommandDataResolvable} command The command
       * @param {Snowflake} [guildId] The guild's id to create this command in,
       * ignored when using a {@link GuildApplicationCommandManager}
       * @returns {Promise<ApplicationCommand>}
       * @example
       * // Create a new command
       * client.application.commands.create({
       *   name: 'test',
       *   description: 'A test command',
       * })
       *   .then(console.log)
       *   .catch(console.error);
       */
      async create(command, guildId) {
        const data = await this.commandPath({ guildId }).post({
          data: this.constructor.transformCommand(command)
        });
        return this._add(data, true, guildId);
      }
      /**
       * Sets all the commands for this application or guild.
       * @param {ApplicationCommandDataResolvable[]} commands The commands
       * @param {Snowflake} [guildId] The guild's id to create the commands in,
       * ignored when using a {@link GuildApplicationCommandManager}
       * @returns {Promise<Collection<Snowflake, ApplicationCommand>>}
       * @example
       * // Set all commands to just this one
       * client.application.commands.set([
       *   {
       *     name: 'test',
       *     description: 'A test command',
       *   },
       * ])
       *   .then(console.log)
       *   .catch(console.error);
       * @example
       * // Remove all commands
       * guild.commands.set([])
       *   .then(console.log)
       *   .catch(console.error);
       */
      async set(commands, guildId) {
        const data = await this.commandPath({ guildId }).put({
          data: commands.map((c) => this.constructor.transformCommand(c))
        });
        return data.reduce((coll, command) => coll.set(command.id, this._add(command, true, guildId)), new Collection2());
      }
      /**
       * Edits an application command.
       * @param {ApplicationCommandResolvable} command The command to edit
       * @param {Partial<ApplicationCommandDataResolvable>} data The data to update the command with
       * @param {Snowflake} [guildId] The guild's id where the command registered,
       * ignored when using a {@link GuildApplicationCommandManager}
       * @returns {Promise<ApplicationCommand>}
       * @example
       * // Edit an existing command
       * client.application.commands.edit('123456789012345678', {
       *   description: 'New description',
       * })
       *   .then(console.log)
       *   .catch(console.error);
       */
      async edit(command, data, guildId) {
        const id = this.resolveId(command);
        if (!id) throw new TypeError2("INVALID_TYPE", "command", "ApplicationCommandResolvable");
        const patched = await this.commandPath({ id, guildId }).patch({
          data: this.constructor.transformCommand(data)
        });
        return this._add(patched, true, guildId);
      }
      /**
       * Deletes an application command.
       * @param {ApplicationCommandResolvable} command The command to delete
       * @param {Snowflake} [guildId] The guild's id where the command is registered,
       * ignored when using a {@link GuildApplicationCommandManager}
       * @returns {Promise<?ApplicationCommand>}
       * @example
       * // Delete a command
       * guild.commands.delete('123456789012345678')
       *   .then(console.log)
       *   .catch(console.error);
       */
      async delete(command, guildId) {
        const id = this.resolveId(command);
        if (!id) throw new TypeError2("INVALID_TYPE", "command", "ApplicationCommandResolvable");
        await this.commandPath({ id, guildId }).delete();
        const cached = this.cache.get(id);
        this.cache.delete(id);
        return cached ?? null;
      }
      /**
       * Transforms an {@link ApplicationCommandData} object into something that can be used with the API.
       * @param {ApplicationCommandDataResolvable} command The command to transform
       * @returns {APIApplicationCommand}
       * @private
       */
      static transformCommand(command) {
        var _a;
        if (isJSONEncodable(command)) return command.toJSON();
        let default_member_permissions;
        if ("default_member_permissions" in command) {
          default_member_permissions = command.default_member_permissions ? new Permissions2(BigInt(command.default_member_permissions)).bitfield.toString() : command.default_member_permissions;
        }
        if ("defaultMemberPermissions" in command) {
          default_member_permissions = command.defaultMemberPermissions !== null ? new Permissions2(command.defaultMemberPermissions).bitfield.toString() : command.defaultMemberPermissions;
        }
        return {
          name: command.name,
          name_localizations: command.nameLocalizations ?? command.name_localizations,
          description: command.description,
          description_localizations: command.descriptionLocalizations ?? command.description_localizations,
          type: typeof command.type === "number" ? command.type : ApplicationCommandTypes[command.type],
          options: (_a = command.options) == null ? void 0 : _a.map((o) => ApplicationCommand.transformOption(o)),
          default_permission: command.defaultPermission ?? command.default_permission,
          default_member_permissions,
          dm_permission: command.dmPermission ?? command.dm_permission
        };
      }
    };
    module2.exports = ApplicationCommandManager;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/structures/WebEmbed.js
var require_WebEmbed = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/structures/WebEmbed.js"(exports2, module2) {
    "use strict";
    var baseURL = "https://webembed-sb.onrender.com/embed?";
    var hiddenCharter = "||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||";
    var { RangeError: RangeError2 } = require_errors2();
    var Util = require_Util();
    var WebEmbed = class {
      /**
       * @param {WebEmbed} [data={}] Raw data
       */
      constructor(data = {}) {
        this._setup(data);
      }
      /**
       * @private
       * @param {Object} data The data for the embed
       */
      _setup(data) {
        this.imageType = "thumbnail";
        this.title = data.title ?? null;
        this.description = data.description ?? null;
        this.url = data.url ?? null;
        this.color = "color" in data ? Util.resolveColor(data.color) : null;
        this.image = data.image ? {
          url: data.image.url,
          proxyURL: data.image.proxyURL ?? data.image.proxy_url,
          height: data.image.height,
          width: data.image.width
        } : null;
        this.thumbnail = data.thumbnail ? {
          url: data.thumbnail.url,
          proxyURL: data.thumbnail.proxyURL ?? data.thumbnail.proxy_url,
          height: data.thumbnail.height,
          width: data.thumbnail.width
        } : null;
        this.video = data.video ? {
          url: data.video.url,
          proxyURL: data.video.proxyURL ?? data.video.proxy_url,
          height: data.video.height,
          width: data.video.width
        } : null;
        this.author = data.author ? {
          name: data.author.name,
          url: data.author.url
        } : null;
        this.provider = data.provider ? {
          name: data.provider.name,
          url: data.provider.name
        } : null;
        this.redirect = data.redirect;
      }
      /**
       * The options to provide for setting an author for a {@link WebEmbed}.
       * @typedef {Object} EmbedAuthorData
       * @property {string} name The name of this author.
       */
      /**
       * Sets the author of this embed.
       * @param {string|EmbedAuthorData|null} options The options to provide for the author.
       * Provide `null` to remove the author data.
       * @returns {WebEmbed}
       */
      setAuthor(options) {
        if (options === null) {
          this.author = {};
          return this;
        }
        const { name, url } = options;
        this.author = {
          name: Util.verifyString(name, RangeError2, "EMBED_AUTHOR_NAME"),
          url
        };
        return this;
      }
      /**
       * The options to provide for setting an provider for a {@link WebEmbed}.
       * @typedef {Object} EmbedProviderData
       * @property {string} name The name of this provider.
       */
      /**
       * Sets the provider of this embed.
       * @param {string|EmbedProviderData|null} options The options to provide for the provider.
       * Provide `null` to remove the provider data.
       * @returns {WebEmbed}
       */
      setProvider(options) {
        if (options === null) {
          this.provider = {};
          return this;
        }
        const { name, url } = options;
        this.provider = {
          name: Util.verifyString(name, RangeError2, "EMBED_PROVIDER_NAME"),
          url
        };
        return this;
      }
      /**
       * Sets the color of this embed.
       * @param {ColorResolvable} color The color of the embed
       * @returns {WebEmbed}
       */
      setColor(color) {
        this.color = Util.resolveColor(color);
        return this;
      }
      /**
       * Sets the description of this embed.
       * @param {string} description The description (Limit 350 characters)
       * @returns {WebEmbed}
       */
      setDescription(description) {
        this.description = Util.verifyString(description, RangeError2, "EMBED_DESCRIPTION");
        return this;
      }
      /**
       * Sets the image of this embed.
       * @param {string} url The URL of the image
       * @returns {WebEmbed}
       */
      setImage(url) {
        if (this.thumbnail && this.thumbnail.url) {
          console.warn("You can only set image or thumbnail per embed.");
          this.thumbnail.url = null;
        }
        this.imageType = "image";
        this.image = { url };
        return this;
      }
      /**
       * Sets the thumbnail of this embed.
       * @param {string} url The URL of the image
       * @returns {WebEmbed}
       */
      setThumbnail(url) {
        if (this.image && this.image.url) {
          console.warn("You can only set image or thumbnail per embed.");
          this.image.url = null;
        }
        this.imageType = "thumbnail";
        this.thumbnail = { url };
        return this;
      }
      /**
       * Sets the video of this embed.
       * @param {string} url The URL of the video
       * @returns {WebEmbed}
       */
      setVideo(url) {
        this.video = { url };
        return this;
      }
      /**
       * Sets the title of this embed.
       * @param {string} title The title
       * @returns {WebEmbed}
       */
      setTitle(title) {
        this.title = Util.verifyString(title, RangeError2, "EMBED_TITLE");
        return this;
      }
      /**
       * Sets the URL of this embed.
       * @param {string} url The URL
       * @returns {WebEmbed}
       */
      setURL(url) {
        this.url = url;
        return this;
      }
      /**
       * Sets the redirect URL of this embed.
       * @param {string} url The URL
       * @returns {WebEmbed}
       */
      setRedirect(url) {
        this.redirect = url;
        return this;
      }
      toString() {
        var _a, _b, _c;
        const url = new URL(baseURL);
        url.searchParams.set("image_type", this.imageType);
        if (this.title) {
          url.searchParams.set("title", this.title);
        }
        if (this.description) {
          url.searchParams.set("description", this.description);
        }
        if (this.url) {
          url.searchParams.set("url", this.url);
        }
        if (this.color) {
          url.searchParams.set("color", `#${this.color.toString(16)}`);
        }
        if ((_a = this.image) == null ? void 0 : _a.url) {
          url.searchParams.set("image", this.image.url);
        }
        if ((_b = this.video) == null ? void 0 : _b.url) {
          url.searchParams.set("video", this.video.url);
        }
        if (this.author) {
          if (this.author.name) {
            url.searchParams.set("author_name", this.author.name);
          }
          if (this.author.url) {
            url.searchParams.set("author_url", this.author.url);
          }
        }
        if (this.provider) {
          if (this.provider.name) {
            url.searchParams.set("provider_name", this.provider.name);
          }
          if (this.provider.url) {
            url.searchParams.set("provider_url", this.provider.url);
          }
        }
        if ((_c = this.thumbnail) == null ? void 0 : _c.url) {
          url.searchParams.set("image", this.thumbnail.url);
        }
        if (this.redirect) {
          url.searchParams.set("redirect", this.redirect);
        }
        return url.toString();
      }
    };
    module2.exports = WebEmbed;
    module2.exports.hiddenEmbed = hiddenCharter;
  }
});

// ../../../node_modules/discord.js-selfbot-v13/src/index.js
var require_src2 = __commonJS({
  "../../../node_modules/discord.js-selfbot-v13/src/index.js"(exports2) {
    exports2.BaseClient = require_BaseClient();
    exports2.Client = require_Client();
    exports2.Shard = require_Shard();
    exports2.ShardClientUtil = require_ShardClientUtil();
    exports2.ShardingManager = require_ShardingManager();
    exports2.WebhookClient = require_WebhookClient();
    exports2.ActivityFlags = require_ActivityFlags();
    exports2.ApplicationFlags = require_ApplicationFlags();
    exports2.AttachmentFlags = require_AttachmentFlags();
    exports2.BaseManager = require_BaseManager();
    exports2.BitField = require_BitField();
    exports2.Collection = require_dist().Collection;
    exports2.Constants = require_Constants();
    exports2.DataResolver = require_DataResolver();
    exports2.DiscordAPIError = require_DiscordAPIError();
    exports2.Formatters = require_Formatters();
    exports2.GuildMemberFlags = require_GuildMemberFlags();
    exports2.HTTPError = require_HTTPError();
    exports2.Intents = require_Intents();
    exports2.LimitedCollection = require_LimitedCollection();
    exports2.MessageFlags = require_MessageFlags();
    exports2.Options = require_Options();
    exports2.Permissions = require_Permissions();
    exports2.RateLimitError = require_RateLimitError();
    exports2.RoleFlags = require_RoleFlags();
    exports2.SnowflakeUtil = require_SnowflakeUtil();
    exports2.Sweepers = require_Sweepers();
    exports2.SystemChannelFlags = require_SystemChannelFlags();
    exports2.ThreadMemberFlags = require_ThreadMemberFlags();
    exports2.UserFlags = require_UserFlags();
    exports2.Util = require_Util();
    exports2.version = require_package().version;
    exports2.ApplicationCommandManager = require_ApplicationCommandManager();
    exports2.ApplicationCommandPermissionsManager = require_ApplicationCommandPermissionsManager();
    exports2.AutoModerationRuleManager = require_AutoModerationRuleManager();
    exports2.BaseGuildEmojiManager = require_BaseGuildEmojiManager();
    exports2.CachedManager = require_CachedManager();
    exports2.ChannelManager = require_ChannelManager();
    exports2.ClientVoiceManager = require_ClientVoiceManager();
    exports2.DataManager = require_DataManager();
    exports2.GuildBanManager = require_GuildBanManager();
    exports2.GuildChannelManager = require_GuildChannelManager();
    exports2.GuildEmojiManager = require_GuildEmojiManager();
    exports2.GuildEmojiRoleManager = require_GuildEmojiRoleManager();
    exports2.GuildInviteManager = require_GuildInviteManager();
    exports2.GuildManager = require_GuildManager();
    exports2.GuildMemberManager = require_GuildMemberManager();
    exports2.GuildMemberRoleManager = require_GuildMemberRoleManager();
    exports2.GuildScheduledEventManager = require_GuildScheduledEventManager();
    exports2.GuildStickerManager = require_GuildStickerManager();
    exports2.MessageManager = require_MessageManager();
    exports2.PermissionOverwriteManager = require_PermissionOverwriteManager();
    exports2.PresenceManager = require_PresenceManager();
    exports2.ReactionManager = require_ReactionManager();
    exports2.ReactionUserManager = require_ReactionUserManager();
    exports2.RoleManager = require_RoleManager();
    exports2.StageInstanceManager = require_StageInstanceManager();
    exports2.ThreadManager = require_ThreadManager();
    exports2.ThreadMemberManager = require_ThreadMemberManager();
    exports2.UserManager = require_UserManager();
    exports2.VoiceStateManager = require_VoiceStateManager();
    exports2.WebSocketManager = require_WebSocketManager();
    exports2.WebSocketShard = require_WebSocketShard();
    exports2.RelationshipManager = require_RelationshipManager();
    exports2.UserNoteManager = require_UserNoteManager();
    exports2.Activity = require_Presence().Activity;
    exports2.AnonymousGuild = require_AnonymousGuild();
    exports2.Application = require_Application();
    exports2.ApplicationCommand = require_ApplicationCommand();
    exports2.ApplicationRoleConnectionMetadata = require_ApplicationRoleConnectionMetadata().ApplicationRoleConnectionMetadata;
    exports2.AutoModerationActionExecution = require_AutoModerationActionExecution();
    exports2.AutoModerationRule = require_AutoModerationRule();
    exports2.Base = require_Base();
    exports2.BaseGuild = require_BaseGuild();
    exports2.BaseGuildEmoji = require_BaseGuildEmoji();
    exports2.BaseGuildTextChannel = require_BaseGuildTextChannel();
    exports2.BaseGuildVoiceChannel = require_BaseGuildVoiceChannel();
    exports2.CategoryChannel = require_CategoryChannel();
    exports2.Channel = require_Channel().Channel;
    exports2.ClientPresence = require_ClientPresence();
    exports2.ClientUser = require_ClientUser();
    exports2.Collector = require_Collector();
    exports2.DMChannel = require_DMChannel();
    exports2.Emoji = require_Emoji().Emoji;
    exports2.ForumChannel = require_ForumChannel();
    exports2.Guild = require_Guild().Guild;
    exports2.GuildAuditLogs = require_GuildAuditLogs();
    exports2.GuildAuditLogsEntry = require_GuildAuditLogs().Entry;
    exports2.GuildBan = require_GuildBan();
    exports2.GuildChannel = require_GuildChannel();
    exports2.GuildEmoji = require_GuildEmoji();
    exports2.GuildMember = require_GuildMember().GuildMember;
    exports2.GuildPreview = require_GuildPreview();
    exports2.GuildPreviewEmoji = require_GuildPreviewEmoji();
    exports2.GuildScheduledEvent = require_GuildScheduledEvent().GuildScheduledEvent;
    exports2.GuildTemplate = require_GuildTemplate();
    exports2.Integration = require_Integration();
    exports2.IntegrationApplication = require_IntegrationApplication();
    exports2.Invite = require_Invite();
    exports2.InviteStageInstance = require_InviteStageInstance();
    exports2.InviteGuild = require_InviteGuild();
    exports2.MediaChannel = require_MediaChannel();
    exports2.Message = require_Message().Message;
    exports2.MessageActionRow = require_MessageActionRow();
    exports2.MessageAttachment = require_MessageAttachment();
    exports2.MessageButton = require_MessageButton();
    exports2.MessageCollector = require_MessageCollector();
    exports2.MessageEmbed = require_MessageEmbed();
    exports2.MessageMentions = require_MessageMentions();
    exports2.MessagePayload = require_MessagePayload();
    exports2.MessageReaction = require_MessageReaction();
    exports2.Modal = require_Modal();
    exports2.NewsChannel = require_NewsChannel();
    exports2.OAuth2Guild = require_OAuth2Guild();
    exports2.GroupDMChannel = require_GroupDMChannel();
    exports2.PermissionOverwrites = require_PermissionOverwrites();
    exports2.Presence = require_Presence().Presence;
    exports2.ReactionCollector = require_ReactionCollector();
    exports2.ReactionEmoji = require_ReactionEmoji();
    exports2.RichPresenceAssets = require_Presence().RichPresenceAssets;
    exports2.Role = require_Role().Role;
    exports2.StageChannel = require_StageChannel();
    exports2.StageInstance = require_StageInstance().StageInstance;
    exports2.Sticker = require_Sticker().Sticker;
    exports2.StickerPack = require_StickerPack();
    exports2.StoreChannel = require_StoreChannel();
    exports2.Team = require_Team();
    exports2.TeamMember = require_TeamMember();
    exports2.TextChannel = require_TextChannel();
    exports2.TextInputComponent = require_TextInputComponent();
    exports2.ThreadChannel = require_ThreadChannel();
    exports2.ThreadOnlyChannel = require_ThreadOnlyChannel();
    exports2.ThreadMember = require_ThreadMember();
    exports2.Typing = require_Typing();
    exports2.User = require_User();
    exports2.VoiceChannel = require_VoiceChannel();
    exports2.VoiceRegion = require_VoiceRegion();
    exports2.VoiceState = require_VoiceState();
    exports2.Webhook = require_Webhook();
    exports2.Widget = require_Widget();
    exports2.WidgetMember = require_WidgetMember();
    exports2.WelcomeChannel = require_WelcomeChannel();
    exports2.WelcomeScreen = require_WelcomeScreen();
    exports2.WebSocket = require_WebSocket();
    exports2.CustomStatus = require_Presence().CustomStatus;
    exports2.RichPresence = require_Presence().RichPresence;
    exports2.SpotifyRPC = require_Presence().SpotifyRPC;
    exports2.WebEmbed = require_WebEmbed();
    exports2.DiscordAuthWebsocket = require_RemoteAuth();
    exports2.PurchasedFlags = require_PurchasedFlags();
    exports2.Poll = require_Poll().Poll;
    exports2.PollAnswer = require_PollAnswer().PollAnswer;
  }
});
export default require_src2();
/*! Bundled license information:

tough-cookie/lib/pubsuffix-psl.js:
  (*!
   * Copyright (c) 2018, Salesforce.com, Inc.
   * All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are met:
   *
   * 1. Redistributions of source code must retain the above copyright notice,
   * this list of conditions and the following disclaimer.
   *
   * 2. Redistributions in binary form must reproduce the above copyright notice,
   * this list of conditions and the following disclaimer in the documentation
   * and/or other materials provided with the distribution.
   *
   * 3. Neither the name of Salesforce.com nor the names of its contributors may
   * be used to endorse or promote products derived from this software without
   * specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
   * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
   * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
   * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
   * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
   * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
   * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
   * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   * POSSIBILITY OF SUCH DAMAGE.
   *)

tough-cookie/lib/store.js:
  (*!
   * Copyright (c) 2015, Salesforce.com, Inc.
   * All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are met:
   *
   * 1. Redistributions of source code must retain the above copyright notice,
   * this list of conditions and the following disclaimer.
   *
   * 2. Redistributions in binary form must reproduce the above copyright notice,
   * this list of conditions and the following disclaimer in the documentation
   * and/or other materials provided with the distribution.
   *
   * 3. Neither the name of Salesforce.com nor the names of its contributors may
   * be used to endorse or promote products derived from this software without
   * specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
   * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
   * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
   * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
   * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
   * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
   * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
   * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   * POSSIBILITY OF SUCH DAMAGE.
   *)

tough-cookie/lib/permuteDomain.js:
  (*!
   * Copyright (c) 2015, Salesforce.com, Inc.
   * All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are met:
   *
   * 1. Redistributions of source code must retain the above copyright notice,
   * this list of conditions and the following disclaimer.
   *
   * 2. Redistributions in binary form must reproduce the above copyright notice,
   * this list of conditions and the following disclaimer in the documentation
   * and/or other materials provided with the distribution.
   *
   * 3. Neither the name of Salesforce.com nor the names of its contributors may
   * be used to endorse or promote products derived from this software without
   * specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
   * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
   * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
   * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
   * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
   * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
   * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
   * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   * POSSIBILITY OF SUCH DAMAGE.
   *)

tough-cookie/lib/pathMatch.js:
  (*!
   * Copyright (c) 2015, Salesforce.com, Inc.
   * All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are met:
   *
   * 1. Redistributions of source code must retain the above copyright notice,
   * this list of conditions and the following disclaimer.
   *
   * 2. Redistributions in binary form must reproduce the above copyright notice,
   * this list of conditions and the following disclaimer in the documentation
   * and/or other materials provided with the distribution.
   *
   * 3. Neither the name of Salesforce.com nor the names of its contributors may
   * be used to endorse or promote products derived from this software without
   * specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
   * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
   * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
   * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
   * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
   * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
   * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
   * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   * POSSIBILITY OF SUCH DAMAGE.
   *)

tough-cookie/lib/memstore.js:
  (*!
   * Copyright (c) 2015, Salesforce.com, Inc.
   * All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are met:
   *
   * 1. Redistributions of source code must retain the above copyright notice,
   * this list of conditions and the following disclaimer.
   *
   * 2. Redistributions in binary form must reproduce the above copyright notice,
   * this list of conditions and the following disclaimer in the documentation
   * and/or other materials provided with the distribution.
   *
   * 3. Neither the name of Salesforce.com nor the names of its contributors may
   * be used to endorse or promote products derived from this software without
   * specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
   * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
   * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
   * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
   * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
   * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
   * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
   * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   * POSSIBILITY OF SUCH DAMAGE.
   *)

tough-cookie/lib/cookie.js:
  (*!
   * Copyright (c) 2015-2020, Salesforce.com, Inc.
   * All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are met:
   *
   * 1. Redistributions of source code must retain the above copyright notice,
   * this list of conditions and the following disclaimer.
   *
   * 2. Redistributions in binary form must reproduce the above copyright notice,
   * this list of conditions and the following disclaimer in the documentation
   * and/or other materials provided with the distribution.
   *
   * 3. Neither the name of Salesforce.com nor the names of its contributors may
   * be used to endorse or promote products derived from this software without
   * specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
   * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
   * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
   * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
   * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
   * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
   * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
   * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   * POSSIBILITY OF SUCH DAMAGE.
   *)

undici/lib/web/fetch/body.js:
  (*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> *)

undici/lib/web/websocket/frame.js:
  (*! ws. MIT License. Einar Otto Stangvik <einaros@gmail.com> *)

@sapphire/shapeshift/dist/cjs/index.cjs:
  (**
   * @license MIT
   * @copyright 2020 Colin McDonnell
   * @see https://github.com/colinhacks/zod/blob/master/LICENSE
   *)
*/
//# sourceMappingURL=discord__js-selfbot-v13.js.map
